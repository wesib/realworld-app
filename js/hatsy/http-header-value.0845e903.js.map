{"version":3,"file":"http-header-value.0845e903.js","sources":["../../../../../hatsy/http-header-value/src/impl/hthv-item.ts","../../../../../hatsy/http-header-value/src/parser/add-param.ts","../../../../../hatsy/http-header-value/src/parser/parse-none.ts","../../../../../hatsy/http-header-value/src/parser/date-time-parser.ts","../../../../../hatsy/http-header-value/src/parser/next-in-item.ts","../../../../../hatsy/http-header-value/src/parser/item-parser.ts","../../../../../hatsy/http-header-value/src/parser/angle-brackets-parser.ts","../../../../../hatsy/http-header-value/src/parser/quoted-string-parser.ts","../../../../../hatsy/http-header-value/src/parser/next-in-comment.ts","../../../../../hatsy/http-header-value/src/parser/spaces-parser.ts","../../../../../hatsy/http-header-value/src/parser/param-parser.ts","../../../../../hatsy/http-header-value/src/parser/parser-config.ts","../../../../../hatsy/http-header-value/src/hthv-parser.ts","../../../../../hatsy/http-header-value/src/parser/item-delimit-parser.ts","../../../../../hatsy/http-header-value/src/parser/comment-parser.ts","../../../../../hatsy/http-header-value/src/hthv-parse.ts","../../../../../hatsy/http-header-value/src/hthv-quote.ts"],"sourcesContent":["import type { HthvItem } from '../hthv-item';\nimport type { HthvPartial } from './hthv-partial';\n\n/**\n * @internal\n */\nexport function hthvItem<TItem extends HthvItem<any, any, any>>(\n    {\n      $ = 'raw',\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<TItem>,\n): TItem {\n  if (n) {\n    (p as Record<string, HthvPartial>)[n as string] = { $, n, v, x: [], p: {}, pl: [] };\n  }\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as TItem;\n}\n","import type { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam(\n    {\n      p,\n      pl,\n    }: HthvItem,\n    param: HthvParamItem,\n): void {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","/**\n * @internal\n */\nexport const parseNone = (): false => false;\n","import { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function dateTimeParser(\n    { dateTime }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return dateTime ? parseDateTime : parseNone;\n}\n\nfunction parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (datePattern.test(input.s)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","import type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = delimiterOf(c);\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { dateTimeParser } from './date-time-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { quotedStringParser } from './quoted-string-parser';\n\n/**\n * @internal\n */\nexport interface ItemParserConfig {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseDateTime = dateTimeParser(config);\n  const parseQuotedString = quotedStringParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem))); // eslint-disable-line curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser({ delimiterOf }: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport type { HthvParserConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  readonly dateTime?: boolean;\n  delimiterOf(this: void, char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n      dateTime,\n    }: HthvParserConfig = {},\n): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    dateTime,\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = (/*#__PURE__*/ buildParserConfig());\n\n/**\n * @internal\n */\nexport const commentParserConfig = (/*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n}));\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport type { HthvDelimiterChar } from './hthv-delimiter';\nimport type { HthvItem } from './hthv-item';\nimport { hthvItem } from './impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeParam TNameMode - Whether parsed items have {@link HthvItem.n names}.\n * @typeParam TTagMode - Whether parsed items have {@link HthvItem.t tags}.\n * @typeParam TParamsMode - Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    TNameMode extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    TTagMode extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    TParamsMode extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value - HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<TNameMode, TTagMode, TParamsMode>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse date/time values.\n   *\n   * @default `false`\n   */\n  readonly dateTime?: boolean;\n\n  /**\n   * Whether to parse comments.\n   *\n   * @default `false`.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config - New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // eslint-disable-line curly\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const commentParserConfig: ItemParserConfig = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserConfig);\n  const parseParam = paramParser(config, commentParserConfig);\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while ( // eslint-disable-line curly\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        );\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments or date/time values.\n *\n * Treats illegal characters as ASCII letters.\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser = (/*#__PURE__*/ newHthvParser());\n\n/**\n * Parses HTTP header value that may contain date/time.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default config except {@link HthvParserConfig.dateTime date/time parsing enabled}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParseDT: HthvParser = (/*#__PURE__*/ newHthvParser({ dateTime: true }));\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string - A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  const { delimiterOf } = defaultParserConfig;\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n"],"names":["hthvItem","$","n","t","v","x","p","pl","addParam","param","key","prev","push","parseNone","datePattern","dateTimeParser","dateTime","parseDateTime","input","out","s","substring","i","test","nextInItem","delimiterOf","c","d","itemParser","config","named","tagged","extra","next","parseAngleBrackets","result","length","angleBracketsParser","parseQuotedString","unquoted","quotedStringParser","parseExtra","tag","value","item","name","type","undefined","extraItem","nextInComment","spacesParser","start","paramParser","opts","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter"],"mappings":"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"}