{"version":3,"file":"api.a4379be1.js","sources":["../../../src/core/api/api-root-url.ts","../../../src/core/api/api-fetch.ts","../../../src/core/api/api-submitter.ts"],"sourcesContent":["import { SingleContextUpKey, SingleContextUpRef } from '@proc7ts/context-values/updatable';\n\nexport type ApiRootURL = URL;\n\nexport const ApiRootURL: SingleContextUpRef<ApiRootURL> = (\n    /*#__PURE__*/ new SingleContextUpKey<ApiRootURL>(\n    'api-root-url',\n    {\n      byDefault: () => new URL('https://conduit.productionready.io/api/'),\n    },\n));\n","import { nextArgs, NextCall } from '@proc7ts/call-thru';\nimport { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, nextOnEvent, onAsync, OnEvent, OnEventCallChain } from '@proc7ts/fun-events';\nimport { HttpFetch } from '@wesib/generic';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { AuthService__key } from '../auth/auth-service.key.impl';\nimport { ApiRootURL } from './api-root-url';\n\n/**\n * Request to some API endpoint.\n *\n * @typeparam T  Response type.\n */\nexport interface ApiRequest<T> {\n\n  /**\n   * API endpoint path __relative__ to {@link ApiRootURL API root URL}.\n   *\n   * Do not start it with `/` as this would make it absolute.\n   */\n  readonly path: string;\n\n  /**\n   * Wrapper field containing response object, or a function extracting it.\n   */\n  readonly respondAs: string | ((this: void, json: any) => T);\n\n  /**\n   * Additional HTTP request options.\n   */\n  readonly init?: RequestInit;\n\n  /**\n   * Whether to send authentication token.\n   *\n   * - `true` to always send it,\n   * - `false` to never send it,\n   * - `undefined` (the default) - to send it only when {@link AuthService.authentication authenticated}.\n   */\n  readonly auth?: boolean;\n\n}\n\nexport type ApiResponse<T> =\n    | ApiResponse.Ok<T>\n    | ApiResponse.Failure;\n\nexport namespace ApiResponse {\n\n  export type Any<T> =\n      | Success<T>\n      | None\n      | Failure;\n\n  export interface Success<T> {\n    readonly ok: true;\n    readonly body: T;\n  }\n\n  export interface None {\n    readonly ok: true;\n    readonly body?: undefined;\n  }\n\n  export interface Ok<T> extends Success<T> {\n    readonly response: Response;\n  }\n\n  export interface Failure {\n    readonly ok: false;\n    readonly response?: Response;\n    readonly errors: Errors;\n  }\n\n  export type Errors = {\n    readonly [field in string]: readonly string[];\n  };\n\n}\n\nexport type ApiFetch = <T>(this: void, request: ApiRequest<T>) => OnEvent<[ApiResponse<T>]>;\n\nexport const ApiFetch: ContextUpRef<ApiFetch, ApiFetch> = (\n    /*#__PURE__*/ new FnContextKey<[ApiRequest<any>], OnEvent<[ApiResponse<any>]>>(\n    'api-fetch',\n    {\n      byDefault: bootstrapDefault(newApiFetch),\n    },\n));\n\nexport function notAuthenticatedError(): ApiResponse.Errors {\n  return {\n    authentication: ['absent'],\n  };\n}\n\ntype RequestOrFailure =\n    | { request: Request }\n    | { request?: undefined; failure: ApiResponse.Failure };\ntype ResponseOrFailure =\n    | { response: Response }\n    | { response?: undefined; failure: ApiResponse.Failure };\ntype ResponseBodyOrFailure =\n    | [{ response: Response }, any]\n    | [{ response?: undefined; failure: ApiResponse.Failure }];\n\nfunction newApiFetch(context: BootstrapContext): ApiFetch {\n\n  const httpFetch = context.get(HttpFetch);\n  const apiRootURL = context.get(ApiRootURL);\n\n  return request => {\n\n    const { path, init, auth } = request;\n    const onResponse: OnEvent<[ResponseOrFailure]> = apiRootURL.thru_(\n        baseURL => new URL(path, baseURL),\n        url => buildApiRequest(url, init),\n    ).thru_(\n        (request: Request): NextCall<OnEventCallChain, [RequestOrFailure]> => auth === false\n            ? nextArgs({ request })\n            : nextOnEvent(authenticateApiRequest(context, request, auth)),\n        (requestOrFailure): NextCall<OnEventCallChain, [ResponseOrFailure]> => requestOrFailure.request\n            ? nextOnEvent(httpFetch(requestOrFailure.request).thru_(response => ({ response })))\n            : nextArgs({ failure: requestOrFailure.failure }),\n    );\n\n    return onAsync(onResponse.thru_(parseApiResponse)).thru_(\n        ([responseOrFailure, json]) => handleApiResponse(request, responseOrFailure, json),\n    );\n  };\n}\n\nfunction buildApiRequest(url: URL, init: RequestInit = {}): Request {\n\n  const request = new Request(url.href, { mode: 'cors', ...init });\n  const { headers } = request;\n\n  headers.set('X-Requested-With', 'XMLHttpRequest');\n\n  return request;\n}\n\nfunction authenticateApiRequest(\n    context: BootstrapContext,\n    request: Request,\n    auth?: true,\n): AfterEvent<[RequestOrFailure]> {\n  // Access by key to avoid circular dependencies during the build\n  return context.get(AuthService__key).token().keepThru_(\n      ({ token, failure }) => {\n        if (token) {\n          request.headers.set('Authorization', `Token ${token}`);\n          return { request };\n        }\n        if (!auth) {\n          return { request };\n        }\n        if (!failure) {\n          failure = {\n            ok: false,\n            errors: notAuthenticatedError(),\n          };\n        }\n        return { failure };\n      },\n  );\n}\n\nfunction parseApiResponse(\n    responseOfFailure: ResponseOrFailure,\n): ResponseBodyOrFailure | Promise<ResponseBodyOrFailure> {\n  return responseOfFailure.response\n      ? Promise.all([responseOfFailure, responseOfFailure.response.json()])\n          .catch(error => [{\n            failure: {\n              ok: false,\n              response: responseOfFailure.response,\n              errors: !responseOfFailure.response.ok\n                  ? httpError(responseOfFailure.response)\n                  : {\n                    api: [`Failed to parse response: ${error}`],\n                  },\n            },\n          }])\n      : [responseOfFailure];\n}\n\nfunction handleApiResponse<T>(\n    { respondAs }: ApiRequest<T>,\n    responseOfFailure: ResponseOrFailure,\n    json?: any,\n): ApiResponse<T> {\n  if (!responseOfFailure.response) {\n    return responseOfFailure.failure;\n  }\n\n  const { response } = responseOfFailure;\n\n  if (response.ok) {\n    return {\n      ok: true,\n      response,\n      body: typeof respondAs === 'function' ? respondAs(json) : json[respondAs],\n    };\n  }\n\n  return {\n    ok: false,\n    response,\n    errors: json.errors || httpError(response),\n  };\n}\n\nfunction httpError(response: Response): ApiResponse.Errors {\n  return {\n    HTTP: ['ERROR ' + response.status + (response.statusText ? ': ' + response.statusText : '')],\n  };\n}\n","import { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { InSubmit, InSubmitError } from '@proc7ts/input-aspects';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { ApiFetch, ApiRequest, ApiResponse } from './api-fetch';\n\nexport type ApiSubmitter =\n    <Value = any, Result = any>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result>;\n\nexport const ApiSubmitter: ContextUpRef<ApiSubmitter, ApiSubmitter> = (\n    /*#__PURE__*/ new FnContextKey<[ApiRequest<any>], InSubmit.Submitter<any, any>>(\n        'api-submitter',\n        {\n          byDefault: bootstrapDefault(newApiSubmitter),\n        },\n    )\n);\n\nfunction newApiSubmitter(\n    context: BootstrapContext,\n): <Value, Result>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result> {\n\n  const apiFetch: ApiFetch = context.get(ApiFetch);\n\n  return <Value, Result>(request: ApiRequest<Result>) => {\n\n    const { init = {} } = request;\n    const { method = 'POST', headers = {} } = init;\n\n    return (body: Value) => {\n\n      const apiRequest: ApiRequest<Result> = {\n        ...request,\n        init: {\n          ...init,\n          method,\n          body: JSON.stringify(body),\n          headers: {\n            ...headers,\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n          },\n        },\n      };\n\n      return apiSubmit(apiFetch(apiRequest));\n    };\n  };\n}\n\nexport function apiSubmit<Result>(onFetch: OnEvent<[ApiResponse<Result>]>): Promise<Result> {\n  return new Promise((resolve, reject) => {\n    onFetch.once(\n        (response: ApiResponse<Result>) => {\n          if (response.ok) {\n            resolve(response.body);\n          } else {\n            reject(new InSubmitError({ submit: 'api', api: response.errors }));\n          }\n        },\n    ).whenOff(\n        reason => {\n          reject(\n              reason instanceof InSubmitError\n                  ? reason\n                  : new InSubmitError({ submit: 'cancel', cancel: reason }),\n          );\n        },\n    );\n  });\n}\n"],"names":["ApiRootURL","SingleContextUpKey","byDefault","URL","ApiFetch","FnContextKey","bootstrapDefault","context","httpFetch","get","HttpFetch","apiRootURL","request","path","init","auth","onResponse","thru_","baseURL","url","Request","href","mode","headers","set","buildApiRequest","nextArgs","nextOnEvent","AuthService__key","token","keepThru_","failure","ok","errors","authentication","authenticateApiRequest","requestOrFailure","response","onAsync","parseApiResponse","responseOrFailure","json","respondAs","responseOfFailure","body","httpError","handleApiResponse","notAuthenticatedError","Promise","all","catch","error","api","HTTP","status","statusText","apiSubmit","onFetch","resolve","reject","once","InSubmitError","submit","whenOff","reason","cancel"],"mappings":"8WAIO,MAAMA,MACSC,EAClB,eACA,CACEC,UAAW,IAAM,IAAIC,IAAI,6CC0ElBC,MACSC,EAClB,YACA,CACEH,UAAWI,GAoBjB,SAAqBC,GAEnB,MAAMC,EAAYD,EAAQE,IAAIC,GACxBC,EAAaJ,EAAQE,IAAIT,GAE/B,OAAOY,IAEL,MAAMC,KAAEA,EAAIC,KAAEA,EAAIC,KAAEA,GAASH,EACvBI,EAA2CL,EAAWM,MACxDC,GAAW,IAAIf,IAAIU,EAAMK,GACzBC,GAgBR,SAAyBA,EAAUL,EAAoB,IAErD,MAAMF,EAAU,IAAIQ,QAAQD,EAAIE,oBAAQC,KAAM,QAAWR,KACnDS,QAAEA,GAAYX,EAIpB,OAFAW,EAAQC,IAAI,mBAAoB,kBAEzBZ,EAvBMa,CAAgBN,EAAKL,IAC9BG,MACGL,IAA8E,IAATG,EAChEW,EAAS,CAAEd,QAAAA,IACXe,EAsBd,SACIpB,EACAK,EACAG,GAGF,OAAOR,EAAQE,IAAImB,GAAkBC,QAAQC,UACzC,EAAGD,MAAAA,EAAOE,QAAAA,KACJF,GACFjB,EAAQW,QAAQC,IAAI,gBAAiB,SAASK,KACvC,CAAEjB,QAAAA,IAENG,GAGAgB,IACHA,EAAU,CACRC,IAAI,EACJC,OArEH,CACLC,eAAgB,CAAC,aAuEN,CAAEH,QAAAA,IARA,CAAEnB,QAAAA,IAnCOuB,CAAuB5B,EAASK,EAASG,IAC1DqB,GAAsEA,EAAiBxB,QAClFe,EAAYnB,EAAU4B,EAAiBxB,SAASK,MAAMoB,KAAeA,SAAAA,MACrEX,EAAS,CAAEK,QAASK,EAAiBL,WAG/C,OAAOO,EAAQtB,EAAWC,MAAMsB,IAAmBtB,MAC/C,EAAEuB,EAAmBC,KA4D7B,UACIC,UAAEA,GACFC,EACAF,GAEF,IAAKE,EAAkBN,SACrB,OAAOM,EAAkBZ,QAG3B,MAAMM,SAAEA,GAAaM,EAErB,GAAIN,EAASL,GACX,MAAO,CACLA,IAAI,EACJK,SAAAA,EACAO,KAA2B,mBAAdF,EAA2BA,EAAUD,GAAQA,EAAKC,IAInE,MAAO,CACLV,IAAI,EACJK,SAAAA,EACAJ,OAAQQ,EAAKR,QAAUY,EAAUR,IAlFES,CAAkBlC,EAAS4B,EAAmBC,mBArCrEM,IACd,MAAO,CACLb,eAAgB,CAAC,WA4ErB,SAASK,EACLI,GAEF,OAAOA,EAAkBN,SACnBW,QAAQC,IAAI,CAACN,EAAmBA,EAAkBN,SAASI,SACxDS,MAAMC,GAAS,CAAC,CACfpB,QAAS,CACPC,IAAI,EACJK,SAAUM,EAAkBN,SAC5BJ,OAASU,EAAkBN,SAASL,GAE9B,CACAoB,IAAK,CAAC,6BAA6BD,MAFnCN,EAAUF,EAAkBN,cAMxC,CAACM,GA6BT,SAASE,EAAUR,GACjB,MAAO,CACLgB,KAAM,CAAC,SAAWhB,EAASiB,QAAUjB,EAASkB,WAAa,KAAOlB,EAASkB,WAAa,eCrK5EC,EAAkBC,GAChC,OAAO,IAAIT,QAAQ,CAACU,EAASC,KAC3BF,EAAQG,KACHvB,IACKA,EAASL,GACX0B,EAAQrB,EAASO,MAEjBe,EAAO,IAAIE,EAAc,CAAEC,OAAQ,MAAOV,IAAKf,EAASJ,YAG9D8B,QACEC,IACEL,EACIK,aAAkBH,EACZG,EACA,IAAIH,EAAc,CAAEC,OAAQ,SAAUG,OAAQD"}