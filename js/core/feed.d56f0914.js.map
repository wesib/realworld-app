{"version":3,"file":"feed.d56f0914.js","sources":["../../../src/core/feed/feed-request.ts","../../../src/pages/article/current-article.ts","../../../src/core/feed/feed-service.ts","../../../src/core/feed/feed-service.impl.ts","../../../src/core/feed/feed-support.feature.ts"],"sourcesContent":["import { NextSkip, nextSkip } from '@proc7ts/call-thru';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { thruIt } from '@proc7ts/push-iterator/call-thru';\n\nexport type FeedId = '/personal-feed' | '/global-feed';\n\nexport interface FeedRequest {\n  readonly feed?: FeedId;\n  readonly tag?: string;\n  readonly author?: string;\n  readonly favorited?: string;\n  readonly limit?: number;\n  readonly offset?: number;\n}\n\nconst feedRequestKeys: readonly (keyof FeedRequest)[] = ['feed', 'tag', 'author', 'favorited', 'limit', 'offset'];\n\nexport function feedRequestsEqual(first: FeedRequest, second: FeedRequest): boolean {\n  return feedRequestKeys.every(key => first[key] === second[key]);\n}\n\nexport function feedRequestSearchParams(request: FeedRequest): URLSearchParams {\n\n  const params = new URLSearchParams();\n\n  itsEach(\n      thruIt(\n          feedRequestKeys,\n          key => key !== 'feed' ? key : nextSkip,\n          (key: keyof FeedRequest): [keyof FeedRequest, string] | NextSkip => {\n\n            const value = request[key];\n\n            return value ? [key, String(value)] : nextSkip;\n          },\n      ),\n      ([key, value]) => params.set(key, value),\n  );\n\n  return params;\n}\n","import { EventSupplier, mapOn_, OnEvent, onSupplied, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { Article } from '../../core/articles';\n\nexport interface UpdatableArticle extends Article {\n  update(article: Article): void;\n}\n\nexport interface NoArticle {\n  readonly slug?: undefined;\n}\n\nexport type CurrentArticle =\n    | UpdatableArticle\n    | NoArticle;\n\nexport const noArticle: NoArticle = {};\n\nexport class CurrentArticleTracker extends ValueTracker<CurrentArticle> {\n\n  private readonly _it = trackValue<CurrentArticle>(noArticle);\n\n  get supply(): Supply {\n    return this._it.supply;\n  }\n\n  get it(): CurrentArticle {\n    return this._it.it;\n  }\n\n  set it(value: CurrentArticle) {\n    this._it.it = value;\n  }\n\n  get on(): OnEvent<[CurrentArticle, CurrentArticle]> {\n    return this._it.on;\n  }\n\n  set(article: Article | NoArticle): void {\n    this.it = this.cast(article);\n  }\n\n  byArticles(source: EventSupplier<[Article | NoArticle]>): this {\n    return this.by(\n        onSupplied(source).do(\n            mapOn_(article => this.cast(article)),\n        ),\n    );\n  }\n\n  cast(article: Article | NoArticle): CurrentArticle {\n    return article.slug\n        ? {\n          ...article,\n          update: updated => this.set(updated),\n        }\n        : noArticle;\n  }\n\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { noArticle, NoArticle } from '../../pages/article/current-article';\nimport { ApiResponse } from '../api';\nimport { Article } from '../articles';\nimport { FeedRequest } from './feed-request';\n\nexport interface ArticleList {\n  readonly list: readonly Article[];\n  readonly count: number;\n  bySlug(slug: string): Article | NoArticle;\n}\n\nexport const noArticles: ArticleList = {\n  list: [],\n  count: 0,\n  bySlug(_slug: string) {\n    return noArticle;\n  },\n};\n\nexport interface FeedService {\n\n  readonly tags: OnEvent<string[]>;\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]>;\n\n}\n\nexport const FeedService: ContextRef<FeedService> = (\n    /*#__PURE__*/ new SingleContextKey<FeedService>('feed-service')\n);\n","import { afterSupplied, mapOn_, OnEvent, onEventBy, trackValueBy, translateOn_ } from '@proc7ts/fun-events';\nimport { asis } from '@proc7ts/primitives';\nimport { BootstrapContext } from '@wesib/wesib';\nimport { noArticle } from '../../pages/article/current-article';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { Article } from '../articles';\nimport { FeedId, FeedRequest, feedRequestSearchParams } from './feed-request';\nimport { ArticleList, FeedService } from './feed-service';\n\ninterface FeedSource {\n  path: string;\n  auth?: boolean;\n}\n\nconst feedSources: { readonly [id in FeedId]: FeedSource } = {\n  '/personal-feed': { path: 'articles/feed', auth: true },\n  '/global-feed': { path: 'articles' },\n};\n\nexport class FeedService$ implements FeedService {\n\n  readonly tags: OnEvent<string[]>;\n  private readonly _apiFetch: ApiFetch;\n\n  constructor(context: BootstrapContext) {\n    this._apiFetch = context.get(ApiFetch);\n\n    let onTags: OnEvent<string[]> | undefined;\n\n    this.tags = onEventBy(receiver => {\n      if (!onTags) {\n\n        const apiRequest: ApiRequest<string[]> = {\n          path: 'tags',\n          init: {\n            method: 'GET',\n            headers: {\n              Accept: 'application/json',\n            },\n          },\n          respondAs: 'tags',\n          auth: false,\n        };\n        const onTagsLoad: OnEvent<[string[]]> = this._apiFetch(apiRequest).do(\n            mapOn_(response => {\n              if (response.ok) {\n                return response.body;\n              }\n\n              console.error('Failed to load tags', response.errors);\n\n              return [];\n            }),\n        );\n        const tags = trackValueBy<string[] | undefined>(\n            afterSupplied<[string[]?]>(onTagsLoad, () => []),\n        );\n\n        onTags = tags.read.do(\n            translateOn_((send, tagList) => tagList && send(...tagList)),\n        );\n      }\n\n      onTags(receiver);\n    });\n  }\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]> {\n\n    const { path, auth } = feedSources[request.feed || '/global-feed'];\n\n    const apiRequest: ApiRequest<FeedArticles> = {\n      path: `${path}?${feedRequestSearchParams(request)}`,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      auth,\n      respondAs: asis,\n    };\n\n    return this._apiFetch(apiRequest).do(\n        mapOn_(response => {\n          if (!response.ok) {\n            return response;\n          }\n\n          const { articles: list, articlesCount: count } = response.body;\n          const bySlug = new Map<string, Article>(list.map(article => [article.slug, article]));\n\n          return {\n            ok: true,\n            response: response.response,\n            body: {\n              list,\n              count,\n              bySlug(slug) {\n                return bySlug.get(slug) || noArticle;\n              },\n            },\n          };\n        }),\n    );\n  }\n\n}\n\ninterface FeedArticles {\n  readonly articles: readonly Article[];\n  readonly articlesCount: number;\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedService } from './feed-service';\nimport { FeedService$ } from './feed-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: FeedService, as: FeedService$ });\n  },\n})\nexport class FeedSupport {\n}\n"],"names":["feedRequestKeys","feedRequestsEqual","first","second","every","key","feedRequestSearchParams","request","params","URLSearchParams","itsEach","thruIt","nextSkip","value","String","set","noArticle","CurrentArticleTracker","ValueTracker","[object Object]","this","trackValue","supply","_it","it","on","article","cast","source","by","onSupplied","do","mapOn_","slug","update","updated","noArticles","list","count","bySlug","_slug","FeedService","SingleContextKey","feedSources","/personal-feed","path","auth","/global-feed","FeedService$","context","onTags","_apiFetch","get","ApiFetch","tags","onEventBy","receiver","apiRequest","init","method","headers","Accept","respondAs","onTagsLoad","response","ok","body","console","error","errors","trackValueBy","afterSupplied","read","translateOn_","send","tagList","feed","asis","articles","articlesCount","Map","map","FeedSupport","Feature","setup","provide","a","as"],"mappings":"qiBAeA,MAAMA,EAAkD,CAAC,OAAQ,MAAO,SAAU,YAAa,QAAS,mBAExFC,EAAkBC,EAAoBC,GACpD,OAAOH,EAAgBI,OAAMC,GAAOH,EAAMG,KAASF,EAAOE,cAG5CC,EAAwBC,GAEtC,MAAMC,EAAS,IAAIC,gBAgBnB,OAdAC,EACIC,EACIX,GACAK,GAAe,SAARA,EAAiBA,EAAMO,IAC7BP,IAEC,MAAMQ,EAAQN,EAAQF,GAEtB,OAAOQ,EAAQ,CAACR,EAAKS,OAAOD,IAAUD,MAG5C,EAAEP,EAAKQ,KAAWL,EAAOO,IAAIV,EAAKQ,KAG/BL,QCvBIQ,EAAuB,SAEvBC,UAA8BC,EAA3CC,kCAEmBC,SAAMC,EAA2BL,GAElDM,aACE,OAAOF,KAAKG,IAAID,OAGlBE,SACE,OAAOJ,KAAKG,IAAIC,GAGlBA,OAAOX,GACLO,KAAKG,IAAIC,GAAKX,EAGhBY,SACE,OAAOL,KAAKG,IAAIE,GAGlBN,IAAIO,GACFN,KAAKI,GAAKJ,KAAKO,KAAKD,GAGtBP,WAAWS,GACT,OAAOR,KAAKS,GACRC,EAAWF,GAAQG,GACfC,GAAON,GAAWN,KAAKO,KAAKD,OAKtCP,KAAKO,GACH,OAAOA,EAAQO,KACT,IACGP,EACHQ,OAAQC,GAAWf,KAAKL,IAAIoB,IAE5BnB,SC3CGoB,EAA0B,CACrCC,KAAM,GACNC,MAAO,EACPC,OAAOC,GACExB,GAYEyB,MACSC,EAA8B,gBChB9CC,EAAuD,CAC3DC,iBAAkB,CAAEC,KAAM,gBAAiBC,MAAM,GACjDC,eAAgB,CAAEF,KAAM,mBAGbG,EAKX7B,YAAY8B,GAGV,IAAIC,EAFJ9B,KAAK+B,UAAYF,EAAQG,IAAIC,GAI7BjC,KAAKkC,KAAOC,GAAUC,IACpB,IAAKN,EAAQ,CAEX,MAAMO,EAAmC,CACvCZ,KAAM,OACNa,KAAM,CACJC,OAAQ,MACRC,QAAS,CACPC,OAAQ,qBAGZC,UAAW,OACXhB,MAAM,GAEFiB,EAAkC3C,KAAK+B,UAAUM,GAAY1B,GAC/DC,GAAOgC,GACDA,EAASC,GACJD,EAASE,MAGlBC,QAAQC,MAAM,sBAAuBJ,EAASK,QAEvC,OAGPf,EAAOgB,EACTC,EAA2BR,GAAY,IAAM,MAGjDb,EAASI,EAAKkB,KAAKzC,GACf0C,GAAa,CAACC,EAAMC,IAAYA,GAAWD,KAAQC,MAIzDzB,EAAOM,MAIXrC,SAASZ,GAEP,MAAMsC,KAAEA,EAAIC,KAAEA,GAASH,EAAYpC,EAAQqE,MAAQ,gBAE7CnB,EAAuC,CAC3CZ,KAAM,GAAGA,KAAQvC,EAAwBC,KACzCmD,KAAM,CACJC,OAAQ,MACRC,QAAS,CACPC,OAAQ,qBAGZf,KAAAA,EACAgB,UAAWe,GAGb,OAAOzD,KAAK+B,UAAUM,GAAY1B,GAC9BC,GAAOgC,IACL,IAAKA,EAASC,GACZ,OAAOD,EAGT,MAAQc,SAAUzC,EAAM0C,cAAezC,GAAU0B,EAASE,KACpD3B,EAAS,IAAIyC,IAAqB3C,EAAK4C,KAAIvD,GAAW,CAACA,EAAQO,KAAMP,MAE3E,MAAO,CACLuC,IAAI,EACJD,SAAUA,EAASA,SACnBE,KAAM,CACJ7B,KAAAA,EACAC,MAAAA,EACAC,OAAON,GACEM,EAAOa,IAAInB,IAASjB,aC1F9BkE,EAAb,QAAaA,KALZC,EAAQ,CACPhE,MAAMiE,GACJA,EAAMC,QAAQ,CAAEC,EAAG7C,EAAa8C,GAAIvC,QAG3BkC"}