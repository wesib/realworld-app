{"version":3,"file":"api.51544e65.js","sources":["../../../src/core/api/api-root-url.ts","../../../src/core/api/api-fetch.ts","../../../src/core/api/api-submitter.ts"],"sourcesContent":["import { SingleContextUpKey, SingleContextUpRef } from '@proc7ts/context-values/updatable';\n\nexport type ApiRootURL = URL;\n\nexport const ApiRootURL: SingleContextUpRef<ApiRootURL> = (\n    /*#__PURE__*/ new SingleContextUpKey<ApiRootURL>(\n    'api-root-url',\n    {\n      byDefault: () => new URL('https://conduit.productionready.io/api/'),\n    },\n));\n","import { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digOn_, mapAfter_, mapOn_, OnEvent, resolveOnOrdered } from '@proc7ts/fun-events';\nimport { HttpFetch } from '@wesib/generic';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { AuthService__key } from '../auth/auth-service.key.impl';\nimport { ApiRootURL } from './api-root-url';\n\n/**\n * Request to some API endpoint.\n *\n * @typeparam T  Response type.\n */\nexport interface ApiRequest<T> {\n\n  /**\n   * API endpoint path __relative__ to {@link ApiRootURL API root URL}.\n   *\n   * Do not start it with `/` as this would make it absolute.\n   */\n  readonly path: string;\n\n  /**\n   * Wrapper field containing response object, or a function extracting it.\n   */\n  readonly respondAs: string | ((this: void, json: any) => T);\n\n  /**\n   * Additional HTTP request options.\n   */\n  readonly init?: RequestInit;\n\n  /**\n   * Whether to send authentication token.\n   *\n   * - `true` to always send it,\n   * - `false` to never send it,\n   * - `undefined` (the default) - to send it only when {@link AuthService.authentication authenticated}.\n   */\n  readonly auth?: boolean;\n\n}\n\nexport type ApiResponse<T> =\n    | ApiResponse.Ok<T>\n    | ApiResponse.Failure;\n\nexport namespace ApiResponse {\n\n  export type Any<T> =\n      | Success<T>\n      | None\n      | Failure;\n\n  export interface Success<T> {\n    readonly ok: true;\n    readonly body: T;\n  }\n\n  export interface None {\n    readonly ok: true;\n    readonly body?: undefined;\n  }\n\n  export interface Ok<T> extends Success<T> {\n    readonly response: Response;\n  }\n\n  export interface Failure {\n    readonly ok: false;\n    readonly response?: Response;\n    readonly errors: Errors;\n  }\n\n  export type Errors = {\n    readonly [field in string]: readonly string[];\n  };\n\n}\n\nexport type ApiFetch = <T>(this: void, request: ApiRequest<T>) => OnEvent<[ApiResponse<T>]>;\n\nexport const ApiFetch: ContextUpRef<ApiFetch, ApiFetch> = (\n    /*#__PURE__*/ new FnContextKey<[ApiRequest<any>], OnEvent<[ApiResponse<any>]>>(\n    'api-fetch',\n    {\n      byDefault: bootstrapDefault(newApiFetch),\n    },\n));\n\nexport function notAuthenticatedError(): ApiResponse.Errors {\n  return {\n    authentication: ['absent'],\n  };\n}\n\ntype RequestOrFailure =\n    | { request: Request }\n    | { request?: undefined; failure: ApiResponse.Failure };\ntype ResponseOrFailure =\n    | { response: Response }\n    | { response?: undefined; failure: ApiResponse.Failure };\ntype ResponseBodyOrFailure =\n    | [{ response: Response }, any]\n    | [{ response?: undefined; failure: ApiResponse.Failure }];\n\nfunction newApiFetch(context: BootstrapContext): ApiFetch {\n\n  const httpFetch = context.get(HttpFetch);\n  const apiRootURL = context.get(ApiRootURL);\n\n  return request => {\n\n    const { path, init, auth } = request;\n    const onResponse: OnEvent<[ResponseOrFailure]> = apiRootURL.do(\n        mapAfter_(baseURL => new URL(path, baseURL)),\n        mapAfter_(url => buildApiRequest(url, init)),\n        digOn_((request: Request): OnEvent<[RequestOrFailure]> => auth === false\n            ? afterThe({ request })\n            : authenticateApiRequest(context, request, auth)),\n        digOn_((requestOrFailure): OnEvent<[ResponseOrFailure]> => requestOrFailure.request\n            ? httpFetch(requestOrFailure.request).do(mapOn_(response => ({ response })))\n            : afterThe({ failure: requestOrFailure.failure })),\n    );\n\n    return onResponse.do(\n        mapOn_(parseApiResponse),\n        resolveOnOrdered,\n        mapOn_(([responseOrFailure, json]) => handleApiResponse(request, responseOrFailure, json)),\n    );\n  };\n}\n\nfunction buildApiRequest(url: URL, init: RequestInit = {}): Request {\n\n  const request = new Request(url.href, { mode: 'cors', ...init });\n  const { headers } = request;\n\n  headers.set('X-Requested-With', 'XMLHttpRequest');\n\n  return request;\n}\n\nfunction authenticateApiRequest(\n    context: BootstrapContext,\n    request: Request,\n    auth?: true,\n): AfterEvent<[RequestOrFailure]> {\n  // Access by key to avoid circular dependencies during the build\n  return context.get(AuthService__key).token.do(\n      mapAfter_(({ token, failure }) => {\n        if (token) {\n          request.headers.set('Authorization', `Token ${token}`);\n          return { request };\n        }\n        if (!auth) {\n          return { request };\n        }\n        if (!failure) {\n          failure = {\n            ok: false,\n            errors: notAuthenticatedError(),\n          };\n        }\n        return { failure };\n      }),\n  );\n}\n\nfunction parseApiResponse(\n    responseOfFailure: ResponseOrFailure,\n): ResponseBodyOrFailure | Promise<ResponseBodyOrFailure> {\n  return responseOfFailure.response\n      ? Promise.all([responseOfFailure, responseOfFailure.response.json()])\n          .catch(error => [{\n            failure: {\n              ok: false,\n              response: responseOfFailure.response,\n              errors: !responseOfFailure.response.ok\n                  ? httpError(responseOfFailure.response)\n                  : {\n                    api: [`Failed to parse response: ${error}`],\n                  },\n            },\n          }])\n      : [responseOfFailure];\n}\n\nfunction handleApiResponse<T>(\n    { respondAs }: ApiRequest<T>,\n    responseOfFailure: ResponseOrFailure,\n    json: { errors?: ApiResponse.Failure['errors'] } & Record<string, any>,\n): ApiResponse<T> {\n  if (!responseOfFailure.response) {\n    return responseOfFailure.failure;\n  }\n\n  const { response } = responseOfFailure;\n\n  if (response.ok) {\n    return {\n      ok: true,\n      response,\n      body: typeof respondAs === 'function' ? respondAs(json) : json[respondAs],\n    };\n  }\n\n  return {\n    ok: false,\n    response,\n    errors: json.errors || httpError(response),\n  };\n}\n\nfunction httpError(response: Response): ApiResponse.Errors {\n  return {\n    HTTP: [`ERROR ${response.status}${response.statusText ? ': ' + response.statusText : ''}`],\n  };\n}\n","import { InSubmit, InSubmitError } from '@frontmeans/input-aspects';\nimport { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { onceOn, OnEvent } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { ApiFetch, ApiRequest, ApiResponse } from './api-fetch';\n\nexport type ApiSubmitter =\n    <TValue = any, TResult = any>(this: void, request: ApiRequest<TResult>) => InSubmit.Submitter<TValue, TResult>;\n\nexport const ApiSubmitter: ContextUpRef<ApiSubmitter, ApiSubmitter> = (\n    /*#__PURE__*/ new FnContextKey<[ApiRequest<any>], InSubmit.Submitter<any, any>>(\n        'api-submitter',\n        {\n          byDefault: bootstrapDefault(newApiSubmitter),\n        },\n    )\n);\n\nfunction newApiSubmitter(\n    context: BootstrapContext,\n): <TValue, TResult>(this: void, request: ApiRequest<TResult>) => InSubmit.Submitter<TValue, TResult> {\n\n  const apiFetch: ApiFetch = context.get(ApiFetch);\n\n  return <TValue, TResult>(request: ApiRequest<TResult>) => {\n\n    const { init = {} } = request;\n    const { method = 'POST', headers = {} } = init;\n\n    return (body: TValue) => {\n\n      const apiRequest: ApiRequest<TResult> = {\n        ...request,\n        init: {\n          ...init,\n          method,\n          body: JSON.stringify(body),\n          headers: {\n            ...headers,\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n          },\n        },\n      };\n\n      return apiSubmit(apiFetch(apiRequest));\n    };\n  };\n}\n\nexport function apiSubmit<TResult>(onFetch: OnEvent<[ApiResponse<TResult>]>): Promise<TResult> {\n  return new Promise((resolve, reject) => {\n    onFetch.do(onceOn)(\n        (response: ApiResponse<TResult>) => {\n          if (response.ok) {\n            resolve(response.body);\n          } else {\n            reject(new InSubmitError({ submit: 'api', api: response.errors }));\n          }\n        },\n    ).whenOff(\n        reason => {\n          reject(\n              reason instanceof InSubmitError\n                  ? reason\n                  : new InSubmitError({ submit: 'cancel', cancel: reason }),\n          );\n        },\n    );\n  });\n}\n"],"names":["ApiRootURL","SingleContextUpKey","byDefault","URL","ApiFetch","FnContextKey","bootstrapDefault","context","httpFetch","get","HttpFetch","apiRootURL","request","path","init","auth","do","mapAfter_","baseURL","url","Request","href","mode","headers","set","buildApiRequest","digOn_","afterThe","AuthService__key","token","failure","ok","errors","authentication","authenticateApiRequest","requestOrFailure","mapOn_","response","parseApiResponse","resolveOnOrdered","responseOrFailure","json","respondAs","responseOfFailure","body","httpError","handleApiResponse","notAuthenticatedError","Promise","all","catch","error","api","HTTP","status","statusText","apiSubmit","onFetch","resolve","reject","onceOn","InSubmitError","submit","whenOff","reason","cancel"],"mappings":"sYAIO,MAAMA,MACSC,EAClB,eACA,CACEC,UAAW,IAAM,IAAIC,IAAI,6CCyElBC,MACSC,EAClB,YACA,CACEH,UAAWI,GAoBjB,SAAqBC,GAEnB,MAAMC,EAAYD,EAAQE,IAAIC,GACxBC,EAAaJ,EAAQE,IAAIT,GAE/B,OAAOY,IAEL,MAAMC,KAAEA,EAAIC,KAAEA,EAAIC,KAAEA,GAASH,EAY7B,OAXiDD,EAAWK,GACxDC,GAAUC,GAAW,IAAIf,IAAIU,EAAMK,KACnCD,GAAUE,GAiBlB,SAAyBA,EAAUL,EAAoB,IAErD,MAAMF,EAAU,IAAIQ,QAAQD,EAAIE,KAAM,CAAEC,KAAM,UAAWR,KACnDS,QAAEA,GAAYX,EAIpB,OAFAW,EAAQC,IAAI,mBAAoB,kBAEzBZ,EAxBgBa,CAAgBN,EAAKL,KACtCY,GAAQd,IAA2D,IAATG,EACpDY,EAAS,CAAEf,QAAAA,IAyBzB,SACIL,EACAK,EACAG,GAGF,OAAOR,EAAQE,IAAImB,GAAkBC,MAAMb,GACvCC,GAAU,EAAGY,MAAAA,EAAOC,QAAAA,KACdD,GACFjB,EAAQW,QAAQC,IAAI,gBAAiB,SAASK,KACvC,CAAEjB,QAAAA,IAENG,GAGAe,IACHA,EAAU,CACRC,IAAI,EACJC,OAtEH,CACLC,eAAgB,CAAC,aAwEN,CAAEH,QAAAA,IARA,CAAElB,QAAAA,MArCLsB,CAAuB3B,EAASK,EAASG,KAC/CW,GAAQS,GAAmDA,EAAiBvB,QACtEJ,EAAU2B,EAAiBvB,SAASI,GAAGoB,GAAOC,KAAeA,SAAAA,OAC7DV,EAAS,CAAEG,QAASK,EAAiBL,aAG7Bd,GACdoB,EAAOE,GACPC,EACAH,GAAO,EAAEI,EAAmBC,KA4DpC,UACIC,UAAEA,GACFC,EACAF,GAEF,IAAKE,EAAkBN,SACrB,OAAOM,EAAkBb,QAG3B,MAAMO,SAAEA,GAAaM,EAErB,GAAIN,EAASN,GACX,MAAO,CACLA,IAAI,EACJM,SAAAA,EACAO,KAA2B,mBAAdF,EAA2BA,EAAUD,GAAQA,EAAKC,IAInE,MAAO,CACLX,IAAI,EACJM,SAAAA,EACAL,OAAQS,EAAKT,QAAUa,EAAUR,IAlFSS,CAAkBlC,EAAS4B,EAAmBC,qBAtC5EM,IACd,MAAO,CACLd,eAAgB,CAAC,WA6ErB,SAASK,EACLK,GAEF,OAAOA,EAAkBN,SACnBW,QAAQC,IAAI,CAACN,EAAmBA,EAAkBN,SAASI,SACxDS,OAAMC,GAAS,CAAC,CACfrB,QAAS,CACPC,IAAI,EACJM,SAAUM,EAAkBN,SAC5BL,OAASW,EAAkBN,SAASN,GAE9B,CACAqB,IAAK,CAAC,6BAA6BD,MAFnCN,EAAUF,EAAkBN,eAMxC,CAACM,GA6BT,SAASE,EAAUR,GACjB,MAAO,CACLgB,KAAM,CAAC,SAAShB,EAASiB,SAASjB,EAASkB,WAAa,KAAOlB,EAASkB,WAAa,gBCrKzEC,EAAmBC,GACjC,OAAO,IAAIT,SAAQ,CAACU,EAASC,KAC3BF,EAAQzC,GAAG4C,EAAXH,EACKpB,IACKA,EAASN,GACX2B,EAAQrB,EAASO,MAEjBe,EAAO,IAAIE,EAAc,CAAEC,OAAQ,MAAOV,IAAKf,EAASL,aAG9D+B,SACEC,IACEL,EACIK,aAAkBH,EACZG,EACA,IAAIH,EAAc,CAAEC,OAAQ,SAAUG,OAAQD"}