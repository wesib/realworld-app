{"version":3,"file":"auth.e0c9460a.js","sources":["../../../../../frontmeans/dom-events/src/on-dom-event.ts","../../../../../frontmeans/dom-events/src/dom-event-dispatcher.ts","../../../../../frontmeans/dom-events/src/processors/handle-dom-events.ts","../../../../../frontmeans/dom-events/src/processors/stop-dom-events.ts","../../../src/core/auth/auth-service.key.impl.ts","../../../src/core/auth/auth-service.ts","../../../src/core/auth/authentication.ts","../../../src/core/auth/auth-service.impl.ts","../../../src/core/auth/auth-support.feature.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @frontmeans/dom-events\n */\nimport { eventReceiver, EventReceiver, OnEvent, OnEvent__symbol, onEventBy } from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * May be constructed using {@link onDomEventBy} function.\n *\n * @typeParam TEvent - Supported DOM event type.\n */\nexport type DomEventListener<TEvent extends Event> = EventReceiver<[TEvent]>;\n\n/**\n * Signature of {@link EventSender} implementation able to register DOM event listeners.\n *\n * @typeParam TEvent - Supported DOM event type.\n */\nexport interface OnDomEvent<TEvent extends Event> extends OnEvent<[TEvent]> {\n\n  /**\n   * Starts sending DOM events to the given `listener`.\n   *\n   * @param listener - Target listener of DOM events.\n   * @param opts - DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events from this sender to the given `listener`.\n   */\n  (listener: DomEventListener<TEvent>, opts?: AddEventListenerOptions | boolean): Supply;\n\n}\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$sample = (/*#__PURE__*/ onEventBy<any>(noop));\n\n/**\n * Converts a plain DOM event listener registration function to {@link OnDomEvent} sender.\n *\n * @typeParam TEvent - Supported DOM event type.\n * @param register - A generic DOM event listener registration function.\n *\n * @returns An {@link OnDomEvent} sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<TEvent extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[TEvent]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<TEvent> {\n\n  const onDomEvent = ((listener: DomEventListener<TEvent>, opts?: AddEventListenerOptions | boolean): Supply => {\n\n    const receiver = eventReceiver(listener);\n    const { supply } = receiver;\n\n    if (!supply.isOff) {\n      register(receiver, opts);\n    }\n\n    return supply;\n  }) as OnDomEvent<TEvent>;\n\n  onDomEvent[OnEvent__symbol] = OnDomEvent$sample[OnEvent__symbol];\n  onDomEvent.do = OnDomEvent$sample.do;\n  onDomEvent.then = OnDomEvent$sample.then;\n\n  return onDomEvent;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/dom-events\n */\nimport type { EventReceiver } from '@proc7ts/fun-events';\nimport { noop, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$context: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners of particular event types and dispatch events.\n */\nexport class DomEventDispatcher implements SupplyPeer {\n\n  readonly supply: Supply = new Supply();\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target - Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link Supply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link Supply.off cut off}.\n   *\n   * @typeParam TEvent - Supported DOM event type.\n   * @param type - DOM event type name.\n   *\n   * @returns {@link OnDomEvent} sender of DOM events of the given `type`.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n    return onDomEventBy<TEvent>((listener, opts) => {\n\n      const { supply } = listener;\n\n      supply.needs(this);\n\n      if (!supply.isOff) {\n\n        // Create unique DOM listener instance\n        const domListener: EventListener = event => listener.receive(OnDomEvent$context, event as TEvent);\n\n        this._target.addEventListener(type, domListener, opts);\n        listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n      }\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event - An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise. Also returns `false` when {@link supply} is cut off.\n   */\n  dispatch(event: Event): boolean {\n    return !this.supply.isOff && this._target.dispatchEvent(event);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/dom-events\n */\nimport { eventReceiver } from '@proc7ts/fun-events';\nimport { DomEventListener, OnDomEvent, onDomEventBy } from '../on-dom-event';\n\n/**\n * Creates a DOM events processor that enables or disables default DOM event handlers.\n *\n * @typeParam TEvent - DOM event type.\n * @param enable - Whether to enable default handlers. `true` to enable (default value, corresponds to specifying\n * `{ passive: true }` as a second argument to `EventTarget.addEventListener()`), or `false` to disable\n * (causes listeners to invoke an `Event.preventDefault()` method prior to event handling).\n *\n * @returns {@link OnDomEvent} mapper function.\n */\nexport function handleDomEvents<TEvent extends Event>(\n    enable = true,\n): (this: void, supplier: OnDomEvent<TEvent>) => OnDomEvent<TEvent> {\n  return enable ? listenDomEventsPassively : preventDefaultDomEventHandler;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction listenDomEventsPassively<TEvent extends Event>(supplier: OnDomEvent<TEvent>): OnDomEvent<TEvent> {\n  return onDomEventBy((\n      listener: DomEventListener<TEvent>,\n      opts?: AddEventListenerOptions | boolean,\n  ) => {\n    if (opts == null) {\n      return supplier(listener, { passive: true });\n    }\n    if (typeof opts === 'boolean') {\n      return supplier(listener, { capture: opts, passive: true });\n    }\n    if (opts.passive == null) {\n      return supplier(listener, { ...opts, passive: true });\n    }\n\n    return supplier(listener, opts);\n  });\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction preventDefaultDomEventHandler<TEvent extends Event>(supplier: OnDomEvent<TEvent>): OnDomEvent<TEvent> {\n  return onDomEventBy((\n      listener: DomEventListener<TEvent>,\n      opts?: AddEventListenerOptions | boolean,\n  ) => {\n\n    const receiver = eventReceiver(listener);\n\n    return supplier(\n        {\n          supply: receiver.supply,\n          receive(context, event) {\n            event.preventDefault();\n            receiver.receive(context, event);\n          },\n        },\n        opts,\n    );\n  });\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/dom-events\n */\nimport { eventReceiver } from '@proc7ts/fun-events';\nimport { DomEventListener, OnDomEvent, onDomEventBy } from '../on-dom-event';\n\n/**\n * Creates an {@link OnDomEvent} sender preventing further propagation of events in the capturing and bubbling phases.\n *\n * Causes listeners to invoke an [Event.stopPropagation()] method prior to event handing.\n *\n * [Event.stopPropagation()]: https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation\n *\n * @typeParam TEvent - DOM event type.\n * @param supplier - DOM events sender.\n *\n * @returns DOM events sender.\n */\nexport function stopDomEvents<TEvent extends Event>(\n    supplier: OnDomEvent<TEvent>,\n): OnDomEvent<TEvent> {\n  return onDomEventBy((\n      listener: DomEventListener<TEvent>,\n      opts?: AddEventListenerOptions | boolean,\n  ) => {\n\n    const receiver = eventReceiver(listener);\n\n    return supplier(\n        {\n          supply: receiver.supply,\n          receive(context, event) {\n            event.stopPropagation();\n            receiver.receive(context, event);\n          },\n        },\n        opts,\n    );\n  });\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { AuthService } from './auth-service';\n\nexport const AuthService__key = (\n    /*#__PURE__*/ new SingleContextKey<AuthService>('auth-service')\n);\n","import { ContextKey, ContextKey__symbol } from '@proc7ts/context-values';\nimport { AfterEvent, OnEvent } from '@proc7ts/fun-events';\nimport { ApiResponse } from '../api';\nimport { AuthService__key } from './auth-service.key.impl';\nimport { Authentication, AuthToken, AuthUser, NotAuthenticated } from './authentication';\n\nexport interface LoginRequest {\n  readonly email: string;\n  readonly password: string;\n}\n\nexport interface RegisterRequest {\n  readonly username: string;\n  readonly email: string;\n  readonly password: string;\n}\n\nexport interface UpdateSettingsRequest {\n  readonly email: string;\n  readonly username: string;\n  readonly password?: string;\n  readonly bio?: string;\n  readonly image?: string;\n}\n\nexport abstract class AuthService {\n\n  static get [ContextKey__symbol](): ContextKey<AuthService> {\n    return AuthService__key;\n  }\n\n  abstract readonly token: AfterEvent<[AuthToken | NotAuthenticated]>;\n  abstract readonly authentication: AfterEvent<[Authentication]>;\n  abstract readonly user: AfterEvent<[AuthUser | NotAuthenticated]>;\n  abstract readonly requireUser: AfterEvent<[AuthUser | NotAuthenticated]>;\n\n  abstract login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract loadUser(): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract updateSettings(request: UpdateSettingsRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract logout(): void;\n\n}\n","import { ApiResponse } from '../api';\n\nexport interface AuthToken {\n  readonly token: string;\n  readonly email?: undefined;\n  readonly username?: undefined;\n  readonly failure?: undefined;\n}\n\nexport interface NotAuthenticated {\n  readonly token?: undefined;\n  readonly email?: undefined;\n  readonly username?: undefined;\n  readonly failure?: ApiResponse.Failure;\n}\n\nexport const notAuthenticated: NotAuthenticated = {};\n\nexport type Authentication =\n    | NotAuthenticated\n    | AuthToken\n    | AuthUser;\n\nexport interface AuthUser {\n  readonly email: string;\n  readonly token: string;\n  readonly username: string;\n  readonly bio?: string;\n  readonly image?: string;\n  readonly failure?: undefined;\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport {\n  AfterEvent,\n  afterThe,\n  digAfter,\n  EventKeeper,\n  mapAfter_,\n  mapOn_,\n  OnEvent,\n  trackValue,\n  trackValueBy,\n  valueOn_,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { ApiFetch, ApiRequest, ApiResponse, notAuthenticatedError } from '../api';\nimport { AuthService, LoginRequest, RegisterRequest, UpdateSettingsRequest } from './auth-service';\nimport { Authentication, AuthToken, AuthUser, notAuthenticated, NotAuthenticated } from './authentication';\n\nconst authTokenKey = 'wesib-conduit:auth';\n\nexport class AuthService$ extends AuthService {\n\n  readonly user: AfterEvent<[AuthUser | NotAuthenticated]>;\n  readonly requireUser: AfterEvent<[AuthUser | NotAuthenticated]>;\n\n  private readonly _auth: ValueTracker<Authentication>;\n  private readonly _token = trackValue<AuthToken | NotAuthenticated>(notAuthenticated);\n\n  constructor(private readonly _context: BootstrapContext) {\n    super();\n\n    const window = _context.get(BootstrapWindow);\n    const storage = window.localStorage;\n\n    this._auth = trackValue<Authentication>(toAuthentication(storage.getItem(authTokenKey)));\n    this._token.by(this.authentication.do(\n        valueOn_(({ token }) => this._token.it.token !== token && { token }),\n    ));\n\n    this._auth.on(storeAuthToken);\n\n    let userRequest: [AuthToken | AuthUser, ValueTracker<AuthUser | NotAuthenticated>] | undefined;\n\n    this.requireUser = this.authentication.do(\n        digAfter((auth): EventKeeper<[AuthUser | NotAuthenticated]> => {\n          if (!auth.token) {\n            // No token. Can not authenticate.\n            return afterThe<[NotAuthenticated]>({\n              failure: {\n                ok: false,\n                errors: notAuthenticatedError(),\n              },\n            });\n          }\n          if (auth.email) {\n            // User authenticated.\n\n            const tracker = trackValue(auth);\n\n            userRequest = [auth, tracker];\n\n            return tracker;\n          }\n          if (userRequest) {\n            // Some user is loading.\n\n            const [requestToken, responseTracker] = userRequest;\n\n            if (requestToken.token === auth.token) {\n              // The right user is loading.\n              return responseTracker;\n            }\n            // Stop loading the wrong user.\n            responseTracker.byNone();\n          }\n\n          // Request user settings.\n          const tracker = trackValueBy<AuthUser | NotAuthenticated>(\n              this.loadUser().do(\n                  mapAfter_(\n                      (response: ApiResponse<AuthUser>): AuthUser | NotAuthenticated => response.ok\n                          ? response.body\n                          : { failure: response },\n                      valueProvider(notAuthenticated),\n                  ),\n              ),\n          );\n\n          userRequest = [auth, tracker];\n\n          return tracker;\n        }),\n    );\n\n    this.user = this.requireUser.do(\n        mapAfter_(user => user.username ? user : notAuthenticated),\n    );\n    new DomEventDispatcher(window).on<StorageEvent>('storage')(({ key, newValue }) => {\n      if (key === authTokenKey) {\n\n        const token = newValue || undefined;\n\n        if (this._auth.it.token !== token) {\n          this._auth.it = toAuthentication(token);\n        }\n      }\n    });\n\n    function storeAuthToken({ token }: Authentication): void {\n      if (token) {\n        storage.setItem(authTokenKey, token);\n      } else {\n        storage.removeItem(authTokenKey);\n      }\n    }\n  }\n\n  get token(): AfterEvent<[AuthToken | NotAuthenticated]> {\n    return this._token.read;\n  }\n\n  get authentication(): AfterEvent<[Authentication]> {\n    return this._auth.read;\n  }\n\n  login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users/login', request);\n  }\n\n  register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users', request);\n  }\n\n  loadUser(): OnEvent<[ApiResponse<AuthUser>]> {\n\n    const apiFetch: ApiFetch = this._context.get(ApiFetch);\n    const apiRequest: ApiRequest<AuthUser> = {\n      path: 'user',\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      respondAs: 'user',\n      auth: true,\n    };\n\n    return apiFetch(apiRequest).do(\n        mapOn_(response => {\n          if (response.ok) {\n            this._setUserSettings(response.body);\n          }\n          return response;\n        }),\n    );\n  }\n\n  updateSettings(request: UpdateSettingsRequest): OnEvent<[ApiResponse<AuthUser>]> {\n\n    const apiFetch: ApiFetch = this._context.get(ApiFetch);\n    const apiRequest: ApiRequest<AuthUser> = {\n      path: 'user',\n      init: {\n        method: 'PUT',\n        body: JSON.stringify({ user: request }),\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json',\n        },\n      },\n      respondAs: 'user',\n      auth: true,\n    };\n\n    return apiFetch(apiRequest).do(\n        mapOn_(response => {\n          if (response.ok) {\n            this._setUserSettings(response.body);\n          }\n          return response;\n        }),\n    );\n  }\n\n  logout(): void {\n    this._auth.it = notAuthenticated;\n  }\n\n  private _setUserSettings(user: AuthUser): void {\n    this._auth.it = {\n      ...user,\n      token: this._token.it.token || user.token, // Do not update token here, as this would cause multiple user reloads\n    };\n  }\n\n  private _request(\n      path: string,\n      request: object,\n  ): OnEvent<[ApiResponse<AuthUser>]> {\n\n    const apiFetch: ApiFetch = this._context.get(ApiFetch);\n    const apiRequest: ApiRequest<AuthUser> = {\n      path,\n      init: {\n        method: 'POST',\n        body: JSON.stringify({ user: request }),\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json',\n        },\n      },\n      respondAs: 'user',\n      auth: false,\n    };\n\n    return apiFetch(apiRequest).do(\n        mapOn_(response => {\n          this._auth.it = response.ok ? response.body : { failure: response };\n          return response;\n        }),\n    );\n  }\n\n}\n\nfunction toAuthentication(token: string | null | undefined): Authentication {\n  return token ? { token } : notAuthenticated;\n}\n","import { Feature } from '@wesib/wesib';\nimport { AuthService } from './auth-service';\nimport { AuthService$ } from './auth-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: AuthService, as: AuthService$ });\n  },\n})\nexport class AuthSupport {\n}\n"],"names":["OnDomEvent$sample","onEventBy","noop","onDomEventBy","register","onDomEvent","listener","opts","receiver","eventReceiver","supply","isOff","OnEvent__symbol","do","then","OnDomEvent$context","onRecurrent","DomEventDispatcher","[object Object]","target","this","Supply","_target","type","needs","domListener","event","receive","addEventListener","whenOff","removeEventListener","dispatchEvent","handleDomEvents","enable","listenDomEventsPassively","preventDefaultDomEventHandler","supplier","passive","capture","context","preventDefault","stopDomEvents","stopPropagation","AuthService__key","SingleContextKey","AuthService","ContextKey__symbol","notAuthenticated","AuthService$","_context","super","trackValue","window","get","BootstrapWindow","storage","localStorage","userRequest","_auth","toAuthentication","getItem","_token","by","authentication","valueOn_","token","it","on","setItem","removeItem","requireUser","digAfter","auth","afterThe","failure","ok","errors","notAuthenticatedError","email","tracker","requestToken","responseTracker","byNone","trackValueBy","loadUser","mapAfter_","response","body","valueProvider","user","username","key","newValue","undefined","read","request","_request","ApiFetch","apiFetch","path","init","method","headers","Accept","respondAs","mapOn_","_setUserSettings","JSON","stringify","Content-Type","AuthSupport","Feature","setup","provide","a","as"],"mappings":"wYAyCA,MAAMA,EAAmCC,EAAeC,YAUxCC,EACZC,GAOF,MAAMC,GAAeC,EAAoCC,KAEvD,MAAMC,EAAWC,EAAcH,IACzBI,OAAEA,GAAWF,EAMnB,OAJKE,EAAOC,OACVP,EAASI,EAAUD,GAGdG,GAOT,OAJAL,EAAWO,GAAmBZ,EAAkBY,GAChDP,EAAWQ,GAAKb,EAAkBa,GAClCR,EAAWS,KAAOd,EAAkBc,KAE7BT,EC/DT,MAAMU,EAAiD,CACrDC,YAAad,SAMFe,EAcXC,YAAYC,GAZHC,YAAiB,IAAIC,EAa5BD,KAAKE,QAAUH,EAiBjBD,GAAyBK,GACvB,OAAOpB,GAAqB,CAACG,EAAUC,KAErC,MAAMG,OAAEA,GAAWJ,EAInB,GAFAI,EAAOc,MAAMJ,OAERV,EAAOC,MAAO,CAGjB,MAAMc,EAA6BC,GAASpB,EAASqB,QAAQZ,EAAoBW,GAEjFN,KAAKE,QAAQM,iBAAiBL,EAAME,EAAalB,GACjDD,EAASI,OAAOmB,SAAQ,IAAMT,KAAKE,QAAQQ,oBAAoBP,EAAME,SAe3EP,SAASQ,GACP,OAAQN,KAAKV,OAAOC,OAASS,KAAKE,QAAQS,cAAcL,aC/D5CM,EACZC,GAAS,GAEX,OAAOA,EAASC,EAA2BC,EAO7C,SAASD,EAA+CE,GACtD,OAAOjC,GAAa,CAChBG,EACAC,IAEU,MAARA,EACK6B,EAAS9B,EAAU,CAAE+B,SAAS,IAEnB,kBAAT9B,EACF6B,EAAS9B,EAAU,CAAEgC,QAAS/B,EAAM8B,SAAS,IAElC,MAAhB9B,EAAK8B,QACAD,EAAS9B,EAAU,IAAKC,EAAM8B,SAAS,IAGzCD,EAAS9B,EAAUC,KAQ9B,SAAS4B,EAAoDC,GAC3D,OAAOjC,GAAa,CAChBG,EACAC,KAGF,MAAMC,EAAWC,EAAcH,GAE/B,OAAO8B,EACH,CACE1B,OAAQF,EAASE,OACjBQ,QAAQqB,EAASb,GACfA,EAAMc,iBACNhC,EAASmB,QAAQY,EAASb,KAG9BnB,eC/CQkC,EACZL,GAEF,OAAOjC,GAAa,CAChBG,EACAC,KAGF,MAAMC,EAAWC,EAAcH,GAE/B,OAAO8B,EACH,CACE1B,OAAQF,EAASE,OACjBQ,QAAQqB,EAASb,GACfA,EAAMgB,kBACNlC,EAASmB,QAAQY,EAASb,KAG9BnB,YClCKoC,MACSC,EAA8B,sBCqB9BC,EAEpBC,WAAYA,KACV,OAAOH,SCZEI,EAAqC,SCMrCC,UAAqBH,EAQhC3B,YAA6B+B,GAC3BC,QAD2B9B,cAAA6B,EAFZ7B,YAAS+B,EAAyCJ,GAKjE,MAAMK,EAASH,EAASI,IAAIC,GACtBC,EAAUH,EAAOI,aASvB,IAAIC,EAPJrC,KAAKsC,MAAQP,EAA2BQ,EAAiBJ,EAAQK,QAhBhD,wBAiBjBxC,KAAKyC,OAAOC,GAAG1C,KAAK2C,eAAelD,GAC/BmD,GAAS,EAAGC,MAAAA,KAAY7C,KAAKyC,OAAOK,GAAGD,QAAUA,GAAS,CAAEA,MAAAA,OAGhE7C,KAAKsC,MAAMS,IAqEX,UAAwBF,MAAEA,IACpBA,EACFV,EAAQa,QA5FK,qBA4FiBH,GAE9BV,EAAQc,WA9FK,yBAyBjBjD,KAAKkD,YAAclD,KAAK2C,eAAelD,GACnC0D,GAAUC,IACR,IAAKA,EAAKP,MAER,OAAOQ,EAA6B,CAClCC,QAAS,CACPC,IAAI,EACJC,OAAQC,OAId,GAAIL,EAAKM,MAAO,CAGd,MAAMC,EAAU5B,EAAWqB,GAI3B,OAFAf,EAAc,CAACe,EAAMO,GAEdA,EAET,GAAItB,EAAa,CAGf,MAAOuB,EAAcC,GAAmBxB,EAExC,GAAIuB,EAAaf,QAAUO,EAAKP,MAE9B,OAAOgB,EAGTA,EAAgBC,SAIlB,MAAMH,EAAUI,EACZ/D,KAAKgE,WAAWvE,GACZwE,GACKC,GAAiEA,EAASX,GACrEW,EAASC,KACT,CAAEb,QAASY,IACjBE,EAAczC,MAO1B,OAFAU,EAAc,CAACe,EAAMO,GAEdA,MAIb3D,KAAKqE,KAAOrE,KAAKkD,YAAYzD,GACzBwE,GAAUI,GAAQA,EAAKC,SAAWD,EAAO1C,KAE7C,IAAI9B,EAAmBmC,GAAQe,GAAiB,UAAhD,EAA2D,EAAGwB,IAAAA,EAAKC,SAAAA,MACjE,GAhFe,uBAgFXD,EAAsB,CAExB,MAAM1B,EAAQ2B,QAAYC,EAEtBzE,KAAKsC,MAAMQ,GAAGD,QAAUA,IAC1B7C,KAAKsC,MAAMQ,GAAKP,EAAiBM,QAczCA,YACE,OAAO7C,KAAKyC,OAAOiC,KAGrB/B,qBACE,OAAO3C,KAAKsC,MAAMoC,KAGpB5E,MAAM6E,GACJ,OAAO3E,KAAK4E,SAAS,cAAeD,GAGtC7E,SAAS6E,GACP,OAAO3E,KAAK4E,SAAS,QAASD,GAGhC7E,WAeE,OAb2BE,KAAK6B,SAASI,IAAI4C,EAatCC,CAZkC,CACvCC,KAAM,OACNC,KAAM,CACJC,OAAQ,MACRC,QAAS,CACPC,OAAQ,qBAGZC,UAAW,OACXhC,MAAM,IAGoB3D,GACxB4F,GAAOnB,IACDA,EAASX,IACXvD,KAAKsF,iBAAiBpB,EAASC,MAE1BD,MAKfpE,eAAe6E,GAiBb,OAf2B3E,KAAK6B,SAASI,IAAI4C,EAetCC,CAdkC,CACvCC,KAAM,OACNC,KAAM,CACJC,OAAQ,MACRd,KAAMoB,KAAKC,UAAU,CAAEnB,KAAMM,IAC7BO,QAAS,CACPC,OAAQ,mBACRM,eAAgB,qBAGpBL,UAAW,OACXhC,MAAM,IAGoB3D,GACxB4F,GAAOnB,IACDA,EAASX,IACXvD,KAAKsF,iBAAiBpB,EAASC,MAE1BD,MAKfpE,SACEE,KAAKsC,MAAMQ,GAAKnB,EAGV7B,iBAAiBuE,GACvBrE,KAAKsC,MAAMQ,GAAK,IACXuB,EACHxB,MAAO7C,KAAKyC,OAAOK,GAAGD,OAASwB,EAAKxB,OAIhC/C,SACJiF,EACAJ,GAkBF,OAf2B3E,KAAK6B,SAASI,IAAI4C,EAetCC,CAdkC,CACvCC,KAAAA,EACAC,KAAM,CACJC,OAAQ,OACRd,KAAMoB,KAAKC,UAAU,CAAEnB,KAAMM,IAC7BO,QAAS,CACPC,OAAQ,mBACRM,eAAgB,qBAGpBL,UAAW,OACXhC,MAAM,IAGoB3D,GACxB4F,GAAOnB,IACLlE,KAAKsC,MAAMQ,GAAKoB,EAASX,GAAKW,EAASC,KAAO,CAAEb,QAASY,GAClDA,OAOjB,SAAS3B,EAAiBM,GACxB,OAAOA,EAAQ,CAAEA,MAAAA,GAAUlB,MC5NhB+D,EAAb,QAAaA,KALZC,EAAQ,CACP7F,MAAM8F,GACJA,EAAMC,QAAQ,CAAEC,EAAGrE,EAAasE,GAAInE,QAG3B8D"}