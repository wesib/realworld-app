{"version":3,"file":"lib.e4c19b17.js","sources":["../../node_modules/call-thru/src/misc/asis.ts","../../node_modules/call-thru/src/misc/noop.ts","../../node_modules/call-thru/src/misc/presence.ts","../../node_modules/call-thru/src/misc/value-providers.ts","../../node_modules/call-thru/src/next-call.ts","../../node_modules/call-thru/src/passes/arg.ts","../../node_modules/call-thru/src/passes/args.ts","../../node_modules/call-thru/src/passes/each.ts","../../node_modules/call-thru/src/passes/skip.ts","../../node_modules/a-iterable/src/api.ts","../../node_modules/a-iterable/src/revertible-iterable.ts","../../node_modules/a-iterable/src/util.ts","../../node_modules/a-iterable/src/reverse.ts","../../node_modules/a-iterable/src/termination.ts","../../node_modules/a-iterable/src/transform.ts","../../node_modules/a-iterable/src/thru/thru-it.ts","../../node_modules/a-iterable/src/a-iterable.ts","../../node_modules/a-iterable/src/construction.ts","../../node_modules/a-iterable/src/objects.ts","../../node_modules/context-values/src/context-key.ts","../../node_modules/context-values/src/context-key-error.ts","../../node_modules/context-values/src/context-value-spec.ts","../../node_modules/context-values/src/context-values.ts","../../node_modules/context-values/src/context-registry.ts","../../node_modules/context-values/src/simple-context-key.ts","../../node_modules/fun-events/src/base/event-keeper.ts","../../node_modules/fun-events/src/base/event-supply.ts","../../node_modules/fun-events/src/base/event-receiver.ts","../../node_modules/fun-events/src/base/event-sender.ts","../../node_modules/fun-events/src/base/event-notifier.ts","../../node_modules/fun-events/src/impl/once.ts","../../node_modules/fun-events/src/impl/share.ts","../../node_modules/fun-events/src/impl/till-off.ts","../../node_modules/fun-events/src/on-event.ts","../../node_modules/fun-events/src/impl/thru.ts","../../node_modules/fun-events/src/after-event.ts","../../node_modules/fun-events/src/keepers/after-all.ts","../../node_modules/fun-events/src/keepers/after-each.ts","../../node_modules/fun-events/src/passes/next-after-event.ts","../../node_modules/fun-events/src/passes/next-on-event.ts","../../node_modules/fun-events/src/senders/event-emitter.ts","../../node_modules/fun-events/src/senders/on-any.ts","../../node_modules/fun-events/src/senders/on-async.ts","../../node_modules/fun-events/src/senders/on-any-async.ts","../../node_modules/fun-events/src/state/state-path.ts","../../node_modules/fun-events/src/state/state-tracker.ts","../../node_modules/fun-events/src/value/value-tracker.ts","../../node_modules/fun-events/src/value/track-value.ts","../../node_modules/namespace-aliaser/src/naming.ts","../../node_modules/namespace-aliaser/src/namings.ts","../../node_modules/namespace-aliaser/src/namespace.ts","../../node_modules/namespace-aliaser/src/name.ts","../../node_modules/namespace-aliaser/src/namespace-aliaser.ts","../../node_modules/context-values/src/updatable/context-up-key.ts","../../node_modules/context-values/src/updatable/fn-context-key.ts","../../node_modules/render-scheduler/src/render-schedule.ts","../../node_modules/render-scheduler/src/custom-render-scheduler.ts","../../node_modules/render-scheduler/src/animation-render-scheduler.ts","../../node_modules/render-scheduler/src/render-scheduler.ts","../../node_modules/fun-events/src/dom/on-dom-event.ts","../../node_modules/fun-events/src/dom/dom-event-dispatcher.ts","../../node_modules/http-header-value/src/hthv-partial.impl.ts","../../node_modules/http-header-value/src/parser/add-param.ts","../../node_modules/http-header-value/src/parser/next-in-item.ts","../../node_modules/http-header-value/src/parser/parse-date-time.ts","../../node_modules/http-header-value/src/parser/parse-none.ts","../../node_modules/http-header-value/src/parser/item-parser.ts","../../node_modules/http-header-value/src/parser/quoted-string-parser.ts","../../node_modules/http-header-value/src/parser/angle-brackets-parser.ts","../../node_modules/http-header-value/src/parser/next-in-comment.ts","../../node_modules/http-header-value/src/parser/spaces-parser.ts","../../node_modules/http-header-value/src/parser/param-parser.ts","../../node_modules/http-header-value/src/parser/parser-config.ts","../../node_modules/http-header-value/src/hthv-parser.ts","../../node_modules/http-header-value/src/parser/item-delimit-parser.ts","../../node_modules/http-header-value/src/parser/comment-parser.ts","../../node_modules/http-header-value/src/hthv-parse.ts","../../node_modules/http-header-value/src/hthv-quote.ts","../../node_modules/delta-set/src/delta-set.ts","../../node_modules/input-aspects/src/aspect.ts","../../node_modules/input-aspects/src/aspect.impl.ts","../../node_modules/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../node_modules/input-aspects/src/aspects/render-scheduler.aspect.ts","../../node_modules/input-aspects/src/converter.ts","../../node_modules/input-aspects/src/control.ts","../../node_modules/input-aspects/src/controls/abstract.control.ts","../../node_modules/input-aspects/src/controls/value-of.control.ts","../../node_modules/input-aspects/src/containers/container.control.ts","../../node_modules/input-aspects/src/containers/parents.aspect.ts","../../node_modules/input-aspects/src/element.control.ts","../../node_modules/input-aspects/src/data/mode.aspect.ts","../../node_modules/input-aspects/src/data/data.aspect.ts","../../node_modules/input-aspects/src/containers/group.control.ts","../../node_modules/input-aspects/src/validation/require-nothing.validator.ts","../../node_modules/input-aspects/src/validation/validator.ts","../../node_modules/input-aspects/src/validation/validator.impl.ts","../../node_modules/input-aspects/src/validation/validation.aspect.ts","../../node_modules/input-aspects/src/validation/require-all.validator.ts","../../node_modules/input-aspects/src/validation/require-present.validator.ts","../../node_modules/input-aspects/src/submit.aspect.ts","../../node_modules/input-aspects/src/data/modes/mode-by-form.ts","../../node_modules/input-aspects/src/data/modes/mode-by-validity.ts","../../node_modules/input-aspects/src/elements/element.impl.ts","../../node_modules/input-aspects/src/elements/text.control.ts","../../node_modules/input-aspects/src/elements/focus/focus.aspect.ts","../../node_modules/input-aspects/src/elements/focus/status.aspect.ts","../../node_modules/input-aspects/src/elements/forms/form-element.control.ts","../../node_modules/input-aspects/src/elements/forms/submit-button.control.ts","../../node_modules/input-aspects/src/elements/style/styled-element.aspect.ts","../../node_modules/input-aspects/src/elements/style/css-classes.aspect.ts","../../node_modules/input-aspects/src/elements/style/css-error.ts","../../node_modules/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * A function that returns its argument as is.\n *\n * @param value  A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * A function that checks whether the given value is present.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value  A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return (): T => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return (): T => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return (): T => Array.from(values) as T;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from './call-chain';\n\n/**\n * A key of a [[NextCall]] method responsible for calling the next pass in chain.\n */\nexport const NextCall__symbol = (/*#__PURE__*/ Symbol('next-call'));\n\n/**\n * A call of the next pass in chain.\n *\n * This is basically a function with additional method, which is treated specially by call chaining functions.\n * When previous pass in chain returns a [[NextCall]] instance, it will be used to call the next pass in chain.\n * Otherwise the next pass will be called with value returned as its {@link CallChain.pass single argument}.\n *\n * A [[NextCall]] is a function returning itself. So it can be chained like any other pass.\n *\n * A [[nextCall]] function can be used to construct a next call.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of arguments tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass. The same as `NextArgs` by default.\n */\nexport interface NextCall<Chain extends CallChain, NextArgs extends any[], NextArg = NextArgs> {\n\n  readonly $?: NextArg; // Silence the TypeScript compiler, as `NextArg` is never read.\n\n  /**\n   * Calls the given pass of the call chain.\n   *\n   * @param chain  Target call chain.\n   * @param pass  A pass in call chain to call.\n   */\n  [NextCall__symbol](\n      chain: Chain,\n      pass: (this: void, ...args: NextArgs) => void,\n  ): void;\n\n  /**\n   * Returns itself.\n   *\n   * Makes this call a valid no-arg pass of a call chain.\n   */\n  (): this; // eslint-disable-line @typescript-eslint/prefer-function-type\n\n}\n\n/**\n * Constructs a call of the next pass in chain.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of argument tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass. The same as `NextArgs` by default.\n * @param callNext  A next pass caller function.\n *\n * @returns Next pass call performed by the given function.\n */\nexport function nextCall<Chain extends CallChain, NextArgs extends any[], NextArg>(\n    callNext: (\n        this: void,\n        chain: Chain,\n        fn: (this: void, ...args: NextArgs) => void,\n    ) => void,\n): NextCall<Chain, NextArgs, NextArg> {\n\n  const result = (() => result) as NextCall<Chain, NextArgs, NextArg>;\n\n  result[NextCall__symbol] = (chain, fn) => callNext(chain, fn);\n\n  return result;\n}\n\n/**\n * Checks whether the `target` value is a {@link NextCall next call}.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of arguments tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass.\n * @param target  A value to check.\n *\n * @returns `true` if the `target` value is a function with [[NextCall__symbol]] property, or `false` otherwise.\n */\nexport function isNextCall<Chain extends CallChain, NextArgs extends any[], NextArg>(\n    target: any,\n): target is NextCall<Chain, NextArgs, NextArg> {\n  return typeof target === 'function' && NextCall__symbol in target;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Provides a single argument for the next call chain pass.\n *\n * The returned [[NextCall]] implementation does the same as if the `arg` returned from the call chain pass.\n *\n * @typeparam NextArg  A type of argument for the next pass.\n * @param arg  Argument for the next pass.\n *\n * @return A call of the next pass with the given argument.\n */\nexport function nextArg<NextArg>(arg: NextArg): NextCall<CallChain, [NextArg], NextArg> {\n  return nextCall((chain, pass) => chain.pass(pass, arg));\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Provides arguments for the next call chain pass.\n *\n * @typeparam NextArgs  A type of arguments tuple for the next pass.\n * @param args  Arguments for the next pass.\n *\n * @return A call of the next pass with the given arguments.\n */\nexport function nextArgs<NextArgs extends any[]>(\n    ...args: NextArgs\n): NextCall<CallChain, NextArgs, NextArgs> {\n  return nextCall((chain, fn) => chain.call(fn, args));\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Builds a next chained call that passes each provided element to the next pass.\n *\n * Note that default [[CallChain]] supported by [[callThru]] would return only the last element.\n *\n * @typeparam T  A type of element to pass down the chain.\n * @param elements  An iterable of elements to pass down the chain.\n *\n * @returns A multi-call of the next pass with each element.\n */\nexport function nextEach<T>(elements: Iterable<T>): NextCall<CallChain, [T], T> {\n  return nextCall((chain, pass) => {\n    for (const element of elements) {\n      chain.pass(pass, element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * A special [[NextCall]] indicating the rest of the steps are skipped.\n *\n * @typeparam Result  Call chain result type.\n */\nexport type NextSkip<Result = undefined> = NextCall<CallChain, never, Result>;\n\n/**\n * Builds a next call that skips the rest of the chain.\n *\n * This has the same effect as {@link nextReturn `nextReturn(undefined)`}.\n */\nexport const nextSkip: NextSkip = (/*#__PURE__*/ nextCall(chain => chain.skip()));\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\n/**\n * A type of elements of iterable.\n *\n * @typeparam T  A type of iterable.\n */\nexport type IterableElement<T extends Iterable<any>> = T extends Iterable<infer E> ? E : never;\n\n/**\n * Arbitrary class implementing `Iterable` interface.\n *\n * @typeparam T  A type of iterable.\n * @typeparam E  A type of elements to iterate.\n */\nexport interface IterableClass<T extends Iterable<E>, E = IterableElement<T>> extends Function {\n  prototype: T;\n  new (...args: any[]): T;\n}\n\n/**\n * Checks whether the given value is array-like.\n *\n * @param target  A value to check.\n *\n * @returns `true` if the `value` has a `length` property, or `false` otherwise.\n */\nexport function isArrayLike<T>(target: any): target is ArrayLike<T> {\n  return 'length' in target;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\n/**\n * An iterable which elements order can be reversed.\n *\n * Arrays implement this interface.\n */\nexport interface RevertibleIterable<T> extends Iterable<T> {\n\n  /**\n   * Returns an iterable containing this iterable's elements in reverse order.\n   *\n   * Corresponds to `Array.prototype.reverse()`. Note however, that the array counterpart reverses elements _in place_\n   * rather than creating a new array.\n   *\n   * @return Reversed iterable instance.\n   */\n  reverse(): Iterable<T>;\n\n}\n\n/**\n * Checks whether the given iterable is revertible.\n *\n * This is always `true` for arrays.\n *\n * @param iterable  Iterable to check.\n *\n * @returns `true` if `iterable` has a `reverse` property, or `false` otherwise.\n */\nexport function itsRevertible<T>(iterable: Iterable<T>): iterable is RevertibleIterable<T> {\n  return 'reverse' in iterable;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  return function *() { yield* iterable; }();\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>,\n): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>,\n): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (!reverse) {\n    return iterable;\n  }\n\n  const reversible = iterable as RevertibleIterable<T>;\n\n  reversible.reverse = reverse;\n\n  return reversible;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Constructs a reversed iterable.\n *\n * If the `source` iterable is an array-like structure, then uses `reverseArray()` function to revert the constructed\n * iterable.\n * If the `source` iterable is revertible, then uses its `reverse()` method to revert the constructed one.\n * Otherwise stores elements to array and reverts them with `reverseArray()` function.\n *\n * @param source  A source iterable.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseIt<T>(source: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): Iterable<T> {\n  if (isArrayLike(source)) {\n    return reverseArray(source);\n  }\n  if (itsRevertible(source)) {\n\n    const reversed = source.reverse();\n\n    return makeIt(() => itsIterator(reversed));\n  }\n  return reverseArray(Array.from(source));\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): Iterable<T> {\n  return makeIt(\n      function *() {\n\n        const len = array.length;\n\n        for (let i = len - 1; i >= 0; --i) {\n          yield array[i];\n        }\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Tests whether at least one element of the given `iterable` passes the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n * and return `true` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the callback function returned a truthy value for at least one element in the array, or `false`\n * otherwise. Returns `false` for empty iterable.\n */\nexport function itsSome<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (test(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  return itsIterator(iterable).next().value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: R, element: T) => R,\n    initialValue: R,\n): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { asis } from 'call-thru';\nimport { makeIt } from './util';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is R,\n): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (this: void, element: T) => boolean): Iterable<T> {\n  return makeIt(function *() {\n    for (const element of source) {\n      if (test(element)) {\n        yield element;\n      }\n    }\n  });\n}\n\n/**\n * Flattens the source iterable of iterables into a new iterable.\n *\n * Calling this function is the same as calling `flatMapIt(source, asis)`.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable of iterables.\n *\n * @returns A new iterable with each element of `source` being the flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): Iterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => Iterable<R>): Iterable<R>;\n\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R> = asis as (element: T) => Iterable<R>,\n): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield* convert(element);\n    }\n  });\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => R): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield convert(element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { asis, isNextCall, NextCall__symbol, noop } from 'call-thru';\nimport { flatMapIt } from '../transform';\nimport { IterableCallChain } from './iterable-call-chain';\nimport Args = IterableCallChain.Args;\nimport Out = IterableCallChain.Out;\n\n/**\n * Passes each element of the given iterable trough the {@link IterableCallChain chain of transformation passes}.\n *\n * The passes are preformed by `call-thru`.\n *\n * @returns An iterable of transformed elements.\n */\nexport function thruIt<\n    T, Return1\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n): Iterable<Out<Return1>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n): Iterable<Out<Return2>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n): Iterable<Out<Return3>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    Args13 extends Args<Return12>, Return13,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n    pass13: (this: void, ...args: Args13) => Return13,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<T>(\n    it: Iterable<T>,\n    ...passes: ((...args: any[]) => any)[]\n): Iterable<any> {\n\n  let result: Iterable<any>[] = [];\n  const chain = (index: number): IterableCallChain => {\n\n    const lastPass = index >= passes.length;\n\n    ++index;\n\n    const pass = index < passes.length ? passes[index] : noop;\n    const handleResult = (callResult: any, arg: any): void => {\n      if (isNextCall(callResult)) {\n        callResult[NextCall__symbol](chain(index), pass);\n      } else if (lastPass) {\n        result.push([arg]);\n      } else {\n        chain(index).pass(pass, callResult);\n      }\n    };\n\n    return ({\n      call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n        handleResult(fn(...args), args);\n      },\n      pass<A>(fn: (arg: A) => any, arg: A): void {\n        handleResult(fn(arg), arg);\n      },\n      skip() {/* skip item */},\n      iterate<I>(fn: (this: void, arg: I) => void, iterable: Iterable<I>): void {\n        result.push({\n          *[Symbol.iterator]() {\n            for (const item of iterable) {\n\n              const oldResult = result;\n              const newResult: Iterable<any>[] = [];\n\n              try {\n                result = newResult;\n                handleResult(fn(item), item);\n              } finally {\n                result = oldResult;\n              }\n\n              for (const res of newResult) {\n                yield* res;\n              }\n            }\n          },\n        });\n      },\n    });\n  };\n\n  chain(0).iterate(passes[0], it);\n\n  return flatMapIt(result, asis);\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { IterableClass, IterableElement } from './api';\nimport { ArrayLikeIterable } from './array-like-iterable';\nimport { reverseArray, reverseIt } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { itsEach, itsEvery, itsReduction, itsSome } from './termination';\nimport { IterableCallChain, thruIt } from './thru';\nimport { filterIt, flatMapIt, mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\nimport Args = IterableCallChain.Args;\nimport Out = IterableCallChain.Out;\n\n/**\n * @internal\n */\nconst ArrayLikeIterableMethods: (keyof ArrayLikeIterable<any>)[] = [\n  'every',\n  'filter',\n  'flatMap',\n  'forEach',\n  'map',\n  'reduce',\n  'reverse',\n  'some',\n];\n\n/**\n * Abstract `Iterable` implementation with array-like iteration operations.\n *\n * @typeparam T  A type of elements.\n */\nexport abstract class AIterable<T> implements ArrayLikeIterable<T> {\n\n  /**\n   * Returns an iterable without elements.\n   *\n   * @returns An empty iterable instance.\n   */\n  static none<T>(): AIterable<T> {\n    return noneAIterable; // eslint-disable-line @typescript-eslint/no-use-before-define\n  }\n\n  /**\n   * Checks whether the given iterable is an array-like one.\n   *\n   * @param source  An iterable to check.\n   *\n   * @returns `true` is the `source` has all `ArrayLikeIterable` methods (like `Array` or `AIterable` instance),\n   * or `false` otherwise.\n   */\n  static is<T>(source: Iterable<T>): source is ArrayLikeIterable<T> {\n    return ArrayLikeIterableMethods.every(name => name in source);\n  }\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source array-like iterable.\n   *\n   * @return A `source` itself.\n   */\n  static of<T>(source: ArrayLikeIterable<T>): typeof source;\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Either `source` itself if it implements `ArrayLikeIterable` already (see `is()` method),\n   * or new [[AIterable]] instance iterating over the `source`.\n   */\n  static of<T>(source: Iterable<T>): AIterable<T>;\n\n  static of<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): ArrayLikeIterable<T> {\n    if (AIterable.is(source)) {\n      return source;\n    }\n    return AIterable.from(source);\n  }\n\n  /**\n   * Creates an `AIterable` instance that iterates over the same elements as the given one.\n   *\n   * Uses [[reverseIt]] function to reverse the constructed iterable.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Always new `AIterable` instance.\n   */\n  static from<T>(source: Iterable<T> | RevertibleIterable<T> | readonly T[]): AIterable<T> {\n    return makeAIterable(() => source, () => reverseIt(source));\n  }\n\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.every()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n   * and return `false` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n   * Returns `true` for empty iterable.\n   */\n  every(test: (this: void, element: T) => boolean): boolean {\n    return itsEvery(this, test);\n  }\n\n  /**\n   * Creates an iterable with all elements that pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n   * It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter(test: (this: void, element: T) => boolean): AIterable<T>;\n\n  /**\n   * Creates an iterable with all elements extending the given type.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @typeparam R  Target type.\n   * @param test  A predicate function to test that element extends the type R. Returns `true` to keep the element, or\n   * `false` otherwise. It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter<R extends T>(test: (this: void, element: T) => element is R): AIterable<R>;\n\n  filter(test: (this: void, element: T) => boolean): AIterable<T> {\n    return makeAIterable(\n        () => filterIt(this, test),\n        () => filterIt(this.reverse(), test),\n    );\n  }\n\n  /**\n   * First maps each element using a mapping function, then flattens the result into a new iterable.\n   *\n   * Corresponds to `Array.prototype.flatMap()`.\n   *\n   * Note that the overridden `flatMap` method of `ArrayLikeIterable` expects an array to be returned from `convert`\n   * callback, while in this method it may return arbitrary iterable.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n   *\n   * @returns A new [[AIterable]] with each element being the flattened result of the `convert` function call.\n   */\n  flatMap<R>(convert: (this: void, element: T) => Iterable<R>): AIterable<R> {\n    return makeAIterable(\n        () => flatMapIt(this, convert),\n        () => flatMapIt(this.reverse(), element => reverseIt(convert(element))),\n    );\n  }\n\n  /**\n   * Performs the given `action` for each element.\n   *\n   * Corresponds to `Array.prototype.forEach()`.\n   *\n   * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n   * parameter.\n   */\n  forEach(action: (this: void, element: T) => void): void {\n    itsEach(this, action);\n  }\n\n  /**\n   * Creates a new iterable with the results of calling a provided function on every element.\n   *\n   * Corresponds to `Array.prototype.map()`.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n   * parameter.\n   *\n   * @return A new [[AIterable]] with each element being the result of the `convert` function call.\n   */\n  map<R>(convert: (this: void, element: T) => R): AIterable<R> {\n    return makeAIterable(\n        () => mapIt(this, convert),\n        () => mapIt(this.reverse(), convert),\n    );\n  }\n\n  /**\n   * Applies a function against an accumulator and each element to reduce elements to a single value.\n   *\n   * Corresponds to `Array.prototype.reduce()`.\n   *\n   * @typeparam R  A type of reduced value.\n   * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n   * @param initialValue  Initial value passed to the first `reducer` call.\n   *\n   * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in this\n   * iterable.\n   */\n  reduce<R>(reducer: (this: void, prev: R, element: T) => R, initialValue: R): R {\n    return itsReduction(this, reducer, initialValue);\n  }\n\n  /**\n   * Constructs an iterable containing this iterable's elements in reverse order.\n   *\n   * By default this method converts iterable to array and then reverts its elements with [[reverseArray]] function.\n   *\n   * @return Reversed [[AIterable]] instance.\n   */\n  reverse(): AIterable<T> {\n    return makeAIterable(() => reverseArray(Array.from(this)), () => this);\n  }\n\n  /**\n   * Tests whether some element passed the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.some()`.\n   *\n   * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n   * and return `true` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for some element, or `false` otherwise.\n   * Returns `false` for empty iterable.\n   */\n  some(test: (this: void, element: T) => boolean): boolean {\n    return itsSome(this, test);\n  }\n\n  /**\n   * Passes each element of this iterable trough a chain of transformation passes.\n   *\n   * The passes are preformed by `call-thru` library.\n   *\n   * @returns Next iterable of transformed elements.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n  ): AIterable<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AIterable<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AIterable<Out<Return3>>;\n\n  thru<R>(...fns: ((...args: any[]) => any)[]): AIterable<R> {\n\n    const thru = thruIt as any;\n\n    return makeAIterable(() => thru(this, ...fns));\n  }\n\n}\n\n/**\n * @internal\n */\nclass NoneAIterable extends AIterable<any> {\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  *[Symbol.iterator](): Iterator<any> {}\n\n  reverse(): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst noneAIterable = (/*#__PURE__*/ new NoneAIterable());\n\n/**\n * @internal\n */\nfunction makeAIterable<T>(\n    iterate: (this: void) => Iterable<T>,\n    reverse?: (this: void) => Iterable<T>,\n): AIterable<T> {\n\n  class Iterable extends AIterable<T> {\n\n    [Symbol.iterator](): Iterator<T> {\n      return itsIterator(iterate());\n    }\n\n    reverse(): Iterable {\n      if (!reverse) {\n        return super.reverse();\n      }\n      return AIterable.from(makeIt(() => itsIterator(reverse()), () => this));\n    }\n\n  }\n\n  return new Iterable();\n}\n\n/**\n * Extends an iterable class with `AIterable` API.\n *\n * @typeparam C  A type of iterable class to extend.\n * @typeparam E  A type of elements to iterate.\n * @param iterableClass  A class to extend.\n *\n * @returns A new class extending original `iterableClass` and implementing the missing [[AIterable]] methods.\n */\nexport function toAIterable<C extends IterableClass<any, E>, E = IterableElement<InstanceType<C>>>(\n    iterableClass: C,\n): C & IterableClass<AIterable<E>, E> {\n\n  class ExtendedIterable extends iterableClass {\n  }\n\n  const extended = ExtendedIterable;\n  const proto = extended.prototype;\n\n  ArrayLikeIterableMethods.forEach(name => {\n    if (!(name in proto)) {\n      Object.defineProperty(proto, name, {\n        configurable: true,\n        value: AIterable.prototype[name],\n      });\n    }\n  });\n\n  return extended as C & IterableClass<AIterable<E>, E>;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { reverseArray } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * Builds an iterable over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      function *() {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < array.length; ++i) {\n          yield array[i];\n        }\n      },\n      () => reverseArray(array),\n  );\n}\n\n/**\n * @internal\n */\nconst noneIterable: RevertibleIterable<any> = {\n\n  *[Symbol.iterator](): Iterator<any> {/* do not iterate */},\n\n  reverse() { return this; },\n\n};\n\n/**\n * Returns an iterable without elements.\n *\n * @typeparam T  A type of constructed iterable elements.\n *\n * @returns An empty iterable instance revertible to itself.\n */\nexport function overNone<T>(): RevertibleIterable<T> {\n  return noneIterable;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { overArray } from './construction';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Builds an iterable over the keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys from.\n */\nexport function overKeys<T extends object>(target: T): RevertibleIterable<keyof T> {\n  return overArray(Reflect.ownKeys(target) as (keyof T)[]);\n}\n\n/**\n * Object property entry. This is a tuple consisting of property key and value.\n */\nexport type ObjectEntry<T, K extends keyof T = keyof T> = [K, T[K]];\n\n/**\n * Builds an iterable over the key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys and values from.\n */\nexport function overEntries<T extends object>(target: T): RevertibleIterable<ObjectEntry<T>> {\n\n  const keys = overKeys(target);\n\n  function mapToEntries(_keys: Iterable<keyof T>): Iterable<ObjectEntry<T>> {\n    return mapIt(_keys, key => [key, target[key]] as ObjectEntry<T>);\n  }\n\n  return makeIt(() => itsIterator(mapToEntries(keys)), () => mapToEntries(keys.reverse()));\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @typeparam Ctx  Context type.\n   * @param opts  Context value growth options.\n   *\n   * @returns Single context value, or `undefined` if there is no default value.\n   */\n  abstract grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Value, Src, Seed>): Value | null | undefined;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value growth options.\n *\n * An instance of these options is passed to [[ContextKey.grow]] method to provide the necessary value growth context.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport interface ContextValueOpts<Ctx extends ContextValues, Value, Src, Seed> {\n\n  /**\n   * Target context.\n   */\n  readonly context: Ctx;\n\n  /**\n   * Context value seeder.\n   */\n  readonly seeder: ContextSeeder<Ctx, Src, Seed>;\n\n  /**\n   * Context value seed.\n   */\n  readonly seed: Seed;\n\n  /**\n   * A fallback value to use if there is no value associated with the given key.\n   *\n   * Can be `null` or `undefined`.\n   */\n  readonly or?: Value | null;\n\n  /**\n   * Handles missing context value.\n   *\n   * It can be called to prefer a fallback value over the default one specified in the value key.\n   *\n   * @param defaultProvider  Default value provider. It is called unless a fallback value is specified.\n   * If it returns a non-null/non-undefined value, then the returned value will be associated with the context key.\n   */\n  byDefault(defaultProvider: () => Value | null | undefined): Value | null | undefined;\n\n}\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Seed, Src, Seed>): Seed | null | undefined {\n\n    const { seeder, seed } = opts;\n\n    return seeder.isEmpty(seed) ? opts.byDefault(() => seed) : seed;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { valueProvider } from 'call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: Ctx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: Ctx) {\n        return new DepType(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${spec}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\n/**\n * @internal\n */\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n    return this.newValues(cache).get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, defaultUsed] = growValue(context, key, opts);\n\n        if (cache && !defaultUsed) {\n          values.set(key, constructed);\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> | undefined,\n    ): [Value | null | undefined, boolean] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let defaultUsed = false;\n\n      const valueOpts: {\n        -readonly [K in keyof ContextValueOpts<Ctx, Value, Src, Seed>]: ContextValueOpts<Ctx, Value, Src, Seed>[K];\n      } = {\n        context,\n        seeder,\n        seed,\n        byDefault: (opts && 'or' in opts)\n            ? () => {\n              defaultUsed = true;\n              return opts.or;\n            }\n            : defaultProvider => {\n\n              const defaultValue = defaultProvider();\n\n              if (defaultValue == null) {\n                throw new ContextKeyError(key);\n              }\n\n              return defaultValue;\n            },\n      };\n\n      if (opts && 'or' in opts) {\n        valueOpts.or = opts.or;\n      }\n\n      return [\n        key.grow(valueOpts),\n        defaultUsed,\n      ];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n    return new ContextRegistry(<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx) => {\n\n      const [seeder, factory] = this._seeding(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { AIterable, itsEmpty, itsLast, overArray, overNone } from 'a-iterable';\nimport { asis, isPresent, noop, valuesProvider } from 'call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\nclass SimpleContextSeeder<Ctx extends ContextValues, Src> implements ContextSeeder<Ctx, Src, AIterable<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.push(provider);\n    return () => {\n\n      const found = this._providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AIterable<Src> = AIterable.from(overNone())): AIterable<Src> {\n    return AIterable.from([\n      initial,\n      sourceValues(context, this._providers),\n    ]).flatMap(asis);\n  }\n\n  isEmpty(seed: AIterable<Src>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: AIterable<Src>, second: AIterable<Src>): AIterable<Src> {\n    return AIterable.from([first, second]).flatMap(asis);\n  }\n\n}\n\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, AIterable<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects value sources into iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, AIterable<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, AIterable<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, AIterable<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextRef<Value> = ContextRef<Value, Value>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, AIterable<Value>>;\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, Value, Value, AIterable<Value>>,\n  ): Value | null | undefined {\n\n    const value = itsLast(opts.seed);\n\n    if (value != null) {\n      return value;\n    }\n\n    return opts.byDefault(() => this.byDefault(opts.context, this));\n  }\n\n}\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport type MultiContextRef<Src> = ContextRef<readonly Src[], Src>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport class MultiContextKey<Src>\n    extends SimpleContextKey<readonly Src[], Src>\n    implements MultiContextRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<Src, AIterable<Src>>;\n        byDefault?: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, readonly Src[], Src, AIterable<Src>>,\n  ): readonly Src[] | null | undefined {\n\n    const result = Array.from(opts.seed);\n\n    if (result.length) {\n      return result;\n    }\n\n    return opts.byDefault(() => {\n\n      const defaultSources = this.byDefault(opts.context, this);\n\n      if (defaultSources) {\n        return Array.from(defaultSources);\n      }\n\n      return;\n    });\n  }\n\n}\n\n/**\n * Context value provider and cached context value source.\n *\n * @internal\n */\ntype SourceEntry<Ctx extends ContextValues, Src> = [ContextValueProvider<Ctx, Src>, (Src | null | undefined)?];\n\n/**\n * @internal\n */\nfunction sourceValues<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providers: ContextValueProvider<Ctx, Src>[],\n): AIterable<Src> {\n  return AIterable.from(overArray(providers.map<SourceEntry<Ctx, Src>>(provider => [provider])))\n      .map(entry => {\n        if (entry.length > 1) {\n          return entry[1];\n        }\n\n        const source = entry[0](context);\n\n        entry.push(source);\n\n        return source;\n      })\n      .filter<Src>(isPresent);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventReceiver } from './event-receiver';\nimport { EventSupply } from './event-supply';\n\n/**\n * A key of event receiver registration method of [[EventKeeper]].\n *\n * @category Core\n */\nexport const AfterEvent__symbol = (/*#__PURE__*/ Symbol('after-event'));\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<E extends any[]> {\n\n  /**\n   * Registers a receiver of events kept and sent by this keeper.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  [AfterEvent__symbol](receiver: EventReceiver<E>): EventSupply;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeparam T  Target event keeper.\n   */\n  export type Event<T extends EventKeeper<any>> = T extends EventKeeper<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventKeeper]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains an `[AfterEvent__symbol]` property, or `false` otherwise.\n */\nexport function isEventKeeper<E extends any[]>(value: object): value is EventKeeper<E> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\n\n/**\n * A key of [[EventSupplyPeer]] property containing [[EventSupply]] instance.\n *\n * @category Core\n */\nexport const EventSupply__symbol = (/*#__PURE__*/ Symbol('events-supply'));\n\n/**\n * A supply of events from {@link EventSupplier event supplier} to {@link EventReceiver event receiver}.\n *\n * When no longer needed the supply may be {@link off cut off}.\n *\n * May be constructed using [[eventSupply]] function.\n *\n * @category Core\n */\nexport abstract class EventSupply implements EventSupplyPeer {\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means the events will no longer be supplied.\n   */\n  abstract readonly isOff: boolean;\n\n  /**\n   * `this` event supply.\n   */\n  get [EventSupply__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Cuts off the supply of events.\n   *\n   * After this method call the receiver will no longer receive events.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason  An optional reason why supply is cut off. It will be reported to [[whenOff]] callbacks.\n   * @returns A cut off event supply instance.\n   */\n  abstract off(reason?: any): EventSupply;\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if [[isOff]] is `true`.\n   *\n   * @param callback  A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means normal completion.\n   *\n   * @returns `this` instance.\n   */\n  abstract whenOff(callback: (this: void, reason?: any) => void): this;\n\n  /**\n   * Declares this event supply depends on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one is will be cut off with the same reason.\n   *\n   * @param another  A peer of event supply this one depends on.\n   *\n   * @return `this` instance.\n   */\n  needs(another: EventSupplyPeer): this {\n    eventSupplyOf(another).whenOff(reason => this.off(reason));\n    return this;\n  }\n\n}\n\n/**\n * A peer of event supply.\n *\n * Contains an [[EventSupply]] that can be extracted by [[eventSupplyOf]] function.\n *\n * To be implemented by objects that controls event supply. An [[EventSupply]] is a peer of itself.\n *\n * @category Core\n */\nexport interface EventSupplyPeer {\n\n  /**\n   * An event supply of this peer.\n   */\n  readonly [EventSupply__symbol]: EventSupply;\n\n}\n\n/**\n * Extracts an event supply from its peer.\n *\n * @category Core\n * @param peer  A peer of event supply.\n *\n * @returns Extracted event supply contained in [[EventSupply__symbol]] property.\n */\nexport function eventSupplyOf(peer: EventSupplyPeer): EventSupply {\n  return peer[EventSupply__symbol];\n}\n\n/**\n * Constructs new {@link EventSupply event supply}.\n *\n * @category Core\n * @param off  A function to call when supply will supply is {@link EventSupply.off cut off}. Accepts optional\n * cut off reason as its only parameter. No-op by default.\n */\nexport function eventSupply(off: (this: void, reason?: any) => void = noop): EventSupply {\n\n  let whenOff: (callback: (reason?: any) => void) => void;\n  let cutOff: (reason?: any) => void = reason => {\n    whenOff = callback => callback(reason);\n    cutOff = noop;\n    off(reason);\n  };\n\n  whenOff = callback => {\n\n    const prev = cutOff;\n\n    cutOff = reason => {\n      prev(reason);\n      callback(reason);\n    };\n  };\n\n  class Supply extends EventSupply {\n\n    get isOff(): boolean {\n      return cutOff === noop;\n    }\n\n    off(reason?: any): EventSupply {\n      cutOff(reason);\n      return this;\n    }\n\n    whenOff(callback: (reason?: any) => void): this {\n      whenOff(callback);\n      return this;\n    }\n\n  }\n\n  return new Supply();\n}\n\n/**\n * @internal\n */\nclass NoSupply extends EventSupply {\n\n  get isOff(): true {\n    return true;\n  }\n\n  off(): this {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst noSupply = (/*#__PURE__*/ new NoSupply());\n\n/**\n * Returns a no-event supply.\n *\n * @category Core\n *\n * @returns An event supply that is already cut off without any particular reason.\n */\nexport function noEventSupply(): EventSupply {\n  return noSupply;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { eventSupply, EventSupply } from './event-supply';\n\n/**\n * Event receiver is called on each event sent by [[EventSender]] when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of [[EventReceiver.Object.receive]] method.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<E extends any[]> = EventReceiver.Function<E> | EventReceiver.Object<E>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<E extends any[]> =\n  /**\n   * @param event  An event represented by function call arguments.\n   */\n      (this: void, ...event: E) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<E extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link EventSupply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: EventSupply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context  An event processing context.\n     * @param event  An event represented as the rest of arguments.\n     */\n    receive(context: Context<E>, ...event: E): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by [[eventReceiver]] function.\n   *\n   * In contrast to [[Object]] this one always has a supply.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<E extends any[]> extends Object<E> {\n\n    readonly supply: EventSupply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to [[Object]] receivers.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<E extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver  Recurrent events receiver function.\n     */\n    onRecurrent(receiver: Function<E>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n * @param receiver  An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<E extends any[]>(receiver: EventReceiver<E>): EventReceiver.Generic<E> {\n\n  let generic: {\n    readonly supply: EventSupply;\n    receive: (context: EventReceiver.Context<E>, ...event: E) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: eventSupply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || eventSupply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventReceiver } from './event-receiver';\nimport { EventSupply } from './event-supply';\n\n/**\n * A key of event receiver registration method of [[EventSender]].\n *\n * @category Core\n */\nexport const OnEvent__symbol = (/*#__PURE__*/ Symbol('on-event'));\n\n/**\n * A sender of events.\n *\n * It is able to register event receivers.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<E extends any[]> {\n\n  /**\n   * Registers a receiver of events sent by this sender.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  [OnEvent__symbol](receiver: EventReceiver<E>): EventSupply;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeparam T  Target event sender.\n   */\n  export type Event<T extends EventSender<any>> = T extends EventSender<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventSender]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains `[OnEvent__symbol]` property, or `false` otherwise.\n */\nexport function isEventSender<E extends any[]>(value: object): value is EventSender<E> {\n  return OnEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { eventSupply, EventSupply, EventSupply__symbol, eventSupplyOf, EventSupplyPeer } from './event-supply';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an [[OnEvent]] interface though. Use an [[EventEmitter]] if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link EventSupply.off cut off}.\n *\n * Can be used as [[EventSender]].\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<E extends any[]> implements EventSender<E>, EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private readonly _rcvs = new Set<EventReceiver.Generic<E>>();\n\n  readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event  An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: E) => void = receiveEventsByEach(this._rcvs);\n\n  constructor() {\n    this[EventSupply__symbol] = eventSupply(reason => {\n      this._rcvs.forEach(({ supply }) => supply.off(reason));\n    });\n  }\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcvs.size;\n  }\n\n  [OnEvent__symbol](receiver: EventReceiver<E>): EventSupply {\n    return this.on(receiver);\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<E>): EventSupply {\n\n    const generic = eventReceiver(receiver);\n\n    this._rcvs.add(generic);\n\n    return generic.supply.needs(this).whenOff(() => this._rcvs.delete(generic));\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive any events. While new receivers would be cut off immediately upon\n   * registration.\n   *\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @category Core\n * @param receivers  An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nfunction receiveEventsByEach<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n): (this: void, ...event: E) => void {\n\n  let send: (this: void, event: E) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: E): void {\n\n    let actualReceivers = receivers;\n    const received: E[] = [];\n\n    send = (recurrent: E) => received.push(recurrent);\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n  }\n}\n\nfunction processEvent<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n    event: E,\n): EventReceiver.Generic<E>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<E>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<E> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","import { EventReceiver } from '../base';\n\n/**\n * @internal\n */\nexport function once<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<E>) => void,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => register({\n    supply: receiver.supply,\n    receive: (context, ...event) => {\n      receiver.receive(context, ...event);\n      receiver.supply.off();\n    },\n  });\n}\n","import { EventNotifier, EventReceiver, eventSupply, EventSupply } from '../base';\n\n/**\n * @internal\n */\nexport function share<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<E>) => EventSupply,\n): (receiver: EventReceiver.Generic<E>) => void {\n\n  const shared = new EventNotifier<E>();\n  let sharedSupply: EventSupply;\n  let initialEvents: E[] | undefined;\n\n  return receiver => {\n    if (!shared.size) {\n      initialEvents = [];\n      sharedSupply = eventSupply(() => initialEvents = undefined);\n\n      register({\n        supply: sharedSupply,\n        receive(_ctx, ...event) {\n          if (initialEvents) {\n            if (shared.size) {\n              // More events received\n              // Stop sending initial ones\n              initialEvents = undefined;\n            } else {\n              // Record events received during first receiver registration\n              // to send them to all receivers until more event received\n              initialEvents.push(event);\n            }\n          }\n          shared.send(...event);\n        },\n      });\n    }\n\n    receiver.supply.needs(sharedSupply);\n    shared.on(receiver).whenOff((reason?: any) => {\n      if (!shared.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatcher = new EventNotifier<E>();\n\n      dispatcher.on(receiver);\n      initialEvents.forEach(event => dispatcher.send(...event));\n    }\n  };\n}\n","import { EventReceiver, eventSupply, EventSupply, eventSupplyOf, EventSupplyPeer } from '../base';\n\n/**\n * @internal\n */\nexport function tillOff<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<E>) => void,\n    required: EventSupplyPeer,\n    dependentSupply?: EventSupply,\n): (receiver: EventReceiver.Generic<E>) => void {\n  const requiredSupply = eventSupplyOf(required);\n  return receiver => {\n    if (dependentSupply) {\n\n      const supply = eventSupply().needs(requiredSupply);\n\n      dependentSupply.needs(supply);\n\n      register({\n        supply,\n        receive: (receiver.receive as Function).bind(receiver),\n      });\n    } else {\n      receiver.supply.needs(requiredSupply);\n      register(receiver);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport {\n  AfterEvent__symbol,\n  eventReceiver,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  EventSupplyPeer,\n  isEventSender,\n  noEventSupply,\n  OnEvent__symbol,\n} from './base';\nimport { once, share, thru, tillOff } from './impl';\nimport { OnEventCallChain } from './passes';\nimport Args = OnEventCallChain.Args;\nimport Out = OnEventCallChain.Out;\n\n/**\n * An event receiver registration function interface.\n *\n * A registered event receiver would receive upcoming events, until the returned event supply will be\n * {@link EventSupply.off cut off}.\n *\n * An [[OnEvent]] function also has a set of handy methods. More could be added later. It also can be used as\n * [[EventSender]].\n *\n * To convert a plain event receiver registration function to [[OnEvent]] an [[onEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport abstract class OnEvent<E extends any[]> extends Function implements EventSender<E> {\n\n  get [OnEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * An [[OnEvent]] sender derived from this one that stops sending events to registered receiver after the first one.\n   */\n  get once(): OnEvent<E> {\n    return onEventBy(once(this));\n  }\n\n  /**\n   * Builds an [[OnEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New event sender.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): OnEvent<E> {\n    return onEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Consumes events.\n   *\n   * @param consume  A function consuming events. This function may return a {@link EventSupplyPeer peer of event\n   * supply} when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n   *\n   * @returns An event supply that will stop consuming events once {@link EventSupply.off cut off}.\n   */\n  consume(consume: (...event: E) => EventSupplyPeer | void | undefined): EventSupply {\n\n    let consumerSupply = noEventSupply();\n    const senderSupply = this((...event: E) => {\n\n      const prevSupply = consumerSupply;\n\n      try {\n        consumerSupply = eventSupplyOf(consume(...event) || noEventSupply());\n      } finally {\n        if (consumerSupply !== prevSupply) {\n          prevSupply.off();\n        }\n      }\n    });\n\n    return eventSupply(reason => {\n      consumerSupply.off(reason);\n      senderSupply.off(reason);\n    }).needs(senderSupply);\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender that shares events supply among all registered receivers.\n   *\n   * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * supplies do.\n   *\n   * @returns An [[OnEvent]] sender sharing a common supply of events originated from this sender.\n   */\n  share(): OnEvent<E> {\n    return onEventBy(share(this));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `callThru()` function. The event receivers registered by resulting event sender\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes. The returned sender shares the supply\n   * of transformed events among receivers.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): OnEvent<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): OnEvent<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): OnEvent<Out<Return3>>;\n\n  thru(...fns: any[]): OnEvent<any[]> {\n    return onEventBy(share((this as any).thru_(...fns)));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[OnEvent.thru]] one, except it does not share the supply of transformed events\n   * among receivers. This may be useful e.g. when the result will be further transformed anyway. It is wise to\n   * {@link share share} the supply of events from final result in this case.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes.\n   */\n  thru_<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): OnEvent<Out<Return1>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): OnEvent<Out<Return2>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): OnEvent<Out<Return3>>;\n\n  thru_(...passes: any[]): OnEvent<any[]> {\n    return thru(this, onEventBy, onSupplied, passes);\n  }\n\n}\n\nexport interface OnEvent<E extends any[]> {\n\n  /**\n   * Registers a receiver of events sent by this sender.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  (this: void, receiver: EventReceiver<E>): EventSupply;// eslint-disable-line @typescript-eslint/prefer-function-type\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[OnEvent]] sender.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An [[OnEvent]] sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n): OnEvent<E> {\n\n  const onEvent = ((receiver: EventReceiver<E>) => {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      register(generic);\n    }\n\n    return supply;\n  }) as OnEvent<E>;\n\n  Object.setPrototypeOf(onEvent, OnEvent.prototype);\n\n  return onEvent;\n}\n\n/**\n * Builds an [[OnEvent]] sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n *\n * @returns An [[OnEvent]] sender of events originated from the given `supplier`.\n */\nexport function onSupplied<E extends any[]>(supplier: EventSupplier<E>): OnEvent<E> {\n\n  const onEvent = isEventSender(supplier) ? supplier[OnEvent__symbol] : supplier[AfterEvent__symbol];\n\n  if (onEvent instanceof OnEvent) {\n    return onEvent;\n  }\n\n  return onEventBy(onEvent.bind(supplier));\n}\n\n/**\n * An [[OnEvent]] sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = (/*#__PURE__*/ onEventBy(({ supply }) => supply.off()));\n","import { isNextCall, NextCall__symbol, noop } from 'call-thru';\nimport { EventReceiver, EventSupplier, eventSupply, EventSupply, noEventSupply } from '../base';\nimport { OnEvent } from '../on-event';\nimport { OnEventCallChain } from '../passes';\n\n/**\n * @internal\n */\nexport function thru<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<any[]>) => void,\n    onEvent: <F extends any[]>(register: (receiver: EventReceiver.Generic<F>) => void) => OnEvent<F>,\n    toSupplier: <F extends any[]>(supplier: EventSupplier<F>) => OnEvent<F>,\n    passes: ((...args: any[]) => any)[],\n): OnEvent<E> {\n\n  interface ChainEntry {\n    readonly chain: OnEventCallChain;\n    supply: EventSupply;\n  }\n\n  return onEvent<any>(receiver => {\n\n    const chains: ChainEntry[] = [];\n\n    register({\n      supply: receiver.supply,\n      receive(context, ...event) {\n\n        const chain = (index: number, chainSupply: EventSupply): [OnEventCallChain, EventSupply] => {\n\n          const lastPass = index >= passes.length;\n\n          ++index;\n\n          const existing = chains[index];\n\n          if (existing) {\n\n            const prevSupply = existing.supply;\n\n            existing.supply = chainSupply;\n\n            return [existing.chain, prevSupply];\n          }\n\n          const pass = index < passes.length ? passes[index] : noop;\n\n          const entry: ChainEntry = {\n            chain: {\n              call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n                handleResult(fn(...args), args);\n              },\n              pass<A>(fn: (arg: A) => any, arg: A): void {\n                handleResult(fn(arg), [arg]);\n              },\n              skip(): void {\n                entry.supply.off();\n              },\n              onEvent<E extends any[]>(\n                  fn: (this: void, ...event: E) => void,\n                  supplier: EventSupplier<E>,\n              ): void {\n\n                const supply = eventSupply().needs(entry.supply);\n\n                toSupplier(supplier)({\n                  supply,\n                  receive(_context, ...event): void {\n                    handleResult(fn(...event), event, supply);\n                  },\n                });\n              },\n            },\n            supply: chainSupply,\n          };\n\n          chains[index] = entry;\n\n          return [entry.chain, noEventSupply()];\n\n          function handleResult(\n              callResult: any,\n              args: any[],\n              parentSupply = entry.supply,\n          ): void {\n\n            const [nextChain, prevSupply] = chain(index, eventSupply().needs(parentSupply));\n\n            try {\n              if (isNextCall(callResult)) {\n                callResult[NextCall__symbol](nextChain, pass);\n              } else if (lastPass) {\n                receiver.receive(context, ...args);\n              } else {\n                nextChain.pass(pass, callResult);\n              }\n            } finally {\n              prevSupply.off();\n            }\n          }\n        };\n\n        const [firstChain, prevSupply] = chain(0, eventSupply().needs(receiver.supply));\n\n        try {\n          firstChain.call(passes[0], event);\n        } finally {\n          prevSupply.off();\n        }\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop, valueProvider } from 'call-thru';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  eventReceiver,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  EventSupply,\n  eventSupply,\n  EventSupplyPeer,\n  isEventKeeper,\n  OnEvent__symbol,\n} from './base';\nimport { once, share, tillOff } from './impl';\nimport { OnEvent } from './on-event';\nimport { OnEventCallChain } from './passes';\nimport Args = OnEventCallChain.Args;\nimport Out = OnEventCallChain.Out;\n\n/**\n * A subset of [[AfterEvent]] transformation methods inherited that return [[AfterEvent]] keepers instead of\n * [[OnEvent]] senders.\n *\n * This can not be done automatically, as not every transformation results to [[EventKeeper]]. E.g. when some events\n * are filtered out.\n *\n * An instance of this class can be obtained from [[AfterEvent.keep]] property.\n *\n * @category Core\n */\nexport class AfterEventKeep<E extends any[]> {\n\n  /**\n   * @internal\n   */\n  private readonly _keeper: AfterEvent<E>;\n\n  constructor(keeper: AfterEvent<E>) {\n    this._keeper = keeper;\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `callThru()` function. The event receivers registered by resulting event keeper\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes. The returned keeper shares the supply\n   * of transformed events among receivers.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): AfterEvent<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AfterEvent<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AfterEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AfterEvent<Out<Return3>>;\n\n  thru(...fns: any[]): AfterEvent<any[]> {\n    return (this as any).thru_(...fns).share();\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[AfterEventKeep.thru]] one, except it does not share the supply of transformed\n   * events among receivers. This may be useful e.g. when the result will be further transformed anyway.\n   * It is wise to {@link AfterEvent.share share} the supply of events from final result in this case.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes.\n   */\n  thru_<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): AfterEvent<Out<Return1>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AfterEvent<Out<Return2>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AfterEvent<Out<Return3>>;\n\n  thru_(...fns: any[]): AfterEvent<any[]> {\n    return afterSupplied((this._keeper as any).thru_(...fns));\n  }\n\n}\n\n/**\n * A kept and upcoming events receiver registration function interface.\n *\n * A registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * To convert a plain event receiver registration function to [[AfterEvent]] an [[afterEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport abstract class AfterEvent<E extends any[]> extends OnEvent<E> implements EventKeeper<E> {\n\n  get [AfterEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * A subset of [[AfterEvent]] transformation methods that return [[AfterEvent]] keepers instead of [[OnEvent]]\n   * senders.\n   *\n   * Note that not every transformation can properly result to [[EventKeeper]]. E.g. some events may be filtered out and\n   * the resulting [[AfterEvent]] would rise an exception on receiver registration, as it won't have any events to send.\n   */\n  get keep(): AfterEventKeep<E> {\n    return new AfterEventKeep(this);\n  }\n\n  /**\n   * An [[AfterEvent]] keeper derived from this one that sends currently the kept event to registered receiver\n   * and stops sending them after that.\n   */\n  get once(): AfterEvent<E> {\n    return afterEventBy(once(this));\n  }\n\n  /**\n   * Builds an [[AfterEvent]] keeper that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New event keeper.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): AfterEvent<E> {\n    return afterEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper that shares events supply among all registered receivers.\n   *\n   * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * event supplies do.\n   *\n   * @returns An [[AfterEvent]] keeper sharing a common supply of events originating from this keeper.\n   */\n  share(): AfterEvent<E> {\n    return afterEventBy(share(this));\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[AfterEvent]] keeper with a fallback.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n    fallback: (this: void) => E = noEvent,\n): AfterEvent<E> {\n\n  let lastEvent: E | undefined;\n  let numReceivers = 0;\n\n  const afterEvent = ((receiver: EventReceiver<E>) => {\n\n    let dest: (context: EventReceiver.Context<E>, ...event: E) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = eventSupply().needs(generic.supply);\n    let reported = false;\n\n    register({\n      supply,\n      receive(context, ...event: E) {\n        reported = true;\n        lastEvent = event;\n        dest(context, ...event);\n      },\n    });\n    ++numReceivers;\n\n    if (!supply.isOff || reported) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(lastEvent || (lastEvent = fallback())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(reason => {\n      if (!--numReceivers) {\n        lastEvent = undefined;\n      }\n      generic.supply.off(reason);\n    });\n\n    return supply;\n  }) as AfterEvent<E>;\n\n  Object.setPrototypeOf(afterEvent, AfterEvent.prototype);\n\n  return afterEvent;\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param keeper  A keeper of events.\n *\n * @returns An [[AfterEvent]] keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<E extends any[]>(keeper: EventKeeper<E>): AfterEvent<E>;\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * This is a synonym of [[afterSent]], unless `sender` is an [[EventKeeper]].\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSupplied<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E>;\n\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  if (!isEventKeeper(supplier)) {\n    return afterSent(supplier, fallback);\n  }\n\n  const afterEvent = supplier[AfterEvent__symbol];\n\n  if (afterEvent instanceof AfterEvent) {\n    return afterEvent;\n  }\n\n  return afterEventBy(afterEvent.bind(supplier));\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return afterEventBy(receiver => sender[OnEvent__symbol](receiver), fallback);\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of the given `event`.\n *\n * @category Core\n * @param event  An event that will be sent to all receivers upon registration.\n *\n * @returns An [[AfterEvent]] keeper that always sends the given `event`.\n */\nexport function afterThe<E extends any[]>(...event: E): AfterEvent<E> {\n  return afterEventBy(() => eventSupply(), valueProvider(event));\n}\n\n/**\n * An [[AfterEvent]] keeper that never sends any events.\n *\n * @category Core\n */\nexport const afterNever: AfterEvent<any> = (/*#__PURE__*/ afterEventBy(({ supply }) => supply.off()));\n\nfunction noEvent(): never {\n  throw new Error('No events to send');\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterSupplied } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventNotifier, EventReceiver } from '../base';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeparam S  A type of `sources` map.\n * @param sources  A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nexport function afterAll<S extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: S,\n): AfterEvent<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>,\n  ): void {\n\n    const notifier = new EventNotifier<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>();\n    const supply = notifier.on(receiver);\n    let send: () => void = noop;\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach((key: keyof S) => {\n      supply.needs(sources[key][AfterEvent__symbol]((...event) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => notifier.send(result);\n    }\n  }\n\n  function latestEvent(): [{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }] {\n\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(\n        key => afterSupplied(sources[key]).once(\n            (...event) => result[key as keyof S] = event,\n        ),\n    );\n\n    return [result];\n  }\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterSupplied } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventNotifier, EventReceiver } from '../base';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeparam E  A type of events sent by each source.\n * @param sources  An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nexport function afterEach<E extends any[]>(...sources: EventKeeper<E>[]): AfterEvent<E[]> {\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(receiver: EventReceiver.Generic<E[]>): void {\n\n    const notifier = new EventNotifier<E[]>();\n    const supply = notifier.on(receiver);\n    let send: () => void = noop;\n    const result: E[] = [];\n\n    sources.forEach((source, index) => {\n      supply.needs(source[AfterEvent__symbol]((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => notifier.send(...result);\n    }\n  }\n\n  function latestEvent(): E[] {\n\n    const result: E[] = [];\n\n    sources.forEach(\n        source => afterSupplied(source).once(\n            (...event) => result.push(event),\n        ),\n    );\n\n    return result;\n  }\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { NextCall, nextCall } from 'call-thru';\nimport { afterSupplied } from '../after-event';\nimport { EventKeeper } from '../base';\nimport { OnEventCallChain } from './on-event-call-chain';\n\n/**\n * Builds a next chained call of {@link OnEventCallChain} that calls the next pass with every event supplied by\n * the given keeper.\n *\n * The event supply from the given keeper will be cut off each time the call is applied.\n *\n * This differs from [[nextOnEvent]] when passing supplier implementing both [[EventSender]] and [[EventKeeper]]\n * interfaces such as [[ValueTracker]]. [[nextOnEvent]] would prefer the former, while this one would prefer the latter.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of argument types of the next pass.\n * @param keeper  A keeper of events to pass down the chain.\n *\n * @returns Next call passing events from the given `keeper`.\n */\nexport function nextAfterEvent<E extends any[]>(\n    keeper: EventKeeper<E>,\n): NextCall<OnEventCallChain, E> {\n  return nextCall((chain, pass) => chain.onEvent(pass, afterSupplied(keeper)));\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { NextCall, nextCall } from 'call-thru';\nimport { EventSupplier } from '../base';\nimport { OnEventCallChain } from './on-event-call-chain';\n\n/**\n * Builds a next chained call of {@link OnEventCallChain} that calls the next pass with every event supplied by\n * the given supplier.\n *\n * The event supply from the given supplier will be cut off each time the call is applied.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of argument types of the next pass.\n * @param supplier  A supplier of events to pass down the chain.\n *\n * @returns Next call passing events from the given `supplier`.\n */\nexport function nextOnEvent<E extends any[]>(\n    supplier: EventSupplier<E>,\n): NextCall<OnEventCallChain, E> {\n  return nextCall((chain, pass) => chain.onEvent(pass, supplier));\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventNotifier, EventSender, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Event emitter is a handy implementation of [[OnEvent]] sender.\n *\n * Extends [[EventNotifier]] by making its [[EventNotifier.on]] method implement an [[OnEvent]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<E extends any[]> extends EventNotifier<E> implements EventSender<E> {\n\n  /**\n   * An [[OnEvent]] sender.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  readonly on = onEventBy<E>(receiver => super.on(receiver));\n\n  readonly [OnEvent__symbol]: OnEvent<E> = this.on;\n\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventReceiver, EventSupplier, eventSupply } from '../base';\nimport { OnEvent, onEventBy, onNever, onSupplied } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param suppliers  Original event suppliers.\n *\n * @returns An [[OnEvent]] sender of all supplied events.\n */\nexport function onAny<E extends any[]>(...suppliers: EventSupplier<E>[]): OnEvent<E> {\n  if (!suppliers.length) {\n    return onNever;\n  }\n\n  return onEventBy<E>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any): void => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<E>, ...event: E): void => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier)({\n          supply: eventSupply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  }).share();\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventNotifier, EventSender, eventSupply } from '../base';\nimport { OnEvent, onEventBy, onSupplied } from '../on-event';\nimport { onAnyAsync } from './on-any-async';\n\n/**\n * Builds an [[OnEvent]] sender of asynchronously resolved events originated from the given sender of unresolved events.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Possibly in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Core\n * @typeparam E  Resolved event type.\n * @param from  Unresolved events sender containing either events or their promises.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nexport function onAsync<E>(from: EventSender<[PromiseLike<E> | E]>): OnEvent<[E, ...E[]]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const sender = new EventNotifier<[E, ...E[]]>();\n\n    sender.on(receiver);\n\n    const sourceSupply = eventSupply();\n    let numInProcess = 0;\n    const source = onSupplied(from)\n        .tillOff(supply, sourceSupply)\n        .thru_(event => {\n          ++numInProcess;\n          return event;\n        });\n    let received: E[] = [];\n    let numSent = 1;\n    let numReceived = 0;\n\n    sourceSupply.whenOff(reason => {\n      if (!numInProcess) {\n        receiver.supply.off(reason);\n      }\n    });\n\n    onAnyAsync(source)({\n      supply,\n      receive(_ctx, event, index) {\n\n        const i = index - numSent;\n\n        received[i] = event;\n        ++numReceived;\n        if (numReceived > i) {\n\n          let toSend: E[];\n\n          if (numReceived === received.length) {\n            // Can send all received events\n            toSend = received;\n            received = [];\n          } else {\n            // Can send events up to `i`\n            toSend = received.splice(0, i + 1);\n          }\n          numSent += toSend.length;\n          numReceived -= toSend.length;\n          numInProcess -= toSend.length;\n\n          sender.send(...(toSend as [E, ...E[]]));\n          if (!numInProcess && sourceSupply.isOff) {\n            receiver.supply.needs(sourceSupply);\n          }\n        }\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventNotifier, EventSender, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of any of asynchronously resolved events originated from the given sender of\n * unresolved events.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Core\n * @typeparam E  Resolved event type.\n * @param from  Unresolved events sender containing either events or their promises.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nexport function onAnyAsync<E>(from: EventSender<[PromiseLike<E> | E]>): OnEvent<[E, number]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const sender = new EventNotifier<[E, number]>();\n\n    sender.on(receiver);\n\n    let lastIndex = 0;\n\n    from[OnEvent__symbol]({\n      supply,\n      receive(_ctx, promise) {\n\n        const index = ++lastIndex;\n\n        Promise.resolve()\n            .then(() => promise)\n            .then(\n                event => sender.send(event, index),\n                reason => supply.off(reason),\n            );\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @param key  A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<K extends PropertyKey>(key: K): [K];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path  Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return Array.isArray(path) ? path : [path];\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { EventSender, eventSupply, EventSupply, OnEvent__symbol } from '../base';\nimport { onEventBy } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n      path = statePath(path);\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): EventSupply {\n\n    const supply = this.emitter.on(receiver);\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      this._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: any): void {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.done(reason);\n  }\n\n  private _remove(key: PropertyKey): void {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty(): void {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): EventSupply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<V>(path: StatePath.Normalized, newValue: V, oldValue: V): void {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: any): void {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void = (<V>(path: StatePath, newValue: V, oldValue: V) => {\n    this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n  });\n\n  readonly onUpdate: OnStateUpdate =\n      onEventBy<[StatePath, any, any]>(receiver => this._trackers.on(this._path, receiver));\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  get _tracker(): this {\n    return this;\n  }\n\n  get [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: any): void {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under [[StatePath]].\n *\n * When node modified a [[StateTracker.update]] should be called. Then all state update receivers registered by\n * [[StateTracker.onUpdate]] will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * A {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   */\n  get onUpdate(): OnStateUpdate {\n    return this._tracker.onUpdate;\n  }\n\n  get [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with [[onUpdate]] will receive this update.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  get update(): <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path  A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason  An optional reason to stop tracking.\n   */\n  done(reason?: any): void {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  EventSupplyPeer,\n  isEventKeeper,\n  noEventSupply,\n  OnEvent__symbol,\n} from '../base';\nimport { OnEvent, onSupplied } from '../on-event';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an [[EventSender]] interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an [[EventKeeper]] interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeparam T  Tracked value type.\n * @typeparam N  New (updated) value type.\n */\nexport abstract class ValueTracker<T = any, N extends T = T>\n    implements EventSender<[N, T]>, EventKeeper<[T]>, EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _by = noEventSupply();\n\n  /**\n   * An [[OnEvent]] sender of value changes. The new value is sent as first argument, and the old value as a second one.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[N, T]>;\n\n  /**\n   * An [[AfterEvent]] keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  readonly read: AfterEvent<[T]> = afterEventBy<[T]>(\n      receiver => this.on(receiveNewValue(receiver)),\n      () => [this.it],\n  );\n\n  get [OnEvent__symbol](): OnEvent<[N, T]> {\n    return this.on;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * An event supply of this value tracker.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier  The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeparam S  Source value type.\n   * @param supplier  The event supplier to extract value suppliers from.\n   * @param extract  A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<S extends any[]>(\n      supplier: EventSupplier<S>,\n      extract: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<S extends any[]>(\n      supplier: EventSupplier<S> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const acceptValuesFrom = (sender: EventSupplier<[T]>): EventSupply => {\n\n      const registrar = isEventKeeper(sender) ? sender[AfterEvent__symbol] : sender[OnEvent__symbol];\n\n      return registrar(value => this.it = value);\n    };\n\n    this.byNone();\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<S>;\n\n      this._by = onSupplied(container).consume((...event: S) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      });\n    }\n\n    this._by.whenOff(() => this._by = noEventSupply());\n\n    return this;\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason  Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive events.\n\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction receiveNewValue<T, N extends T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[N, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventKeeper, EventSupply, EventSupply__symbol, eventSupplyOf } from '../base';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * @internal\n */\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._on);\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier  The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeparam S  Source value type.\n * @param supplier  The event keeper to extract value keepers from.\n * @param extract  A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S>,\n    extract: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as any).by(supplier, extract);\n}\n","/**\n * @module namespace-aliaser\n */\nimport { QualifiedName } from './name';\nimport { NamespaceDef } from './namespace';\nimport { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\n\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = (/*#__PURE__*/ new CssNaming());\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url  Unique namespace URL.\n   * @param aliases  Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for [default namespace][[DEFAULT__NS]].\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls [[Naming.applyAlias]] by default.\n   *\n   * @param alias  Namespace alias to apply to the name.\n   * @param name  A name to convert.\n   * @param naming  Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of [[NamespaceDef]]. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: any): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of [[NamespaceDef]].\n * Or `false` otherwise.\n */\nexport function isQualifiedName(value: any): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name  Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name  Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","/**\n * @module namespace-aliaser\n */\nimport { NamespaceDef } from './namespace';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns  A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = mostPreferred + (++nsNumRegistered);\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","/**\n * @packageDocumentation\n * @module context-values/updatable\n */\nimport { flatMapIt, mapIt, overArray } from 'a-iterable';\nimport { CallChain, nextArg, nextArgs, NextCall, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { ContextKey, ContextKey__symbol, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keep.thru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read.keep.thru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<Src>(...sources: Src[][]): NextCall<CallChain, Src[]> {\n  return nextArgs<Src[]>(...flatMapIt<Src>(sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport interface ContextUpRef<Value, Src> extends ContextRef<Value, Src | EventKeeper<Src[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<Value, Src>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<Value, Src>\n    extends ContextKey<ContextUpKey.Up<Value>, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  get seedKey(): ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<Value, Src>,\n      readonly grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ) {\n    super(_key.name + ':up');\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src> {\n\n  readonly seedKey: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[growUp]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<Value, Src>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ): ContextUpKey.UpKey<Value, Src> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeparam Value  Original context value type.\n   */\n  export type Up<Value> = Value extends AfterEvent<any>\n      ? Value\n      : (Value extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[Value]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   */\n  export type UpKey<Value, Src> = ContextKey<ContextUpKey.Up<Value>, Src>;\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextUpRef<Value> = ContextUpRef<AfterEvent<[Value]>, Value>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value | EventKeeper<Value[]>, AfterEvent<Value[]>>;\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): AfterEvent<[Value]> {\n    return opts.seed.keep.thru((...sources: Value[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue && afterThe(defaultValue);\n      });\n\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n  }\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Src  Source value type.\n */\nexport type MultiContextUpRef<Src> = ContextUpRef<AfterEvent<Src[]>, Src>;\n\n/**\n * Multiple updatable context values key.\n *\n * The associated value is an `AfterEvent` keeper of the source values. It is always present, even though\n * the array can be empty.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Src  Source value type.\n */\nexport class MultiContextUpKey<Src>\n    extends ContextUpKey<AfterEvent<Src[]>, Src>\n    implements MultiContextUpRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs multiple updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>;\n        byDefault?: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<Src[]>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ): AfterEvent<Src[]> {\n    return opts.seed.keep.thru((...sources) => {\n      if (sources.length) {\n        // Sources present. Use them.\n        return nextArgs(...sources);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue ? afterThe(...defaultValue) : afterThe();\n      });\n\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<Src[]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values/updatable\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { ContextKeyDefault, ContextSeedKey, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport type FnContextRef<Args extends any[], Ret = void> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<\n            ((this: void, ...args: Args) => Ret) | EventKeeper<((this: void, ...args: Args) => Ret)[]>,\n            AfterEvent<((this: void, ...args: Args) => Ret)[]>>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.thru(\n            (...fns) => {\n              if (fns.length) {\n                return fns[fns.length - 1];\n              }\n\n              const defaultProvider = (): AfterEvent<[(this: void, ...args: Args) => Ret]> => afterThe(this.byDefault(\n                  opts.context,\n                  this,\n              ));\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): (this: void, ...args: Args) => Ret {\n\n    let delegated!: (this: void, ...args: Args) => Ret;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(fn => delegated = fn);\n\n    return (...args) => delegated(...args);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { ScheduledRender } from './scheduled-render';\n\n/**\n * Render schedule signature.\n *\n * This function accepts {@link ScheduledRender renders} to schedule.\n *\n * If multiple renders scheduled before execution starts, only the last one will be executed to limit their execution\n * rate.\n *\n * The render execution may fail. This should not prevent other scheduled or postponed renders from being executed.\n * The render execution failure reason is expected to be reported with [[RenderScheduleConfig.error]] method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by [[newRenderSchedule]] function\n * that uses the {@link setRenderScheduler default scheduler} for that.\n */\nexport type RenderSchedule =\n/**\n * @param render  A render to schedule.\n */\n    (this: void, render: ScheduledRender) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by [[nodeWindow]] by default, if [[node]] is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing [[window]] option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error(...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render scheduler by its options.\n   *\n   * @param options  Render scheduler options the configuration should be base on.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n\n    return {\n      get node() {\n        return options.node;\n      },\n      get window() {\n        return win || (win = options.window || (options.node && nodeWindow(options.node)) || window);\n      },\n      error(...messages) {\n        if (options && options.error) {\n          options.error(...messages);\n        } else {\n          console.error(...messages);\n        }\n      },\n    };\n  },\n\n};\n\n/**\n * Detects a window the given DOM node is attached to.\n *\n * @param node  Target DOM node.\n *\n * @returns A window of the owner document, or `null` if absent.\n */\nexport function nodeWindow(node: Node): Window | null {\n\n  const document = node.ownerDocument || node as Document;\n\n  return document.defaultView;\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { RenderScheduleConfig } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { ScheduledRender, ScheduledRenderExecution } from './scheduled-render';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to [[customRenderScheduler]] function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config  Render schedule configuration.\n   *\n   * @returns  Scheduled render queue.\n   */\n  newQueue(config: RenderScheduleConfig): ScheduledRenderQueue;\n\n}\n\n/**\n * A queue of scheduled renders.\n *\n * Utilized by render scheduler in order to collect scheduled renders and schedule their execution.\n *\n * The default implementation may constructed using [[ScheduledRenderQueue.by]] function.\n */\nexport interface ScheduledRenderQueue {\n\n  /**\n   * Adds a render to this queue.\n   *\n   * @param render  Scheduled render to add.\n   */\n  add(render: ScheduledRender): void;\n\n  /**\n   * Retrieves the first added render and removes it from the queue.\n   *\n   * @returns  Either pulled out scheduled render, or `undefined` when there is no more renders.\n   */\n  pull(): ScheduledRender | undefined;\n\n  /**\n   * Schedules queued renders execution.\n   *\n   * @param task  A function that performs scheduled renders execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled renders from now on.\n   */\n  reset(): ScheduledRenderQueue;\n\n}\n\nexport const ScheduledRenderQueue = {\n\n  /**\n   * Builds the default implementation of scheduled renders queue.\n   *\n   * @param schedule  Schedules queued renders execution. This is an implementation of\n   * [[ScheduledRenderQueue.schedule]] method.\n   * @param replace  Called right after [[ScheduledRenderQueue.reset]] method in order to inform on queue that will\n   * collect scheduled renders from now.\n   *\n   * @returns New scheduled render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = () => {/* do not replace */},\n      }: {\n        schedule(this: ScheduledRenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: ScheduledRenderQueue): void;\n      },\n  ): ScheduledRenderQueue {\n\n    const renders: ScheduledRender[] = [];\n\n    return {\n      schedule,\n      add(render) {\n        renders.push(render);\n      },\n      pull() {\n        return renders.shift();\n      },\n      reset() {\n\n        const next = ScheduledRenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n\n/**\n * @internal\n */\nconst ScheduledRenderQ__symbol = Symbol('scheduled-render-q');\n\n/**\n * @internal\n */\nclass ScheduledRenderQ {\n\n  readonly ref: [ScheduledRenderQ];\n  schedule: (this: ScheduledRenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: ScheduledRenderQueue, ref?: [ScheduledRenderQ]): ScheduledRenderQ {\n    return (queue as any)[ScheduledRenderQ__symbol]\n        || ((queue as any)[ScheduledRenderQ__symbol] = new ScheduledRenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: ScheduledRenderQueue, ref?: [ScheduledRenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this];\n  }\n\n  add(render: ScheduledRender): void {\n    this.q.add(render);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    this.schedule = () => {/* do not schedule */};\n\n    const execution: ScheduledRenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone: postponed => this.add(postponed),\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: ScheduledRenderExecution): void {\n    for (; ;) {\n\n      const render = this.q.pull();\n\n      if (!render) {\n        break;\n      }\n      render(execution);\n    }\n  }\n\n  private reset(): ScheduledRenderQ {\n    return this.ref[0] = ScheduledRenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {/* do not schedule */};\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options  Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return scheduleOptions => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef = ScheduledRenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [ScheduledRenderQ, ScheduledRender] | [] = [];\n\n    return render => {\n\n      const [lastQueue] = enqueued;\n      const [nextQueue] = queueRef;\n\n      if (lastQueue === nextQueue) {\n        enqueued[1] = render;\n      } else {\n\n        const nextEnqueued = enqueued = [nextQueue, render];\n\n        nextQueue.add((execution: ScheduledRenderExecution) => {\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      nextQueue.schedule(config);\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { customRenderScheduler, ScheduledRenderQueue } from './custom-render-scheduler';\nimport { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, ScheduledRenderQueue>());\n\n/**\n * A render scheduler that executes the scheduled renders within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The renders scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link ScheduledRenderExecution.postpone postponed} renders are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = ScheduledRenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { animationRenderScheduler } from './animation-render-scheduler';\nimport { RenderSchedule, RenderScheduleOptions } from './render-schedule';\n\n/**\n * Render scheduler signature.\n *\n * This function constructs {@link RenderSchedule render schedules} according to the given options.\n *\n * The default render scheduler is always available as [[newRenderSchedule]] function.\n *\n * There are several scheduler implementations exist:\n * - [[animationRenderScheduler]] (used by default),\n * - [[asyncRenderScheduler]],\n * - [[immediateRenderScheduler]],\n * - [[ManualRenderScheduler]],\n * - [[noopRenderScheduler]].\n *\n * Custom scheduler implementations could be created using [[customRenderScheduler]] function.\n */\nexport type RenderScheduler =\n/**\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: RenderScheduleOptions) => RenderSchedule;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler  New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n","/**\n * @packageDocumentation\n * @module fun-events/dom\n */\nimport { eventReceiver, EventReceiver, EventSupply, EventSupplyPeer } from '../base';\nimport { once, tillOff } from '../impl';\nimport { OnEvent } from '../on-event';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport type DomEventListener<E extends Event> = EventReceiver<[E]>;\n\n/**\n * A DOM event listener registrar signature.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport abstract class OnDomEvent<E extends Event> extends OnEvent<[E]> {\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that stops sending events to registered listener after the first\n   * one.\n   */\n  get once(): OnDomEvent<E> {\n    return onDomEventBy(once(this));\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New DOM event sender.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): OnDomEvent<E> {\n    return onDomEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that enables event capturing by default.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   */\n  get capture(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this(listener, true);\n      }\n      if (typeof opts === 'object' && opts.capture == null) {\n        return this(listener, { ...opts, capture: true });\n      }\n      return this(listener, opts);\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers listeners to invoke instead of the default action.\n   *\n   * It invokes an `Event.preventDefault()` method prior to calling the registered listeners.\n   */\n  get instead(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.preventDefault();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers listeners preventing further propagation of\n   * current event in the capturing and bubbling phases.\n   *\n   * It invokes an `Event.stopPropagation()` method prior to calling the registered listeners.\n   */\n  get just(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopPropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers the last event listener.\n   *\n   * It invokes an `Event.stopImmediatePropagation()` method prior to calling the registered listeners.\n   */\n  get last(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopImmediatePropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that accepts listeners never calling `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   */\n  get passive(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this(listener, { passive: true });\n      }\n      if (typeof opts === 'boolean') {\n        return this(listener, { capture: opts, passive: true });\n      }\n      if (opts.passive == null) {\n        return this(listener, { ...opts, passive: true });\n      }\n      return this(listener, opts);\n    });\n  }\n\n}\n\nexport interface OnDomEvent<E extends Event> {\n\n  /**\n   * Registers a DOM event listener.\n   *\n   * @param listener  A DOM event listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @return A DOM events supply.\n   */\n  // eslint-disable-next-line @typescript-eslint/prefer-function-type\n  (this: void, listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n}\n\n/**\n * Converts a plain DOM event listener registration function to [[OnDomEvent]] sender.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n * @param register  A generic DOM event listener registration function.\n *\n * @returns An [[OnDomEvent]] sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<E extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[E]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<E> {\n\n  const onDomEvent = (\n      (\n          listener: DomEventListener<E>,\n          opts?: AddEventListenerOptions | boolean,\n      ) => {\n\n        const receiver = eventReceiver(listener);\n\n        register(receiver, opts);\n\n        return receiver.supply;\n      }\n  ) as OnDomEvent<E>;\n\n  Object.setPrototypeOf(onDomEvent, OnDomEvent.prototype);\n\n  return onDomEvent;\n}\n","/**\n * @packageDocumentation\n * @module fun-events/dom\n */\nimport { noop } from 'call-thru';\nimport { EventReceiver, eventSupply, EventSupply, EventSupply__symbol, eventSupplyOf, EventSupplyPeer } from '../base';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\nconst domEventContext: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners and dispatch events.\n *\n * @category DOM\n */\nexport class DomEventDispatcher implements EventSupplyPeer {\n\n  readonly [EventSupply__symbol]: EventSupply = eventSupply();\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target  Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link EventSupply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link EventSupply.off cut off}.\n   *\n   * @typeparam E  Supported DOM event type.\n   * @param type  DOM event type name.\n   *\n   * @returns [[OnDomEvent]] sender of DOM events of the given `type`.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return onDomEventBy<E>((listener, opts) => {\n\n      const { supply } = listener;\n\n      supply.needs(eventSupplyOf(this));\n\n      if (!supply.isOff) {\n\n        // Create unique DOM listener instance\n        const domListener: EventListener = event => listener.receive(domEventContext, event as E);\n\n        this._target.addEventListener(type, domListener, opts);\n        listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n      }\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise. Also returns `false` after [[done]] method called.\n   */\n  dispatch(event: Event): boolean {\n    return !eventSupplyOf(this).isOff && this._target.dispatchEvent(event);\n  }\n\n  /**\n   * Removes all registered event listeners and rejects new listeners registration and event dispatching.\n   *\n   * @param reason  A reason to unregister event listeners.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n","import { HthvItem } from './hthv-item';\n\n/**\n * @internal\n */\nexport interface HthvPartial<I extends HthvItem<any, any, any> = HthvItem> {\n  $: I['$'];\n  n?: I['n'];\n  t?: I['t'];\n  v: I['v'];\n  x?: I['x'];\n  p?: I['p'];\n  pl?: I['pl'];\n}\n\n/**\n * @internal\n */\nexport function hthvItem<I extends HthvItem<any, any, any>>(\n    {\n      $,\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<I>,\n): I {\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as I;\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam({ p, pl }: HthvItem, param: HthvParamItem) {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = config.delimiterOf(c);\n\n    return c;\n  };\n}\n","// tslint:disable-next-line:max-line-length\nimport { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (input.s.match(datePattern)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","/**\n * @internal\n */\nexport const parseNone = () => false;\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseDateTime } from './parse-date-time';\nimport { parseNone } from './parse-none';\nimport { quotedStringParser } from './quoted-string-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport interface ItemParserOpts {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseQuotedString = quotedStringParser(config);\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem),\n    )) ; // tslint:disable-line:curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (config.delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = config.delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = config.delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser(config: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(config.delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport { HthvDelimitConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  delimiterOf(char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n    }: {\n      delimit?: HthvDelimitConfig;\n    } = {}): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = /*#__PURE__*/ buildParserConfig();\n\n/**\n * @internal\n */\nexport const commentParserConfig = /*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n});\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiterChar } from './hthv-delimiter';\nimport { HthvItem } from './hthv-item';\nimport { hthvItem } from './hthv-partial.impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeparam N  Whether parsed items have {@link HthvItem.n names}.\n * @typeparam T  Whether parsed items have {@link HthvItem.t tags}.\n * @typeparam P  Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    N extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    T extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    P extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value  HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<N, T, P>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse comments.\n   *\n   * `false` by default.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // tslint:disable-line\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (config.delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport { spacesParser } from './spaces-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const commentParserOpts: ItemParserOpts = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserOpts);\n  const parseParam = paramParser(config, commentParserOpts);\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while (\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        ) ; /* tslint:disable-line:curly */\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @module http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser =\n    /*#__PURE__*/ newHthvParser();\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = defaultParserConfig.delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","/**\n * @module delta-set\n */\n/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeparam T  A type of elements of delta set.\n */\nexport class DeltaSet<T> extends Set<T> {\n\n  /** @internal */\n  private readonly _added: Set<T>;\n\n  /** @internal */\n  private readonly _removed: Set<T>;\n\n  /**\n   * Constructs new delta set.\n   *\n   * @param values  An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n   */\n  constructor(values?: Iterable<T> | null) {\n    super();\n    this._added = new Set<T>(values);\n    this._removed = new Set<T>();\n    this._added.forEach(value => this.add(value));\n  }\n\n  /**\n   * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n   * already.\n   *\n   * Records element addition and forgets its removal unless the set contains it already.\n   *\n   * @param value  The value of the element to add.\n   *\n   * @returns `this` delta set.\n   */\n  add(value: T): this {\n    if (!this.has(value)) {\n      this._added.add(value);\n      this._removed.delete(value);\n      super.add(value);\n    }\n    return this;\n  }\n\n  /**\n   * Removes the specified element from this delta set.\n   *\n   * Records element removal and forgets its addition if removal succeed.\n   *\n   * @param value  The value of the element to remove.\n   *\n   * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n   */\n  delete(value: T): boolean {\n    if (super.delete(value)) {\n      this._added.delete(value);\n      this._removed.add(value);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all elements from this delta set.\n   *\n   * Records all elements removal and forgets all elements additions.\n   */\n  clear(): void {\n    this._added.clear();\n    this.forEach(value => this._removed.add(value));\n    super.clear();\n  }\n\n  /**\n   * Applies changes to this delta set.\n   *\n   * First removes elements to `remove`. Then appends elements to `add`.\n   *\n   * Records all changes made.\n   *\n   * @param add  An iterable of elements to add.\n   * @param remove  An iterable of elements to remove.\n   *\n   * @returns `this` delta set.\n   */\n  delta(add: Iterable<T>, remove: Iterable<T> = []): this {\n    deltaSetDeltaReceiver(this)(add, remove);\n    return this;\n  }\n\n  /**\n   * Replays changes made to this set in target receiver.\n   *\n   * @param receiver  A receiver of changes delta. E.g. another `Set`.\n   *\n   * @returns `this` delta set.\n   */\n  redelta(receiver: DeltaSet.DeltaReceiver<T>): this {\n\n    const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n\n    receive([...this._added], [...this._removed]);\n\n    return this;\n  }\n\n  /**\n   * Forgets all changes made to this set.\n   *\n   * Does not alter the set contents.\n   *\n   * @returns `this` delta set.\n   */\n  undelta(): this {\n    this._added.clear();\n    this._removed.clear();\n    return this;\n  }\n\n}\n\nexport namespace DeltaSet {\n\n  /**\n   * A delta set changes receiver.\n   *\n   * This can be either an {@link DeltaReceiverObject object}, or a {@link DeltaReceiverFunction function}.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiver<T> =\n      | DeltaReceiverFunction<T>\n      | DeltaReceiverObject<T>;\n\n  /**\n   * A delta set changes receiver function.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiverFunction<T> =\n  /**\n   * @param added  An array of added elements.\n   * @param removed  An array of removed elements.\n   */\n      (this: void, added: T[], remove: T[]) => void;\n\n  /**\n   * A delta set changes receiver object.\n   *\n   * A `Set` class implements this interface.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export interface DeltaReceiverObject<T> {\n\n    /**\n     * Receives an element that has been added to delta set.\n     *\n     * @param value  The value of the added element.\n     */\n    add(value: T): void;\n\n    /**\n     * Receives an element that has been remove from delta set.\n     *\n     * @param value  The value of the removed element.\n     */\n    delete(value: T): void;\n\n  }\n\n}\n\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver<T>(\n    receiver: { add(value: T): void; delete(value: T): void; },\n): (this: void, add: Iterable<T>, remove: Iterable<T>) => void {\n  return (add, remove) => {\n    for (const removed of remove) {\n      receiver.delete(removed);\n    }\n    for (const added of add) {\n      receiver.add(added);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Value, Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by [[InControl.convert]] method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<To, ConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of [[convertTo]] when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<Value>): Applied<Value, Instance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<OfValue, Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance, Kind>,\n    build: <V>(this: void, control: InControl<V>, origin?: InControl<any>) => Instance,\n    instance?: Instance,\n    origin?: InControl<any>,\n): InAspect.Applied<Value, Instance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<To>(target: InControl<To>): InAspect.Applied<To, Instance> {\n      return inAspectSameOrBuild<To, Instance, Kind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<Value>): InAspect.Applied<Value, Instance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as Instance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance | null, Kind>,\n    instance: Instance | null = null,\n): InAspect.Applied<Value, Instance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<any, Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from 'namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * [[InNamespaceAliaser.to]] converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @param nsAlias  Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by [[InRenderScheduler.to]] converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @param scheduler  Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(scheduler: InRenderScheduler): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, flatMapIt, itsReduction, mapIt } from 'a-iterable';\nimport { isPresent, noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Conversion<From, To>\n    | InConverter.Factory<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<From, To>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Conversion<From, To> =\n      | InConverter.Value.Conversion<From, To>\n      | InConverter.Aspect.Conversion<To>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Value<From, To> =\n      | InConverter.Value.Factory<From, To>\n      | InConverter.Value.Conversion<From, To>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To = From> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Conversion<From, To>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: To): From;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To = From> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<Value>(\n    ...converters: InConverter.Aspect<Value, Value>[]\n): InConverter.Aspect.Factory<Value, Value>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter.Value<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Value.Factory<From, To>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter?: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> {\n\n  type AspectApplicator = <Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<From, To> => {\n\n    const conversion = converter(from, to);\n    const conversions = flatMapIt<InConverter.Conversion<From, To>>([\n        [conversion],\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    ]);\n\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev, cv) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeparam Value  Input value type.\n * @param aspects  Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<Value>(\n    aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[],\n): InConverter.Aspect.Factory<Value> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<Value>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion  Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return !(conversion as any).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Value<From, To>,\n): InConverter.Value.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { asis, noop } from 'call-thru';\nimport {\n  EventEmitter,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get [EventSupply__symbol](): EventSupply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<Value, Value>[]\n  ): InControl<Value>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   * @param and  Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      by: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<To>;\n\n  convert<To>(\n      by?: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<Value> | InControl<To> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<From, To> extends InControl<To> {\n\n  private readonly _supply: EventSupply;\n  readonly on: OnEvent<[To, To]>;\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(src: InControl<From>, by: InConverter.Factory<From, To>) {\n    super();\n    this._supply = eventSupply().needs(src);\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const on = new EventEmitter<[To, To]>();\n\n    this.on = on.on;\n\n    const conversion = by(src, this);\n    let set: (value: From) => To;\n    let get: (value: To) => From;\n    let convertAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    if (isInAspectConversion(conversion)) {\n      set = asis as (value: From) => To;\n      get = asis as (value: To) => From;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    eventSupplyOf(this._it).needs(this._supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        on.send(newValue, oldValue);\n      }\n    }).whenOff(reason => on.done(reason));\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).whenOff(reason => this.done(reason));\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n */\nexport abstract class AbstractInControl<Value> extends InControl<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<Value>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { EventSupply, eventSupply, EventSupply__symbol, OnEvent } from 'fun-events';\nimport { InControl } from '../control';\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @param control  Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<Value>(control: InControl<Value>): InControl<Value> {\n\n  let supply: EventSupply | undefined;\n\n  class InSameValue extends InControl<Value> {\n\n    get it(): Value {\n      return control.it;\n    }\n\n    set it(value: Value) {\n      control.it = value;\n    }\n\n    get on(): OnEvent<[Value, Value]> {\n      return control.on;\n    }\n\n    get [EventSupply__symbol](): EventSupply {\n      return supply || (supply = eventSupply().needs(control));\n    }\n\n  }\n\n  return new InSameValue();\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends AbstractInControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n  readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n  readonly read: AfterEvent<[InParents.All]>;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const map = this._map;\n\n    this.on = this._on.on.tillOff(_control);\n    this.read = afterEventBy(\n        this.on.thru(\n            allParents,\n        ),\n        () => [allParents()],\n    );\n\n    function allParents(): IterableIterator<InParents.Entry> {\n      return map.keys();\n    }\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends AbstractInControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<Value, any>,\n        ) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt } from 'a-iterable';\nimport { nextArgs, NextCall, nextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates. Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  get [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get on(): OnEvent<[InMode.Value, InMode.Value]> {\n    return this._tracker.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._tracker);\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n      case 'off':\n      case 'ro':\n      case '-on':\n      case '-ro':\n        break;\n      default:\n        value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterEventBy(\n        this._on.on.thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keep.thru(\n        (set: Set<AfterEvent<[InMode.Value]>>) => nextAfterEvent(afterEach(...set)),\n        mergeInModes,\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): EventSupply {\n\n    const supply = eventSupply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly read: AfterEvent<[InMode.Value]>;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    eventSupplyOf(this.own).needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read.keep.thru_(parentsInMode));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterEventBy<[InMode.Value]>(\n        afterAll({\n          derived: this._derived.read,\n          own: this.own,\n        }).thru(({ derived: [derived], own: [own] }) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          return last === next ? nextSkip() : nextArgs(last = next);\n        }),\n        valuesProvider<[InMode.Value]>(last),\n    ).tillOff(_control);\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    });\n  }\n\n  derive(source: InMode.Source): EventSupply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control))\n            .tillOff(this._control),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n    case 'off':\n      element.setAttribute('disabled', '');\n      break;\n    case 'ro':\n    case '-ro':\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      element.setAttribute('readonly', '');\n      break;\n    default:\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('readonly', '');\n      element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): NextCall<OnEventCallChain, [InMode.Value]> {\n\n  const parentList = Array.from(parents);\n\n  if (!parentList.length) {\n    return nextArgs('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return nextAfterEvent(afterEach(...parentModes).keep.thru_(mergeInModes));\n}\n\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...flatMapIt<InMode.Value>(modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes  Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n      case 'off':\n        return 'off';\n      case 'ro':\n        ro = true;\n        break;\n      case '-on':\n        off = true;\n        break;\n      case '-ro':\n        off = true;\n        ro = true;\n        break;\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll, AfterEvent } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <V>(ctrl: InControl<V>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).keep.thru(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? nextArgs(value as InData.DataType<V>)\n            : nextArgs(),\n    ));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<Value, InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from 'a-iterable';\nimport { nextArg, nextArgs, NextCall, noop } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  nextAfterEvent,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<Instance, Model, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): EventSupply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<Model>): EventSupply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof Model): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<Model> {\n\n  readonly [OnEvent__symbol]: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  readonly [AfterEvent__symbol]: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, InGroupEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, InGroupEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, InGroupEntry][],\n      removed: [keyof Model, InGroupEntry][],\n  ): EventSupply {\n\n    const replaced = this._map.get(key);\n    let supply: EventSupply;\n\n    if (control) {\n      supply = eventSupply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = noEventSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]>,\n      supply: EventSupply,\n  ): InGroupEntry {\n    return [\n      control,\n      eventSupply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof Model, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof Model, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n  clear(): [keyof Model, InGroupEntry][] {\n\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, InGroupEntry][], [keyof Model, InGroupEntry][]]>();\n  readonly on: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const self = this;\n\n    this._map = new InGroupMap<Model>(this);\n    this.on = this._updates.on.thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    );\n    this.read = afterEventBy(\n        this._updates.on.thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()],\n    );\n    this._map._supply.needs(_group.read(applyModelToControls));\n\n    function applyModelToControls(model: Model): void {\n      self.read.once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    }\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined,\n  ): EventSupply {\n\n    const group = this._group;\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n    let supply: EventSupply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = eventSupply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: Model | undefined;\n\n      added.forEach(([key, [control, supply]]) => {\n        supply.needs(control.aspect(InParents).add({ parent: group }).needs(supply));\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(([key, [control, supply]]) => {\n        supply.needs(control.read(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).needs(supply));\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, InGroupEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(\n      model: Model,\n      opts: {\n        readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    eventSupplyOf(this).whenOff(() => this.controls.clear());\n  }\n\n  get on(): OnEvent<[Model, Model]> {\n    return this._model.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._model);\n  }\n\n  get it(): Model {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keep.thru_(\n      readInGroupData,\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    },\n): NextCall<OnEventCallChain, [InData.DataType<Model>?]> {\n  if (!InMode.hasData(mode)) {\n    return nextArgs();\n  }\n\n  const csData: { [key in keyof Model]: InData<any> } = {} as any;\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return nextAfterEvent(afterAll(csData).keep.thru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(overEntries(controlsData), ([key, [controlData]]) => {\n      data[key] = controlData;\n    });\n\n    return nextArg(data as InData.DataType<Model>);\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(\n    model: Model,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n    } = {},\n): InGroup<Model> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<OfValue extends object ? OfValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, afterThe } from 'fun-events';\n\n/**\n * @internal\n */\nconst _requireNothing = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return _requireNothing;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { CallChain, nextArgs, NextCall, valueProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>,\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read.keep.thru(simpleInValidator(control, validator));\n}\n\n/**\n * @internal\n */\nfunction simpleInValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): (value: Value) => NextCall<CallChain, InValidation.Message[]> {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : nextArgs(messages);\n  };\n}\n","import { flatMapIt, itsEach } from 'a-iterable';\nimport { asis, noop, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly [AfterEvent__symbol]: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this[AfterEvent__symbol] = afterEventBy(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share().tillOff(control);\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from 'a-iterable';\nimport { nextArgs, NextCall } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  EventKeeper,\n  EventSupply,\n  nextAfterEvent,\n  OnEventCallChain,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild<Value, InValidation<Value>, 'validation'>(\n        control,\n        InValidation,\n        <V>(ctrl: InControl<V>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<V>(ctrl);\n\n          if (origin) {\n\n            const from = origin.aspect(InValidation);\n\n            validation.by(from.read.keep.thru(result => nextArgs(...result.messages())));\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes  Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code, [message]);\n              }\n            }\n          });\n\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        },\n    );\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): IterableIterator<InValidation.Message> {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n\n    this.read = afterSupplied(this._messages).keep.thru(inValidationResult);\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.keep.thru(\n      nestedInValidations,\n      combineInValidationResults,\n  );\n}\n\n/**\n * @internal\n */\nfunction nestedInValidations(\n    controls: InContainer.Snapshot,\n): NextCall<OnEventCallChain, [InValidation.Result][]> {\n  return nextAfterEvent(afterEach(...mapIt(controls, control => control.aspect(InValidation))));\n}\n\n/**\n * @internal\n */\nfunction combineInValidationResults(\n    ...results: [InValidation.Result][]\n): NextCall<OnEventCallChain, InValidation.Message[]> {\n  return nextArgs<InValidation.Message[]>(\n      ...flatMapIt(mapIt(results, result => result[0])),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { EventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control ? control.read.keep.thru(value => value ? nextArgs() : { missing: 'missing' }) : requirePresent;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEvery, mapIt } from 'a-iterable';\nimport { nextArgs } from 'call-thru';\nimport { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper, eventSupplyOf, trackValue } from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrBuild } from './aspect.impl';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors  Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...mapIt(errors, message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason  A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * [input data]: InData\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InSubmit<Value> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of submit status flag.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @param submitter  A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Result  Submit result value type.\n   */\n  export type Submitter<Value, Result> =\n  /**\n   * @param data  Input data to submit.\n   * @param control  Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          data: Value extends undefined ? never : Value,\n          control: InControl<Value>,\n      ) => Promise<Result>;\n\n}\n\nclass InControlSubmit<Value> extends InSubmit<Value> {\n\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n  readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read.keep.thru(\n        messages => nextArgs(...messages),\n    ));\n    this.read = afterAll({\n      flags: this._flags,\n      data: _control.aspect(InData),\n      messages: validation,\n    }).keep.thru(({ flags: [flags], data: [data], messages: [messages] }) => ({\n      ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n      submitted: flags.submitted,\n      busy: flags.busy,\n    })).tillOff(_control);\n  }\n\n  async submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result> {\n    if (eventSupplyOf(this._control).isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    function submitData(): Promise<Value extends undefined ? never : Value> {\n      return new Promise((resolve, reject) => {\n        afterAll({\n          data: control.aspect(InData),\n          flags: submit.read,\n        }).once(({ data: [d], flags: [{ ready }] }) => {\n          if (!ready) {\n            reject(new InSubmitRejectedError('notReady'));\n          } else {\n            resolve(d as any);\n          }\n        });\n      });\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form  Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady  Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid  Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy  Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read.keep.thru(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid  Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore  Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read.keep.thru(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  );\n}\n","import { asis, nextArgs, nextSkip } from 'call-thru';\nimport {\n  AfterEvent,\n  afterSupplied,\n  EventEmitter,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n} from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nexport class InElementControl<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly input: AfterEvent<[InElement.Input<Value>]>;\n  readonly on: OnEvent<[Value, Value]>;\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: InElementControl<Value, Elt>) => Value;\n  private readonly _set: (this: InElementControl<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private _value: Value;\n  // noinspection TypeScriptFieldCanBeMadeReadonly\n  private _update: (value: Value, oldValue: Value) => void;\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._input);\n  }\n\n  constructor(\n      readonly element: Elt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n        readonly get: (this: InElementControl<Value, Elt>) => Value;\n        readonly set: (this: InElementControl<Value, Elt>, value: Value) => void;\n      },\n  ) {\n    super({ aspects });\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const update = this._update = (value: Value, oldValue: Value): void => send({ value }, oldValue);\n\n    this.input = afterSupplied<[InElement.Input<Value>]>(\n        this._input.on.thru(asis),\n        () => [{ value: this.it }],\n    );\n\n    this.on = this._input.on.thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    );\n\n    this.events = new DomEventDispatcher(element);\n\n    const self = this;\n    const supply = eventSupplyOf(this);\n    const onInput = (event: Event): void => send({ value: self.it, event }, self._value);\n\n    this.events.on('input')(onInput).needs(supply);\n    this.events.on('change')(onInput).needs(supply);\n\n    function send(input: InElement.Input<Value>, oldValue: Value): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = update;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { InElementControl } from './element.impl';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new InElementControl(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { EventSupply, EventSupply__symbol, eventSupplyOf, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot | null = element.getRootNode\n        ? element.getRootNode() as any\n        : element.ownerDocument;\n\n    this._it = trackValue(!!owner && owner.activeElement === element);\n    eventSupplyOf(this).needs(inElement);\n\n    events.on('focus')(() => this._it.it = true);\n    events.on('blur')(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get on(): OnEvent<[boolean, boolean]> {\n    return this._it.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._it);\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, mapIt } from 'a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.by(elementInStatusFlags(this._flags, control));\n    this.read = this._flags.read.tillOff(control);\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.keep.thru(({ event }) => !!event) : afterThe(false),\n  }).keep.thru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  );\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n    this.read = containerInStatusFlags(_container).tillOff(_container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markEdited(edited),\n        ),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markTouched(touched),\n        ),\n    );\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.keep.thru_(\n      (snapshot: InContainer.Snapshot) => nextAfterEvent(afterEach(...inControlStatuses(snapshot))),\n      combineInStatusFlags,\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { eventSupplyOf } from 'fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { InElementControl } from '../element.impl';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by [[inFormElement]] function.\n *\n * @category Control\n * @typeparam Elt  A type of HTML form element.\n */\nexport type InFormElement<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element  HTML element to create control for.\n * @param options  Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<Elt extends HTMLElement>(\n    element: Elt,\n    options: InFormElement.Options,\n): InFormElement<Elt> {\n\n  const { form, aspects, modes } = options;\n  const control = new InElementControl<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, modes));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { eventSupplyOf } from 'fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { InElementControl } from '../element.impl';\n\n/**\n * Form submit button control.\n *\n * It is connected to control to submit (form) and may change submit button state depending on form submit status.\n * E.g. by disabling it when submit is {@link InSubmit.Flags.ready not ready}, or while {@link InSubmit.Flags.busy\n * submitting} the form.\n *\n * Submit button control can be created by [[inSubmitButton]] function.\n *\n * @category Control\n * @typeparam Elt  A type of submit button element.\n */\nexport type InSubmitButton<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InSubmitButton {\n\n  /**\n   * Submit button control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to submit button control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `off` (disable) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `off` (disabled) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element  Submit button element to create control for.\n * @param options  Submit button control options.\n *\n * @returns New submit button control.\n */\nexport function inSubmitButton<Elt extends HTMLElement>(\n    element: Elt,\n    options: InSubmitButton.Options,\n): InSubmitButton<Elt> {\n\n  const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n  const control = new InElementControl<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, { notReady, invalid, busy }));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @param element  A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(element: InStyledElement | null = null): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { DeltaSet } from 'delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventKeeper,\n  EventNotifier,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { css__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { RenderSchedule } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Reports current CSS classes as added ones on receiver registration.\n   */\n  abstract readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element  Target element to apply CSS classes to.\n   * @param schedule  DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by [[InNamespaceAliaser]] aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n  private readonly _sources: ValueTracker<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]> = trackValue([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this.read = this._sources.read.keep.thru_(\n        ([sources]) => nextAfterEvent(afterEach(...sources.keys())),\n        (...classes) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        },\n    ).tillOff(_control);\n    this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    }).tillOff(_control);\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n\n    eventSupplyOf(_control).whenOff(reason => this.done(reason));\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).keep.thru(\n        (...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        },\n    );\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const inSupply = eventSupplyOf(this._control);\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source)({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): EventSupply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark  Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when  {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  let marks: InCssClasses.Spec[];\n\n  if (!mark) {\n    marks = defaultInCssErrorMarks;\n  } else if (Array.isArray(mark)) {\n    marks = mark.length ? mark : defaultInCssErrorMarks;\n  } else {\n    marks = [mark];\n  }\n\n  return control => control.aspect(InValidation).read.keep.thru(\n      errors => hasError(errors) ? nextArgs(...marks) : nextArgs(),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll } from 'fun-events';\nimport { NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InStatus } from '../focus';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns  A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keep.thru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          return nextArgs(...names);\n        },\n    );\n  };\n}\n"],"names":["asis","value","noop","isPresent","valueProvider","valuesProvider","values","NextCall__symbol","Symbol","nextCall","callNext","result","chain","fn","isNextCall","target","nextArg","arg","pass","nextArgs","args","call","nextEach","elements","element","nextSkip","skip","isArrayLike","itsRevertible","iterable","itsIterator","iterator","itsIterable","makeIt","iterate","reverse","[object Object]","reversible","reverseIt","source","reverseArray","reversed","Array","from","array","i","length","itsEach","action","itsEvery","test","itsFirst","next","itsReduction","reducer","initialValue","reduced","filterIt","flatMapIt","convert","mapIt","thruIt","it","passes","index","lastPass","handleResult","callResult","push","item","oldResult","newResult","res","ArrayLikeIterableMethods","AIterable","noneAIterable","every","name","is","makeAIterable","this","itsSome","fns","thru","NoneAIterable","super","overArray","noneIterable","overEntries","keys","Reflect","ownKeys","overKeys","mapToEntries","_keys","key","ContextKey__symbol","ContextKey","ContextSeedKey","seedKey","opts","seeder","seed","isEmpty","byDefault","ContextKeyError","Error","message","contextValueSpec","spec","byProvider","withDeps","a","by","with","deps","context","map","dep","get","isConstant","viaAlias","via","ctx","asInstance","selfInstance","Object","as","toAsInstance","Type","DepType","TypeError","ContextValues","ContextRegistry","initial","Map","_initial","_seeding","provide","found","_seeds","seeding","set","factory","cache","newValues","bind","_nonCachedValues","registry","Values","cached","constructed","defaultUsed","findSeed","valueOpts","or","defaultProvider","defaultValue","grow","growValue","other","combine","SimpleContextSeeder","provider","_providers","indexOf","splice","sourceValues","flatMap","done","first","second","SimpleSeedKey","SimpleContextKey","SingleContextKey","last","itsLast","MultiContextKey","defaultSources","providers","entry","filter","AfterEvent__symbol","isEventKeeper","EventSupply__symbol","EventSupply","another","eventSupplyOf","whenOff","reason","off","peer","eventSupply","cutOff","callback","prev","isOff","NoSupply","noSupply","noEventSupply","eventReceiver","receiver","generic","supply","_context","event","receive","OnEvent__symbol","EventNotifier","Set","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","processEvent","shift","receiveEventsByEach","_rcvs","forEach","size","on","add","needs","delete","recurrentReceivers","idx","recurrentReceiver","recurrentEvent","once","register","share","shared","sharedSupply","initialEvents","undefined","_ctx","dispatcher","tillOff","required","dependentSupply","requiredSupply","OnEvent","Function","onEventBy","consume","consumerSupply","senderSupply","prevSupply","thru_","onEvent","toSupplier","chains","chainSupply","existing","supplier","parentSupply","nextChain","firstChain","onSupplied","setPrototypeOf","prototype","onNever","AfterEventKeep","keeper","_keeper","afterSupplied","AfterEvent","keep","afterEventBy","fallback","noEvent","lastEvent","numReceivers","afterEvent","dest","reported","sender","afterSent","afterThe","afterAll","sources","notifier","afterEach","nextAfterEvent","nextOnEvent","EventEmitter","onAny","suppliers","remained","removeSupplier","onAsync","sourceSupply","numInProcess","numSent","numReceived","lastIndex","promise","Promise","resolve","then","onAnyAsync","toSend","statePath","path","isArray","PathEntry","_drop","emitter","newValue","oldValue","nested","_nested","slice","_dropIfEmpty","dontCreateMissing","created","_remove","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","_tracker","onUpdate","StateTracker","update","subTracker","track","ValueTracker","valueReceiver","onRecurrent","recurrentValue","read","extract","acceptValuesFrom","byNone","container","_by","TrackedValue","_it","_on","trackValue","Naming","nsAlias","local","ns","DefaultNaming","alias","default__naming","html__naming","CssNaming","css__naming","NamespaceDef","url","aliases","naming","applyAlias","isQualifiedName","isNameAndNamespace","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","ContextUpSeeder","concat","providersTracker","prov","toUpSrcKeeper","flatUpSources","upSrcKeepers","src","isUpSrcKeeper","ContextSeedUpKey","ContextUpKeyUpKey","_key","ContextUpKey","SingleContextUpKey","upKey","backup","FnContextKey","createUpKey","delegated","RenderScheduleConfig","options","win","node","window","ownerDocument","defaultView","messages","error","console","ScheduledRenderQueue","schedule","replace","renders","render","pull","ScheduledRenderQ__symbol","ScheduledRenderQ","q","ref","doSchedule","queue","config","execution","postpone","postponed","reset","suspend","exec","resume","scheduled","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","nextQueue","nextEnqueued","e","animationRenderQueues","WeakMap","defaultRenderScheduler","task","requestAnimationFrame","replacement","newRenderSchedule","OnDomEvent","onDomEventBy","capture","listener","instead","preventDefault","just","stopPropagation","stopImmediatePropagation","passive","onDomEvent","domEventContext","DomEventDispatcher","_target","type","domListener","addEventListener","removeEventListener","dispatchEvent","hthvItem","$","n","t","v","x","p","pl","addParam","param","nextInItem","input","c","s","d","delimiterOf","datePattern","parseDateTime","out","substring","match","parseNone","itemParser","named","tagged","extra","parseQuotedString","unquoted","quotedStringParser","parseAngleBrackets","angleBracketsParser","parseExtra","tag","extraItem","nextInComment","spacesParser","start","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParserOpts","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","DeltaSet","_added","_removed","has","clear","remove","deltaSetDeltaReceiver","removed","added","InAspect__symbol","inAspectNull","instance","convertTo","inAspectSameOrBuild","control","aspectKey","build","origin","attachTo","aspect","inAspectSameOrNull","inAspectValue","InputAspects__NS","InNamespaceAliaser__aspect","applyTo","InNamespaceAliaser","to","applyAspect","InRenderScheduler__aspect","InRenderScheduler","scheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","aspectConverters","conversion","acf","cv","isInAspectConversion","intoConvertedAspects","aspects","noopInConversion","InControl","_aspect","aspectKeyOrSetup","aspectSetup","and","InConverted","_aspects","applied","_applyAspect","_supply","backward","lastRev","convertAspect","rev","prevValue","prevRev","AbstractInControl","_aspectConversion","inValueOf","InContainer__aspect","InContainer","InParents__aspect","InControlParents","InParents","_control","_map","allParents","existingSupply","parent","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","own","OwnModeTracker","getAttribute","initialInMode","DerivedInModes","_all","mergeInModes","derive","InParentsAspect","parentsInMode","derived","_derived","setAttribute","removeAttribute","applyInMode","lastUpdate","old","parents","parentList","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","inControlReplacedReason","InGroupSnapshot","entries","InGroupMap","_controls","replaced","newEntry","sendUpdate","modify","_shot","k","InGroupControlControls","_group","self","_updates","controlEntryToGroupEntry","snapshot","model","withValues","keyOrControls","newControl","group","newModel","applyControlsToModel","InGroupControl","_model","controls","cs","readInGroupData","csData","controlsData","data","controlData","inGroup","_requireNothing","requireNothing","inValidator","validator","validate","simpleInValidator","dontRemove","InValidationMessages","validators","validatorMessages","resultSupply","validatorSupply","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","ok","hasBut","InValidationErrors","nonEmpty","code","codePresent","_byCode","codes","some","inValidationResult","_messages","nestedInValidations","combineInValidationResults","nestedInValidationMessages","numValidators","requireAll","results","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","errors","submit","InSubmitRejectedError","rejected","submitted","busy","_errors","flags","_flags","ready","submitter","reject","toInSubmitMessages","inModeByForm","form","notReady","invalid","inModeByValidity","ignore","validity","InElementControl","_get","_set","_value","_update","_input","events","onInput","correction","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","activeElement","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","inSubmitButton","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_sources","classes","mergeInCssClassesMap","classesSent","flag","delta","redelta","undelta","_schedule","controlSchedule","specs","names","inSupply","classesSupply","classList","updateClasses","defaultInCssErrorMarks","defaultInCssHasError","inCssError","mark","when","hasError","marks","inCssInfo","cls","md","vl","st","valid"],"mappings":"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"}