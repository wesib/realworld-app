{"version":3,"file":"common.d13eb97a.js","sources":["../../src/common/articles/article.ts","../../src/common/articles/feed-request.ts","../../src/common/articles/feed-service.ts","../../src/common/api/api-root-url.ts","../../src/common/auth/auth-service.key.impl.ts","../../src/common/api/api-fetch.ts","../../src/common/api/api-submitter.ts","../../src/common/articles/feed-service.impl.ts","../../src/common/articles/feed-support.feature.ts","../../src/common/auth/auth-service.ts","../../src/common/auth/auth-service.impl.ts","../../src/common/auth/auth-support.feature.ts","../../src/common/conduit.ns.ts","../../src/common/generic/loader.component.ts","../../src/common/generic/pager-event.ts","../../src/common/generic/pager.component.ts","../../src/common/generic/conduit-generic-support.feature.ts","../../src/common/input/api-error-generator.ts","../../src/common/input/bootstrap-css-error.ts","../../src/common/input/api-errors.component.ts","../../src/common/input/in-error.component.ts","../../src/common/input/conduit-input-support.feature.ts","../../src/common/input/fill-conduit-form.decorator.ts","../../src/common/input/handle-conduit-submit-button.decorator.ts","../../src/common/input/use-conduit-input.decorator.ts","../../src/common/layout/main.component.ts","../../src/common/layout/navbar.component.ts","../../src/common/layout/container.component.ts","../../src/common/layout/footer.component.ts","../../src/common/layout/conduit-layout-support.feature.ts","../../src/common/conduit.feature.ts","../../src/common/util/escape-html.ts","../../src/common/index.ts"],"sourcesContent":["import marked from 'marked';\nimport { UserProfile } from '../users';\n\nexport interface Article {\n  readonly slug: string;\n  readonly title: string;\n  readonly description: string;\n  readonly body: string;\n  readonly tagList: readonly string[];\n  readonly createdAt: string;\n  readonly updatedAt: string;\n  readonly favorited: boolean;\n  readonly favoritesCount: number;\n  readonly author: UserProfile;\n}\n\nexport function articleContent(article: Article): Promise<string> {\n  // TODO Sanitize article\n  return new Promise<string>((resolve, reject) => {\n    marked(article.body, (error, html) => {\n      if (error != null) {\n        reject(error);\n      } else {\n        resolve(html);\n      }\n    });\n  });\n}\n","import { itsEach, thruIt } from 'a-iterable';\nimport { NextSkip, nextSkip } from 'call-thru';\n\nexport type FeedId = '/personal-feed' | '/global-feed';\n\nexport interface FeedRequest {\n  readonly feed?: FeedId;\n  readonly tag?: string;\n  readonly author?: string;\n  readonly favorited?: string;\n  readonly limit?: number;\n  readonly offset?: number;\n}\n\nconst feedRequestKeys: readonly (keyof FeedRequest)[] = ['feed', 'tag', 'author', 'favorited', 'limit', 'offset'];\n\nexport function feedRequestsEqual(first: FeedRequest, second: FeedRequest): boolean {\n  return feedRequestKeys.every(key => first[key] === second[key]);\n}\n\nexport function feedRequestSearchParams(request: FeedRequest): URLSearchParams {\n\n  const params = new URLSearchParams();\n\n  itsEach(\n      thruIt(\n          feedRequestKeys,\n          key => key !== 'feed' ? key : nextSkip,\n          (key: keyof FeedRequest): [keyof FeedRequest, string] | NextSkip => {\n\n            const value = request[key];\n\n            return value ? [key, String(value)] : nextSkip;\n          },\n      ),\n      ([key, value]) => params.set(key, value),\n  );\n\n  return params;\n}\n","import { ContextRef, SingleContextKey } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { ApiResponse } from '../api';\nimport { Article } from './article';\nimport { FeedRequest } from './feed-request';\n\nexport interface ArticleList {\n  readonly articles: readonly Article[];\n  readonly articlesCount: number;\n}\n\nexport interface FeedService {\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]>;\n\n  tags(): OnEvent<string[]>;\n\n  article(slug: string): OnEvent<[ApiResponse<Article>]>;\n\n}\n\nexport const FeedService: ContextRef<FeedService> = new SingleContextKey<FeedService>('feed-service');\n","import { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\n\nexport type ApiRootURL = URL;\n\nexport const ApiRootURL: SingleContextUpRef<ApiRootURL> = new SingleContextUpKey<ApiRootURL>(\n    'api-root-url',\n    {\n      byDefault: () => new URL('https://conduit.productionready.io/api/'),\n    },\n);\n","import { SingleContextKey } from 'context-values';\nimport { AuthService } from './auth-service';\n\nexport const AuthService__key = new SingleContextKey<AuthService>('auth-service');\n","import { HttpFetch } from '@wesib/generic';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { AfterEvent, nextOnEvent, onAsync, OnEvent, OnEventCallChain } from 'fun-events';\nimport { AuthService__key } from '../auth/auth-service.key.impl';\nimport { ApiRootURL } from './api-root-url';\n\n/**\n * Request to some API endpoint.\n *\n * @typeparam T  Response type.\n */\nexport interface ApiRequest<T> {\n\n  /**\n   * API endpoint path __relative__ to {@link ApiRootURL API root URL}.\n   *\n   * Do not start it with `/` as this would make it absolute.\n   */\n  readonly path: string;\n\n  /**\n   * Wrapper field containing response object, or a function extracting it.\n   */\n  readonly respondAs: string | ((this: void, json: any) => T);\n\n  /**\n   * Additional HTTP request options.\n   */\n  readonly init?: RequestInit;\n\n  /**\n   * Whether to send authentication token.\n   *\n   * - `true` to always send it,\n   * - `false` to never send it,\n   * - `undefined` (the default) - to send it only when {@link AuthService.authentication authenticated}.\n   */\n  readonly auth?: boolean;\n\n}\n\nexport type ApiResponse<T> =\n    | ApiResponse.Ok<T>\n    | ApiResponse.Failure;\n\nexport namespace ApiResponse {\n\n  export interface Ok<T = any> {\n    readonly ok: true;\n    readonly response: Response;\n    readonly body: T;\n  }\n\n  export interface Failure {\n    readonly ok: false;\n    readonly response?: Response;\n    readonly errors: Errors;\n  }\n\n  export type Errors = {\n    readonly [field in string]: readonly string[];\n  };\n\n}\n\nexport type ApiFetch = <T>(this: void, request: ApiRequest<T>) => OnEvent<[ApiResponse<T>]>;\n\nexport const ApiFetch: ContextUpRef<ApiFetch, ApiFetch> = (\n    new FnContextKey<[ApiRequest<any>], OnEvent<[ApiResponse<any>]>>(\n        'api-fetch',\n        {\n          byDefault: bootstrapDefault(newApiFetch),\n        },\n    ));\n\ntype RequestOrFailure =\n    | { request: Request }\n    | { request?: undefined; failure: ApiResponse.Failure };\ntype ResponseOrFailure =\n    | { response: Response }\n    | { response?: undefined; failure: ApiResponse.Failure };\ntype ResponseBodyOrFailure =\n    | [{ response: Response }, any]\n    | [{ response?: undefined; failure: ApiResponse.Failure }];\n\nfunction newApiFetch(context: BootstrapContext): ApiFetch {\n\n  const httpFetch = context.get(HttpFetch);\n  const apiRootURL = context.get(ApiRootURL);\n\n  return request => {\n\n    const { path, init, auth } = request;\n    const onResponse: OnEvent<[ResponseOrFailure]> = apiRootURL.thru_(\n        baseURL => new URL(path, baseURL),\n        url => buildApiRequest(url, init),\n    ).thru_(\n        (request: Request): NextCall<OnEventCallChain, [RequestOrFailure]> => auth === false\n            ? nextArgs({ request })\n            : nextOnEvent(authenticateApiRequest(context, request, auth)),\n        (requestOrFailure): NextCall<OnEventCallChain, [ResponseOrFailure]> => requestOrFailure.request\n            ? nextOnEvent(httpFetch(requestOrFailure.request).thru_(response => ({ response })))\n            : nextArgs({ failure: requestOrFailure.failure }),\n    );\n\n    return onAsync(onResponse.thru_(parseApiResponse)).thru_(\n        ([responseOrFailure, json]) => handleApiResponse(request, responseOrFailure, json),\n    );\n  };\n}\n\nfunction buildApiRequest(url: URL, init: RequestInit = {}): Request {\n\n  const request = new Request(url.href, { mode: 'cors', ...init });\n  const { headers } = request;\n\n  headers.set('X-Requested-With', 'XMLHttpRequest');\n\n  return request;\n}\n\nfunction authenticateApiRequest(\n    context: BootstrapContext,\n    request: Request,\n    auth?: true,\n): AfterEvent<[RequestOrFailure]> {\n  // Access by key to avoid circular dependencies during the build\n  return context.get(AuthService__key).authentication.keep.thru_(\n      ({ token, failure }) => {\n        if (token) {\n          request.headers.set('Authorization', `Token ${token}`);\n          return { request };\n        }\n        if (!auth) {\n          return { request };\n        }\n        if (!failure) {\n          failure = {\n            ok: false,\n            errors: {\n              api: ['Not authenticated'],\n            },\n          };\n        }\n        return { failure };\n      },\n  );\n}\n\nfunction parseApiResponse(\n    responseOfFailure: ResponseOrFailure,\n): ResponseBodyOrFailure | Promise<ResponseBodyOrFailure> {\n  return responseOfFailure.response\n      ? Promise.all([responseOfFailure, responseOfFailure.response.json()])\n          .catch(error => [{\n            failure: {\n              ok: false,\n              response: responseOfFailure.response,\n              errors: {\n                api: [`Failed to parse response: ${error}`],\n              },\n            },\n          }])\n      : [responseOfFailure];\n}\n\nfunction handleApiResponse<T>(\n    { respondAs }: ApiRequest<T>,\n    responseOfFailure: ResponseOrFailure,\n    json?: any,\n): ApiResponse<T> {\n  if (!responseOfFailure.response) {\n    return responseOfFailure.failure;\n  }\n\n  const { response } = responseOfFailure;\n\n  if (response.ok) {\n    return {\n      ok: true,\n      response,\n      body: typeof respondAs === 'function' ? respondAs(json) : json[respondAs],\n    };\n  }\n\n  return {\n    ok: false,\n    response,\n    errors: json.errors || {\n      http: [\n        response.statusText\n            ? `${response.status}: ${response.statusText}`\n            : `ERROR ${response.status}`,\n      ],\n    },\n  };\n}\n","import { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { OnEvent } from 'fun-events';\nimport { InSubmit, InSubmitError } from 'input-aspects';\nimport { ApiFetch, ApiRequest, ApiResponse } from './api-fetch';\n\nexport type ApiSubmitter =\n    <Value = any, Result = any>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result>;\n\nexport const ApiSubmitter: ContextUpRef<ApiSubmitter, ApiSubmitter> = (\n    new FnContextKey<[ApiRequest<any>], InSubmit.Submitter<any, any>>(\n        'api-submitter',\n        {\n          byDefault: bootstrapDefault(newApiSubmitter),\n        },\n    ));\n\nfunction newApiSubmitter(\n    context: BootstrapContext,\n): <Value, Result>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result> {\n\n  const apiFetch: ApiFetch = context.get(ApiFetch);\n\n  return <Value, Result>(request: ApiRequest<Result>) => {\n\n    const { init = {} } = request;\n    const { method = 'POST', headers = {} } = init;\n\n    return (body: Value) => {\n\n      const apiRequest: ApiRequest<Result> = {\n        ...request,\n        init: {\n          ...init,\n          method,\n          body: JSON.stringify(body),\n          headers: {\n            ...headers,\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n          },\n        },\n      };\n\n      return apiSubmit(apiFetch(apiRequest));\n    };\n  };\n}\n\nexport function apiSubmit<Result>(onFetch: OnEvent<[ApiResponse<Result>]>): Promise<Result> {\n  return new Promise((resolve, reject) => {\n    onFetch.once(\n        (response: ApiResponse<Result>) => {\n          if (response.ok) {\n            resolve(response.body);\n          } else {\n            reject(new InSubmitError({ submit: 'api', api: response.errors }));\n          }\n        },\n    ).whenOff(\n        reason => {\n          reject(\n              reason instanceof InSubmitError\n                  ? reason\n                  : new InSubmitError({ submit: 'cancel', cancel: reason }),\n          );\n        },\n    );\n  });\n}\n","import { BootstrapContext } from '@wesib/wesib';\nimport { asis, nextArg, nextArgs, nextSkip } from 'call-thru';\nimport { afterSupplied, OnEvent, onEventBy, trackValueBy } from 'fun-events';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { Article } from './article';\nimport { FeedId, FeedRequest, feedRequestSearchParams } from './feed-request';\nimport { ArticleList, FeedService } from './feed-service';\n\ninterface FeedSource {\n  path: string;\n  auth?: boolean;\n}\n\nconst feedSources: { readonly [id in FeedId]: FeedSource } = {\n  '/personal-feed': { path: 'articles/feed', auth: true },\n  '/global-feed': { path: 'articles' },\n};\n\nexport class FeedService$ implements FeedService {\n\n  private readonly _apiFetch: ApiFetch;\n  private _tags?: OnEvent<string[]>;\n\n  constructor(context: BootstrapContext) {\n    this._apiFetch = context.get(ApiFetch);\n  }\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]> {\n\n    const { path, auth } = feedSources[request.feed || '/global-feed'];\n\n    const apiRequest: ApiRequest<ArticleList> = {\n      path: `${path}?${feedRequestSearchParams(request)}`,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      auth,\n      respondAs: asis,\n    };\n\n    return this._apiFetch(apiRequest);\n  }\n\n  article(slug: string): OnEvent<[ApiResponse<Article>]> {\n\n    const apiRequest: ApiRequest<Article> = {\n      path: `articles/${encodeURIComponent(slug)}`,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      respondAs: 'article',\n    };\n\n    return this._apiFetch(apiRequest);\n  }\n\n  tags(): OnEvent<string[]> {\n    if (this._tags) {\n      return this._tags;\n    }\n\n    let onTags: OnEvent<string[]> | undefined;\n\n    return this._tags = onEventBy(receiver => {\n      if (!onTags) {\n\n        const apiRequest: ApiRequest<string[]> = {\n          path: 'tags',\n          init: {\n            method: 'GET',\n            headers: {\n              Accept: 'application/json',\n            },\n          },\n          respondAs: 'tags',\n          auth: false,\n        };\n        const onTagsLoad: OnEvent<[string[]]> = this._apiFetch(apiRequest).thru_(response => {\n          if (response.ok) {\n            return nextArg(response.body);\n          }\n          if (response.ok === false) {\n            console.log('Failed to load tags', response.errors);\n            return nextArg([]);\n          }\n          return nextSkip;\n        });\n        const tags = trackValueBy<string[] | undefined>(\n            afterSupplied<[string[]?]>(onTagsLoad, () => []),\n        );\n\n        onTags = tags.read.thru_(\n            tagList => tagList ? nextArgs(...tagList) : nextSkip,\n        );\n      }\n\n      onTags(receiver);\n    });\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedService } from './feed-service';\nimport { FeedService$ } from './feed-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: FeedService, as: FeedService$ });\n  },\n})\nexport class FeedSupport {\n}\n","import { ContextKey, ContextKey__symbol } from 'context-values';\nimport { AfterEvent, OnEvent } from 'fun-events';\nimport { ApiResponse } from '../api';\nimport { AuthService__key } from './auth-service.key.impl';\nimport { Authentication, AuthUser, AuthUserOrFailure } from './authentication';\n\nexport interface LoginRequest {\n  readonly email: string;\n  readonly password: string;\n}\n\nexport interface RegisterRequest {\n  readonly username: string;\n  readonly email: string;\n  readonly password: string;\n}\n\nexport abstract class AuthService {\n\n  static get [ContextKey__symbol](): ContextKey<AuthService> {\n    return AuthService__key;\n  }\n\n  abstract readonly authentication: AfterEvent<[Authentication]>;\n\n  abstract readonly user: AfterEvent<AuthUserOrFailure>;\n\n  abstract login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract logout(): void;\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { nextArgs, NextCall, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  eventSupply,\n  nextOnEvent,\n  OnEvent,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { AuthService, LoginRequest, RegisterRequest } from './auth-service';\nimport { Authentication, AuthUser, AuthUserOrFailure } from './authentication';\n\nconst authTokenKey = 'wesib-conduit:auth';\n\nexport class AuthService$ extends AuthService {\n\n  readonly user: AfterEvent<AuthUserOrFailure>;\n  private readonly _auth: ValueTracker<Authentication>;\n\n  get authentication(): AfterEvent<[Authentication]> {\n    return this._auth.read;\n  }\n\n  constructor(private readonly _context: BootstrapContext) {\n    super();\n\n    const window = _context.get(BootstrapWindow);\n    const storage = window.localStorage;\n\n    this._auth = trackValue<Authentication>(toAuthToken(storage.getItem(authTokenKey)));\n    this._auth.on(storeAuthToken);\n    this.user = this.authentication.keep.thru(authUser);\n    new DomEventDispatcher(window).on<StorageEvent>('storage')(({ key, newValue }) => {\n      if (key === authTokenKey) {\n\n        const token = newValue || undefined;\n\n        if (this._auth.it.token !== token) {\n          this._auth.it = toAuthToken(token);\n        }\n      }\n    });\n\n    function storeAuthToken({ token }: Authentication): void {\n      if (token) {\n        storage.setItem(authTokenKey, token);\n      } else {\n        storage.removeItem(authTokenKey);\n      }\n    }\n\n    function authUser(auth: Authentication): NextCall<OnEventCallChain, AuthUserOrFailure> {\n      if (auth.email) {\n        return nextArgs(auth);\n      }\n      if (auth.failure) {\n        return nextArgs(undefined, auth.failure);\n      }\n      if (!auth.token) {\n        return nextArgs();\n      }\n      return nextOnEvent(fetchCurrentUser(auth.token));\n    }\n\n    function fetchCurrentUser(token: string): AfterEvent<AuthUserOrFailure> {\n\n      const apiFetch: ApiFetch = _context.get(ApiFetch);\n      const apiRequest: ApiRequest<AuthUser> = {\n        path: 'user',\n        init: {\n          headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            Authorization: `Token ${token}`,\n          },\n        },\n        respondAs: 'user',\n        auth: false,\n      };\n\n      return afterEventBy<AuthUserOrFailure>(\n          receiver => {\n            apiFetch(apiRequest).thru_(\n                (response: ApiResponse<AuthUser>): NextCall<OnEventCallChain, AuthUserOrFailure> => {\n                  if (response.ok) {\n                    return nextArgs(response.body);\n                  }\n                  return nextArgs(undefined, response);\n                },\n            )({\n              supply: eventSupply().needs(receiver.supply), // Do not abort after user received\n              receive(ctx, ...event) {\n                receiver.receive(ctx, ...event);\n              },\n            });\n          },\n          valuesProvider(),\n      );\n    }\n  }\n\n  login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users/login', request);\n  }\n\n  register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users', request);\n  }\n\n  logout(): void {\n    this._auth.it = {};\n  }\n\n  private _request(path: string, request: LoginRequest | RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n\n    const apiFetch: ApiFetch = this._context.get(ApiFetch);\n    const apiRequest: ApiRequest<AuthUser> = {\n      path,\n      init: {\n        method: 'POST',\n        body: JSON.stringify({ user: request }),\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json',\n        },\n      },\n      respondAs: 'user',\n      auth: false,\n    };\n\n    return apiFetch(apiRequest).thru_(\n        response => {\n          if (response.ok) {\n            this._auth.it = response.body;\n          } else if (response.ok === false) {\n            this._auth.it = { failure: response };\n          }\n          return response;\n        },\n    );\n  }\n\n}\n\nfunction toAuthToken(token: string | null | undefined): Authentication {\n  return token ? { token } : {};\n}\n","import { Feature } from '@wesib/wesib';\nimport { AuthService } from './auth-service';\nimport { AuthService$ } from './auth-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: AuthService, as: AuthService$ });\n  },\n})\nexport class AuthSupport {\n}\n","import { NamespaceDef } from 'namespace-aliaser';\n\nexport const Conduit__NS: NamespaceDef = new NamespaceDef(\n    'https://wesib.github.io/realworld-app/ns/',\n    'conduit',\n);\n","import { Attribute, BootstrapWindow, Component, ComponentContext, ElementRender, Render } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(['loader', Conduit__NS])\nexport class LoaderComponent {\n\n  @Attribute('load-error')\n  loadError?: string | null;\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const { document } = this._context.get(BootstrapWindow);\n    const range = document.createRange();\n\n    range.selectNodeContents(this._context.contentRoot);\n\n    return () => {\n      range.deleteContents();\n      if (this.loadError != null) {\n        range.insertNode(document.createTextNode(this.loadError));\n      }\n    };\n  }\n\n}\n","export class PagerEvent extends CustomEvent<number> {\n}\n","import { Attribute, BootstrapWindow, Component, ComponentContext, ElementRender, Render } from '@wesib/wesib';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { Conduit__NS } from '../conduit.ns';\nimport { PagerEvent } from './pager-event';\n\n@Component(['pager', Conduit__NS])\nexport class PagerComponent {\n\n  @Attribute('current-page')\n  currentPage?: string;\n\n  @Attribute('total-pages')\n  totalPages?: string;\n\n  @Attribute('visible-pages')\n  visiblePages?: string;\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const { contentRoot } = this._context;\n    const { document } = this._context.get(BootstrapWindow);\n\n    return () => {\n\n      const totalPages = this.totalPages && parseInt(this.totalPages, 10) || 0;\n      const range = contentRange();\n\n      range.deleteContents();\n      if (totalPages <= 1) {\n        return; // No paging required\n      }\n\n      const visiblePages = Math.max(1, this.visiblePages && parseInt(this.visiblePages, 10) || 5);\n      const currentPage = this.currentPage && parseInt(this.currentPage, 10) || 0;\n\n      const ul = document.createElement('ul');\n\n      ul.className = 'pagination';\n\n      let startPage = Math.max(0, currentPage - (visiblePages >> 1));\n      let endPage = startPage + visiblePages;\n\n      if (endPage > totalPages) {\n        startPage = Math.max(0, startPage - (endPage - totalPages));\n        endPage = totalPages;\n      }\n\n      ul.appendChild(pageItem('<<', 0, currentPage > 0));\n      ul.appendChild(pageItem('<', currentPage - 1, currentPage > 0));\n      for (let page = startPage; page < endPage; ++page) {\n        ul.appendChild(pageItem(String(page + 1), page, true, currentPage === page));\n      }\n      ul.appendChild(pageItem('>', currentPage + 1, currentPage + 1 < totalPages));\n      ul.appendChild(pageItem('>>', totalPages - 1, currentPage + 1 < totalPages));\n\n      range.insertNode(ul);\n    };\n\n    function contentRange(): Range {\n\n      const range = document.createRange();\n\n      range.selectNodeContents(contentRoot);\n\n      return range;\n    }\n\n    function pageItem(\n        text: string,\n        page: number,\n        enabled: boolean,\n        active = false,\n    ): HTMLLIElement {\n\n      const li = document.createElement('li');\n\n      li.className = 'page-item';\n\n      let link: HTMLElement;\n\n      if (enabled && !active) {\n        link = document.createElement('a');\n        link.setAttribute('href', '');\n        new DomEventDispatcher(li).on('click').capture.instead(event => {\n          event.preventDefault();\n          li.dispatchEvent(new PagerEvent('conduit:pager', { cancelable: true, bubbles: true, detail: page }));\n        });\n      } else {\n        li.classList.add(active ? 'active' : 'disabled');\n        link = document.createElement('span');\n      }\n      link.className = 'page-link';\n      link.innerHTML = text;\n      li.appendChild(link);\n\n      return li;\n    }\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { LoaderComponent } from './loader.component';\nimport { PagerComponent } from './pager.component';\n\n@Feature({\n  needs: [\n    LoaderComponent,\n    PagerComponent,\n  ],\n})\nexport class ConduitGenericSupport {\n}\n","import { bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { AIterable, overEntries } from 'a-iterable';\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { ApiResponse } from '../api';\n\nexport type ApiErrorGenerator = (this: void, errors: ApiResponse.Errors) => Element | undefined;\n\nexport const ApiErrorGenerator: FnContextRef<[ApiResponse.Errors], Element | undefined> = (\n    new FnContextKey<[ApiResponse.Errors], Element | undefined>(\n        'api-error-generator',\n        {\n          byDefault: bootstrapDefault(context => {\n\n            const document = context.get(BootstrapWindow).document;\n\n            return errors => {\n\n              let list: Element | undefined;\n\n              AIterable.from(overEntries(errors)).forEach(\n                  ([key, messages]) => {\n                    if (!list) {\n                      list = document.createElement('ul');\n                      list.classList.add('error-messages');\n                    }\n\n                    const ul = list;\n\n                    messages.forEach(message => {\n\n                      const li = document.createElement('li');\n\n                      li.innerText = `${key} ${message}`;\n                      ul.appendChild(li);\n                    });\n                  },\n              );\n\n              return list;\n            };\n          }),\n        },\n    ));\n","import { nextArgs } from 'call-thru';\nimport { afterAll, nextAfterEvent } from 'fun-events';\nimport { InCssClasses, inCssError, InStatus, InValidation } from 'input-aspects';\n\nexport function bootstrapCssError(\n    {\n      mark = 'is-invalid',\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n  return control => {\n\n    const cssClasses = control.aspect(InCssClasses);\n\n    return afterAll({\n      status: control.aspect(InStatus),\n      validity: control.aspect(InValidation),\n    }).keep.thru(\n        ({\n          status: [{ touched, hasFocus }],\n          validity: [validity],\n        }) => {\n\n          const incomplete = validity.has('incomplete') || validity.has('missing');\n\n          return touched && !(hasFocus && incomplete)\n              ? nextAfterEvent(cssClasses.specs(inCssError({ mark, when })))\n              : nextArgs();\n        },\n    );\n  };\n}\n","import { HierarchyContext } from '@wesib/generic';\nimport { InputToForm } from '@wesib/generic/input';\nimport { Component, ComponentContext, ElementRender, Render } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InValidation } from 'input-aspects';\nimport { ApiResponse } from '../api';\nimport { Conduit__NS } from '../conduit.ns';\nimport { ApiErrorGenerator } from './api-error-generator';\n\nconst noApiErrors: ApiResponse.Errors = {};\n\n@Component(['api-errors', Conduit__NS])\nexport class ApiErrorsComponent {\n\n  private _errors: ApiResponse.Errors = noApiErrors;\n\n  constructor(private readonly _context: ComponentContext) {\n    _context.get(HierarchyContext)\n        .get(InputToForm)\n        .thru_(\n            ({ control }): NextCall<OnEventCallChain, [ApiResponse.Errors]> => {\n              if (!control) {\n                return nextArgs(noApiErrors);\n              }\n              return nextAfterEvent(\n                  control.aspect(InValidation).read.keep.thru_(\n                      validity => validity.messages('api').reduce(\n                          (prev, message) => ({\n                            ...prev,\n                            ...message.api,\n                          }),\n                          noApiErrors,\n                      ),\n                  ),\n              );\n            },\n        )(errors => this.errors = errors);\n  }\n\n  get errors(): ApiResponse.Errors {\n    return this._errors;\n  }\n\n  set errors(value: ApiResponse.Errors) {\n\n    const old = this._errors;\n\n    if (old === value) {\n      return;\n    }\n    this._errors = value;\n    this._context.updateState('errors', value, old);\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const { contentRoot } = this._context;\n    let list: Element | undefined;\n\n    return () => {\n      if (list) {\n        list.remove();\n        list = undefined;\n      }\n      list = this._context.get(ApiErrorGenerator)(this.errors);\n      if (list) {\n        contentRoot.append(list);\n      }\n    };\n  }\n\n}\n","import { ConvertInput } from '@wesib/generic/input';\nimport { Attributes, Component, trackAttribute } from '@wesib/wesib';\nimport { AfterEvent } from 'fun-events';\nimport { InCssClasses, inCssInfo, InStyledElement } from 'input-aspects';\nimport { Conduit__NS } from '../conduit.ns';\nimport { bootstrapCssError } from './bootstrap-css-error';\n\n@Component(\n    ['in-error', Conduit__NS],\n    Attributes('code'),\n    ConvertInput(\n        ({ control: { control }, aspects, context }) => {\n\n          const codes: AfterEvent<[string[]]> = trackAttribute(context, 'code')\n              .read.keep.thru_(\n                  code => code ? code.trim().split(/\\s+/) : [],\n              );\n\n          return codes.keep.thru(\n              when => control.convert(\n                  InStyledElement.to(context.element),\n                  aspects,\n              ).setup(\n                  InCssClasses,\n                  cssClasses => {\n                    cssClasses.add(inCssInfo());\n                    cssClasses.add(bootstrapCssError({ when }));\n                  },\n              ),\n          );\n        },\n    ),\n)\nexport class InErrorComponent {}\n","import { Feature } from '@wesib/wesib';\nimport { ApiErrorsComponent } from './api-errors.component';\nimport { InErrorComponent } from './in-error.component';\n\n@Feature({\n  needs: [\n    ApiErrorsComponent,\n    InErrorComponent,\n  ],\n})\nexport class ConduitInputSupport {\n}\n","import { FillInputForm, FillInputFormDef } from '@wesib/generic/input';\nimport { Class, Component, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { InCssClasses, inCssInfo, inFormElement, inGroup, InGroup, InMode, inModeByValidity } from 'input-aspects';\nimport { HandleConduitSubmitButton, HandleConduitSubmitButtonDef } from './handle-conduit-submit-button.decorator';\n\nexport function FillConduitForm<Model extends object = any, T extends ComponentClass = Class>(\n    {\n        emptyModel = {} as Model,\n        form = {\n          makeForm({ node, aspects }) {\n\n            const group: InGroup<Model> = inGroup<Model>(emptyModel)\n                .setup(InCssClasses, classes => classes.add(inCssInfo()))\n                .setup(InMode, mode => mode.derive(inModeByValidity()));\n            const form = inFormElement(node.element, { form: group, aspects })\n                .setup(InCssClasses, classes => classes.add(group.aspect(InCssClasses)));\n\n            return [group, form];\n          },\n        },\n        button,\n    }: FillConduitFormDef<Model> = {},\n): ComponentDecorator<T> {\n  return Component(\n      FillInputForm(form),\n      HandleConduitSubmitButton(button),\n  );\n}\n\nexport interface FillConduitFormDef<Model extends object> {\n  readonly emptyModel?: Model;\n  readonly form?: FillInputFormDef;\n  readonly button?: HandleConduitSubmitButtonDef;\n}\n","import { ComponentNode, ComponentTreeSupport, ElementPickMode, HierarchyContext } from '@wesib/generic';\nimport { DefaultInAspects, InputToForm } from '@wesib/generic/input';\nimport { Class, Component, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { afterAll } from 'fun-events';\nimport { inSubmitButton } from 'input-aspects';\n\nexport function HandleConduitSubmitButton<T extends ComponentClass = Class>(\n    {\n      select = 'button',\n      pick = { deep: true, all: true },\n    }: HandleConduitSubmitButtonDef = {},\n): ComponentDecorator<T> {\n  return Component({\n    feature: {\n      needs: ComponentTreeSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n        const hierarchy = context.get(HierarchyContext);\n\n        context.whenOn(supply => {\n          afterAll({\n            form: hierarchy.get(InputToForm),\n            button: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).tillOff(supply).consume(\n              ({\n                form: [{ control: form }],\n                button: [button],\n                aspects: [aspects],\n              }) => form && button && inSubmitButton(button.element, { form, aspects }),\n          );\n        });\n      });\n    },\n  });\n}\n\nexport interface HandleConduitSubmitButtonDef {\n  readonly select?: string;\n  readonly pick?: ElementPickMode;\n}\n","import { HierarchyContext } from '@wesib/generic';\nimport { InputToForm, UseInputElement, UseInputElementDef } from '@wesib/generic/input';\nimport { Class, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { afterSupplied, EventSupply, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InCssClasses, inCssInfo, InMode } from 'input-aspects';\nimport { bootstrapCssError } from './bootstrap-css-error';\n\nexport function UseConduitInput<T extends ComponentClass = Class>(\n    def: UseInputElementDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return UseInputElement({\n    ...def,\n    makeControl(opts) {\n      return opts.context.get(HierarchyContext).get(InputToForm).keep.thru_(\n          ({ form }) => {\n\n            const ctrl = def.makeControl(opts);\n\n            if (!ctrl) {\n              return nextArgs();\n            }\n            if (ctrl instanceof InControl) {\n              return augmentControl(ctrl);\n            }\n\n            return nextAfterEvent(afterSupplied(ctrl).keep.thru_(\n                (control, supply): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n                  if (!control) {\n                    return nextArgs();\n                  }\n\n                  augmentControl(control);\n\n                  return supply ? nextArgs(control, supply) : nextArgs(control);\n                },\n            ));\n\n            function augmentControl(control: InControl<any>): InControl<any> {\n              if (form) {\n                control.aspect(InMode).derive(form.aspect(InMode));\n              }\n\n              const classes = control.aspect(InCssClasses);\n\n              classes.add(inCssInfo());\n              classes.add(bootstrapCssError());\n\n              return control;\n            }\n          },\n      );\n    },\n  });\n}\n","import { IncludePage } from '@wesib/generic';\nimport { BootstrapWindow, Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['main', Conduit__NS],\n    IncludePage({\n      onResponse({ context, response, range }) {\n        if (!response.ok) {\n          range.deleteContents();\n\n          const { document } = context.get(BootstrapWindow);\n          const loader = document.createElement('conduit-loader');\n\n          if (response.ok != null) {\n            loader.setAttribute('load-error', `Error. ${String(response.error)}`);\n          }\n\n          range.insertNode(loader);\n        }\n      },\n    }),\n)\nexport class MainComponent {}\n","import { ActivateNavLink, HandleNavLinks } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['navbar', Conduit__NS],\n    HandleNavLinks(),\n    ActivateNavLink({ active: 'active' }),\n)\nexport class NavbarComponent {\n}\n","import { Component, ComponentContext, DefaultNamespaceAliaser, ElementRender, Render } from '@wesib/wesib';\nimport { css__naming, QualifiedName } from 'namespace-aliaser';\nimport { Authentication, AuthService } from '../auth';\nimport { Conduit__NS } from '../conduit.ns';\nimport { MainComponent } from './main.component';\nimport { NavbarComponent } from './navbar.component';\n\nconst authenticatedClassQName: QualifiedName = ['authenticated', Conduit__NS];\nconst notAuthenticatedClassQName: QualifiedName = ['not-authenticated', Conduit__NS];\n\n@Component({\n  name: ['container', Conduit__NS],\n  feature: {\n    needs: [MainComponent, NavbarComponent],\n  },\n})\nexport class ContainerComponent {\n\n  private _auth: Authentication = {};\n\n  constructor(private readonly _context: ComponentContext) {\n    _context.whenOn(connectSupply => {\n      _context.get(AuthService).authentication.tillOff(connectSupply)(auth => {\n        this.auth = auth;\n      });\n    });\n  }\n\n  get auth(): Authentication {\n    return this._auth;\n  }\n\n  set auth(value: Authentication) {\n\n    const prev = this._auth;\n\n    this._auth = value;\n    this._context.updateState('auth', value, prev);\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const nsAlis = this._context.get(DefaultNamespaceAliaser);\n    const authenticatedClass = css__naming.name(authenticatedClassQName, nsAlis);\n    const notAuthenticatedClass = css__naming.name(notAuthenticatedClassQName, nsAlis);\n    const { classList }: Element = this._context.element;\n\n    return () => {\n      if (this.auth.token) {\n        classList.remove(notAuthenticatedClass);\n        classList.add(authenticatedClass);\n      } else {\n        classList.remove(authenticatedClass);\n        classList.add(notAuthenticatedClass);\n      }\n    };\n  }\n\n}\n","import { HandleNavLinks } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['footer', Conduit__NS],\n    HandleNavLinks(),\n)\nexport class FooterComponent {\n}\n","import { Feature } from '@wesib/wesib';\nimport { ContainerComponent } from './container.component';\nimport { FooterComponent } from './footer.component';\n\n@Feature({\n  needs: [\n    ContainerComponent,\n    FooterComponent,\n  ],\n})\nexport class ConduitLayoutSupport {\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedSupport } from './articles';\nimport { AuthSupport } from './auth';\nimport { ConduitGenericSupport } from './generic';\nimport { ConduitInputSupport } from './input';\nimport { ConduitLayoutSupport } from './layout';\n\n@Feature({\n  needs: [\n    AuthSupport,\n    ConduitGenericSupport,\n    ConduitInputSupport,\n    ConduitLayoutSupport,\n    FeedSupport,\n  ],\n})\nexport class ConduitFeature {\n}\n","const htmlUnsafe: { [key: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n};\n\nfunction replaceHtmlUnsafe(tag: string): string {\n  return htmlUnsafe[tag] || tag;\n}\n\nexport function escapeHtml(str: string | null | undefined): string {\n  return str ? str.replace(/[&<>]/g, replaceHtmlUnsafe) : '';\n}\n","import { bootstrapComponents } from '@wesib/wesib';\nimport { ConduitFeature } from './conduit.feature';\n\nexport * from './api';\nexport * from './articles';\nexport * from './auth';\nexport * from './conduit.feature';\nexport * from './conduit.ns';\nexport * from './generic';\nexport * from './input';\nexport * from './users';\nexport * from './util';\n\nexport const conduitContext = bootstrapComponents(ConduitFeature);\n"],"names":["articleContent","article","Promise","resolve","reject","marked","body","error","html","feedRequestKeys","feedRequestsEqual","first","second","every","key","feedRequestSearchParams","request","params","URLSearchParams","itsEach","thruIt","nextSkip","value","String","set","FeedService","SingleContextKey","ApiRootURL","SingleContextUpKey","byDefault","URL","AuthService__key","ApiFetch","FnContextKey","bootstrapDefault","context","httpFetch","get","HttpFetch","apiRootURL","path","init","auth","onResponse","thru_","baseURL","url","Request","href","mode","headers","buildApiRequest","nextArgs","nextOnEvent","authentication","keep","token","failure","ok","errors","api","authenticateApiRequest","requestOrFailure","response","onAsync","parseApiResponse","responseOrFailure","json","respondAs","responseOfFailure","http","statusText","status","handleApiResponse","all","catch","apiFetch","method","apiRequest","JSON","stringify","Accept","Content-Type","apiSubmit","onFetch","once","InSubmitError","submit","whenOff","reason","cancel","feedSources","/personal-feed","/global-feed","FeedService$","[object Object]","this","_apiFetch","feed","asis","slug","encodeURIComponent","_tags","onTags","onEventBy","receiver","onTagsLoad","nextArg","console","log","tags","trackValueBy","afterSupplied","read","tagList","FeedSupport","Feature","setup","provide","a","as","AuthService","ContextKey__symbol","AuthService$","_context","super","window","BootstrapWindow","storage","localStorage","_auth","trackValue","toAuthToken","getItem","on","setItem","removeItem","user","thru","email","undefined","Authorization","afterEventBy","supply","eventSupply","needs","ctx","event","receive","valuesProvider","fetchCurrentUser","DomEventDispatcher","newValue","it","_request","AuthSupport","Conduit__NS","NamespaceDef","LoaderComponent","document","range","createRange","selectNodeContents","contentRoot","deleteContents","loadError","insertNode","createTextNode","__decorate","Attribute","Render","Component","PagerEvent","CustomEvent","PagerComponent","totalPages","parseInt","contentRange","visiblePages","Math","max","currentPage","ul","createElement","className","startPage","endPage","appendChild","pageItem","page","text","enabled","active","li","link","setAttribute","capture","instead","preventDefault","dispatchEvent","cancelable","bubbles","detail","classList","add","innerHTML","ConduitGenericSupport","ApiErrorGenerator","list","AIterable","from","overEntries","forEach","messages","message","innerText","bootstrapCssError","mark","when","control","cssClasses","aspect","InCssClasses","afterAll","InStatus","validity","InValidation","touched","hasFocus","incomplete","has","nextAfterEvent","specs","inCssError","noApiErrors","ApiErrorsComponent","HierarchyContext","InputToForm","reduce","prev","_errors","old","updateState","remove","append","InErrorComponent","Attributes","ConvertInput","aspects","trackAttribute","code","trim","split","convert","InStyledElement","to","element","inCssInfo","ConduitInputSupport","FillConduitForm","emptyModel","form","node","group","inGroup","classes","InMode","derive","inModeByValidity","inFormElement","button","FillInputForm","select","pick","deep","feature","ComponentTreeSupport","defContext","whenComponent","componentNode","ComponentNode","hierarchy","whenOn","DefaultInAspects","tillOff","consume","inSubmitButton","HandleConduitSubmitButton","UseConduitInput","def","UseInputElement","makeControl","opts","ctrl","InControl","augmentControl","MainComponent","IncludePage","loader","NavbarComponent","HandleNavLinks","ActivateNavLink","authenticatedClassQName","notAuthenticatedClassQName","ContainerComponent","connectSupply","nsAlis","DefaultNamespaceAliaser","authenticatedClass","css__naming","name","notAuthenticatedClass","FooterComponent","ConduitLayoutSupport","ConduitFeature","htmlUnsafe","&","<",">","replaceHtmlUnsafe","tag","escapeHtml","str","replace","conduitContext","bootstrapComponents"],"mappings":"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"}