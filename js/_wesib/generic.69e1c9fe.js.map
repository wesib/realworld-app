{"version":3,"file":"generic.69e1c9fe.js","sources":["../../../node_modules/@wesib/generic/src/fetch/fetch-agent-key.impl.ts","../../../node_modules/@wesib/generic/src/fetch/http-fetch-agent.ts","../../../node_modules/@wesib/generic/src/fetch/http-fetch.impl.ts","../../../node_modules/@wesib/generic/src/fetch/http-fetch.ts","../../../node_modules/@wesib/generic/src/hierarchy/hierarchy-updates.impl.ts","../../../node_modules/@wesib/generic/src/hierarchy/hierarchy-context.ts","../../../node_modules/@wesib/generic/src/hierarchy/hierarchy-registry.impl.ts","../../../node_modules/@wesib/generic/src/tree/element-node.ts","../../../node_modules/@wesib/generic/src/tree/element-node-list.ts","../../../node_modules/@wesib/generic/src/tree/element-node-list.impl.ts","../../../node_modules/@wesib/generic/src/tree/node-attributes.impl.ts","../../../node_modules/@wesib/generic/src/tree/node-properties.impl.ts","../../../node_modules/@wesib/generic/src/tree/element-node.impl.ts","../../../node_modules/@wesib/generic/src/tree/component-tree-support.feature.ts","../../../node_modules/@wesib/generic/src/navigation/navigation.ts","../../../node_modules/@wesib/generic/src/navigation/page-param.ts","../../../node_modules/@wesib/generic/src/navigation/page-param-context.ts","../../../node_modules/@wesib/generic/src/navigation/nav-history.impl.ts","../../../node_modules/@wesib/generic/src/navigation/navigation-agent.ts","../../../node_modules/@wesib/generic/src/navigation/navigation.event.ts","../../../node_modules/@wesib/generic/src/navigation/navigation.impl.ts","../../../node_modules/@wesib/generic/src/navigation/navigation-support.feature.ts","../../../node_modules/@wesib/generic/src/navigation/activate-nav-link.decorator.ts","../../../node_modules/@wesib/generic/src/navigation/handle-nav-links.decorator.ts","../../../node_modules/@wesib/generic/src/navigation/hash-url/hash-url.ts","../../../node_modules/@wesib/generic/src/navigation/hash-url/page-hash-url-param.impl.ts","../../../node_modules/@wesib/generic/src/navigation/hash-url/page-hash-url-param.ts","../../../node_modules/@wesib/generic/src/navigation/hash-url/page-hash-url-support.feature.ts","../../../node_modules/@wesib/generic/src/util/import-node.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/caching-page-loader.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-load-requests.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-load-agent.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-load-url-modifier.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-loader.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-load-param.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-cache-buster.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-style-agent.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-title-agent.impl.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/page-load-support.feature.ts","../../../node_modules/@wesib/generic/src/navigation/page-load/include-page.decorator.ts","../../../node_modules/@wesib/generic/src/input/default-in-aspects.ts","../../../node_modules/@wesib/generic/src/input/input-from-control.ts","../../../node_modules/@wesib/generic/src/input/convert-input.decorator.ts","../../../node_modules/@wesib/generic/src/input/input-to-form.ts","../../../node_modules/@wesib/generic/src/input/fill-input-form.decorator.ts","../../../node_modules/@wesib/generic/src/input/on-submit.decorator.ts","../../../node_modules/@wesib/generic/src/input/set-input-name.decorator.ts","../../../node_modules/@wesib/generic/src/input/use-input-element.decorator.ts"],"sourcesContent":["import { nextArg } from 'call-thru';\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, EventSender, nextAfterEvent, OnEvent, onSupplied } from 'fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<Res>,\n    request: Request,\n) => EventSender<Res>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n) => OnEvent<Res>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<Res extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>\n    implements ContextUpRef<CombinedFetchAgent<Res>, FetchAgent<Res>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.thru(\n            (...agents) => {\n              if (agents.length) {\n                return nextArg(combineFetchAgents(agents));\n              }\n\n              const defaultProvider = (): AfterEvent<[CombinedFetchAgent<Res>]> => afterThe(defaultFetchAgent);\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          CombinedFetchAgent<Res>,\n          EventKeeper<FetchAgent<Res>[]> | FetchAgent<Res>,\n          AfterEvent<FetchAgent<Res>[]>>,\n  ): CombinedFetchAgent<Res> {\n\n    let delegated!: CombinedFetchAgent<Res>;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(agent => delegated = agent);\n\n    return (next, request) => delegated(next, request);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<Res extends any[]>(\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n): OnEvent<Res> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<Res extends any[]>(agents: FetchAgent<Res>[]): CombinedFetchAgent<Res> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<Res> = (agentIdx, agentRequest) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values/updatable';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter [[HttpFetch]] processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by [[HttpFetch]].\n */\nexport type HttpFetchAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * [[HttpFetch]] call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under [[HttpFetchAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of response object(s) receivers. It is returned as a result of [[HttpFetch]] call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an [[HttpFetchAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { EventEmitter, EventSupply, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: EventSupply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new (window as any).AbortController();\n        const { signal } = abortController;\n\n        supply = eventSupply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal).on('abort').once(() => abortController.abort());\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { OnEvent } from 'fun-events';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of [[HttpFetch]] is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input  The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init  Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an [[HttpFetch]] instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import {\n  BootstrapContext,\n  BootstrapRoot,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n} from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\n\n/**\n * @internal\n */\nexport type HierarchyRoot = ValueTracker<ComponentContext | undefined>;\n\n/**\n * @internal\n */\nexport const HierarchyRoot = (/*#__PURE__*/ new SingleContextKey<HierarchyRoot>(\n    'hierarchy-root',\n    {\n      byDefault: bsContext => {\n\n        const root: Element = bsContext.get(BootstrapRoot);\n\n        new DomEventDispatcher(root).on<ComponentEvent>('wesib:component')(\n            ({ context }: ComponentEvent) => context.get(HierarchyUpdates).issue(),\n        );\n\n        return trackValue();\n      },\n    },\n));\n\nconst HierarchyUpdates__key = (/*#__PURE__*/ new SingleContextKey<HierarchyUpdates>(\n    'hierarchy-updates',\n    {\n      byDefault: context => new HierarchyUpdates(context.get(ComponentContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class HierarchyUpdates {\n\n  static get [ContextKey__symbol](): ContextKey<HierarchyUpdates> {\n    return HierarchyUpdates__key;\n  }\n\n  readonly on: OnEvent<[ComponentContext]>;\n  readonly send: (this: void) => void;\n  readonly issue: () => void;\n\n  constructor(context: ComponentContext) {\n\n    const updates = new EventEmitter<[ComponentContext]>();\n    const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n\n    this.on = updates.on;\n    this.send = () => updates.send(context);\n    this.issue = () => {\n\n      const parent = findParentContext(context);\n\n      if (parent) {\n        parent[0].get(HierarchyUpdates).send();\n      } else {\n        hierarchyRoot.it = context;\n      }\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport function findParentContext(of: ComponentContext): [ComponentContext, boolean] | undefined {\n\n  const root = of.get(BootstrapContext).get(BootstrapRoot);\n  let element: Node = of.element;\n  let immediate = true;\n\n  if (element === root) {\n    return;\n  }\n  for (;;) {\n\n    const parent = element.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    const ctx: ComponentContext = (parent as any)[ComponentContext__symbol];\n\n    if (ctx) {\n      return [ctx, immediate];\n    }\n    if (parent === root) {\n      return;\n    }\n\n    immediate = false;\n    element = parent;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext } from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { AfterEvent, afterEventBy, EventKeeper, eventSupply, trackValue } from 'fun-events';\nimport { newHierarchyRegistry } from './hierarchy-registry.impl';\nimport { findParentContext, HierarchyRoot, HierarchyUpdates } from './hierarchy-updates.impl';\n\n/**\n * @internal\n */\nconst HierarchyContext__key = (/*#__PURE__*/ new SingleContextKey<HierarchyContext>(\n    'hierarchy-context',\n    {\n      byDefault: context => newHierarchyContext(context.get(ComponentContext)),\n    },\n));\n\n/**\n * Component's hierarchy context.\n *\n * Passes provided values to hierarchy contexts of nested components.\n *\n * Available as component context value.\n *\n * @typeparam T  A type of component.\n */\nexport abstract class HierarchyContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of component context value containing its hierarchy context instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<HierarchyContext> {\n    return HierarchyContext__key;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * An `AfterEvent` keeper of enclosing component's hierarchy context.\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   */\n  abstract readonly up: AfterEvent<[HierarchyContext?]>;\n\n  /**\n   * Provides hierarchy context value.\n   *\n   * The provided value will be available in context itself, as well as in all nested hierarchy contexts.\n   *\n   * Note that the provided value key has to `ContextUpKey`.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src | EventKeeper<Src[]>, Seed>,\n  ): () => void;\n\n}\n\n/**\n * @internal\n */\nfunction newHierarchyContext<T extends object>(context: ComponentContext<T>): HierarchyContext<T> {\n\n  const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n  const up = afterEventBy<[HierarchyContext?]>(\n      receiver => {\n\n        const parentHierarchy = trackValue<HierarchyContext>();\n        const rootSupply = eventSupply().needs(receiver.supply);\n        const parentSupply = eventSupply().needs(receiver.supply);\n        const updateParent = (): void => {\n\n          const parent = findParentContext(context);\n\n          if (parent) {\n\n            const [parentCtx, immediate] = parent;\n\n            parentHierarchy.it = parentCtx.get(HierarchyContext);\n            rootSupply.off();\n            if (immediate) {\n              parentSupply.off();\n            }\n          } else {\n            parentHierarchy.it = undefined;\n          }\n        };\n\n        hierarchyRoot.read({\n          supply: rootSupply,\n          receive: () => context.connected && updateParent(),\n        });\n        parentHierarchy.read.consume(\n            newParent => newParent && newParent.context.get(HierarchyUpdates).on(updateParent),\n        ).needs(parentSupply);\n        parentHierarchy.read(receiver);\n        context.whenOn({\n          supply: receiver.supply,\n          receive: (_, onSupply) => {\n            updateParent();\n            onSupply.whenOff(\n                () => {\n                  Promise.resolve().then(\n                      () => context.connected || (parentHierarchy.it = undefined),\n                  );\n                },\n            );\n          },\n        });\n      },\n  ).share();\n  const registry = newHierarchyRegistry<T>(up);\n  const values = registry.newValues();\n\n  class HierarchyCtx extends HierarchyContext<T> {\n\n    readonly get = values.get;\n\n    get context(): ComponentContext<T> {\n      return context;\n    }\n\n    get up(): AfterEvent<[HierarchyContext?]> {\n      return up;\n    }\n\n    provide<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src | EventKeeper<Src[]>, Seed>,\n    ): () => void {\n      return registry.provide(spec);\n    }\n\n  }\n\n  return new HierarchyCtx();\n}\n","import { nextArgs } from 'call-thru';\nimport { ContextRegistry } from 'context-values';\nimport { AfterEvent, nextAfterEvent } from 'fun-events';\nimport { HierarchyContext } from './hierarchy-context';\n\n/**\n * @internal\n */\nexport function newHierarchyRegistry<T extends object>(\n    up: AfterEvent<[HierarchyContext?]>,\n): ContextRegistry<HierarchyContext<T>> {\n  return new ContextRegistry(\n      key => up.keep.thru(\n          upper => upper ? nextAfterEvent(upper.get(key as any)) : nextArgs(),\n      ) as any,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested components.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType  Nested component type with custom element name.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode  A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * @param name  Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null, string>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @param key  Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<V>(key: PropertyKey): ValueTracker<V>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>('component-node')\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { AIterable, ArrayLikeIterable } from 'a-iterable';\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n */\nexport abstract class ElementNodeList<N extends ElementNode = ElementNode>\n    extends AIterable<N>\n    implements EventSender<[N[], N[]]>, EventKeeper<[ElementNodeList<N>]> {\n\n  /**\n   * An `OnEvent` sender of list changes. Sends arrays of added and removed nodes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[N[], N[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[N[], N[]]> {\n    return this.onUpdate;\n  }\n\n  /**\n   * An `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[ElementNodeList<N>]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[ElementNodeList<N>]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of node list changes.\n   *\n   * Sends an iterables of added and removed nodes. Sends current nodes immediately upon receiver registration.\n   */\n  abstract readonly track: AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>;\n\n  /**\n   * An `AfterEvent` keeper of the first node in this list.\n   */\n  abstract readonly first: AfterEvent<[N?]>;\n\n}\n","import {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport { AIterable, ArrayLikeIterable, filterIt, itsEach, itsFirst, itsIterator, mapIt, overArray } from 'a-iterable';\nimport { isPresent, nextArg, nextArgs } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterSupplied, EventEmitter, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { html__naming } from 'namespace-aliaser';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList as ElementNodeList_ } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<N extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => N | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList_<N> {\n\n  const updates = new EventEmitter<[N[], N[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let iterable: Iterable<N> | undefined;\n  let selector: string | undefined;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      iterable = undefined;\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = Array.from(\n                filterIt<N | undefined, N>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    });\n  }\n\n  const observer = bsContext.get(ElementObserver)(update);\n  let nodeList: ElementNodeList;\n\n  const onUpdate = onEventBy<[N[], N[]]>(receiver => {\n\n    const firstReceiver = !updates.size;\n    const supply = updates.on(receiver);\n\n    if (firstReceiver) {\n      refresh();\n      observer.observe(root, init);\n    }\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      if (!updates.size) {\n        observer.disconnect();\n      }\n    }).needs(supply);\n  });\n  const read = afterEventBy<[ElementNodeList]>(onUpdate.thru(() => nodeList), () => [nodeList]);\n  const onTrackUpdate: OnEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]> = onUpdate.thru(\n      (added, removed) => nextArgs(AIterable.of(added), AIterable.of(removed)),\n  );\n  const track = afterEventBy<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>(receiver => {\n\n    const initialEmitter = new EventEmitter<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>();\n\n    initialEmitter.on(receiver);\n    initialEmitter.send(nodeList, AIterable.of([]));\n\n    onTrackUpdate(receiver);\n  });\n  const first: AfterEvent<[N?]> = afterSupplied(read).keep.thru(\n      list => nextArg(itsFirst(list)),\n  );\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as N;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  class ElementNodeList extends ElementNodeList_<N> {\n\n    get onUpdate(): OnEvent<[N[], N[]]> {\n      return onUpdate;\n    }\n\n    get read(): AfterEvent<[ElementNodeList]> {\n      return read;\n    }\n\n    get track(): AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]> {\n      return track;\n    }\n\n    get first(): AfterEvent<[N?]> {\n      return first;\n    }\n\n    [Symbol.iterator](): Iterator<N> {\n      return itsIterator(iterable || (iterable = filterIt<N | undefined, N>(\n          mapIt(\n              elements(),\n              element => nodeOf(element),\n          ),\n          isPresent,\n      )));\n    }\n\n  }\n\n  return nodeList = new ElementNodeList();\n\n  function elements(): Set<Element> {\n    return updates.size ? cache : refresh();\n  }\n\n  function refresh(): Set<Element> {\n    iterable = undefined;\n    return cache = select();\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n    return new Set(\n        filterIt(\n            overArray(root.children),\n            item => item.matches(sel),\n        ),\n    );\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: N[] = [];\n    const removed: N[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overArray(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overArray(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n  ValueTracker,\n} from 'fun-events';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer: typeof MutationObserver = (this._bs.get(BootstrapWindow) as any).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string, string | null]>): EventSupply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: eventSupply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: Array.from(self._emitters.keys()),\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string, string | null]> {\n\n    const emitter = new EventEmitter<[string, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null, string> {\n\n  private readonly _updates = new EventEmitter<[string, string | null]>();\n  readonly on: OnEvent<[string, string | null]>;\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n\n    let observeSupply = noEventSupply();\n\n    this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            _name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._updates);\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    this._observer.element.setAttribute(this._name, value as string);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null, string> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\nimport {\n  EventEmitter,\n  EventSupply,\n  eventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  ValueTracker,\n} from 'fun-events';\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n  private readonly _supply = eventSupply();\n\n  constructor(\n      private readonly _element: any,\n      private readonly _key: PropertyKey,\n  ) {\n    super();\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._updates.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  done(reason?: any): this {\n    this._supply.off(reason);\n    return this;\n  }\n\n  bind(context: ComponentContext): void {\n\n    const supply = eventSupplyOf(this);\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    supply.needs(\n        propertyState.onUpdate({\n          supply: eventSupply().whenOff(reason => this._updates.done(reason)),\n          receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n        }).needs(supply),\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ValueTracker } from 'fun-events';\nimport { ComponentNode, ComponentTreeNode, ElementPickMode, ElementNode as ElementNode_ } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\nclass ElementNode implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    (element as any)[ElementNode__symbol] = this;\n\n    const context = (element as any)[ComponentContext__symbol] as ComponentContext<any> | undefined;\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return (this.element as any)[ComponentContext__symbol];\n  }\n\n  get parent(): ElementNode_ | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null, string> {\n    return this._attrs.get(name);\n  }\n\n  property<V>(key: PropertyKey): ValueTracker<V> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(bsContext: BootstrapContext, element: Element, optional?: boolean): ElementNode_ {\n\n  const existing: ElementNode_ = (element as any)[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode_>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext, FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { ComponentNode } from './element-node';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * @internal\n */\nconst ComponentTreeSupport__feature: FeatureDef = {\n  needs: StateSupport,\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentNode,\n      by(context: ComponentContext) {\n        return elementNodeOf(context.get(BootstrapContext), context.element) as ComponentNode;\n      },\n    });\n  },\n};\n\n/**\n * Component tree support feature.\n *\n * Provides a [[ComponentNode]] instance for each component.\n */\nexport class ComponentTreeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ComponentTreeSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { EnterPageEvent, LeavePageEvent, NavigationEvent, StayOnPageEvent } from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>('navigation'));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value when [[NavigationSupport]] feature is enabled.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` registrar of enter page event receivers.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` registrar of leave page event receivers.\n   *\n   * These receivers may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` registrar of stay on page event receivers.\n   *\n   * These receivers are informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` registrar of navigation events receivers.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  get [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` registrar of current page receivers.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta  Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target  Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target  Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url  An URL to replace the\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   * @param ref  A reference to page navigation parameter to apply.\n   * @param input  Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     * @param ref  A reference to page navigation parameter to apply.\n     * @param input  Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target  Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target  Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target  Either navigation target or URL to pretend navigation to.\n     * @param callback A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target  Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to [[Navigation.open]] and [[Navigation.replace]] methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to [[LeavePageEvent]]). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeparam T  Parameter value type.\n * @typeparam I  Parameter input type.\n */\nexport abstract class PageParam<T, I> implements PageParam.Ref<T, I> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page  A page to assign navigation parameter to.\n   * @param input  Parameter input used to construct its initial value.\n   * @param context  Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: I, context: PageParamContext): PageParam.Handle<T, I>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page  A page to assign navigation parameter to.\n   * @param _context  Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, I> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface Ref<T, I> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, I>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface WithDefaults<T, I> extends PageParam<T, I> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, I>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     */\n    export interface Ref<T, I> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, I>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface Handle<T, I> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input  Parameter input to use when updating its value.\n     */\n    put(input: I): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before [[LeavePageEvent]] is fired for each parameter handle of current page.\n     *\n     * @param to  A page to transfer parameter to.\n     * @param when  When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): Handle<T, I> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page  Entered page.\n     * @param when  When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at  The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValues } from 'context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object' ? { data: state } : state[NAV_DATA_KEY];\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      get data() {\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, I>(ref: PageParam.Ref<T, I>, input: I): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, I> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, I>(param: PageParam<T, I>, handle: PageParam.Handle<T, I>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { nextArg } from 'call-thru';\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n * @param when  When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from  The page to leave.\n * @param to  Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => {\n\n          const { document } = opts.context.get(BootstrapWindow);\n\n          return opts.seed.keep.thru(\n              (...agents) => {\n                if (agents.length) {\n                  return nextArg(combinedAgent);\n                }\n\n                const defaultProvider = (): AfterEvent<[NavigationAgent.Combined]> => afterThe(defaultNavigationAgent);\n\n                return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              },\n          );\n        },\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): NavigationAgent.Combined {\n\n    let delegated: NavigationAgent.Combined;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(agent => delegated = agent);\n\n    return (next, when, from, to) => delegated(next, when, from, to);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under [[NavigationAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n   * one. Not calling this function effectively prevents navigation.\n   * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n   * @param when  When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from  The page to leave.\n   * @param to  Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an [[NavigationAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","import { BootstrapContext, BootstrapWindow, mergeFunctions } from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { AfterEvent, onAny, OnEvent, trackValue } from 'fun-events';\nimport { DomEventDispatcher, OnDomEvent } from 'fun-events/dom';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { Navigation as Navigation_ } from './navigation';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\nexport function createNavigation(context: BootstrapContext): Navigation_ {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n  const onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n  const onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n  const onEvent = onAny<[NavigationEvent]>(onEnter, onLeave, onStay);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  const readPage: AfterEvent<[Page]> = nav.read.keep.thru(entry => entry.page);\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation_.URLTarget]: Navigation_.URLTarget[K] };\n\n  class Navigation extends Navigation_ {\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    get onEnter(): OnDomEvent<EnterPageEvent> {\n      return onEnter;\n    }\n\n    get onLeave(): OnDomEvent<LeavePageEvent> {\n      return onLeave;\n    }\n\n    get onStay(): OnDomEvent<StayOnPageEvent> {\n      return onStay;\n    }\n\n    get on(): OnEvent<[NavigationEvent]> {\n      return onEvent;\n    }\n\n    get read(): AfterEvent<[Page]> {\n      return readPage;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation_.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation_.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation_.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation();\n\n  function withParam(applyParams: (page: Page) => void): Navigation_.Parameterized {\n    return {\n      with<TT, II>(ref: PageParam.Ref<TT, II>, input: II): Navigation_.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation_.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation_.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation_.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation_.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation_.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation_.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation_.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { createNavigation } from './navigation.impl';\n\n/**\n * @internal\n */\nconst NavigationSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: Navigation, by: createNavigation });\n  },\n};\n\n/**\n * Browser navigation support feature.\n *\n * Makes [[Navigation]] available in bootstrap context.\n */\nexport class NavigationSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return NavigationSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  DefaultRenderScheduler,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { nextArgs, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  eventSupply,\n  EventSupply,\n  nextAfterEvent,\n} from 'fun-events';\nimport { css__naming, QualifiedName } from 'namespace-aliaser';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  readonly node?: ElementNode;\n  supply(): EventSupply | undefined;\n}\n\n/**\n * @internal\n */\nconst inactiveNavLink: ActiveNavLink = {\n  supply: noop,\n};\n\n/**\n * Creates component decorator that marks at most one of navigation links inside decorated component active.\n *\n * Enables [[ComponentTreeSupport]], and [[NavigationSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    feature: {\n      needs: [ComponentTreeSupport, NavigationSupport],\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenOn(connectSupply => {\n\n          let active: ActiveNavLink = inactiveNavLink;\n\n          navigation.read.consume(\n              page => componentNode.select(select, pick).read.keep.thru_(\n                  nodes => nextAfterEvent(afterEach(\n                      ...nodes.map(node => weigh({ node, context, page })),\n                  )),\n              ).consume(\n                  (...weights: NavLinkWeight[]) => {\n\n                    const selected = selectActiveNavLink(weights);\n\n                    if (!selected) {\n                      active = inactiveNavLink;\n                    } else if (selected !== active.node) {\n                      active = activate({ node: selected, context, page });\n                    }\n\n                    return active.supply();\n                  },\n              ),\n          ).needs(connectSupply);\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked [[active]].\n *\n * @typeparam T  A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters is used\n   *    as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as `path[?query]`. The weight is calculated by applying steps 1 and 2 to hashes.\n   *\n   * @param node  Navigation link node to weigh.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active  Whether to make target link active (`true`), or inactive (`false`).\n   * @param node  Navigation link node to update activity state of.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLink(weights: NavLinkWeight[]): ElementNode | undefined {\n\n  let maxWeight = 0;\n  let active: ElementNode | undefined;\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = node;\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = afterSupplied(weight).keep.thru_(\n        weight => nextArgs(opts.node, weight),\n    );\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier({\n        supply: eventSupply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier(receiver);\n            }),\n        receive: receiver.receive.bind(receiver),\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const element: Element = node.element;\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument!.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n    if (navLinkSearchParamsWeight(linkURL, pageURL) < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n    return calcNavLinkWeight(navLinkHash2url(linkURL), navLinkHash2url(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkHash2url(url: URL): URL {\n\n  let { hash } = url;\n\n  hash = hash.substring(1); // Remove leading `#` symbol\n  if (hash[0] !== '/') {\n    hash = '/' + hash;\n  }\n\n  return new URL(hash, url);\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((_value, key) => {\n\n    const pageValues = new Set(pageParams.getAll(key));\n\n    if (weight >= 0) {\n      if (linkParams.getAll(key).every(linkValue => pageValues.has(linkValue))) {\n        weight += 1;\n      } else {\n        weight = -1;\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(DefaultRenderScheduler);\n  const { active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const element: Element = node.element;\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node;\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler({ node: element }));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: EventSupply | undefined;\n\n    return {\n      node: opts.node,\n      supply(): EventSupply {\n\n        const supply = lastSupply = eventSupply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ArraySet, Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link @Navigation navigation actions} instead of default ones.\n *\n * Enables [[NavigationSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks(def);\n  const events = new ArraySet(def.event || 'click');\n\n  return Component({\n    feature: {\n      needs: NavigationSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenOn(connectSupply => {\n\n          const navigation = context.get(Navigation);\n\n          events.forEach(eventType => {\n            context.on(eventType)(\n                event => navigation.read.once(\n                    page => handle({\n                      event,\n                      page,\n                      context,\n                      navigation,\n                    }),\n                ),\n            ).needs(connectSupply);\n          });\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeparam T  A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action. It also prevents navigation\n   * if URL didn't change.\n   *\n   * @param event  A click event to handle.\n   * @param page  Current navigation page.\n   * @param navigation  Navigation service to use.\n   * @param context  Component context.\n   */\n  handle?(\n      {\n        event,\n        page,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        page: Page;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n  /**\n   * Extracts hyper-reference of clicked element.\n   *\n   * Extracts hyper-reference from `href` attribute of event target.\n   *\n   * @param event  A click event to handle.\n   *\n   * @returns Extracted hyper-reference, or nothing if it can not be extracted. Event will be ignored in this case.\n   */\n  href?(event: Event): string | undefined | null;\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkHref(event: Event): string | null {\n\n  const target = event.target as Element;\n\n  return target.getAttribute('href');\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    def: HandleNavLinksDef,\n): (\n    opts: {\n      event: Event;\n      page: Page;\n      navigation: Navigation;\n    },\n) => void {\n\n  const getHref = def.href ? def.href.bind(def) : defaultNavLinkHref;\n\n  return ({\n    event,\n    page,\n    navigation,\n  }) => {\n\n    const href = getHref(event);\n\n    if (href == null) {\n      return;\n    }\n\n    const target = event.target as Element;\n    const pageURL = page.url;\n    const url = new URL(href, target.ownerDocument!.baseURI);\n\n    if (url.origin !== pageURL.origin) {\n      return; // External link\n    }\n\n    event.preventDefault();\n    if (pageURL.href !== url.href) {\n      navigation.open(href);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\n/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url  An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url  Base URL.\n * @param hashURL  Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL('#' + hashURL, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","import { Page } from '../page';\nimport { PageParam } from '../page-param';\n\nclass PageHashURLValueParam$ extends PageParam<URL | undefined | null, URL | string | null | undefined> {\n\n  create(\n      page: Page,\n      input: URL | null | undefined,\n  ): PageParam.Handle<URL | null | undefined, URL | string | null | undefined> {\n\n    let hashURL: URL | null | undefined;\n    const handle: PageParam.Handle<URL | null | undefined, URL | string | null | undefined> = {\n      get() {\n        return hashURL;\n      },\n      put(value) {\n        hashURL = typeof value === 'string' ? new URL(value, page.url.origin) : value;\n      },\n    };\n\n    handle.put(input);\n\n    return handle;\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageHashURLValueParam: PageParam<URL | null | undefined, URL | string | null | undefined> = (\n    /*#__PURE__*/ new PageHashURLValueParam$()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { getHashURL } from './hash-url';\nimport { PageHashURLValueParam } from './page-hash-url-param.impl';\n\n/**\n * @internal\n */\nclass PageHashURLParam$ extends PageParam<URL, URL | string | null | undefined> {\n\n  create(page: Page, input: URL | string | null | undefined): PageParam.Handle<URL, URL | string | null | undefined> {\n\n    const handle: PageParam.Handle<URL, URL | string | null | undefined> = {\n      get() {\n        return page.get(PageHashURLValueParam) || getHashURL(page.url);\n      },\n      put(value) {\n        page.put(PageHashURLValueParam, value);\n      },\n    };\n\n    handle.put(input);\n\n    return handle;\n  }\n\n  byDefault(page: Page): PageParam.Handle<URL, URL> {\n    return this.create(page, null);\n  }\n\n}\n\n/**\n * Page parameter representing its {@link getHashURL hash URL}.\n *\n * When {@link Navigation.with set} to another value while navigating, the hash of target URL is updated, unless set to\n * `null` or `undefined`.\n *\n * Requires [[PageHashURLSupport]] for above to function properly.\n */\nexport const PageHashURLParam: PageParam.WithDefaults<URL, URL | string | null | undefined> = (\n    /*#__PURE__*/ new PageHashURLParam$()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { NavigationAgent } from '../navigation-agent';\nimport { NavigationSupport } from '../navigation-support.feature';\nimport { Page } from '../page';\nimport { setHashURL } from './hash-url';\nimport { PageHashURLValueParam } from './page-hash-url-param.impl';\n\nconst PageHashURLSupport__feature: FeatureDef = {\n  needs: NavigationSupport,\n  setup(setup) {\n    setup.provide({ a: NavigationAgent, is: pageHashURLAgent });\n  },\n};\n\n/**\n * {@link PageHashURLParam Page hash URL parameter} support feature.\n *\n * Enables [[NavigationSupport]].\n */\nexport class PageHashURLSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageHashURLSupport__feature;\n  }\n\n}\n\nfunction pageHashURLAgent(\n    next: (this: void, target?: Navigation.Target) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n\n  const hashURL = to.get(PageHashURLValueParam);\n\n  if (hashURL) {\n    next({ url: setHashURL(to.url, hashURL) });\n  } else {\n    next();\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { isElement } from '@wesib/wesib';\nimport { itsEach, overArray } from 'a-iterable';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param before  The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: N, to: N) => void),\n    importContent: (this: void, from: N, to: N) => void = importNodeContent,\n): N {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & N);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from  The node which contents to import.\n * @param to  The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { eventSupply, EventSupply, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: EventSupply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = eventSupply().whenOff(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.whenOff(reason => {\n          trackSupply.off(reason);\n          tracker.done(reason);\n        });\n\n        tracked = {\n          on: tracker.read.thru_(\n              response => response ? nextArgs(response) : nextSkip(),\n          ),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on(receiver).needs(supply).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          });\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import { flatMapIt, itsEach, itsIterator } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n} from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests implements Iterable<PageLoadReq> {\n\n  private readonly _map = new Map<EventSupply, PageLoadReq[]>();\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {}\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    for (const request of this) {\n      if (!request.fragment) {\n        return [];\n      }\n      result.push(request.fragment);\n    }\n\n    return result;\n  }\n\n  [Symbol.iterator](): Iterator<PageLoadReq> {\n    return itsIterator(flatMapIt(this._map.values()));\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = eventSupply();\n    let loadSupply = noEventSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = eventSupply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page)(response => emitter.send(response)).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                error,\n              });\n            }\n          }).needs(loadSupply);\n\n          return supply;\n        }).share();\n\n        itsEach(\n            self,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: eventSupply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, Array.from(list));\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.thru_(\n          response => response.ok\n              ? {\n                ...response,\n                fragment: (\n                    fragment.tag != null\n                    ? response.document.getElementsByTagName(fragment.tag)[0]\n                    : response.document.getElementById(fragment.id)\n                ) || undefined,\n              }\n              : response,\n      )\n      : onLoad;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values/updatable';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under [[PageLoadAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of loaded document.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an [[PageLoadAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url  An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsReduction } from 'a-iterable';\nimport { nextEach } from 'call-thru';\nimport { SingleContextKey } from 'context-values';\nimport { EventNotifier, onAsync, OnEvent, onEventBy } from 'fun-events';\nimport { hthvParse, hthvQuote } from 'http-header-value';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser: DOMParser = new (window as any).DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        onAsync(httpFetch(fetchRequest).thru_(\n            response => Promise.all([response, response.text()]),\n        )).thru_(\n            (...batch: [Response, string][]) => nextEach(batch),\n            ([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error,\n                };\n              }\n            },\n        )(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        itsReduction(\n            fragments,\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as SupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { AfterEvent, afterThe } from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request))\n              .thru_(\n                  response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  },\n              ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { filterIt, itsEach, mapIt, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, overArray(doc.scripts)),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, overArray(response.document.querySelectorAll('script'))),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      },\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: Iterable<HTMLScriptElement>,\n): Iterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterIt(\n          scripts,\n          script => !!script.src,\n      ),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach, itsFirst, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      },\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { NavigationSupport } from '../navigation-support.feature';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  needs: NavigationSupport,\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  BootstrapWindow,\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultRenderScheduler,\n} from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes [[PageLoadParam]] navigation parameter.\n *\n * Enables [[NavigationSupport]] and [[PageLoadSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n  const contentKey = def.contentKey ? def.contentKey.bind(def) : defaultPageContentKey;\n\n  return Component({\n    feature: {\n      needs: PageLoadSupport,\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(DefaultRenderScheduler)();\n        const navigation = context.get(Navigation);\n        let lastPageURL: string | undefined = contentKey(navigation.page);\n        const detectFragment = (): PageFragmentRequest => {\n\n          const { fragment } = def;\n\n          if (fragment) {\n            return fragment;\n          }\n\n          const { element: { id, tagName: tag } }: { element: Element } = context;\n\n          return id ? { id } : { tag };\n        };\n\n        context.whenOn(supply => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot);\n\n          navigation.read.once(page => {\n            page.put(\n                PageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply,\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n\n            const newPageURL = contentKey(response.page);\n\n            if (newPageURL === lastPageURL) {\n              return; // Only hash changed. Do not refresh the page.\n            }\n\n            if (!response.ok) {\n              schedule(() => onResponse({ context, range, response }));\n              return;\n            }\n\n            lastPageURL = newPageURL;\n            schedule(() => {\n              range.deleteContents();\n\n              const target = document.createDocumentFragment();\n              const { fragment } = response;\n\n              if (fragment) {\n                importNodeContent(fragment, target);\n                range.insertNode(target);\n              }\n\n              onResponse({ context, range, response });\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction defaultPageContentKey({ url }: Page): string {\n  return new URL('', url).href;\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  readonly fragment?: PageFragmentRequest;\n\n  /**\n   * Builds content key for the given page.\n   *\n   * The loaded content will replace already included one only when their content key differ.\n   *\n   * By default uses page URL without hash part as a key. This prevents content refresh when only URL hash changes.\n   *\n   * @param page  Target page. Either loaded or not.\n   *\n   * @returns Content key.\n   */\n  contentKey?(page: Page): any;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse.ok each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context  Decorated component context.\n   * @param response  Page load response.\n   * @param range  Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { DefaultNamespaceAliaser, DefaultRenderScheduler } from '@wesib/wesib';\nimport { ContextKey__symbol, ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { afterAll, AfterEvent, EventKeeper } from 'fun-events';\nimport { InConverter, InNamespaceAliaser, InRenderScheduler, intoConvertedBy } from 'input-aspects';\n\n/**\n * Default input aspects.\n *\n * This is an `AfterEvent` keeper of aspect converter meant to be applied to controls.\n *\n * As a bare minimum it assigns the following aspects to converted controls:\n * - `InRenderScheduler` set to `DefaultRenderScheduler`,\n * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n *\n * More input aspect converters may be registered in context. They may override the default ones.\n */\nexport type DefaultInAspects = AfterEvent<[InConverter.Aspect<any, any>]>;\n\n/**\n * @internal\n */\nclass DefaultInAspectsKey\n    extends ContextUpKey<AfterEvent<[InConverter.Aspect<any, any>]>, InConverter.Aspect<any, any>> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor() {\n    super('default-in-aspects');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[InConverter.Aspect<any, any>]>,\n          EventKeeper<InConverter.Aspect<any, any>[]> | InConverter.Aspect<any, any>,\n          AfterEvent<InConverter.Aspect<any, any>[]>>,\n  ): AfterEvent<[InConverter.Aspect.Factory<any, any>]> {\n\n    const nsAlias = opts.context.get(DefaultNamespaceAliaser);\n\n    return afterAll({\n      scheduler: opts.context.get(DefaultRenderScheduler[ContextKey__symbol].upKey),\n      fns: opts.seed,\n    }).keep.thru(\n        ({\n            scheduler: [scheduler],\n            fns,\n        }) => intoConvertedBy(\n            ...fns,\n            InRenderScheduler.to(scheduler),\n            InNamespaceAliaser.to(nsAlias),\n        ),\n    );\n  }\n\n}\n\n/**\n * A key of bootstrap, definition, or component context containing default input aspects.\n */\nexport const DefaultInAspects: ContextUpRef<DefaultInAspects, InConverter.Aspect<any, any>> = (\n    /*#__PURE__*/ new DefaultInAspectsKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\nimport { eventSupply, EventSupply } from 'fun-events';\nimport { InControl } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\n\n/**\n * A user input originated from control.\n *\n * It is meant to be present in root {@link HierarchyContext hierarchy context}. Nested components may access it from\n * their hierarchy contexts to participate in user input.\n *\n * An [[inputFromControl]] function can be used to initiate user input.\n *\n * @typeparam Value  Input value type.\n */\nexport interface InputFromControl<Value = any> {\n\n  /**\n   * Root component context the input is initiated for.\n   */\n  readonly root: ComponentContext;\n\n  /**\n   * User input control.\n   */\n  readonly control: InControl<Value>;\n\n}\n\n/**\n * No user input originated from control.\n */\nexport interface NoInputFromControl {\n  control?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a user input originated from control. Potentially\n * {@link NoInputFromControl absent}.\n */\nexport const InputFromControl: SingleContextUpRef<InputFromControl | NoInputFromControl> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputFromControl | NoInputFromControl>(\n        'input-from-control',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates user input from the given control for the given root component.\n *\n * Constructs an [[InputFromControl]] instance and makes it available in `root` component's hierarchy.\n *\n * @typeparam Value  Input value type.\n * @param root  Root component context to initiate user input for.\n * @param control  User input control.\n *\n * @returns User input supply. The user input would be stopped once this supply is cut off.\n */\nexport function inputFromControl<Value>(\n    root: ComponentContext,\n    control: InControl<Value>,\n): EventSupply {\n\n  const off = root.get(HierarchyContext).provide({\n    a: InputFromControl,\n    by: () => ({\n      root,\n      control,\n    }),\n  });\n\n  return eventSupply(off).needs(control);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { nextArg, nextArgs, NextCall } from 'call-thru';\nimport { afterAll, EventKeeper, EventSupply, eventSupplyOf, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InConverter } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl, InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that converts input control from {@link HierarchyContext.up enclosing component}\n * and uses it as an {@link InputFromControl origin of user input} in decorated component.\n *\n * @param convert  Input control converter definition.\n *\n * @returns New component decorator.\n */\nexport function ConvertInput<T extends ComponentClass = Class>(\n    convert: ConvertInputDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const { up } = context.get(HierarchyContext);\n\n        afterAll({\n          parent: up.keep.thru_(\n              upper => upper ? nextAfterEvent(upper.get(InputFromControl)) : nextArg<NoInputFromControl>({}),\n          ),\n          aspects: context.get(DefaultInAspects),\n        }).keep.thru_(\n            ({\n              parent: [control],\n              aspects: [aspects],\n            }): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n              if (control.control) {\n\n                const converted = convert({ control, context, aspects });\n\n                if (converted) {\n                  return converted instanceof InControl\n                      ? nextArgs(converted)\n                      : nextAfterEvent(converted);\n                }\n              }\n\n              return nextArgs();\n            },\n        ).consume(\n            (control?: InControl<any> | null, supply?: EventSupply) => {\n              if (!control) {\n                return;\n              }\n\n              const usageSupply = inputFromControl(context, control);\n\n              (supply || eventSupplyOf(control)).needs(usageSupply);\n\n              return usageSupply;\n            },\n        );\n      });\n    },\n  });\n}\n\n/**\n * Converter definition of enclosing component's user input control.\n *\n * The returned converted control keeper may send an event supply as a second parameter. This supply will be cut off\n * once the input from converted control is no longer needed. Otherwise the control's input supply will be cut off\n * instead, and control would become unusable after that.\n *\n * Configures {@link ConvertInput @ConvertInput} component decorator.\n */\nexport type ConvertInputDef<T extends object = any> =\n/**\n * @param control  Enclosing component's user input to convert.\n * @param context  Decorated component context.\n * @param aspects  Default input aspect converter. This is a value of [[DefaultInputAspect]].\n *\n * @returns Either input control, its keeper, or nothing.\n */\n    (\n        this: void,\n        {\n          control,\n          context,\n          aspects,\n        }: {\n          control: InputFromControl;\n          context: ComponentContext<T>;\n          aspects: InConverter.Aspect<any, any>;\n        },\n    ) => InControl<any> | EventKeeper<[InControl<any>?, EventSupply?]> | null | undefined;\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\nimport { eventSupply, EventSupply } from 'fun-events';\nimport { InControl, InFormElement } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputFromControl } from './input-from-control';\n\n/**\n * A form control to fill by user input.\n *\n * An [[inputToForm]] function can be used to initiate filling the form.\n *\n * @typeparam Model  Form model type.\n * @typeparam Elt  A type of HTML form element.\n */\nexport interface InputToForm<Model = any, Elt extends HTMLElement = HTMLElement> extends InputFromControl<Model> {\n\n  /**\n   * Input form element control.\n   *\n   * Unlike input form control this one is not supposed to be submitted. But it contains a `<form>` element issuing a\n   * `submit` event.\n   */\n  readonly form: InFormElement<Elt>;\n\n}\n\n/**\n * No user input filling the form.\n */\nexport interface NoInputToForm {\n  control?: undefined;\n  form?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a form element to fill by user input. Potentially\n * {@link NoInputToForm absent}.\n */\nexport const InputToForm: SingleContextUpRef<InputToForm<any, any> | NoInputToForm> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputToForm<any, any> | NoInputToForm>(\n        'input-to-form',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates filling the form by user input from.\n *\n * Constructs [[InputToForm]] and [[InputFromControl]] instances and makes them available in `root` component's\n * hierarchy.\n *\n * @typeparam Model  Form model type.\n * @typeparam Elt  A type of HTML form element.\n * @param root  Root component context to initiate user input for.\n * @param control  Input form control.\n * @param form  Form element control.\n *\n * @returns Form fill supply. The form filling would be stopped once this supply is cut off.\n */\nexport function inputToForm<Model, Elt extends HTMLElement>(\n    root: ComponentContext,\n    control: InControl<Model>,\n    form: InFormElement<Elt>,\n): EventSupply {\n\n  const hierarchy = root.get(HierarchyContext);\n  const off = hierarchy.provide({\n    a: InputToForm,\n    by: () => ({\n      root,\n      control,\n      form,\n    }),\n  });\n\n  hierarchy.provide({\n    a: InputFromControl,\n    via: InputToForm,\n  });\n\n  return eventSupply(off)\n      .needs(control)\n      .needs(form);\n}\n\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { afterAll, EventKeeper, EventSupply, eventSupplyOf, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InConverter, InFormElement } from 'input-aspects';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputToForm } from './input-to-form';\n\n/**\n * Constructs component decorator that finds form element to {@link InputToForm fill by user input}.\n *\n * Enables [[ComponentTreeSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Form element fill definition.\n *\n * @returns New component decorator.\n */\nexport function FillInputForm<T extends ComponentClass = Class>(\n    def: FillInputFormDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n\n  const { select = 'form', pick = { deep: true, all: true } } = def;\n\n  return Component({\n    feature: {\n      needs: ComponentTreeSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n\n        context.whenOn(connectSupply => {\n          afterAll({\n            node: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).keep.thru(({\n            node: [node],\n            aspects: [aspects],\n          }): NextCall<OnEventCallChain, [InControl<any>, InFormElement, EventSupply?] | []> => {\n            if (!node) {\n              return nextArgs();\n            }\n\n            const tuple = def.makeForm({ node, context, aspects });\n\n            if (!tuple) {\n              return nextArgs();\n            }\n\n            return Array.isArray(tuple) ? nextArgs(...tuple) : nextAfterEvent(tuple);\n          }).tillOff(connectSupply).consume(\n              (control?, form?, supply?) => {\n                if (!control) {\n                  return;\n                }\n\n                const fillSupply = inputToForm(context, control, form!);\n\n                if (supply) {\n                  supply.needs(fillSupply);\n                } else {\n                  eventSupplyOf(form!).needs(fillSupply);\n                  eventSupplyOf(control).needs(fillSupply);\n                }\n\n                return fillSupply;\n              },\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * A definition of form element to {@link InputToForm fill by user input}.\n *\n * Configures {@link FillInputForm @FillInputForm} component decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface FillInputFormDef<T extends object = any> {\n\n  /**\n   * CSS selector of form element to fill.\n   *\n   * `form` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Constructs form control and form element control for element node found by {@link FillInputForm @FillInputForm}\n   * decorator.\n   *\n   * The returned control keeper may send an event supply as a third parameter. This supply will be cut off once\n   * the form filling is no longer needed. Otherwise the form's control supply will be cut off instead,\n   * and it would become unusable after that.\n   *\n   * @param node  Element node to construct form element control for.\n   * @param context  Component context the {@link FillInputForm @FillInputForm} decorator is applied to.\n   * @param aspects  Default input aspect converter. This is a value of [[DefaultInputAspect]].\n   *\n   * @returns Either form control and form element control tuple, their keeper, or nothing.\n   */\n  makeForm(\n      {\n        node,\n        context,\n        aspects,\n      }: {\n        node: ElementNode;\n        context: ComponentContext<T>;\n        aspects: InConverter.Aspect<any, any>;\n      },\n  ):\n      | [InControl<any>, InFormElement]\n      | EventKeeper<[InControl<any>, InFormElement, EventSupply?] | []>\n      | null\n      | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { ComponentClass, ComponentProperty, ComponentPropertyDecorator } from '@wesib/wesib';\nimport { eventSupplyOf } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputToForm, NoInputToForm } from './input-to-form';\n\n/**\n * Creates a decorator for component method to call on input form submit.\n *\n * The decorated method accepts a {@link InputToForm filled input form} and submit event as parameters.\n *\n * @typeparam T  A type of decorated component class.\n * @typeparam M  Submitted value type.\n * @typeparam Elt  A type of HTML form element.\n * @param def  Submit handler definition.\n *\n * @returns New component property decorator.\n */\nexport function OnSubmit<T extends ComponentClass, Model = any, Elt extends HTMLElement = HTMLElement>(\n    def: OnSubmitDef = {},\n): ComponentPropertyDecorator<(form: InputToForm<Model, Elt>, event: Event) => void, T> {\n\n  const { cancel = true } = def;\n\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenOn(supply => {\n\n            const hierarchy = context.get(HierarchyContext);\n            const { component } = context;\n\n            hierarchy.get(InputToForm).consume((inputToForm: InputToForm<Model, Elt> | NoInputToForm) => {\n              if (!inputToForm.control) {\n                return;\n              }\n\n              const submitDispatcher = new DomEventDispatcher(inputToForm.form.element);\n\n              eventSupplyOf(submitDispatcher).needs(supply);\n\n              const onSubmit = submitDispatcher.on('submit');\n\n              return (cancel ? onSubmit.instead : onSubmit)(\n                  event => get(component).call(component, inputToForm, event),\n              );\n            });\n          });\n        });\n      },\n    },\n  }));\n}\n\n/**\n * Form submit handler definition.\n *\n * Configures {@link OnSubmit @OnSubmit} component property decorator.\n */\nexport interface OnSubmitDef {\n\n  /**\n   * Whether to cancel default submit handler.\n   *\n   * `true` by default.\n   */\n  cancel?: boolean;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { nextArg, valueProvider } from 'call-thru';\nimport { afterAll, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { InGroup } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Creates component decorator that adds {@link InputFromControl input control} of decorated component to input control\n * group of enclosing one under the given name.\n *\n * @typeparam T  A type of decorated component class.\n * @param name  A name to assign to component. This could be either a string, or a function returning name as a string\n * or as its keeper.\n *\n * @returns New component decorator.\n */\nexport function SetInputName<T extends ComponentClass = Class>(\n    name: string | ((this: void, context: ComponentContext<InstanceType<T>>) => string | EventKeeper<[string?]>),\n): ComponentDecorator<T> {\n\n  const getName: (context: ComponentContext<InstanceType<T>>) => EventKeeper<[string?]> = typeof name === 'string'\n      ? valueProvider(afterThe(name))\n      : context => {\n        const result = name(context);\n        return typeof result === 'string' ? afterThe(result) : result;\n      };\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const hierarchy = context.get(HierarchyContext);\n\n        afterAll({\n          group: hierarchy.up.keep.thru_(\n              upper => upper ? nextAfterEvent(upper.get(InputFromControl)) : nextArg<NoInputFromControl>({}),\n              ({ control }) => control && control.aspect(InGroup),\n          ),\n          control: hierarchy.get(InputFromControl),\n          name: getName(context),\n        }).consume(\n            ({\n              group: [group],\n              control: [{ control }],\n              name: [name],\n            }) => {\n              if (name == null\n                  || !group\n                  || !control\n                  || group === control) {\n                return;\n              }\n              return group.controls.set(name, control);\n            },\n        );\n      });\n    },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { afterAll, EventKeeper, EventSupply, eventSupplyOf, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InConverter } from 'input-aspects';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that finds input element and uses it as an {@link InputFromControl origin of user\n * input}.\n *\n * Enables [[ComponentTreeSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Input element usage definition.\n *\n * @returns New component decorator.\n */\nexport function UseInputElement<T extends ComponentClass = Class>(\n    def: UseInputElementDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n\n  const { select = 'input', pick = { deep: true, all: true } } = def;\n\n  return Component({\n    feature: {\n      needs: ComponentTreeSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n\n        context.whenOn(connectSupply => {\n          afterAll({\n            node: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).keep.thru(({\n            node: [node],\n            aspects: [aspects],\n          }): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n            if (!node) {\n              return nextArgs();\n            }\n\n            const control = def.makeControl({ node, context, aspects });\n\n            if (!control) {\n              return nextArgs();\n            }\n\n            return control instanceof InControl ? nextArgs(control) : nextAfterEvent(control);\n          }).tillOff(connectSupply).consume(\n              (control?: InControl<any>, supply?: EventSupply) => {\n                if (!control) {\n                  return;\n                }\n\n                const usageSupply = inputFromControl(context, control);\n\n                (supply || eventSupplyOf(control)).needs(usageSupply);\n\n                return usageSupply;\n              },\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * A definition of element to use as an {@link InputFromControl origin of user input}.\n *\n * Configures {@link UseInputElement @UseInputElement} component decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface UseInputElementDef<T extends object = any> {\n\n  /**\n   * CSS selector of input element to use.\n   *\n   * `input` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Constructs input control for element node found by {@link UseInputElement @UseInputElement} decorator.\n   *\n   * The returned control keeper may send an event supply as a second parameter. This supply will be cut off once\n   * the input from control is no longer needed. Otherwise the control's input supply will be cut off instead,\n   * and control would become unusable after that.\n   *\n   * @param node  Element node to construct input control for.\n   * @param context  Component context the {@link UseInputElement @UseInputElement} decorator is applied to.\n   * @param aspects  Default input aspect converter. This is a value of [[DefaultInputAspect]].\n   *\n   * @returns Either input control, its keeper, or nothing.\n   */\n  makeControl(\n      {\n        node,\n        context,\n        aspects,\n      }: {\n        node: ElementNode;\n        context: ComponentContext<T>;\n        aspects: InConverter.Aspect<any, any>;\n      },\n  ):\n      | InControl<any>\n      | EventKeeper<[InControl<any>?, EventSupply?]>\n      | null\n      | undefined;\n\n}\n"],"names":["FetchAgentKey","ContextUpKey","[object Object]","name","super","this","upKey","createUpKey","opts","seed","keep","thru","agents","length","nextArg","next","request","fetch","agentIdx","agentRequest","agent","onSupplied","nextRequest","combineFetchAgents","defaultProvider","afterThe","defaultFetchAgent","nextAfterEvent","byDefault","delegated","context","get","or","undefined","HttpFetchAgent","HttpFetchAborted","HttpFetch","FnContextKey","bootstrapDefault","window","BootstrapWindow","input","init","Request","onEventBy","receiver","responseEmitter","EventEmitter","supply","abortController","AbortController","signal","eventSupply","reason","abort","whenOff","off","needs","on","ctx","response","receive","customSignal","DomEventDispatcher","once","aborted","then","send","catch","HierarchyRoot","SingleContextKey","bsContext","root","BootstrapRoot","HierarchyUpdates","issue","trackValue","HierarchyUpdates__key","ComponentContext","updates","hierarchyRoot","BootstrapContext","parent","findParentContext","it","ContextKey__symbol","of","element","immediate","parentNode","ComponentContext__symbol","HierarchyContext__key","up","afterEventBy","parentHierarchy","rootSupply","parentSupply","updateParent","parentCtx","HierarchyContext","read","connected","consume","newParent","whenOn","_","onSupply","Promise","resolve","share","registry","ContextRegistry","key","upper","nextArgs","newHierarchyRegistry","values","newValues","spec","provide","newHierarchyContext","ContextValues","ComponentNode","ElementNodeList","AIterable","OnEvent__symbol","onUpdate","AfterEvent__symbol","WATCH_DEEP","subtree","elementNodeList","selectorOrType","nodeOf","deep","all","iterable","selector","cache","Set","whenDefined","elementDef","html__naming","DefaultNamespaceAliaser","size","selected","refresh","added","Array","from","filterIt","mapIt","node","isPresent","observer","ElementObserver","mutations","removed","forEach","mutation","itsEach","overArray","removedNodes","removeNode","push","addedNodes","addNode","nodeList","firstReceiver","observe","disconnect","onTrackUpdate","track","initialEmitter","first","afterSupplied","list","itsFirst","addEventListener","event","target","has","ElementNodeList_","Symbol","iterator","itsIterator","sel","querySelectorAll","children","item","matches","select","isElement","add","delete","AttributesObserver","_bs","Map","_observer","Observer","MutationObserver","_update","self","emitter","_emitter","rcv","eventReceiver","_emitters","reconnect","newValue","oldValue","takeRecords","attributes","attributeOldValue","attributeFilter","keys","attributeName","getAttribute","set","AttributeTracker","ValueTracker","_name","observeSupply","noEventSupply","_updates","EventSupply__symbol","eventSupplyOf","value","setAttribute","NodeAttributes","bs","existing","_attrs","created","PropertyTracker","_element","_key","_supply","propertyState","ComponentState","domPropertyPathTo","done","_ctx","_path","NodeProperties","_context","_props","prop","bind","ElementNode__symbol","ElementNode","_bind","elementNodeOf","mode","optional","adapter","ElementAdapter","selectNodes","ComponentTreeSupport__feature","StateSupport","setup","perComponent","a","by","ComponentTreeSupport","FeatureDef__symbol","Navigation__key","Navigation","go","PageParam__symbol","PageParam","_page","PageParamContext","NavHistory__key","NavHistory","extractNavData","state","data","_document","document","_location","location","_history","history","_uid","btoa","String","Math","random","entry","newEntry","url","URL","href","title","_entries","id","schedule","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","tracker","page","pushState","_enter","when","fromEntry","e","_forget","prev","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_bsContext","proto","noop","_params","visited","_status","current","ref","put","param","handle","newHandle","_newContext","_init","create","to","entries","transferred","at","stay","clear","update","NavigationAgentKey","navigate","agentTo","nextURL","nextTitle","nextData","baseURI","defaultNavigationAgent","_when","_from","NavigationAgent","EnterPageEvent","Event","type","cancelable","LeavePageEvent","StayOnPageEvent","createNavigation","dispatcher","navHistory","onEnter","onLeave","onStay","onEvent","onAny","nav","nextEntry","apply","readPage","dispatch","hashChange","Navigation_","delta","toURL","withParam","applyParams","with","mergeFunctions","open","replace","targetOrCallback","callback","navTarget","navTargetOf","applyAgent","whenLeave","promise","doNavigate","prepared","leavePage","prepare","navigated","NavigationSupport__feature","NavigationSupport","inactiveNavLink","ActivateNavLink","def","pick","Component","feature","defContext","whenComponent","activate","scheduler","DefaultRenderScheduler","active","defaultActiveNavLinkClass","activeClass","css__naming","NavLinkRenderSchedule__symbol","makeActive","classList","remove","assignClass","lastSupply","activateNavLink","weigh","defaultNavLinkWeight","weight","supplier","thru_","navLinkWeight","navigation","componentNode","connectSupply","nodes","afterEach","map","weights","maxWeight","selectActiveNavLink","linkURL","ownerDocument","calcNavLinkWeight","pageURL","origin","linkDir","navLinkPath2dir","pageDir","hash","navLinkSearchParamsWeight","navLinkHash2url","searchParamWeight","startsWith","pathname","path","endsWith","substring","searchParams","linkParams","pageParams","_value","pageValues","getAll","every","linkValue","Wesib__NS","HandleNavLinks","getHref","defaultNavLinkHref","preventDefault","defaultHandleNavLinks","events","ArraySet","eventType","setHashURL","hashURL","username","search","result","PageHashURLValueParam$","PageHashURLValueParam","PageHashURLParam$","PageHashURLParam","PageHashURLSupport__feature","is","pageHashURLAgent","PageHashURLSupport","importNode","beforeOrImport","importContent","importNodeContent","before","doc","elementClone","createElement","tagName","toLowerCase","getAttributeNames","attr","insertBefore","nodeClone","childNodes","cachingPageLoader","loader","pageUrl","sup","tracked","onLoad","trackSupply","resp","nextSkip","num","requested","PageLoadAbortError","Error","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","_loader","fragments","fragment","flatMapIt","_map","pageSupply","loadSupply","_add","_transfer","responseReceiver","error","ok","tag","getElementsByTagName","getElementById","onFragment","req","PageLoadAgent","PageLoadURLModifier","valueProvider","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","itsReduction","header","hthvQuote","requestPageFragments","EventNotifier","onAsync","text","batch","nextEach","status","parsePageDocument","parseFromString","hthvParse","v","head","base","querySelector","newBase","appendChild","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","rev","appRev","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","src","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","style","removeChild","pageTitleAgent","textContent","PageLoadSupport__feature","buster","PageLoadSupport","IncludePage","onResponse","contentKey","defaultPageContentKey","lastPageURL","detectFragment","range","createRange","selectNodeContents","contentRoot","newPageURL","deleteContents","createDocumentFragment","insertNode","handleResponse","DefaultInAspectsKey","nsAlias","afterAll","fns","intoConvertedBy","InRenderScheduler","InNamespaceAliaser","DefaultInAspects","InputFromControl","SingleContextUpKey","inputFromControl","control","ConvertInput","convert","aspects","converted","InControl","usageSupply","InputToForm","FillInputForm","tuple","makeForm","isArray","tillOff","form","fillSupply","hierarchy","via","inputToForm","OnSubmit","cancel","ComponentProperty","componentDef","component","submitDispatcher","onSubmit","instead","call","SetInputName","getName","group","aspect","InGroup","controls","UseInputElement","makeControl"],"mappings":"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"}