{"version":3,"file":"context-values.b8be26f5.js","sources":["../../../../../proc7ts/context-values/src/context-key.ts","../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/context-seed-registry.impl.ts","../../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/context-values.impl.ts","../../../../../proc7ts/context-values/src/context-registry.ts","../../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../../proc7ts/context-values/src/single-context-key.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-supply.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextRegistry } from './context-registry';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [ContextKey] instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('context-key'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot  Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value slot to put the grown value into.\n *\n * An instance of the value slot is passed to [[ContextKey.grow]] method to provide the necessary context and optionally\n * accept a new value.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport type ContextValueSlot<TValue, TSrc, TSeed> =\n    | ContextValueSlot.WithFallback<TValue, TSrc, TSeed>\n    | ContextValueSlot.WithoutFallback<TValue, TSrc, TSeed>;\n\nexport namespace ContextValueSlot {\n\n  /**\n   * Base context value slot interface.\n   *\n   * @typeParam TValue  Context value type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Target context.\n     */\n    readonly context: ContextValues;\n\n    /**\n     * A key to associated value with.\n     */\n    readonly key: ContextKey<TValue, TSrc, TSeed>;\n\n    /**\n     * Context value seeder.\n     */\n    readonly seeder: ContextSeeder<ContextValues, TSrc, TSeed>;\n\n    /**\n     * Context value seed.\n     */\n    readonly seed: TSeed;\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     */\n    readonly hasFallback: boolean;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     *\n     * Always `undefined` when {@link hasFallback there is no fallback}.\n     */\n    readonly or: TValue | null | undefined;\n\n    /**\n     * Insert the value into the slot.\n     *\n     * The value will be associated with key after [[ContextKey.grow]] method exit.\n     *\n     * Supersedes a previously inserted value.\n     *\n     * @param value  A value to associate with the key, or `null`/`undefined` to not associate any value.\n     */\n    insert(value: TValue | null | undefined): void;\n\n    /**\n     * Fills this slot by the given function.\n     *\n     * @param grow  A function accepting a value slot as its only parameter.\n     *\n     * @returns A value associated with target key by the given function, or `null`/`undefined` when no value\n     * associated.\n     */\n    fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined;\n\n    /**\n     * Registers a setup procedure issued when context value associated with target key.\n     *\n     * Setup will be issued at most once per context. Setup won't be issued if no value {@link insert inserted}.\n     *\n     * @param setup  Context value setup procedure.\n     */\n    setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void;\n\n  }\n\n  /**\n   * Base context value slot with fallback value.\n   *\n   * @typeParam TValue  Context value type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface WithFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `true`\n     */\n    readonly hasFallback: true;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     */\n    readonly or: TValue | null | undefined;\n\n  }\n\n  export interface WithoutFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `false`\n     */\n    readonly hasFallback: false;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Always `undefined`.\n     */\n    readonly or: undefined;\n\n  }\n\n}\n\n/**\n * Context value setup procedure signature.\n *\n * A function with this signature can be passed to {@link ContextValueSlot.Base.setup} method to be issued when\n * the value associated with target key.\n */\nexport type ContextValueSetup<TValue, TSrc, TSeed> =\n/**\n * @param key  A key the value associated with.\n * @param context  Target context the value associated with.\n * @param registry  A registry of context value providers. This context is shared among all contexts\n * {@link ContextRegistry.newValues created} by it.\n */\n    (\n        this: void,\n        {\n          key,\n          context,\n          registry,\n        }: {\n          key: ContextKey<TValue, TSrc, TSeed>;\n          context: ContextValues;\n          registry: ContextRegistry;\n        }\n    ) => void;\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TValue  Context value type.\n * @typeParam TKey  Context key type.\n */\nexport type ContextKeyDefault<TValue, TKey extends ContextKey<unknown, unknown>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: TKey) => TValue | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","import { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport type SeedFactory<TCtx extends ContextValues, TSeed> = (this: void, context: TCtx) => TSeed;\n\n/**\n * @internal\n */\nexport type SeedData<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n    seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n    factory: SeedFactory<TCtx, TSeed>,\n];\n\n/**\n * @internal\n */\nexport class ContextSeedRegistry<TCtx extends ContextValues> {\n\n  private readonly _byKey = new Map<ContextSeedKey<any, any>, SeedData<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  seedData<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedData<TCtx, TSrc, TSeed> {\n\n    const found: SeedData<TCtx, TSrc, TSeed> | undefined = this._byKey.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const factory: SeedFactory<TCtx, TSeed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seedData: SeedData<TCtx, TSrc, TSeed> = [seeder, factory];\n\n    this._byKey.set(seedKey, seedData);\n\n    return seedData;\n  }\n\n  /**\n   * @internal\n   */\n  findSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.seedData(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/primitives';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TSrc  Source value type.\n */\nexport type ContextValueProvider<TCtx extends ContextValues, TSrc> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: TCtx) => TSrc | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TValue  Context value type.\n * @typeParam TDeps  Dependencies tuple type.\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TDeps extends any[] = unknown[],\n    TSrc = TValue,\n    TSeed = unknown> =\n    | ContextValueSpec.IsConstant<TSrc, TSeed>\n    | ContextValueSpec.ViaAlias<TSrc, TSeed>\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface IsConstant<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface ViaAlias<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc, TSeed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx  Context type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TCtx, TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface ByProviderWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx  Context type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx  Context type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TValue  Context value type.\n * @typeParam TDeps  Dependencies tuple type.\n * @typeParam TSrc  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, TValue, TDeps, TSrc, TSeed>,\n): ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> {\n  if (byProvider(spec)) {\n    if (!withDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstant<TSrc, TSeed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n    if (selfInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed> | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>,\n): ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.IsConstant<TSrc, TSeed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.ViaAlias<TSrc, TSeed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextKey__symbol, ContextValueSetup, ContextValueSlot } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextRegistry } from './context-registry';\nimport { ContextSeedRegistry } from './context-seed-registry.impl';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seedRegistry: ContextSeedRegistry<TCtx>,\n): ContextValues {\n\n  const values = new Map<ContextKey<any>, any>();\n\n  class ContextValues$ extends ContextValues {\n\n    get<TValue, TSrc>(\n        this: TCtx,\n        { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n        opts?: ContextRequest.Opts<TValue>,\n    ): TValue | null | undefined {\n\n      const cached = values.get(key);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      const [constructed, setup] = new ContextValueSlot$(seedRegistry, this, key, opts)._grow();\n\n      if (setup) {\n        values.set(key, constructed);\n        setup({\n          key,\n          context: this,\n          registry: registry as ContextRegistry<any> as ContextRegistry,\n        });\n      }\n\n      return constructed;\n    }\n\n  }\n\n  return new ContextValues$();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n  readonly hasFallback: boolean;\n  readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n  readonly seed: TSeed;\n  private _constructed: TValue | null | undefined = null;\n  private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n  constructor(\n      registry: ContextSeedRegistry<TCtx>,\n      readonly context: TCtx,\n      readonly key: ContextKey<TValue, TSrc, TSeed>,\n      private readonly _opts: ContextRequest.Opts<TValue> = {},\n  ) {\n\n    const [seeder, seed] = registry.findSeed<TSrc, TSeed>(context, key);\n\n    this.seeder = seeder;\n    this.seed = seed;\n    this.hasFallback = 'or' in _opts;\n  }\n\n  get or(): TValue | null | undefined {\n    return this._opts.or;\n  }\n\n  insert(value: TValue | null | undefined): void {\n    this._constructed = value;\n  }\n\n  fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n    grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n    return this._constructed;\n  }\n\n  setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n    const prevSetup = this._setup;\n\n    this._setup = opts => {\n      prevSetup(opts);\n      setup(opts);\n    };\n  }\n\n  _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n    this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n    if (this._constructed != null) {\n      return [this._constructed, this._setup];\n    }\n    if (!this.hasFallback) {\n      throw new ContextKeyError(this.key);\n    }\n\n    return [this.or];\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKey__symbol, ContextSeedKey } from './context-key';\nimport { ContextSeedRegistry } from './context-seed-registry.impl';\nimport { ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\nimport { newContextValues } from './context-values.impl';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx  Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeds: ContextSeedRegistry<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n    this._seeds = new ContextSeedRegistry<TCtx>(\n        initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop,\n    );\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<TDeps extends any[], TSrc, TSeed>(spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeds.seedData<TSrc, TSeed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeds.seedData(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider originated from this registry.\n   *\n   * @returns Mandatory context seeds provider.\n   */\n  seeds(): ContextSeeds.Mandatory<TCtx> {\n    return (seedKey, context) => this.seed(context, seedKey);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeds);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry or context seeds provider.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx> | ContextSeeds<TCtx>): ContextRegistry<TCtx> {\n\n    const otherSeeds: ContextSeeds<TCtx> = typeof other === 'function' ? other : other.seeds();\n\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const second = otherSeeds(key, context);\n      const [seeder, factory] = this._seeds.seedData(key);\n      const first = factory(context);\n\n      return second ? seeder.combine(first, second, context) : first;\n    });\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: ContextValueProvider<TCtx, TSrc>[] = [];\n\n  provide(provider: ContextValueProvider<TCtx, TSrc>): () => void {\n    this._providers.unshift(provider);\n    return () => {\n\n      const found = this._providers.lastIndexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (provider: ContextValueProvider<TCtx, TSrc>): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc  Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue  Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue  Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason  Context destruction reason.\n */\nexport function contextDestroyed(reason?: any): () => never {\n  return () => {\n    throw reason ?? new TypeError('Context destroyed');\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { EventSupply, EventSupply__symbol, EventSupplyPeer } from '@proc7ts/fun-events';\nimport { ContextValueSlot } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { SimpleContextKey } from '../simple-context-key';\n\n/**\n * Context values supply.\n *\n * When available as context value, it is used to indicate the context is no longer used (e.g. destroyed).\n *\n * A context value provider can destroy the value it provides when this supply is cut off.\n */\nexport type ContextSupply = EventSupply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || (slot.hasFallback ? slot.or : null)\n        || (slot.context as Partial<EventSupplyPeer>)[EventSupply__symbol],\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is not guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `EventSupplyPeer` interface.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { CallChain, nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { mapIt, overArray, overElementsOf } from '@proc7ts/push-iterator';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSlot } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(\n        first,\n        second,\n    ).keepThru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>[]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read().keepThru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | TSrc | EventKeeper<TSrc[]>): AfterEvent<TSrc[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<TSrc>(src: TSrc | EventKeeper<TSrc[]>): src is EventKeeper<TSrc[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as object);\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<TSrc>(...sources: TSrc[][]): NextCall<CallChain, TSrc[]> {\n  return nextArgs(...overElementsOf(...sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<TSrc>\n    extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, TSrc | EventKeeper<TSrc[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<TValue, TSrc>\n    extends ContextKey<ContextUpKey.Up<TValue>, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  readonly grow: (\n      slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<TValue, TSrc>,\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value = slot.fillBy(grow);\n\n      if (value) {\n\n        const supply = slot.context.get(ContextSupply, { or: null });\n\n        if (supply) {\n          slot.insert(value.tillOff(supply) as ContextUpKey.Up<TValue>);\n        }\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[grow]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey<TSrc>(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.UpKey<TValue, TSrc> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue  Original context value type.\n   */\n  export type Up<TValue> = TValue extends AfterEvent<any>\n      ? TValue\n      : (TValue extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[TValue]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeParam TValue  Context value type.\n   * @typeParam TSrc  Source value type.\n   */\n  export type UpKey<TValue, TSrc> = ContextKey<ContextUpKey.Up<TValue>, TSrc>;\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc  Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs  Function arguments tuple type.\n * @typeParam TRet  Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs  Function arguments tuple type.\n * @typeParam TRet  Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        slot => {\n          slot.insert(slot.seed.keepThru(\n              (...fns) => {\n                if (fns.length) {\n                  return fns[fns.length - 1];\n                }\n\n                if (slot.hasFallback && slot.or) {\n                  return nextAfterEvent(slot.or);\n                }\n\n                return nextAfterEvent(afterThe(this.byDefault(slot.context, this)));\n              },\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          EventKeeper<((this: void, ...args: TArgs) => TRet)[]> | ((this: void, ...args: TArgs) => TRet),\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { nextArg } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from './context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeParam TValue  Context value type.\n */\nexport type SingleContextUpRef<TValue> = ContextUpRef<AfterEvent<[TValue]>, TValue>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue  Context value type.\n */\nexport class SingleContextUpKey<TValue>\n    extends ContextUpKey<AfterEvent<[TValue]>, TValue>\n    implements SingleContextUpRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TValue>;\n        byDefault?: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<AfterEvent<[TValue]>, EventKeeper<TValue[]> | TValue, AfterEvent<TValue[]>>,\n  ): void {\n\n    const value = slot.seed.keepThru((...sources: TValue[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[TValue]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        backup = defaultValue && afterThe(defaultValue);\n      }\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[TValue]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n\n    const supply = slot.context.get(ContextSupply, { or: null });\n\n    slot.insert(supply ? value.tillOff(supply) : value);\n  }\n\n}\n\n"],"names":["ContextKey__symbol","Symbol","ContextKey","[object Object]","name","this","ContextSeedKey","key","super","seedKey","opts","seeder","seed","isEmpty","hasFallback","insert","ContextKeyError","Error","message","ContextSeedRegistry","_initial","Map","found","_byKey","get","seedData","context","set","factory","withDeps","spec","ContextValues","ContextValueSlot$","registry","_opts","noop","findSeed","or","value","_constructed","grow","setup","prevSetup","_setup","ContextRegistry","initial","_seeds","a","by","byProvider","with","deps","map","dep","isConstant","is","valueProvider","viaAlias","via","ctx","asInstance","selfInstance","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","provide","newValues","bind","seedRegistry","values","cached","constructed","_grow","newContextValues","other","otherSeeds","seeds","second","first","combine","SimpleContextSeeder","provider","_providers","unshift","lastIndexOf","splice","length","makeSeed","lazyValue","undefined","push","combineSimpleSeeds","SimpleSeedKey","SimpleContextKey","SingleContextKey","byDefault","slot","contextDestroyed","reason","ContextSupplyKey","EventSupply__symbol","ContextSupply","ContextUpSeeder","trackValue","it","providers","indexOf","slice","concat","afterThe","providersTracker","read","keepThru","nextAfterEvent","afterEach","mapIt","overArray","prov","toUpSrcKeeper","nextArgs","flatUpSources","upSrcKeepers","src","isEventKeeper","isUpSrcKeeper","afterSupplied","sources","overElementsOf","ContextSeedUpKey","upKey","ContextUpKeyUpKey","_key","fillBy","supply","tillOff","ContextUpKey","FnContextKey","createUpKey","fns","delegated","to","fn","whenOff","args","SingleContextUpKey","nextArg","backup","defaultValue","afterEventBy"],"mappings":"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"}