{"version":3,"file":"primitives.7b24aae7.js","sources":["../../../../../proc7ts/primitives/src/array/array-of-elements.ts","../../../../../proc7ts/primitives/src/value/are-the-same.ts","../../../../../proc7ts/primitives/src/value/value-providers.ts","../../../../../proc7ts/primitives/src/value/lazy-value.ts","../../../../../proc7ts/primitives/src/value/value-recipe.ts","../../../../../proc7ts/primitives/src/array/arrays-are-equal.ts","../../../../../proc7ts/primitives/src/array/element-or-array.ts","../../../../../proc7ts/primitives/src/array/set-of-elements.ts","../../../../../proc7ts/primitives/src/class/super-class-of.ts","../../../../../proc7ts/primitives/src/fn/asis.ts","../../../../../proc7ts/primitives/src/fn/count-args.ts","../../../../../proc7ts/primitives/src/fn/merge-functions.ts","../../../../../proc7ts/primitives/src/fn/noop.ts","../../../../../proc7ts/primitives/src/promises/promise-resolver.ts","../../../../../proc7ts/primitives/src/reflection/field-accessor-descriptor.ts","../../../../../proc7ts/primitives/src/reflection/property-accessor-descriptor.ts","../../../../../proc7ts/primitives/src/type/presence.ts"],"sourcesContent":["/**\n * Checks whether the given value is an array.\n *\n * @param value - Either element, array of elements, `null`, or `undefined`.\n *\n * @returns `true` if the given `value` is an array, or `false` otherwise.\n */\nexport function isArrayOfElements<T>(value: T | T[] | null | undefined): value is T[];\n\n/**\n * Checks whether the given value is a readonly array.\n *\n * @param value - Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns `true` if the given `value` is an array, or `false` otherwise.\n */\nexport function isArrayOfElements<T>(value: T | readonly T[] | null | undefined): value is readonly T[];\n\nexport function isArrayOfElements<T>(value: T | readonly T[] | null | undefined): value is T[] {\n  return Array.isArray(value);\n}\n\n/**\n * Converts element or array of elements to array of elements.\n *\n * @param value - Either element, array of elements, `null`, or `undefined`.\n *\n * @returns The `value` itself if it is an array, empty array if `value` is `null` or `undefined`, or an array\n * containing only `value` otherwise.\n */\nexport function arrayOfElements<T>(value: T | T[] | null | undefined): T[];\n\n/**\n * Converts element or readonly array of elements to readonly array of elements.\n *\n * @param value - Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The `value` itself if it is an array, empty array if the `value` is `null` or `undefined`, or an array\n * containing only `value` otherwise.\n */\nexport function arrayOfElements<T>(value: T | readonly T[] | null | undefined): readonly T[];\n\nexport function arrayOfElements<T>(value: T | T[] | null | undefined): T[] {\n  return (/*#__INLINE__*/ isArrayOfElements(value)) ? value : value != null ? [value] : [];\n}\n","/**\n * Checks whether two values are the same. I.e. strictly equal to each other.\n *\n * @typeParam T - A type of values.\n * @param first - First value to compare.\n * @param second - Second value to compare.\n *\n * @returns `true` if `first === second`, or `false` otherwise.\n */\nexport function areTheSame<T>(first: T, second: T): boolean {\n  return first === second;\n}\n","/**\n * Creates a provider of the only argument.\n *\n * @param value - A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return (): T => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return (): T => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return (): T => values.slice() as T;\n}\n","import { valueProvider } from './value-providers';\n\n/**\n * Creates a provider of lazily evaluated value.\n *\n * The returned function evaluates the value first time it is called. Then it just returns previously evaluated value.\n *\n * @param provider - A no-arg function evaluating the value.\n *\n * @returns A function that returns the value evaluated by `provider`.\n */\nexport function lazyValue<T>(provider: (this: void) => T): (this: void) => T {\n\n  let get = (): T => {\n    get = lazyValue$recurrent; // Prevent recurrent evaluation\n\n    const value = provider();\n\n    get = valueProvider(value);\n\n    return value;\n  };\n\n  return (): T => get();\n}\n\nfunction lazyValue$recurrent(): never {\n  throw new TypeError('Recurrent evaluation');\n}\n","import { valueProvider } from './value-providers';\n\n/**\n * A recipe of value evaluation.\n *\n * This is either a value as-is, or its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n */\nexport type ValueRecipe<TValue, TArgs extends any[] = []> =\n    | TValue\n    | ValueRecipe.Evaluator<TValue, TArgs>;\n\nexport namespace ValueRecipe {\n\n  /**\n   * Value evaluator signature.\n   *\n   * @typeParam TValue - Evaluated value type. This can not be a function.\n   * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n   */\n  export type Evaluator<TValue, TArgs extends any[] = []> =\n  /**\n   * @param args - Parameters required for value evaluation.\n   *\n   * @returns Evaluated value.\n   */\n      (this: void, ...args: TArgs) => TValue;\n\n}\n\n/**\n * @internal\n */\nfunction isValueEvaluator<TValue, TArgs extends any[]>(\n    value: ValueRecipe<TValue, TArgs>,\n): value is ValueRecipe.Evaluator<TValue, TArgs> {\n  return typeof value === 'function';\n}\n\n/**\n * Evaluates a value by its recipe.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value evaluation recipe.\n * @param args - Parameters required for value evaluation.\n *\n * @returns Either the value itself, or the one evaluated by the given evaluator recipe.\n */\nexport function valueByRecipe<TValue, TArgs extends any[]>(\n    recipe: ValueRecipe<TValue, TArgs>,\n    ...args: TArgs\n): TValue {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe(...args) : recipe;\n}\n\n/**\n * Converts a value recipe to its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value recipe to convert.\n *\n * @returns Either evaluator itself, or the one evaluating to the given value.\n */\nexport function valueRecipe<TValue, TArgs extends any[]>(\n    recipe: ValueRecipe<TValue, TArgs>,\n): ValueRecipe.Evaluator<TValue, TArgs> {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe : valueProvider(recipe);\n}\n","import { areTheSame } from '../value';\n\n/**\n * Checks whether two arrays are equal.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param second - Second array to compare.\n * @param length - The maximum number of elements to compare. Defaults to array length. Negative value means `0`.\n *\n * @returns `true` if up to `length` corresponding array elements are strictly equal to each other.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    length?: number | null,\n): boolean;\n\n/**\n * Checks whether two array ranges are equal.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param second - Second array to compare. Negative or absent value means `0`.\n * @param from - The first element index to compare. Negative value means `0`. Absent value means array length.\n * @param to - The number one more than the last element index to compare.\n *\n * @returns `true` if all corresponding elements in corresponding array ranges are strictly equal to each other.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    from: number | null | undefined,\n    to: number | null,\n): boolean;\n\n/**\n * Checks whether two arrays are equal by comparing corresponding elements with the given comparator function.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param elementsAreEqual - Array elements comparator. Accepts elements to compare and their index as arguments.\n * Returns `true` if elements are equal, or `false` otherwise.\n * @param second - Second array to compare.\n * @param length - The maximum number of elements to compare. Defaults to array length.\n *\n * @returns `true` if `elementsAreEqual` comparator returned `true` for up to `length` corresponding array element\n * pairs.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    elementsAreEqual: (this: void, first: T, second: T, index: number) => boolean,\n    length?: number | null,\n): boolean;\n\n/**\n * Checks whether two array ranges are equal by comparing corresponding elements with the given comparator function.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param elementsAreEqual - Array elements comparator. Accepts elements to compare and their index as arguments.\n * Returns `true` if elements are equal, or `false` otherwise.\n * @param second - Second array to compare.\n * @param from - The first element index to compare. Negative value means `0`. Absent value means array length.\n * @param to - The number one more than the last element index to compare.\n *\n * @returns `true` if `elementsAreEqual` comparator returned `true` for up to `length` corresponding array element\n * pairs.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    elementsAreEqual: (this: void, first: T, second: T, index: number) => boolean,\n    from: number | null | undefined,\n    to: number | null,\n): boolean;\n\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    compareOrFromOrLength?: ((this: void, first: T, second: T, index: number) => boolean) | number | null,\n    fromOrLength?: number | null,\n    to?: number | null,\n): boolean {\n  return typeof compareOrFromOrLength === 'function'\n      ? arrayElementsAreEqual(\n          first,\n          second,\n          compareOrFromOrLength,\n          fromOrLength,\n          to,\n      )\n      : arrayElementsAreEqual(\n          first,\n          second,\n          areTheSame,\n          compareOrFromOrLength,\n          fromOrLength,\n      );\n}\n\nfunction arrayElementsAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    elementsAreEqual: (this: void, first: T, second: T, index: number) => boolean,\n    fromOrLength?: number | null,\n    to?: number | null,\n): boolean {\n\n  let start: number;\n  let end: number;\n\n  if (to !== undefined) {\n    start = fromOrLength ? Math.max(fromOrLength, 0) : 0;\n    end = to != null ? to : Math.max(first.length, second.length);\n  } else if (fromOrLength != null) {\n    start = 0;\n    end = fromOrLength;\n  } else {\n    start = 0;\n    end = Math.max(first.length, second.length);\n  }\n\n  if ((first.length <= end || second.length <= end) && first.length !== second.length) {\n    return false;\n  }\n\n  for (let i = start; i < end; ++i) {\n    if (!elementsAreEqual(first[i], second[i], i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Builds element or array of the given elements.\n *\n * @param source - A source of elements as their iterable or array-like container.\n *\n * @returns The only element of the `source`, an array of all elements of non-empty source, or `undefined` if the\n * `source` is empty.\n */\nexport function elementOrArray<T>(source: Iterable<T> | ArrayLike<T>): T | T[] | undefined {\n\n  const array = Array.from(source);\n  const { length } = array;\n\n  if (length) {\n    return length === 1 ? array[0] : array;\n  }\n\n  return;\n}\n","import { isArrayOfElements } from './array-of-elements';\n\n/**\n * Builds a set of the given element or array of elements.\n *\n * @param elements Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns A new set containing all of the given elements, or empty set if `elements` is `null` or `undefined`.\n */\nexport function setOfElements<T>(elements: T | readonly T[] | null | undefined): Set<T> {\n  return (/*#__INLINE__*/ isArrayOfElements(elements))\n      ? new Set(elements)\n      : (elements != null ? new Set([elements]) : new Set());\n}\n\n/**\n * Adds element of array of elements to the given set.\n *\n * Adds to the set a single element, all `elements` of the given array, or nothing when `elements` is `null`\n * or `undefined`.\n *\n * @param set - Target set to add elements to.\n * @param elements - Element(s) to add to the `set`. Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The target `set`.\n */\nexport function extendSetOfElements<T>(set: Set<T>, elements: T | readonly T[] | null | undefined): Set<T> {\n  if (/*#__INLINE__*/ isArrayOfElements(elements)) {\n    elements.forEach(element => set.add(element));\n  } else if (elements != null) {\n    set.add(elements);\n  }\n  return set;\n}\n","import type { Class } from './class';\n\n/**\n * Detects a super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @param type - The class constructor to find super class of.\n * @param satisfying - The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const prototype: object = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * A function that returns its argument as is.\n *\n * @param value - A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * Counts meaningful arguments passed to function.\n *\n * Ignores trailing `undefined` values.\n *\n * @param args - Function call arguments tuple.\n *\n * @returns The number of arguments, except for the trailing `undefined` values.\n */\nexport function countArgs(args: ArrayLike<unknown>): number {\n\n  let len = args.length;\n\n  while (len > 0) {\n\n    const idx = len - 1;\n\n    if (args[idx] !== undefined) {\n      break;\n    }\n\n    len = idx;\n  }\n\n  return len;\n}\n","/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @typeParam TArgs - Function parameter types as tuple.\n * @typeParam TReturn - A type of function result.\n * @typeParam TThis - A type if `this` object expected by function.\n * @param first - The first function to call.\n * @param second - The second function to call.\n * @param merge - Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: (this: TThis, ...args: TArgs) => TReturn,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge: (first: TReturn, second: TReturn) => TReturn,\n): (this: TThis, ...args: TArgs) => TReturn;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: (this: TThis, ...args: TArgs) => TReturn,\n    merge?: (first: TReturn, second: TReturn) => TReturn,\n): (this: TThis, ...args: TArgs) => TReturn;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge?: (first: TReturn, second: TReturn) => TReturn,\n): ((this: TThis, ...args: TArgs) => TReturn) | undefined;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge: (first: TReturn, second: TReturn) => TReturn = (_f, s) => s,\n): ((this: TThis, ...args: TArgs) => TReturn) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: TThis, ...args: TArgs): TReturn {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","import { noop } from '../fn';\nimport { lazyValue } from '../value';\n\n/**\n * A resolver of promise that can be created later or not created at all.\n *\n * Creates the promise only on demand.\n *\n * The methods of this object do not require `this` context and can be called as functions.\n */\nexport interface PromiseResolver<T = void> {\n\n  /**\n   * Resolves the promise.\n   *\n   * Has no effect when the promised is already settled.\n   *\n   * Can be called before the promise constructed.\n   *\n   * @param resolution - Either a promise value, or a promise-like instance resolving to one.\n   */\n  resolve(this: void, resolution: T | PromiseLike<T>): void;\n\n  /**\n   * Rejects the promise.\n   *\n   * Has no effect when the promised is already settled.\n   *\n   * Can be called before the promise constructed.\n   *\n   * @param reason - Promise rejection reason.\n   */\n  reject(this: void, reason?: any): void;\n\n  /**\n   * Creates a promise resolved by {@link resolve}, or rejected by {@link reject}.\n   *\n   * The subsequent calls to this method return the same promise instance.\n   *\n   * @returns Created promise.\n   */\n  promise(this: void): Promise<T>;\n\n}\n\n/**\n * Creates a promise resolver.\n *\n * @returns New promise resolver.\n */\nexport function newPromiseResolver<T = void>(): PromiseResolver<T> {\n\n  let resolvePromise: (value: T | PromiseLike<T>) => void;\n  let rejectPromise: (reason?: any) => void;\n  let buildPromise = lazyValue(() => new Promise<T>((resolve, reject) => {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n  }));\n  const settle = (resolution: () => Promise<T>): void => {\n    buildPromise = lazyValue(resolution);\n    resolvePromise = noop;\n    rejectPromise = noop;\n  };\n\n  resolvePromise = value => {\n    settle(() => Promise.resolve(value));\n  };\n  rejectPromise = error => {\n    settle(() => Promise.reject(error));\n  };\n\n  return {\n    resolve(value?) {\n      resolvePromise(value);\n    },\n    reject(reason) {\n      rejectPromise(reason);\n    },\n    promise() {\n      return buildPromise();\n    },\n  };\n}\n","import type { PropertyAccessorDescriptor } from './property-accessor-descriptor';\n\n/**\n * Creates a property accessor descriptor for the given field.\n *\n * @typeParam TObject - The type of target object.\n * @typeParam TKey - Target object property keys type.\n * @param target - The object containing target field.\n * @param fieldKey - Target field key.\n */\nexport function fieldAccessorDescriptor<TObject, TKey extends keyof TObject>(\n    target: TObject,\n    fieldKey: TKey,\n): PropertyAccessorDescriptor<TObject[TKey]> {\n\n  const value__symbol = Symbol(`${String(fieldKey)}:value`);\n\n  interface ValueHost {\n    [value__symbol]: TObject[TKey];\n  }\n\n  const initial: TObject[TKey] = target[fieldKey];\n\n  return {\n    configurable: true,\n    enumerable: true,\n    get(this: ValueHost): TObject[TKey] {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n    set(this: ValueHost, newValue) {\n      this[value__symbol] = newValue;\n    },\n  };\n}\n","/**\n * Property accessor descriptor. I.e. the one with `get` and `set` functions.\n *\n * @typeParam TValue - Property value type.\n */\nexport interface PropertyAccessorDescriptor<TValue> extends TypedPropertyDescriptor<TValue> {\n  enumerable?: boolean;\n  configurable?: boolean;\n  writable?: undefined;\n  value?: undefined;\n  get?: () => TValue;\n  set?: (value: TValue) => void;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @typeParam TValue - Property value type.\n * @param desc - Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nexport function isPropertyAccessorDescriptor<TValue>(\n    desc: TypedPropertyDescriptor<TValue>,\n): desc is PropertyAccessorDescriptor<TValue> {\n  return desc.value === undefined && desc.writable === undefined;\n}\n\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @typeParam TValue - Property value type.\n * @param desc - Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nexport function toPropertyAccessorDescriptor<TValue>(\n    desc: TypedPropertyDescriptor<TValue>,\n): PropertyAccessorDescriptor<TValue> {\n  if (isPropertyAccessorDescriptor(desc)) {\n    return desc;\n  }\n\n  const value__symbol = Symbol('value');\n\n  interface ValueHost {\n    [value__symbol]: TValue;\n  }\n\n  const initial = desc.value as TValue;\n\n  const accessorDesc: PropertyAccessorDescriptor<TValue> = {\n    ...desc,\n    writable: undefined,\n    value: undefined,\n    get(this: ValueHost) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n  };\n\n  if (desc.writable) {\n    accessorDesc.set = function (this: ValueHost, newValue: TValue) {\n      this[value__symbol] = newValue;\n    };\n  }\n\n  delete accessorDesc.writable;\n  delete accessorDesc.value;\n\n  return accessorDesc;\n}\n","/**\n * A function that checks whether the given value is present.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n"],"names":["arrayOfElements","value","Array","isArray","areTheSame","first","second","valueProvider","valuesProvider","values","lazyValue","provider","get","lazyValue$recurrent","TypeError","valueByRecipe","recipe","args","valueRecipe","arraysAreEqual","compareOrFromOrLength","fromOrLength","to","arrayElementsAreEqual","elementsAreEqual","start","end","undefined","Math","max","length","i","elementOrArray","source","array","from","setOfElements","elements","Set","extendSetOfElements","set","forEach","element","add","superClassOf","type","satisfying","prototype","Object","getPrototypeOf","superType","constructor","asis","countArgs","len","idx","mergeFunctions","merge","_f","s","apply","this","noop","newPromiseResolver","resolvePromise","rejectPromise","buildPromise","Promise","resolve","reject","settle","resolution","error","[object Object]","reason","promise","fieldAccessorDescriptor","target","fieldKey","value__symbol","Symbol","String","initial","configurable","enumerable","newValue","toPropertyAccessorDescriptor","desc","writable","isPropertyAccessorDescriptor","accessorDesc","isPresent","isDefined"],"mappings":"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"}