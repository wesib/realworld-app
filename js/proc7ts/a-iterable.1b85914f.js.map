{"version":3,"file":"a-iterable.1b85914f.js","sources":["../../../../../proc7ts/a-iterable/src/util.ts","../../../../../proc7ts/a-iterable/src/array.ts","../../../../../proc7ts/a-iterable/src/termination.ts","../../../../../proc7ts/a-iterable/src/transform.ts","../../../../../proc7ts/a-iterable/src/thru/thru-it.ts","../../../../../proc7ts/a-iterable/src/objects.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function *itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  yield* iterable;\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>,\n): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>,\n): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (reverse) {\n    (iterable as RevertibleIterable<T>).reverse = reverse;\n  }\n\n  return iterable;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * @internal\n */\nfunction arrayIterator<T>(array: ArrayLike<T>): Iterator<T> {\n\n  let i = 0;\n\n  return {\n    next(): IteratorResult<T> {\n      if (i < array.length) {\n        return { value: array[i++] };\n      }\n\n      return { done: true } as IteratorReturnResult<any>;\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction reverseArrayIterator<T>(array: ArrayLike<T>): Iterator<T> {\n\n  let i = array.length - 1;\n\n  return {\n    next(): IteratorResult<T> {\n      if (i < 0) {\n        return { done: true } as IteratorReturnResult<any>;\n      }\n      return { value: array[i--] };\n    },\n  };\n}\n\n/**\n * Builds a {@link RevertibleIterable revertible iterable} over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      () => arrayIterator(array),\n      () => reverseArray(array),\n  );\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt(\n      () => reverseArrayIterator(array),\n      () => overArray(array),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { isArrayLike } from '@proc7ts/primitives';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  // noinspection PointlessBooleanExpressionJS\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Tests whether at least one element of the given `iterable` passes the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n * and return `true` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the callback function returned a truthy value for at least one element in the array, or `false`\n * otherwise. Returns `false` for empty iterable.\n */\nexport function itsSome<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (test(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n\n  const result = itsIterator(iterable).next();\n\n  return result.done ? undefined : result.value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: R, element: T) => R,\n    initialValue: R,\n): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { asis } from '@proc7ts/primitives';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is R,\n): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (this: void, element: T) => boolean): Iterable<T> {\n  return {\n    [Symbol.iterator](): Iterator<T> {\n\n      const it = source[Symbol.iterator]();\n\n      return {\n        next(): IteratorResult<T> {\n          for (;;) {\n\n            const next = it.next();\n\n            if (next.done || test(next.value)) {\n              return next;\n            }\n          }\n        },\n      };\n    },\n  };\n}\n\n/**\n * Flattens the source iterable of iterables into a new iterable.\n *\n * Calling this function is the same as calling `flatMapIt(source, asis)`.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable of iterables.\n *\n * @returns A new iterable with each element of `source` being the flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): Iterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => Iterable<R>): Iterable<R>;\n\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R> = asis as (element: T) => Iterable<R>,\n): Iterable<R> {\n  return {\n    [Symbol.iterator](): Iterator<R> {\n\n      const it = source[Symbol.iterator]();\n      let cIt: Iterator<R> | undefined;\n\n      return {\n        next(): IteratorResult<R> {\n          for (;;) {\n            if (!cIt) {\n\n              const next = it.next();\n\n              if (next.done) {\n                return next;\n              }\n\n              cIt = convert(next.value)[Symbol.iterator]();\n            }\n\n            const cNext = cIt.next();\n\n            if (cNext.done) {\n              cIt = undefined;\n              continue;\n            }\n\n            return cNext;\n          }\n        },\n      };\n    },\n  };\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => R): Iterable<R> {\n  return {\n    [Symbol.iterator](): Iterator<R> {\n\n      const it = source[Symbol.iterator]();\n\n      return {\n        next(): IteratorResult<R> {\n\n          const next = it.next();\n\n          return next.done ? next : { value: convert(next.value) };\n        },\n      };\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { isNextCall, NextCall__symbol } from '@proc7ts/call-thru';\nimport { asis, noop } from '@proc7ts/primitives';\nimport { flatMapIt } from '../transform';\nimport { IterableCallChain } from './iterable-call-chain';\n/** @hidden */\nimport Args = IterableCallChain.Args;\n/** @hidden */\nimport Out = IterableCallChain.Out;\n\n/**\n * Passes each element of the given iterable trough the {@link IterableCallChain chain of transformation passes}.\n *\n * The passes are preformed by `@proc7ts/call-thru`.\n *\n * @returns An iterable of transformed elements.\n */\nexport function thruIt<\n    T, Return1\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n): Iterable<Out<Return1>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n): Iterable<Out<Return2>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n): Iterable<Out<Return3>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    Args13 extends Args<Return12>, Return13,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n    pass13: (this: void, ...args: Args13) => Return13,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<T>(\n    it: Iterable<T>,\n    ...passes: ((...args: any[]) => any)[]\n): Iterable<any> {\n\n  let result: Iterable<any>[] = [];\n  const chain = (index: number): IterableCallChain => {\n\n    const lastPass = index >= passes.length;\n\n    ++index;\n\n    const pass = index < passes.length ? passes[index] : noop;\n    const handleResult = (callResult: any, arg: any): void => {\n      if (isNextCall(callResult)) {\n        callResult[NextCall__symbol](chain(index), pass);\n      } else if (lastPass) {\n        result.push([arg]);\n      } else {\n        chain(index).pass(pass, callResult);\n      }\n    };\n\n    return ({\n      call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n        handleResult(fn(...args), args);\n      },\n      pass<A>(fn: (arg: A) => any, arg: A): void {\n        handleResult(fn(arg), arg);\n      },\n      skip() {/* skip item */},\n      iterate<I>(fn: (this: void, arg: I) => void, iterable: Iterable<I>): void {\n        result.push({\n          *[Symbol.iterator]() {\n            for (const item of iterable) {\n\n              const oldResult = result;\n              const newResult: Iterable<any>[] = [];\n\n              try {\n                result = newResult;\n                handleResult(fn(item), item);\n              } finally {\n                result = oldResult;\n              }\n\n              for (const res of newResult) {\n                yield* res;\n              }\n            }\n          },\n        });\n      },\n    });\n  };\n\n  chain(0).iterate(passes[0], it);\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return flatMapIt<any, any>(result, asis);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { overArray } from './array';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Builds an iterable over the keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys from.\n */\nexport function overKeys<T extends object>(target: T): RevertibleIterable<keyof T> {\n  return overArray(Reflect.ownKeys(target) as (keyof T)[]);\n}\n\n/**\n * Object property entry. This is a tuple consisting of property key and value.\n */\nexport type ObjectEntry<T, K extends keyof T = keyof T> = [K, T[K]];\n\n/**\n * Builds an iterable over the key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys and values from.\n */\nexport function overEntries<T extends object>(target: T): RevertibleIterable<ObjectEntry<T>> {\n\n  const targetKeys = overKeys(target);\n  const mapToEntries = (keys: Iterable<keyof T>): Iterable<ObjectEntry<T>> => mapIt(\n      keys,\n      key => [key, target[key]] as ObjectEntry<T>,\n  );\n\n  return makeIt(() => itsIterator(mapToEntries(targetKeys)), () => mapToEntries(targetKeys.reverse()));\n}\n"],"names":["itsIterator","iterable","Symbol","iterator","itsIterable","makeIt","iterate","reverse","[object Object]","overArray","array","i","next","length","value","done","arrayIterator","reverseArrayIterator","reverseArray","itsEach","action","element","itsEvery","test","itsFirst","result","undefined","itsReduction","reducer","initialValue","reduced","filterIt","source","it","flatMapIt","convert","asis","cIt","cNext","mapIt","thruIt","passes","chain","index","lastPass","pass","noop","handleResult","callResult","arg","isNextCall","NextCall__symbol","push","fn","args","item","oldResult","newResult","res","overEntries","target","targetKeys","Reflect","ownKeys","overKeys","mapToEntries","keys","key"],"mappings":"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"}