{"version":3,"file":"workbench.47577449.js","sources":["../../../../../proc7ts/workbench/src/work-done-error.ts","../../../../../proc7ts/workbench/src/workload.ts","../../../../../proc7ts/workbench/src/stages/ordered-tasks.impl.ts","../../../../../proc7ts/workbench/src/stages/work-ordering.impl.ts","../../../../../proc7ts/workbench/src/stages/work-stage.ts","../../../../../proc7ts/workbench/src/workbench.impl.ts","../../../../../proc7ts/workbench/src/workbench.ts"],"sourcesContent":["import type { Workload } from './workload';\n\n/**\n * An error indicating the work is already done.\n */\nexport class WorkDoneError<TWork = unknown> extends TypeError {\n\n  /**\n   * Constructs a work done error.\n   *\n   * @param workload - A workload the work is done for.\n   * @param work - The work already done, if any.\n   * @param reason - The reason of work failure, or `undefined` if the work completed successfully.\n   * @param message - Custom error message.\n   */\n  constructor(\n      readonly workload: Workload<TWork>,\n      readonly work: TWork | undefined,\n      readonly reason: unknown,\n      message = workload.workName(work) + (reason !== undefined\n          ? ` already terminated (${reason})`\n          : ' already done'),\n  ) {\n    super(message);\n  }\n\n}\n","import type { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport type { Workbench } from './workbench';\n\n/**\n * A workload able to perform a work within a workbench.\n *\n * The work specific to workload is represented by work instances. Such instances are available in {@link Workbench.work\n * workbench} and can be used e.g. to run workload-specific tasks.\n *\n * The same workload instance can be used in different workbenches.\n *\n * @typeParam TWork - A work type performed by this workload.\n */\nexport class Workload<TWork> {\n\n  /**\n   * Human-readable workload name.\n   */\n  readonly name: string;\n\n  /**\n   * Work allocator.\n   */\n  readonly allocator: Workload.Allocator<TWork>;\n\n  /**\n   * Constructs a workload.\n   *\n   * @param name - Human-readable workload name.\n   * @param allocator - A work allocator specific to constructed workload.\n   */\n  constructor(name: string, allocator: Workload.Allocator<TWork>) {\n    this.name = name;\n    this.allocator = allocator;\n  }\n\n  /**\n   * Builds a human-readable name of the work performed by this workload.\n   *\n   * This is used e.g. to construct a default error message for {@link WorkDoneError}.\n   *\n   * @param _work - Target work.\n   *\n   * @returns A string containing work name.\n   */\n  workName(_work?: TWork): string {\n    return `The work of ${this.name}`;\n  }\n\n  toString(): string {\n    return `Workload(${this.name})`;\n  }\n\n}\n\nexport namespace Workload {\n\n  /**\n   * Work allocator.\n   *\n   * Responsible for the work allocation for particular workload.\n   *\n   * @typeParam TWork - A work type performed by target workload.\n   */\n  export interface Allocator<TWork> {\n\n    /**\n     * Starts the work.\n     *\n     * @param allotment - Work allotment.\n     */\n    start(allotment: Allotment<TWork>): TWork;\n\n  }\n\n  /**\n   * Work allotment.\n   *\n   * Provided by workbench to {@link Allocator workload allocator} to allocate the work.\n   *\n   * @typeParam TWork - A work type performed by target workload.\n   */\n  export interface Allotment<TWork> extends SupplyPeer {\n\n    /**\n     * A workbench the work is allocated within.\n     */\n    readonly workbench: Workbench;\n\n    /**\n     * A workload to allocate the work for.\n     */\n    readonly workload: Workload<TWork>;\n\n    /**\n     * The work allotment supply.\n     *\n     * Once cut off the work is disposed. No more tasks would be accepted after that, while pending ones would\n     * fail.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Runs the task as part of the work.\n     *\n     * @typeParam TResult - A type of task result.\n     * @param task - A task to run.\n     *\n     * @returns A promise resolved to task result, or rejected if the work is {@link supply disposed} already.\n     */\n    run<TResult>(task: Workbench.Task<TResult>): Promise<TResult>;\n\n  }\n\n}\n","import type { Workbench } from '../workbench';\nimport type { Workload } from '../workload';\n\n/**\n * @internal\n */\nexport class OrderedTasks {\n\n  private readonly _queues = new Map<Workload<unknown>, TaskQueue>();\n\n  constructor(private readonly _allotment: Workload.Allotment<OrderedTasks>) {\n  }\n\n  runAfter<TResult>(workload: Workload<unknown>, task: Workbench.Task<TResult>): Promise<TResult> {\n\n    let queue = this._queues.get(workload);\n\n    if (!queue) {\n      queue = new TaskQueue(this._allotment);\n      this._queues.set(workload, queue);\n    }\n\n    return queue.enqueue(task);\n  }\n\n}\n\nclass TaskQueue {\n\n  /**\n   * Enqueued tasks.\n   *\n   * The subsequent tasks are waiting for preceding ones. The very first one is always running.\n   */\n  private readonly _tasks: TaskQueueEntry<unknown>[] = [];\n\n  constructor(readonly _allotment: Workload.Allotment<OrderedTasks>) {\n  }\n\n  enqueue<TResult>(task: Workbench.Task<TResult>): Promise<TResult> {\n    return new Promise(resolve => {\n\n      const entry: TaskQueueEntry<TResult> = {\n        task,\n        run: () => {\n          resolve(this._allotment.run(task).finally(() => {\n            // Remove from the queue.\n            this._tasks.shift();\n            // Run next.\n            this._runNext();\n          }));\n        },\n      };\n\n      this._tasks.push(entry);\n\n      if (this._tasks.length === 1) {\n        // The first task is just enqueued.\n        // Run it immediately, as there is nothing to wait for.\n        this._runNext();\n      }\n    });\n  }\n\n  private _runNext(): void {\n\n    const [first] = this._tasks;\n\n    if (first) {\n      first.run();\n    }\n  }\n\n}\n\ninterface TaskQueueEntry<TResult> {\n  readonly task: Workbench.Task<TResult>;\n  run(): void;\n}\n","import { Workload } from '../workload';\nimport { OrderedTasks } from './ordered-tasks.impl';\n\n/**\n * @internal\n */\nexport class WorkOrdering extends Workload<OrderedTasks> {\n\n  static readonly $ = new WorkOrdering();\n\n  private constructor() {\n    super('ordering', {\n      start(allotment: Workload.Allotment<OrderedTasks>): OrderedTasks {\n        return new OrderedTasks(allotment);\n      },\n    });\n  }\n\n}\n","import { noop, Supply, valueProvider } from '@proc7ts/primitives';\nimport { WorkDoneError } from '../work-done-error';\nimport type { Workbench } from '../workbench';\nimport { Workload } from '../workload';\nimport { WorkOrdering } from './work-ordering.impl';\n\nexport class WorkStage extends Workload<WorkStage.Work> {\n\n  constructor(name: string, allocator: WorkStage.Allocator = {}) {\n    super(\n        name,\n        {\n          start(allotment: Workload.Allotment<WorkStage.Work>): WorkStage.Work {\n\n            const { workbench, workload, supply } = allotment;\n            const runner = new WorkStageRunner(allotment, allocator);\n\n            return {\n\n              workbench,\n              stage: workload,\n              supply,\n\n              async run(task) {\n                return await runner.run(this, task);\n              },\n\n            };\n          },\n        },\n    );\n  }\n\n  workName(_work?: WorkStage.Work): string {\n    return `The ${this.name} stage`;\n  }\n\n  toString(): string {\n    return `WorkStage(${this.name})`;\n  }\n\n}\n\nexport namespace WorkStage {\n\n  export interface Allocator {\n\n    readonly after?: WorkStage;\n\n    start?(work: Work): void | PromiseLike<unknown>;\n\n  }\n\n  export interface Work {\n\n    readonly workbench: Workbench;\n\n    readonly stage: WorkStage;\n\n    readonly supply: Supply;\n\n    run<TResult>(task: Workbench.Task<TResult>): Promise<TResult>;\n\n  }\n\n}\n\nclass WorkStageRunner {\n\n  private readonly _whenAllDone: Promise<unknown>;\n  private _whenTaskDone: Promise<unknown> = Promise.resolve();\n  private _end!: (result?: PromiseLike<unknown>) => void;\n\n  constructor(\n      readonly allotment: Workload.Allotment<WorkStage.Work>,\n      readonly allocator: WorkStage.Allocator,\n  ) {\n\n    const { supply } = allotment;\n\n    this._whenAllDone = new Promise<unknown>(resolve => this._end = resolve)\n        .then(() => supply.off())\n        .catch(error => supply.off(error));\n\n    supply.whenOff(reason => {\n      if (reason === undefined) {\n        this._end();\n      } else {\n        this._end(Promise.reject(reason));\n      }\n\n      // Stop accepting new tasks.\n      this.run = (work, _task) => Promise.reject(\n          new WorkDoneError(allotment.workload, work, reason),\n      );\n    });\n  }\n\n  run<TResult>(work: WorkStage.Work, task: Workbench.Task<TResult>): Promise<TResult> {\n\n    const promise = this._start(work).then(() => this.allotment.run(task));\n\n    this._addTask(promise);\n\n    return promise;\n  }\n\n  private _addTask(taskPromise: Promise<unknown>): void {\n\n    const taskDone = this._whenTaskDone = Promise.all([\n      this._whenTaskDone,\n      taskPromise.catch(noop),\n    ]);\n\n    taskDone.finally(() => {\n      if (taskDone === this._whenTaskDone) {\n        this._end(taskDone);\n      }\n    });\n  }\n\n  private _start(work: WorkStage.Work): Promise<unknown> {\n\n    let whenStarted = this._awaitDeps();\n\n    if (this.allocator.start) {\n      whenStarted = whenStarted.then(async () => {\n        await this.allocator.start!(work);\n      });\n    }\n\n    // Start only once!\n    this._start = valueProvider(whenStarted);\n    this._addTask(whenStarted);\n\n    return whenStarted;\n  }\n\n  private _awaitDeps(): Promise<unknown> {\n\n    const deps: Promise<void>[] = [];\n    const addDep = (dep: WorkStage): void => {\n      deps.push(new Promise(resolve => {\n        this.allotment\n            .workbench\n            .work(WorkOrdering.$)\n            .runAfter(\n                dep,\n                () => {\n                  resolve();\n                  return this._whenAllDone;\n                },\n            )\n            .catch(noop);\n      }));\n    };\n\n    const { after } = this.allocator;\n\n    if (after) {\n      addDep(after);\n    }\n    addDep(this.allotment.workload);\n\n    return Promise.all(deps);\n  }\n\n}\n","import { alwaysSupply, noop, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { WorkDoneError } from './work-done-error';\nimport type { Workbench } from './workbench';\nimport type { Workload } from './workload';\n\n/**\n * @internal\n */\nexport const Workbench$impl__symbol = (/*#__PURE__*/ Symbol('Workbench.impl'));\n\n/**\n * @internal\n */\nexport class Workbench$ implements SupplyPeer {\n\n  readonly supply: Supply;\n  private readonly _works = new Map<Workload<unknown>, unknown>();\n  private readonly _run: Required<Workbench.Options>['run'];\n\n  constructor(readonly workbench: Workbench, options: Workbench.Options) {\n\n    const { supply = alwaysSupply(), run } = options;\n\n    this.supply = new Supply(reason => {\n      // Reject new work.\n      this.work = workload => {\n        throw new WorkDoneError(workload, undefined, reason, 'The workbench is stopped');\n      };\n    })\n        .needs(supply)\n        .cuts(supply);\n\n    this._run = run ? run.bind(options) : Workbench$run;\n  }\n\n  work<TWork>(workload: Workload<TWork>): TWork {\n    if (this._works.has(workload)) {\n      return this._works.get(workload) as TWork;\n    }\n\n    let ensureWorking: () => void = noop;\n    const runWorkTask = async <TResult>(\n        work: TWork,\n        task: Workbench.Task<TResult>,\n    ): Promise<TResult> => {\n\n      const result = await this._run(task, work, workload);\n\n      ensureWorking();\n\n      return result;\n    };\n    const supply = new Supply().needs(this.supply);\n\n    let setWork!: (work: TWork) => TWork;\n    let work: TWork | undefined;\n    let runTask: <TResult>(task: Workbench.Task<TResult>) => Promise<TResult>;\n\n    const whenWork = new Promise<TWork>(resolve => {\n      setWork = newWork => {\n        work = newWork;\n\n        this._works.set(workload, newWork);\n        runTask = async task => await runWorkTask(newWork, task);\n\n        resolve(newWork);\n\n        return newWork;\n      };\n    });\n\n    runTask = async task => await runWorkTask(await whenWork, task);\n\n    supply.whenOff(reason => {\n      runTask = ensureWorking = () => {\n        throw new WorkDoneError(workload, work, reason);\n      };\n      this._works.delete(workload);\n    });\n\n    return setWork(workload.allocator.start({\n      workbench: this.workbench,\n      workload,\n      supply,\n      async run<TResult>(task: Workbench.Task<TResult>) {\n        return await runTask(task);\n      },\n    }));\n  }\n\n}\n\nasync function Workbench$run<TResult, TWork>(\n    task: Workbench.Task<TResult>,\n    _work: TWork,\n    _workload: Workload<TWork>,\n): Promise<TResult> {\n  return await task();\n}\n","import type { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { Workbench$, Workbench$impl__symbol } from './workbench.impl';\nimport type { Workload } from './workload';\n\n/**\n * A workbench for coordinated {@link Workload workloads}.\n *\n * Performs a work by running tasks specific to each kind of workload.\n */\nexport class Workbench implements SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private readonly [Workbench$impl__symbol]: Workbench$;\n\n  /**\n   * Constructs a workbench.\n   *\n   * @param options - Constructed workbench options.\n   */\n  constructor(options: Workbench.Options = {}) {\n    this[Workbench$impl__symbol] = new Workbench$(this, options);\n  }\n\n  /**\n   * Workbench supply.\n   *\n   * Once cut off the workbench terminates all current works, and no longer accepts new ones.\n   */\n  get supply(): Supply {\n    return this[Workbench$impl__symbol].supply;\n  }\n\n  /**\n   * Obtains a work of the given workload.\n   *\n   * Caches the work previously obtained work of the same workload, until the work is {@link Workload.Allotment.supply\n   * disposed}. Creates a new work instance after that.\n   *\n   * @typeParam TWork - A work type.\n   * @param workload - Target workload.\n   *\n   * @returns A work instance.\n   */\n  work<TWork>(workload: Workload<TWork>): TWork {\n    return this[Workbench$impl__symbol].work(workload);\n  }\n\n}\n\nexport namespace Workbench {\n\n  /**\n   * A task to run by workbench.\n   *\n   * @typeParam TResult - A type of task result.\n   */\n  export type Task<TResult> =\n  /**\n   * @returns A task result evaluated synchronously, or a promise-like instance resolved to asynchronously evaluated\n   * result.\n   */\n      (this: void) => TResult | PromiseLike<TResult>;\n\n  /**\n   * Workbench construction options.\n   */\n  export interface Options {\n\n    /**\n     * Workbench supply to use.\n     *\n     * Once cut off the workbench terminates all current works, and no longer accepts new ones.\n     *\n     * A new one will be created when omitted.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Runs the given task.\n     *\n     * The default runner implementation will be used when omitted.\n     *\n     * @typeParam TResult - A type of task result.\n     * @typeParam TWork - A type of the work the task is part of.\n     * @param task - The task to run.\n     * @param work - The work instance the task is part of.\n     * @param workload - The workload the task is part of.\n     */\n    run?<TResult, TWork>(task: Task<TResult>, work: TWork, workload: Workload<TWork>): Promise<TResult>;\n\n  }\n\n}\n"],"names":["WorkDoneError","TypeError","[object Object]","workload","work","reason","message","workName","undefined","super","this","Workload","name","allocator","_work","OrderedTasks","_allotment","Map","task","queue","_queues","get","TaskQueue","set","enqueue","Promise","resolve","entry","run","finally","_tasks","shift","_runNext","push","length","first","WorkOrdering","start","allotment","WorkStage","workbench","supply","runner","WorkStageRunner","stage","_whenAllDone","_end","then","off","catch","error","whenOff","reject","_task","promise","_start","_addTask","taskPromise","taskDone","_whenTaskDone","all","noop","whenStarted","_awaitDeps","async","valueProvider","deps","addDep","dep","$","runAfter","after","Workbench$impl__symbol","Symbol","Workbench$","options","alwaysSupply","Supply","needs","cuts","_run","bind","Workbench$run","_works","has","ensureWorking","runWorkTask","result","setWork","runTask","whenWork","newWork","delete","_workload","Workbench"],"mappings":"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"}