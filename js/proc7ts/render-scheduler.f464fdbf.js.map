{"version":3,"file":"render-scheduler.f464fdbf.js","sources":["../../../../../proc7ts/render-scheduler/src/render-schedule.ts","../../../../../proc7ts/render-scheduler/src/custom-render-scheduler.ts","../../../../../proc7ts/render-scheduler/src/render-queue.ts","../../../../../proc7ts/render-scheduler/src/animation-render-scheduler.ts","../../../../../proc7ts/render-scheduler/src/immediate-render-scheduler.ts","../../../../../proc7ts/render-scheduler/src/render-scheduler.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { RenderShot } from './render-shot';\n\n/**\n * Render schedule signature.\n *\n * This function accepts a {@link RenderShot render shot} to schedule. All scheduled render shots are meant to update\n * the same rendering target. If multiple render shots scheduled before execution starts, only the last one will be\n * executed to limit rendering rate.\n *\n * The render shot execution may fail. This should not prevent other scheduled or postponed render shots from being\n * executed. The render shot execution failure reason is expected to be reported with [[RenderScheduleConfig.error]]\n * method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by [[newRenderSchedule]] function\n * that uses the {@link setRenderScheduler default scheduler} for that.\n */\nexport type RenderSchedule =\n/**\n * @param shot  A render shot to schedule.\n */\n    (this: void, shot: RenderShot) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by [[nodeWindow]] by default, if [[node]] is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing [[window]] option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error(...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render scheduler by its options.\n   *\n   * @param options  Render scheduler options the configuration should be base on.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n\n    return {\n      get node(): Node | undefined {\n        return options.node;\n      },\n      get window(): Window {\n        return win || (win = options.window || (options.node && nodeWindow(options.node)) || window);\n      },\n      error(...messages: any[]): void {\n        if (options && options.error) {\n          options.error(...messages);\n        } else {\n          console.error(...messages);\n        }\n      },\n    };\n  },\n\n};\n\n/**\n * Detects a window the given DOM node is attached to.\n *\n * @param node  Target DOM node.\n *\n * @returns A window of the owner document, or `null` if absent.\n */\nexport function nodeWindow(node: Node): Window | null {\n\n  const document = node.ownerDocument || node as Document;\n\n  return document.defaultView;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { RenderQueue } from './render-queue';\nimport { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to [[customRenderScheduler]] function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config  Render schedule configuration.\n   *\n   * @returns  A queue of scheduled render shots.\n   */\n  newQueue(config: RenderScheduleConfig): RenderQueue;\n\n}\n\n/**\n * @internal\n */\nconst RenderQ__symbol = Symbol('render-q');\n\n/**\n * @internal\n */\ninterface InternalRenderQueue extends RenderQueue {\n  [RenderQ__symbol]?: RenderQ;\n}\n\n/**\n * @internal\n */\nclass RenderQ {\n\n  readonly ref: [RenderQ, RenderQ];\n  schedule: (this: RenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: InternalRenderQueue, ref?: [RenderQ, RenderQ]): RenderQ {\n    return queue[RenderQ__symbol]\n        || (queue[RenderQ__symbol] = new RenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: RenderQueue, ref?: [RenderQ, RenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this, this];\n  }\n\n  add(shot: RenderShot): void {\n    this.q.add(shot);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    this.schedule = () => {/* do not schedule */};\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.unshift(shot);\n      },\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      // Activate next queue\n      this.ref[1] = this.ref[0];\n      // Schedule postponed shots (in reverse order)\n      postponed.forEach(shot => this.q.add(shot));\n      // Recurrently postponed shots are executed immediately after their initiators\n      execution.postpone = shot => this.q.post(shot);\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: RenderExecution): void {\n    for (; ;) {\n\n      const shot = this.q.pull();\n\n      if (!shot) {\n        break;\n      }\n      shot(execution);\n    }\n  }\n\n  private reset(): RenderQ {\n    // Update next queue. Current queue remains active\n    return this.ref[0] = RenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {/* do not schedule */};\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options  Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return (scheduleOptions?: RenderScheduleOptions): RenderSchedule => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef: readonly [RenderQ, RenderQ] = RenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [RenderQ, RenderShot, true?] | [] = [];\n\n    return (shot: RenderShot): void => {\n\n      const [lastQueue,, executed] = enqueued;\n      const [nextQueue, activeQueue] = queueRef;\n      let queue = lastQueue || activeQueue;\n\n      if (lastQueue === activeQueue && !executed || lastQueue === nextQueue) {\n        enqueued[1] = shot;\n      } else {\n\n        // Add to active queue initially, unless a shot executed in it already.\n        // Add to the next queue otherwise.\n        const nextEnqueued: [RenderQ, RenderShot, true?] = enqueued = [\n          queue = executed ? nextQueue : activeQueue,\n          shot,\n        ];\n\n        queue.add((execution: RenderExecution) => {\n          nextEnqueued[2] = true; // Switch to next queue\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      queue.schedule(config);\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { RenderShot } from './render-shot';\n\n/**\n * A queue of scheduled render shots.\n *\n * Utilized by render scheduler in order to collect render shots and schedule their execution.\n *\n * The default implementation may be constructed using [[RenderQueue.by]] function.\n */\nexport interface RenderQueue {\n\n  /**\n   * Adds a render shot to this queue.\n   *\n   * @param shot  Scheduled render shot to add.\n   */\n  add(shot: RenderShot): void;\n\n  /**\n   * Adds a render shot to the head of this queue.\n   *\n   * @param shot  Scheduled render shot to add.\n   */\n  post(shot: RenderShot): void;\n\n  /**\n   * Retrieves the first added render shot and removes it from the queue.\n   *\n   * @returns  Either pulled out render shot, or `undefined` when there is no more render shots.\n   */\n  pull(): RenderShot | undefined;\n\n  /**\n   * Schedules queued render shots execution.\n   *\n   * @param task  A function that performs render shots execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled render shots from now on.\n   */\n  reset(): RenderQueue;\n\n}\n\nexport const RenderQueue = {\n\n  /**\n   * Builds the default implementation of render queue.\n   *\n   * @param schedule  Schedules queued render shots execution. This is an implementation of [[RenderQueue.schedule]]\n   * method.\n   * @param replace  Called right after [[RenderQueue.reset]] method in order to inform on the queue that will collect\n   * scheduled render shots from now.\n   *\n   * @returns New render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = (): void => {/* do not replace */},\n      }: {\n        schedule(this: RenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: RenderQueue): void;\n      },\n  ): RenderQueue {\n\n    const shots: RenderShot[] = [];\n\n    return {\n      schedule,\n      add(shot: RenderShot): void {\n        shots.push(shot);\n      },\n      post(shot: RenderShot): void {\n        shots.unshift(shot);\n      },\n      pull(): RenderShot | undefined {\n        return shots.shift();\n      },\n      reset(): RenderQueue {\n\n        const next = RenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, RenderQueue>());\n\n/**\n * A render scheduler that executes scheduled render shots within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The render shots scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link RenderExecution.postpone postponed} render shots are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = RenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","import { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Render scheduler that executes render shots immediately.\n *\n * @param options\n */\nexport const immediateRenderScheduler: RenderScheduler = (options?: RenderScheduleOptions): RenderSchedule => {\n\n  const config = RenderScheduleConfig.by(options);\n\n  return (shot: RenderShot): void => {\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.push(shot);\n      },\n    };\n\n    execute(shot);\n    for (; ;) {\n\n      const last = postponed.pop();\n\n      if (!last) {\n        break;\n      }\n\n      execute(last);\n    }\n\n    function execute(shot: RenderShot): void {\n      try {\n        shot(execution);\n      } catch (e) {\n        config.error(e);\n      }\n    }\n  };\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { animationRenderScheduler } from './animation-render-scheduler';\nimport { RenderSchedule, RenderScheduleOptions } from './render-schedule';\n\n/**\n * Render scheduler signature.\n *\n * This function constructs a {@link RenderSchedule render schedule} according to the given options.\n *\n * The default render scheduler is always available as [[newRenderSchedule]] function.\n *\n * There are several scheduler implementations exist:\n * - [[animationRenderScheduler]] (used by default),\n * - [[asyncRenderScheduler]],\n * - [[immediateRenderScheduler]],\n * - [[ManualRenderScheduler]],\n * - [[noopRenderScheduler]].\n *\n * Custom scheduler implementations could be created using [[customRenderScheduler]] function.\n */\nexport type RenderScheduler =\n/**\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: RenderScheduleOptions) => RenderSchedule;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler  New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n"],"names":["RenderScheduleConfig","[object Object]","options","win","node","window","ownerDocument","defaultView","messages","error","console","RenderQ__symbol","Symbol","RenderQ","q","ref","this","schedule","doSchedule","queue","shot","add","config","postponed","execution","unshift","next","reset","suspend","exec","forEach","postpone","post","resume","pull","by","scheduled","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","executed","nextQueue","activeQueue","nextEnqueued","e","RenderQueue","replace","shots","push","shift","animationRenderQueues","WeakMap","immediateRenderScheduler","execute","last","pop","defaultRenderScheduler","existing","get","task","requestAnimationFrame","replacement","set","newRenderSchedule"],"mappings":"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"}