{"version":3,"file":"push-iterator.f6f3343e.js","sources":["../../../../../proc7ts/push-iterator/src/push-iterable.ts","../../../../../proc7ts/push-iterator/src/base/is-push-iterable.ts","../../../../../proc7ts/push-iterator/src/base/iterator-of.ts","../../../../../proc7ts/push-iterator/src/base/make-push-iterable.ts","../../../../../proc7ts/push-iterator/src/base/push-iterated.ts","../../../../../proc7ts/push-iterator/src/base/make-push-iterator.ts","../../../../../proc7ts/push-iterator/src/base/push-head.ts","../../../../../proc7ts/push-iterator/src/base/iterate-over-array.impl.ts","../../../../../proc7ts/push-iterator/src/base/iterate-over-indexed.impl.ts","../../../../../proc7ts/push-iterator/src/construction/over-array.ts","../../../../../proc7ts/push-iterator/src/consumption/its-iterated.ts","../../../../../proc7ts/push-iterator/src/consumption/its-each.ts","../../../../../proc7ts/push-iterator/src/consumption/its-elements.ts","../../../../../proc7ts/push-iterator/src/consumption/its-every.ts","../../../../../proc7ts/push-iterator/src/consumption/its-first.ts","../../../../../proc7ts/push-iterator/src/base/raw-iterator.impl.ts","../../../../../proc7ts/push-iterator/src/consumption/its-head.ts","../../../../../proc7ts/push-iterator/src/consumption/its-reduction.ts","../../../../../proc7ts/push-iterator/src/construction/over-none.ts","../../../../../proc7ts/push-iterator/src/construction/over-iterator.ts","../../../../../proc7ts/push-iterator/src/construction/over-elements-of.ts","../../../../../proc7ts/push-iterator/src/construction/over-iterable.ts","../../../../../proc7ts/push-iterator/src/construction/over-one.ts","../../../../../proc7ts/push-iterator/src/transformation/filter-array.ts","../../../../../proc7ts/push-iterator/src/transformation/iterate-over-filtered-indexed.impl.ts","../../../../../proc7ts/push-iterator/src/transformation/filter-it.ts","../../../../../proc7ts/push-iterator/src/transformation/flat-map-array.ts","../../../../../proc7ts/push-iterator/src/transformation/iterate-over-flattened-indexed.impl.ts","../../../../../proc7ts/push-iterator/src/transformation/flat-map-it.ts","../../../../../proc7ts/push-iterator/src/transformation/map-it.ts","../../../../../proc7ts/push-iterator/src/objects/over-entries.ts","../../../../../proc7ts/push-iterator/src/objects/over-keys.ts","../../../../../proc7ts/push-iterator/src/call-thru/thru-it.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterator } from './push-iterator';\n\n/**\n * A key of {@link PushIterable} iteration method.\n */\nexport const PushIterator__symbol = (/*#__PURE__*/ Symbol('push-iterator'));\n\n/**\n * An iterable implementing push iteration protocol.\n *\n * @typeParam T - Iterated elements type.\n */\nexport interface PushIterable<T> extends Iterable<T> {\n\n  /**\n   * Creates a {@link PushIterator | push iterator} over elements of this iterable.\n   *\n   * @returns New push iterator instance.\n   */\n  [Symbol.iterator](): PushIterator<T>;\n\n  /**\n   * Iterates over elements of this push iterable.\n   *\n   * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n   * `true` or `false`.\n   *\n   * Calling this method with `accept` parameter is a faster alternative to creating a push iterator and iterating with\n   * it.\n   *\n   * Calling this method without arguments is the same as calling `[Symbol.iterator]()` one.\n   *\n   * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<T>): PushIterator<T>;\n\n}\n\nexport namespace PushIterable {\n\n  /**\n   * A signature of function conforming to push iteration protocol.\n   *\n   * Used as `PushIterable[PushIterator__symbol]` method implementation when passed to {@link makePushIterable}\n   * function.\n   *\n   * @typeParam T - Iterated elements type.\n   */\n  export type Iterate<T> =\n  /**\n   * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n      (this: void, accept?: PushIterator.Acceptor<T>) => PushIterator<T>;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Checks whether the given iterable conforms to {@link PushIterable | push iteration protocol}.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to check.\n *\n * @returns `true` if the given `iterable` has a {@link PushIterator__symbol [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterable: Iterable<T>): iterable is PushIterable<T>;\n\n/**\n * Checks whether the given iterator conforms to {@link PushIterable | push iteration protocol}.\n *\n * @typeParam T - Iterated elements type.\n * @param iterator - An iterator to check.\n *\n * @returns `true` if the given `iterator` has a {@link PushIterator__symbol | [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterator: Iterator<T>): iterator is PushIterator<T>;\n\nexport function isPushIterable<T>(iterable: Iterable<T> | Iterator<T>): iterable is PushIterator<T> {\n  return !!(iterable as Partial<PushIterable<T>>)[PushIterator__symbol];\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterator over elements of the given push `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to construct iterator of.\n *\n * @returns Push iterator.\n */\nexport function iteratorOf<T>(iterable: PushIterable<T>): PushIterator<T>;\n\n/**\n * Creates an iterable iterator over elements of the given `iterable` supporting iterable iteration.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to construct iterator of.\n *\n * @returns Iterable iterator.\n */\nexport function iteratorOf<T>(iterable: { [Symbol.iterator](): IterableIterator<T> }): IterableIterator<T>;\n\n/**\n * Creates iterator over elements of the given `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to construct iterator of.\n *\n * @returns Either push or raw iterator.\n */\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T>;\n\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterable implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function iterating over iterable elements conforming to {@link PushIterable.Iterate} requirements.\n *\n * @returns New push iterable instance performing iteration by `forNext` function.\n */\nexport function makePushIterable<T>(iterate: PushIterable.Iterate<T>): PushIterable<T> {\n  return {\n    [Symbol.iterator]: PushIterable$iterator,\n    [PushIterator__symbol]: iterate,\n  };\n}\n\n/**\n * @internal\n */\nfunction PushIterable$iterator<T>(this: PushIterable<T>): PushIterator<T> {\n  return this[PushIterator__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `!iterable[PushIterator__symbol](accept).isOver()`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function pushIterated<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  return !iterable[PushIterator__symbol](accept).isOver();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { pushIterated } from './push-iterated';\n\n/**\n * Creates a push iterator implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param forNext - A function iterating over elements conforming to push iteration protocol.\n *\n * @returns New push iterator instance performing iteration by `forNext` function.\n */\nexport function makePushIterator<T>(forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if (accept && !forNext(accept)) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n    }\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next: PushIterator$next,\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function PushIterator$iterator<T>(this: T): T {\n  return this;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$next<T>(this: PushIterator<T>): IteratorResult<T> {\n  for (; ;) {\n\n    let result: IteratorYieldResult<T> | undefined;\n    const over = !pushIterated(\n        this,\n        value => {\n          result = { value };\n          return true;\n        },\n    );\n\n    if (result) {\n      return result;\n    }\n    if (over) {\n      return { done: true } as IteratorReturnResult<T>;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function PushIterator$noNext<T>(): IteratorReturnResult<T> {\n  return { done: true } as IteratorReturnResult<T>;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$dontIterate<T>(\n    _accept?: PushIterator.Acceptor<T>, // unused parameter to prevent deoptimization\n): void {\n  /* do not iterate */\n}\n\n/**\n * @internal\n */\nexport const emptyPushIterator: PushIterator<any> & PushIterable<any> = {\n  [Symbol.iterator]: PushIterator$iterator,\n  [PushIterator__symbol](\n      _accept, // unused parameter to prevent deoptimization\n  ) {\n    return this;\n  },\n  next: () => ({ done: true } as IteratorReturnResult<unknown>),\n  isOver: () => true,\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over the head elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `iterable[PushIterator__symbol](accept)`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function pushHead<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return iterable[PushIterator__symbol](accept);\n}\n","import type { PushIterable } from '../push-iterable';\nimport { iterateOverIndexed } from './iterate-over-indexed.impl';\n\n/**\n * @internal\n */\nexport function arrayElementOf<T>(array: ArrayLike<T>, index: number): T {\n  return array[index];\n}\n\n/**\n * @internal\n */\nexport function iterateOverArray<T>(array: ArrayLike<T>): PushIterable.Iterate<T> {\n  return iterateOverIndexed<ArrayLike<T>, T>(array, arrayElementOf);\n}\n","import type { IndexedItemList } from '../construction';\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport {\n  emptyPushIterator,\n  PushIterator$dontIterate,\n  PushIterator$iterator,\n  PushIterator$noNext,\n} from './make-push-iterator';\n\n/**\n * @internal\n */\nexport interface IndexedElements {\n\n  readonly length: number;\n\n}\n\n/**\n * @internal\n */\nexport function indexedItemOf<T>(indexed: IndexedItemList<T>, index: number): T {\n  return indexed.item(index) as T; // The index is always valid.\n}\n\n/**\n * @internal\n */\nexport function iterateOverIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementOf: (indexed: TIndexed, index: number) => T,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= indexed.length) {\n        return false;\n      }\n      for (; ;) {\n\n        const goOn = accept(elementOf(indexed, i++));\n\n        if (i >= indexed.length || goOn === false) {\n          return false;\n        }\n        if (goOn === true) {\n          return true;\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return emptyPushIterator;\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      if (i < indexed.length) {\n        return { value: elementOf(indexed, i++) };\n      }\n\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n\n      return { done: true } as IteratorReturnResult<T>;\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { iterateOverArray } from '../base/iterate-over-array.impl';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of array-like structure.\n *\n * @typeParam T - Array elements type.\n * @param array - An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns New push iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): PushIterable<T> {\n  return makePushIterable<T>(iterateOverArray(array));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushIterated} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function itsIterated<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  if (isPushIterable(iterable)) {\n    return pushIterated(iterable, accept);\n  }\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushIterated(it, accept);\n  }\n\n  for (; ;) {\n\n    const next = it.next();\n\n    if (next.done) {\n      return false;\n    }\n\n    const status = accept(next.value);\n\n    if (typeof status === 'boolean') {\n      return status;\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable of elements to perform actions on.\n * @param action - An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  itsIterated(iterable, element => { action(element); });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * @internal\n */\nconst itsElements$defaultConverter = <T, TConv>(element: T): TConv => element as unknown as TConv;\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable.\n *\n * Calling this function result to the same result as calling `Array.from(source)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T - Iterated elements type.\n * @param source - A source iterable to copy elements from.\n *\n * @returns New array of `source` elements.\n */\nexport function itsElements<T>(source: Iterable<T>): T[];\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable converted by the given\n * converter function.\n *\n * Calling this function result to the same result as calling `Array.from(source, convert)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TConv - Resulting array elements type.\n * @param source - A source iterable to convert elements from.\n * @param convert - A function that produces an element of result array, taking element of `source` iterable as the only\n * parameter.\n *\n * @returns New array of elements converted from `source` ones.\n */\nexport function itsElements<T, TConv>(source: Iterable<T>, convert: (this: void, element: T) => TConv): TConv[];\n\nexport function itsElements<T, TConv>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => TConv = itsElements$defaultConverter,\n): TConv[] {\n  if (isPushIterable(source)) {\n    return pushedElements(source, convert);\n  }\n\n  const it = iteratorOf(source);\n\n  return isPushIterable(it) ? pushedElements(it, convert) : Array.from(source, convert);\n}\n\n/**\n * @internal\n */\nfunction pushedElements<T, TConv>(\n    it: PushIterable<T>,\n    convert: (this: void, element: T) => TConv,\n): TConv[] {\n\n  const result: TConv[] = [];\n\n  pushIterated(it, element => { result.push(convert(element)); });\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to test elements of.\n * @param test - A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(\n    iterable: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): boolean {\n\n  let allMatch = true;\n\n  itsIterated(\n      iterable,\n      element => {\n        allMatch = !!test(element);\n        if (!allMatch) {\n          return false;\n        }\n        return;\n      },\n  );\n\n  return allMatch;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Extracts the first element of the given `iterable`, if any.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to extract element from.\n *\n * @returns Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  if (isPushIterable(iterable)) {\n    return pushedFirst(iterable);\n  }\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? pushedFirst(it) : rawFirst(it);\n}\n\n/**\n * @internal\n */\nfunction pushedFirst<T>(it: PushIterable<T>): T | undefined {\n\n  let first: T | undefined;\n\n  pushIterated(\n      it,\n      element => {\n        first = element;\n        return false;\n      },\n  );\n\n  return first;\n}\n\n/**\n * @internal\n */\nfunction rawFirst<T>(it: Iterator<T>): T | undefined {\n\n  const result = it.next();\n\n  return result.done ? undefined : result.value;\n}\n","import { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from './make-push-iterator';\n\n/**\n * @internal\n */\nexport function toPushIterator<T>(it: Iterator<T>, forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if ((over = !!accept && !forNext(accept))) {\n      iterate = PushIterator$dontIterate;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      next = PushIterator$noNext;\n    }\n  };\n  let next = (): IteratorResult<T> => {\n\n    const res = it.next();\n\n    if (res.done) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n    }\n\n    return res;\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next() {\n      return next();\n    },\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function rawIteratorPusher<T>(it: Iterator<T>): PushIterator.Pusher<T> {\n  return accept => {\n    for (; ;) {\n\n      const res = it.next();\n\n      if (res.done) {\n        return false;\n      }\n\n      const status = accept(res.value);\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushHead } from '../base';\nimport { iterateOverArray } from '../base/iterate-over-array.impl';\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushHead} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function itsHead<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  if (isPushIterable(iterable)) {\n    return pushHead(iterable, accept);\n  }\n  if (Array.isArray(iterable)) {\n    return arrayHead(iterable, accept);\n  }\n  return rawIterableHead(iterable, accept);\n}\n\n/**\n * @internal\n */\nfunction arrayHead<T>(array: ArrayLike<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return array.length ? iterateOverArray(array)(accept) : emptyPushIterator;\n}\n\n/**\n * @internal\n */\nfunction rawIterableHead<T>(\n    iterable: Iterable<T>,\n    accept: PushIterator.Acceptor<T>,\n): PushIterator<T> {\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushHead(it, accept);\n  }\n\n  const forEach = rawIteratorPusher(it);\n\n  return forEach(accept) ? toPushIterator(it, forEach) : emptyPushIterator;\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TResult - A type of reduced value.\n * @param iterable - An iterable to reduce values of.\n * @param reducer - A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue - Initial value passed to the first `reducer` call.\n *\n * @returns Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, TResult>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: TResult, element: T) => TResult,\n    initialValue: TResult,\n): TResult {\n\n  let reduced = initialValue;\n\n  itsIterated(iterable, element => { reduced = reducer(reduced, element); });\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Returns a {@link PushIterator | push iterable iterator} without elements.\n *\n * @typeParam T - Iterated elements type.\n *\n * @returns Empty push iterable and push iterator instance.\n */\nexport function overNone<T>(): PushIterable<T> & PushIterator<T> {\n  return emptyPushIterator;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, makePushIterable } from '../base';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of iterator created by the given function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function creating new iterator.\n *\n * @returns New push iterable over elements of created iterator.\n */\nexport function overIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable<T> {\n  return makePushIterable(iterateOverRawIterator(iterate));\n}\n\n/**\n * @internal\n */\nfunction iterateOverRawIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable.Iterate<T> {\n  return accept => {\n\n    const it = iterate();\n\n    if (isPushIterable(it)) {\n      return it[PushIterator__symbol](accept);\n    }\n\n    const forNext = rawIteratorPusher(it);\n\n    return accept && !forNext(accept) ? overNone() : toPushIterator(it, forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable, makePushIterator } from '../base';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { overIterable } from './over-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of other iterables.\n *\n * @typeParam T - Iterated elements type.\n * @param sources - Source iterables to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `sources`.\n */\nexport function overElementsOf<T>(...sources: readonly Iterable<T>[]): PushIterable<T> {\n  return sources.length > 1\n      ? makePushIterable(iterateOverSubElements(sources))\n      : (sources.length\n          ? overIterable(sources[0])\n          : overNone());\n}\n\n/**\n * @internal\n */\nfunction iterateOverSubElements<T>(sources: readonly Iterable<T>[]): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let src: Iterable<T> = sources[0];\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        let status: boolean | void;\n        const srcTail = itsHead(src, element => status = accept(element));\n\n        if (srcTail.isOver()) {\n          if (++i >= sources.length) {\n            return false;\n          }\n\n          src = sources[i];\n        } else {\n          src = srcTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { iteratorOf } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { overArray } from './over-array';\nimport { overIterator } from './over-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of the given raw iterable.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `iterable`.\n */\nexport function overIterable<T>(iterable: Iterable<T>): PushIterable<T> {\n  return Array.isArray(iterable)\n      ? overArray<T>(iterable)\n      : overIterator(() => iteratorOf(iterable));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { PushIterator$iterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over one value.\n *\n * @typeParam T - Iterated element value type.\n * @param value - A value to iterate over.\n *\n * @returns New push iterable over the given value.\n */\nexport function overOne<T>(value: T): PushIterable<T> {\n  return makePushIterable(iterateOverOneValue(value));\n}\n\n/**\n * @internal\n */\nfunction iterateOverOneValue<T>(value: T): PushIterable.Iterate<T> {\n  return accept => {\n    if (accept) {\n      accept(value);\n      return overNone();\n    }\n\n    let over = false;\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        if (over) {\n          return overNone();\n        }\n        if (accept) {\n          over = true;\n          accept(value);\n          return overNone();\n        }\n        return this;\n      },\n      next() {\n        if (over) {\n          return { done: over } as IteratorReturnResult<undefined>;\n        }\n\n        over = true;\n\n        return { value };\n      },\n      isOver: () => over,\n    };\n\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { arrayElementOf } from '../base/iterate-over-array.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { iterateOverFilteredIndexed } from './iterate-over-filtered-indexed.impl';\n\n/**\n * Creates a {@link PushIterable push iterable} with all `array` elements extending the given type.\n *\n * @typeParam T - A type of array elements.\n * @typeParam TTarget - Target type.\n * @param array - A source array.\n * @param test - A predicate function to test that element extends the type `TTarget`. Returns `true` to keep the\n * element, or `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T, TTarget extends T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => element is TTarget,\n): PushIterable<TTarget>;\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `array` elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T - A type of array elements.\n * @param array - A source array.\n * @param test - A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(iterateOverFilteredIndexed(array, arrayElementOf, test));\n}\n","import type { IndexedElements } from '../base/iterate-over-indexed.impl';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from '../base/make-push-iterator';\nimport { overNone } from '../construction';\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverFilteredIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementOf: (indexed: TIndexed, index: number) => T,\n    test: (this: void, element: T) => boolean,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n        if (i >= indexed.length) {\n          return false;\n        }\n\n        const value = elementOf(indexed, i++);\n\n        if (test(value)) {\n\n          const status = accept(value);\n\n          if (typeof status === 'boolean') {\n            return status;\n          }\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return overNone();\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      for (; ;) {\n        if (i >= indexed.length) {\n          over = true;\n          iterate = PushIterator$dontIterate;\n          next = PushIterator$noNext;\n          return { done: true } as IteratorReturnResult<T>;\n        }\n\n        const value = elementOf(indexed, i++);\n\n        if (test(value)) {\n          return { value };\n        }\n      }\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `source` iterable elements extending the given type.\n *\n * @typeParam T - A type of source elements.\n * @typeParam TTarget - Target type.\n * @param source - A source iterable.\n * @param test - A predicate function to test that element extends the type `TTarget`. Returns `true` to keep the\n * element, or`false` otherwise. It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T, TTarget extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is TTarget,\n): PushIterable<TTarget>;\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `source` iterable elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T - A type of source elements.\n * @param source - A source iterable.\n * @param test - A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? filterPusher(source, test) : filterRawPusher(source, test);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction filterPusher<T>(\n    source: PushIterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n  return accept => {\n\n    const tail = pushHead(\n        source,\n        element => {\n          if (test(element)) {\n            return accept(element);\n          }\n          return;\n        },\n    );\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction filterRawPusher<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return filterPusher(it, test);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const value = next.value;\n\n      if (test(value)) {\n\n        const status = accept(value);\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { iterateOverFlattenedIndexed } from './iterate-over-flattened-indexed.impl';\n\n/**\n * Flattens the source `array` of iterables into new {@link PushIterable | push iterable}.\n *\n * Calling this function is the same as calling `flatMapArray(source, element => element)`.\n *\n * @typeParam T - A type of converted elements.\n * @param array - A source array-like instance of iterables.\n *\n * @returns New push iterable with each element of `array` being flattened.\n */\nexport function flatMapArray<T>(array: ArrayLike<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the source `array` using a mapping function, then flattens the result into new\n * {@link PushIterable | push iterable}.\n *\n * @typeParam TSrc - A type of array elements.\n * @typeParam TConv - A type of converted elements.\n * @param array - A source array-like instance of elements to convert.\n * @param convert - A function that produces new iterable, taking array element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapArray<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv>;\n\nexport function flatMapArray<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    convert?: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv> {\n  return makePushIterable(iterateOverFlattenedIndexed<ArrayLike<TSrc>, TConv>(\n      array,\n      convert\n          ? (array, index) => convert(array[index])\n          : flatMapArray$defaultElementOf,\n  ));\n}\n\n/**\n * @internal\n */\nfunction flatMapArray$defaultElementOf<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    index: number,\n): Iterable<TConv> {\n  return array[index] as unknown as Iterable<TConv>;\n}\n\n","import { makePushIterator } from '../base';\nimport type { IndexedElements } from '../base/iterate-over-indexed.impl';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverFlattenedIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementsOf: (indexed: TIndexed, index: number) => Iterable<T>,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let subs: Iterable<T> | undefined;\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= indexed.length) {\n        return false;\n      }\n      if (!subs) {\n        subs = elementsOf(indexed, i);\n      }\n\n      for (; ;) {\n\n        let status: boolean | void;\n        const subsTail: PushIterator<T> = itsHead<T>(subs, element => status = accept(element));\n\n        if (subsTail.isOver()) {\n          if (++i >= indexed.length) {\n            return false;\n          }\n          subs = elementsOf(indexed, i);\n        } else {\n          subs = subsTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Flattens the source iterable of iterables into new {@link PushIterable | push iterable}.\n *\n * Calling this function is the same as calling `flatMapIt(source, element => element)`.\n *\n * @typeParam T - A type of converted elements.\n * @param source - A source iterable of iterables.\n *\n * @returns New push iterable with each element of `source` being flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into new\n * {@link PushIterable | push iterable}.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable of elements to convert.\n * @param convert - A function that produces new iterable, taking the source element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv>;\n\nexport function flatMapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv> = flatMapIt$defaultConverter,\n): PushIterable<TConv> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? flatMapPusher(source, convert) : flatMapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction flatMapPusher<TSrc, TConv>(\n    source: PushIterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterator.Pusher<TConv> {\n\n  let subs: Iterable<TConv> | undefined;\n  let lastSrc = false;\n\n  return accept => {\n    for (; ;) {\n      while (!subs) {\n\n        const sourceTail = pushHead(source, src => {\n          subs = convert(src);\n          return true;\n        });\n\n        source = sourceTail;\n\n        if (sourceTail.isOver()) {\n          if (!subs) {\n            return false;\n          }\n          lastSrc = true;\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<TConv> = itsHead(subs, element => status = accept(element));\n\n      if (subsTail.isOver()) {\n        subs = undefined;\n        if (lastSrc) {\n          return false;\n        }\n      } else {\n        subs = subsTail;\n      }\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapRawPusher<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterator.Pusher<TConv> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return flatMapPusher(it, convert);\n  }\n\n  let subs: Iterable<TConv> | undefined;\n\n  return accept => {\n    for (; ;) {\n      if (!subs) {\n\n        const next = it.next();\n\n        if (next.done) {\n          return false;\n        }\n\n        subs = convert(next.value);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<TConv> = itsHead(subs, element => status = accept(element));\n\n      subs = subsTail.isOver() ? undefined : subsTail;\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapIt$defaultConverter<T, TConv>(\n    element: T,\n): Iterable<TConv> {\n  return element as unknown as Iterable<TConv>;\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every element\n * of the `source` iterable.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable.\n * @param convert - A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nexport function mapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterable<TConv> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? mapPusher(source, convert) : mapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction mapPusher<TSrc, TConv>(\n    source: PushIterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterator.Pusher<TConv> {\n  return accept => {\n\n    const tail = pushHead(source, element => accept(convert(element)));\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction mapRawPusher<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterator.Pusher<TConv> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return mapPusher(it, convert);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const status = accept(convert(next.value));\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport { mapIt } from '../transformation';\nimport type { ObjectEntry } from './object-entry';\nimport { overKeys } from './over-keys';\n\n/**\n * Creates a {@link PushIterable | push iterable} over the property key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Object type.\n *\n * @param source - An object to select keys and values from.\n *\n * @returns New push iterable of object property entries.\n */\nexport function overEntries<TObj extends object>(source: TObj): PushIterable<ObjectEntry<TObj>> {\n  return mapIt(\n      overKeys(source),\n      key => [key, source[key]],\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { overArray } from '../construction';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} over keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Source object type.\n * @param source - An object to select keys from.\n *\n * @returns New push iterable over own object keys retrieved by `Reflect.ownKeys()`.\n */\nexport function overKeys<TObj extends object>(source: TObj): PushIterable<keyof TObj> {\n  return overArray(Reflect.ownKeys(source) as (keyof TObj)[]);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator/call-thru\n */\nimport { isNextCall, NextCall__symbol } from '@proc7ts/call-thru';\nimport { overOne } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport { flatMapArray, flatMapIt } from '../transformation';\nimport type { IterableCallChain } from './iterable-call-chain';\n\ntype Args<TReturn> = IterableCallChain.Args<TReturn>;\ntype Out<TReturn> = IterableCallChain.Out<TReturn>;\n\n/**\n * Passes each element of the given iterable trough the {@link IterableCallChain | chain of transformation passes}.\n *\n * The passes are preformed by `@proc7ts/call-thru`.\n *\n * @returns An push iterable of transformed elements.\n */\nexport function thruIt<\n    T, TReturn1\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n): PushIterable<Out<TReturn1>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n): PushIterable<Out<TReturn2>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n): PushIterable<Out<TReturn3>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    TArgs11 extends Args<TReturn10>, TReturn11,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n    pass11: (this: void, ...args: TArgs11) => TReturn11,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    TArgs11 extends Args<TReturn10>, TReturn11,\n    TArgs12 extends Args<TReturn11>, TReturn12,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n    pass11: (this: void, ...args: TArgs11) => TReturn11,\n    pass12: (this: void, ...args: TArgs12) => TReturn12,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    TArgs11 extends Args<TReturn10>, TReturn11,\n    TArgs12 extends Args<TReturn11>, TReturn12,\n    TArgs13 extends Args<TReturn12>, TReturn13,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n    pass11: (this: void, ...args: TArgs11) => TReturn11,\n    pass12: (this: void, ...args: TArgs12) => TReturn12,\n    pass13: (this: void, ...args: TArgs13) => TReturn13,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<T, TReturn>(\n    it: Iterable<T>,\n    ...passes: ((...args: any[]) => any)[]\n): PushIterable<TReturn> {\n\n  const chain = (outcome: PushIterable<any>[], index: number): IterableCallChain => {\n\n    const lastPass = index >= passes.length;\n\n    ++index;\n\n    const pass = index < passes.length ? passes[index] : () => { /* empty pass */ };\n    const handleResult = (outcome: PushIterable<any>[], callResult: any, arg: any): void => {\n      if (isNextCall(callResult)) {\n        callResult[NextCall__symbol](chain(outcome, index), pass);\n      } else if (lastPass) {\n        outcome.push(overOne(arg));\n      } else {\n        chain(outcome, index).pass(pass, callResult);\n      }\n    };\n\n    return ({\n      call<TArgs extends any[]>(fn: (...args: TArgs) => any, args: TArgs): void {\n        handleResult(outcome, fn(...args), args);\n      },\n      pass<TArgs>(fn: (arg: TArgs) => any, arg: TArgs): void {\n        handleResult(outcome, fn(arg), arg);\n      },\n      skip() {/* skip item */},\n      iterate<TElement>(fn: (this: void, arg: TElement) => void, iterable: Iterable<TElement>): void {\n        outcome.push(flatMapIt(\n            iterable,\n            item => {\n\n              const itemOutcome: PushIterable<any>[] = [];\n\n              handleResult(itemOutcome, fn(item), item);\n\n              return flatMapArray(itemOutcome);\n            },\n        ));\n      },\n    });\n  };\n\n  const finalOutcome: PushIterable<any>[] = [];\n\n  chain(finalOutcome, 0).iterate(passes[0], it);\n\n  return flatMapArray<TReturn>(finalOutcome);\n}\n"],"names":["PushIterator__symbol","Symbol","isPushIterable","iterable","iteratorOf","iterator","makePushIterable","iterate","[object Object]","PushIterable$iterator","this","pushIterated","accept","isOver","makePushIterator","forNext","over","PushIterator$dontIterate","PushIterator$iterator","next","PushIterator$next","result","value","done","PushIterator$noNext","_accept","emptyPushIterator","pushHead","arrayElementOf","array","index","iterateOverArray","indexed","elementOf","i","length","goOn","overArray","itsIterated","it","status","itsEach","action","element","itsElements$defaultConverter","itsElements","source","convert","pushedElements","Array","from","push","itsEvery","test","allMatch","itsFirst","pushedFirst","undefined","rawFirst","first","toPushIterator","res","rawIteratorPusher","itsHead","isArray","arrayHead","forEach","rawIterableHead","itsReduction","reducer","initialValue","reduced","overNone","overIterator","iterateOverRawIterator","overElementsOf","sources","src","srcTail","iterateOverSubElements","overOne","iterateOverOneValue","filterArray","iterateOverFilteredIndexed","filterIt","filterPusher","filterRawPusher","tail","flatMapArray","elementsOf","flatMapArray$defaultElementOf","subs","subsTail","flatMapIt","flatMapIt$defaultConverter","flatMapPusher","flatMapRawPusher","lastSrc","sourceTail","mapIt","mapPusher","mapRawPusher","overEntries","Reflect","ownKeys","overKeys","key","thruIt","passes","chain","outcome","lastPass","pass","handleResult","callResult","arg","isNextCall","NextCall__symbol","fn","args","item","itemOutcome","finalOutcome"],"mappings":"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"}