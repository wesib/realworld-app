{"version":3,"file":"context-values.5140e67e.js","sources":["../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/key/context-key.ts","../../../../../proc7ts/context-values/src/key/context-seed-key.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/conventional/contextual.ts","../../../../../proc7ts/context-values/src/conventional/apply-context-to.ts","../../../../../proc7ts/context-values/src/singleton/simple-context-key.ts","../../../../../proc7ts/context-values/src/singleton/single-context-key.ts","../../../../../proc7ts/context-values/src/conventional/context-supply.ts","../../../../../proc7ts/context-values/src/registry/context-builder.ts","../../../../../proc7ts/context-values/src/registry/context-seeders.impl.ts","../../../../../proc7ts/context-values/src/registry/context-value-spec.ts","../../../../../proc7ts/context-values/src/registry/context-values.impl.ts","../../../../../proc7ts/context-values/src/registry/context-registry.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/conventional/apply-context-after.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module-dependency-error.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module-usage.impl.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module-key.impl.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module.impl.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module.ts"],"sourcesContent":["import type { ContextKey } from './key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key - Missing value key.\n   * @param message - Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","import type { ContextRef } from '../context-ref';\nimport type { ContextSeedKey } from './context-seed-key';\nimport type { ContextValueSlot } from './context-value-slot';\n\n/**\n * A symbol of the property containing a {@link ContextKey} instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('ContextKey'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by {@link ContextKey.grow} method.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same {@link seedKey} to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name - Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot - Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n","import type { ContextValues } from '../context-values';\nimport { ContextKey } from './context-key';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValueSlot } from './context-value-slot';\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key - A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx - Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","import type { ContextRequest } from './context-request';\nimport type { ContextSupply } from './conventional';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n\nexport interface ContextValues {\n\n  /**\n   * Context values supply.\n   *\n   * When provided, this value is available under {@link ContextSupply} key, unless overridden.\n   */\n  readonly supply?: ContextSupply;\n\n}\n","import type { ContextValues } from '../context-values';\n\n/**\n * A key of {@link Contextual contextual value reference} method resolving a contextual instance.\n */\nexport const Contextual__symbol = (/*#__PURE__*/ Symbol('Contextual'));\n\n/**\n * Contextual value reference.\n *\n * @typeParam T - Referred contextual instance type.\n * @typeParam TCtx - Supported context type.\n */\nexport interface Contextual<T, TCtx extends ContextValues = ContextValues> {\n\n  /**\n   * Resolves a contextual instance for the target context.\n   *\n   * @param context - Target context.\n   *\n   * @returns Either contextual instance, or `null`/`undefined` when not resolved.\n   */\n  [Contextual__symbol](context: TCtx): T | null | undefined;\n\n}\n\nexport namespace Contextual {\n\n  /**\n   * Mandatory contextual value reference.\n   *\n   * Always resolves to some value.\n   *\n   * @typeParam T - Referred contextual instance type.\n   * @typeParam TCtx - Supported context type.\n   */\n  export interface Mandatory<T, TCtx extends ContextValues = ContextValues> {\n\n    /**\n     * Resolves a contextual instance for the target context.\n     *\n     * @param context - Target context.\n     *\n     * @returns Contextual instance.\n     */\n    [Contextual__symbol](context: TCtx): T;\n\n  }\n\n}\n\n/**\n * Checks whether the given value is a {@link Contextual.Mandatory mandatory contextual reference}.\n *\n * @typeParam T - Expected referred contextual instance type.\n * @typeParam TCtx - Expected context type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` has a {@link Contextual__symbol} method that always returns some value,\n * or `false` otherwise.\n */\nexport function isContextual<T, TCtx extends ContextValues = ContextValues, TOther = unknown>(\n    value: Contextual.Mandatory<T, TCtx> | TOther,\n): value is Contextual.Mandatory<T, TCtx>;\n\n/**\n * Checks whether the given value is a {@link Contextual contextual reference}.\n *\n * @typeParam T - Expected referred contextual instance type.\n * @typeParam TCtx - Expected context type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` has a {@link Contextual__symbol} method, or `false` otherwise.\n */\nexport function isContextual<T, TCtx extends ContextValues = ContextValues, TOther = unknown>(\n    value: Contextual<T, TCtx> | TOther,\n): value is Contextual<T, TCtx>;\n\nexport function isContextual<T, TCtx extends ContextValues = ContextValues, TOther = unknown>(\n    value: Contextual<T, TCtx> | TOther,\n): value is Contextual<T, TCtx> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && typeof (value as Partial<Contextual<T, TCtx>>)[Contextual__symbol] === 'function';\n}\n","import { valueProvider } from '@proc7ts/primitives';\nimport type { ContextValues } from '../context-values';\nimport type { ContextValueProvider } from '../registry';\nimport type { Contextual } from './contextual';\nimport { Contextual__symbol, isContextual } from './contextual';\n\n/**\n * Converts a value or its {@link Contextual.Mandatory mondatory contextual reference} to mandatory context value\n * {@link ContextValueProvider provider}.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param value - A value to convert. May be either a bare value, its contextual reference, or `null`/`undefined` to\n * provide nothing.\n *\n * @returns Mandatory context value provider.\n */\nexport function applyContextTo<T, TCtx extends ContextValues = ContextValues>(\n    value: Contextual.Mandatory<T, TCtx> | T | null | undefined,\n): (this: void, context: TCtx) => T;\n\n/**\n * Converts a value or its {@link Contextual contextual reference} to context value {@link ContextValueProvider\n * provider}.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param value - A value to convert. May be either a bare value, its contextual reference, or `null`/`undefined` to\n * provide nothing.\n *\n * @returns Context value provider.\n */\nexport function applyContextTo<T, TCtx extends ContextValues = ContextValues>(\n    value: Contextual<T, TCtx> | T | null | undefined,\n): ContextValueProvider<T, TCtx>;\n\nexport function applyContextTo<T, TCtx extends ContextValues = ContextValues>(\n    value: Contextual<T, TCtx> | T | null | undefined,\n): ContextValueProvider<T, TCtx> {\n  return isContextual(value)\n      ? context => value[Contextual__symbol](context)\n      : valueProvider(value);\n}\n","import { lazyValue, noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeeder } from '../key';\nimport { ContextKey, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: (readonly [ContextValueProvider<TSrc, TCtx>])[] = [];\n\n  provide(provider: ContextValueProvider<TSrc, TCtx>): Supply {\n\n    // Ensure the same provider may be registered multiple times\n    const entry: readonly [ContextValueProvider<TSrc, TCtx>] = [provider];\n\n    this._providers.unshift(entry);\n\n    return new Supply(() => this._providers.splice(this._providers.lastIndexOf(entry), 1));\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (\n        [provider]: readonly [ContextValueProvider<TSrc, TCtx>],\n    ): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc - Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from '../key';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","import { alwaysSupply, Supply } from '@proc7ts/supply';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextValueSlot } from '../key';\nimport { SimpleContextKey } from '../singleton';\n\n/**\n * Context values supply.\n *\n * It is used to signal when context is no longer used (e.g. destroyed).\n *\n * A context value provider can (and probably should) destroy the provided value in such case.\n */\nexport type ContextSupply = Supply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || slot.context.supply\n        || (slot.hasFallback ? slot.or : alwaysSupply()),\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `SupplyPeer` interface. Defaults to supply-always\n * otherwise.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","import type { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextRegistry } from './context-registry';\n\n/**\n * A key of {@link ContextBuilder context builder} method that provides context values.\n */\nexport const ContextBuilder__symbol = (/*#__PURE__*/ Symbol('ContextBuilder'));\n\n/**\n * Context builder.\n *\n * Able to provide arbitrary context values.\n *\n * @typeParam TCtx - Supported context type.\n */\nexport interface ContextBuilder<TCtx extends ContextValues = ContextValues> {\n\n  /**\n   * Provides context values with the given registry.\n   *\n   * @param registry - A context registry to provide values with.\n   *\n   * @returns A supply instance that removes the added context value providers once cut off.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry<TCtx>): Supply;\n\n}\n","import type { ContextValues } from '../context-values';\nimport type { ContextKey, ContextSeeder, ContextSeedKey } from '../key';\nimport type { ContextSeeds } from './context-seeds';\n\n/**\n * @internal\n */\nexport type SeedIssuer<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n  seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n  factory: (this: void, context: TCtx) => TSeed,\n];\n\n/**\n * @internal\n */\nexport class ContextSeeders<TCtx extends ContextValues> {\n\n  private readonly _issuers = new Map<ContextSeedKey<any, any>, SeedIssuer<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  issuer<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedIssuer<TCtx, TSrc, TSeed> {\n\n    const found: SeedIssuer<TCtx, TSrc, TSeed> | undefined = this._issuers.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const issuer: SeedIssuer<TCtx, TSrc, TSeed> = [\n      seeder,\n      context => seeder.seed(context, this._initial(seedKey, context)),\n    ];\n\n    this._issuers.set(seedKey, issuer);\n\n    return issuer;\n  }\n\n  newSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.issuer(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n","import { valueProvider } from '@proc7ts/primitives';\nimport type { ContextRequest } from '../context-request';\nimport type { ContextValues } from '../context-values';\nimport type { ContextBuilder } from './context-builder';\nimport type { ContextTarget } from './context-target';\nimport type { ContextValueProvider } from './context-value-provider';\n\n/**\n * Context value specifier.\n *\n * Either explicit one, or a {@link ContextBuilder context builder}.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TSrc = TValue,\n    TDeps extends any[] = unknown[]> =\n    | ContextValueSpec.Explicit<TCtx, TValue, TSrc, TDeps>\n    | ContextBuilder<TCtx>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * Explicit context value specifier.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type Explicit<\n      TCtx extends ContextValues,\n      TValue,\n      TSrc = TValue,\n      TDeps extends any[] = unknown[]> =\n      | ContextValueSpec.IsConstant<TSrc>\n      | ContextValueSpec.ViaAlias<TSrc>\n      | ContextValueSpec.ByProvider<TCtx, TSrc>\n      | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>\n      | ContextValueSpec.AsInstance<TCtx, TSrc>\n      | ContextValueSpec.SelfInstance<TCtx, TSrc>\n      | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>\n      | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps>;\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface IsConstant<TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface ViaAlias<TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TSrc, TCtx>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export interface ByProviderWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface AsInstanceWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export interface SelfInstanceWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @param spec - Explicit context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.Explicit<TCtx, TValue, TSrc, TDeps>,\n): ContextValueSpec.ByProvider<TCtx, TSrc> {\n  if (isValueSpecByProvider(spec)) {\n    if (!isValueSpecWithDeps<TCtx, TSrc, TDeps>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstantValueSpec<TSrc>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (isValueSpecViaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (isValueSpecAsInstance<TCtx, TSrc, TDeps>(spec)) {\n    if (isSelfInstanceValueSpec<TCtx, TSrc, TDeps>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!isValueSpecWithDeps<TCtx, TSrc, TDeps>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction isValueSpecByProvider<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc>\n    | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecAsInstance<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc>\n    | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction isSelfInstanceValueSpec<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc>\n    | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc> | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps>,\n): ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>;\n}\n\n/**\n * @internal\n */\nfunction isConstantValueSpec<TSrc>(\n    spec: ContextValueSpec<any, unknown, TSrc, any>,\n): spec is ContextValueSpec.IsConstant<TSrc> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecViaAlias<TSrc>(\n    spec: ContextValueSpec<any, unknown, TSrc, any>,\n): spec is ContextValueSpec.ViaAlias<TSrc> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc> | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>,\n): spec is ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): boolean {\n  return 'with' in spec;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextRequest } from '../context-request';\nimport { ContextValues } from '../context-values';\nimport type { ContextSeeder, ContextValueSetup, ContextValueSlot } from '../key';\nimport { ContextKey, ContextKey__symbol } from '../key';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeders } from './context-seeders.impl';\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seeders: ContextSeeders<TCtx>,\n): ContextValues {\n\n  const values = new Map<ContextKey<any>, any>();\n\n  class ContextValues$ extends ContextValues {\n\n    get<TValue, TSrc>(\n        this: TCtx,\n        { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n        opts?: ContextRequest.Opts<TValue>,\n    ): TValue | null | undefined {\n\n      const cached = values.get(key);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      const [constructed, setup] = new ContextValueSlot$(seeders, this, key, opts)._grow();\n\n      if (setup) {\n        values.set(key, constructed);\n        setup({\n          key,\n          context: this,\n          registry: registry as ContextRegistry<any>,\n        });\n      }\n\n      return constructed;\n    }\n\n  }\n\n  return new ContextValues$();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n  readonly hasFallback: boolean;\n  readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n  readonly seed: TSeed;\n  private _constructed: TValue | null | undefined = null;\n  private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n  constructor(\n      seeders: ContextSeeders<TCtx>,\n      readonly context: TCtx,\n      readonly key: ContextKey<TValue, TSrc, TSeed>,\n      private readonly _opts: ContextRequest.Opts<TValue> = {},\n  ) {\n\n    const [seeder, seed] = seeders.newSeed<TSrc, TSeed>(context, key);\n\n    this.seeder = seeder;\n    this.seed = seed;\n    this.hasFallback = 'or' in _opts; // Fallback _may_ have `undefined` value.\n  }\n\n  get or(): TValue | null | undefined {\n    return this._opts.or; // Access here, as fallback value accessor may be implemented as getter.\n  }\n\n  insert(value: TValue | null | undefined): void {\n    this._constructed = value;\n  }\n\n  fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n    grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n    return this._constructed;\n  }\n\n  setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n    const prevSetup = this._setup;\n\n    this._setup = opts => {\n      prevSetup(opts);\n      setup(opts);\n    };\n  }\n\n  _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n    this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n    if (this._constructed != null) {\n      return [this._constructed, this._setup];\n    }\n    if (!this.hasFallback) {\n      throw new ContextKeyError(this.key);\n    }\n\n    return [this.or];\n  }\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport type { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeedKey } from '../key';\nimport { ContextKey__symbol } from '../key';\nimport { ContextBuilder, ContextBuilder__symbol } from './context-builder';\nimport { ContextSeeders } from './context-seeders.impl';\nimport type { ContextSeeds } from './context-seeds';\nimport { ContextValueSpec, contextValueSpec } from './context-value-spec';\nimport { newContextValues } from './context-values.impl';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx - Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeders: ContextSeeders<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial - An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n    this._seeders = new ContextSeeders<TCtx>(\n        initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop,\n    );\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   * @param spec - Context value specifier.\n   *\n   * @returns Provider supply instance that removes just added context value provider once cut off.\n   */\n  provide<TSrc, TDeps extends any[]>(spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>): Supply {\n    if (isContextBuilder(spec)) {\n      return spec[ContextBuilder__symbol](this);\n    }\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeders.issuer(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context - Target context.\n   * @param key - Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeders.issuer(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider originated from this registry.\n   *\n   * @returns Mandatory context seeds provider.\n   */\n  seeds(): ContextSeeds.Mandatory<TCtx> {\n    return (seedKey, context) => this.seed(context, seedKey);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context - Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeders);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other - Another context value registry or context seeds provider.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx> | ContextSeeds<TCtx>): ContextRegistry<TCtx> {\n\n    const otherSeeds: ContextSeeds<TCtx> = typeof other === 'function' ? other : other.seeds();\n\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const second = otherSeeds(key, context);\n      const [seeder, factory] = this._seeders.issuer(key);\n      const first = factory(context);\n\n      return second ? seeder.combine(first, second, context) : first;\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isContextBuilder<TCtx extends ContextValues, TValue, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, TValue, TSrc, TDeps>,\n): spec is ContextBuilder<TCtx> {\n  return typeof (spec as Partial<ContextBuilder<TCtx>>)[ContextBuilder__symbol] === 'function';\n}\n","/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason - Context destruction reason.\n */\nexport function contextDestroyed(reason: unknown = new TypeError('Context destroyed')): () => never {\n  return () => {\n    throw reason;\n  };\n}\n","import {\n  afterEach,\n  AfterEvent,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  isAfterEvent,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { itsElements, mapIt, overElementsOf, overIterator } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextValues } from '../context-values';\nimport { ContextSupply } from '../conventional';\nimport type { ContextSeeder, ContextValueSlot } from '../key';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nconst flatUpSources: <TSrc>(this: void, input: AfterEvent<TSrc[][]>) => AfterEvent<TSrc[]> = (\n    /*#__PURE__*/ translateAfter((send, ...sources) => send(...itsElements(overElementsOf(...sources))))\n);\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers = trackValue<[Map<Supply, ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>>]>(\n      [new Map()],\n  );\n\n  provide(provider: ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>): Supply {\n\n    const [providers] = this._providers.it;\n    const supply = new Supply();\n\n    providers.set(supply, provider);\n    this._providers.it = [providers];\n\n    return supply.whenOff(() => {\n\n      const [providers] = this._providers.it;\n\n      providers.delete(supply);\n\n      this._providers.it = [providers];\n    });\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(first, second).do(flatUpSources);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<[Map<Supply, ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>>]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read.do(\n      digAfter_(\n          ([providers]): AfterEvent<TSrc[][]> => !providers.size\n              ? afterThe()\n              : afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overIterator(() => providers.values()),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n      ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | ContextUpKey.Source<TSrc>): AfterEvent<TSrc[]> {\n  return isAfterEvent(src)\n      ? src\n      : (src != null ? afterThe(src) : afterThe());\n}\n\n/**\n * @internal\n */\nclass ContextSeed$UpKey<TSrc>\n    extends ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, ContextUpKey.Source<TSrc>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKey$UpKey<TUpdate extends any[], TSrc>\n    extends ContextKey<AfterEvent<TUpdate>, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n\n  readonly grow: (\n      slot: ContextValueSlot<\n          AfterEvent<TUpdate>,\n          ContextUpKey.Source<TSrc>,\n          AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<unknown, TSrc>,\n      grow: (\n          slot: ContextValueSlot<\n              AfterEvent<TUpdate>,\n              ContextUpKey.Source<TSrc>,\n              AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value: AfterEvent<TUpdate> | null | undefined = slot.fillBy(grow);\n\n      if (value != null) {\n        slot.insert(value.do(\n            supplyAfter(slot.context.get(ContextSupply)),\n        ));\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts a {@link ContextUpKey.Source} instances as source values.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc>, ContextUpKey.Base<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by {@link grow} function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeed$UpKey<TSrc>(this);\n  }\n\n  /**\n   * Creates a key of context value containing an `AfterEvent` keeper of updates to the value of this key.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @param grow - A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey<TUpdate extends any[]>(\n      grow: (\n          slot: ContextValueSlot<\n              AfterEvent<TUpdate>,\n              ContextUpKey.Source<TSrc>,\n              AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n    return new ContextUpKey$UpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A source value accepted by {@link ContextUpKey updatable context key}.\n   *\n   * Either a single source value, or an `AfterEvent` keeper of source values.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export type Source<TSrc> = TSrc | AfterEvent<TSrc[]>;\n\n  /**\n   * A type of context value updates tracker.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue - Original context value type.\n   */\n  export type Up<TValue> = TValue extends EventKeeper<any> ? TValue : AfterEvent<[TValue]>;\n\n  /**\n   * Base interface of updatable context value key.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface Base<TValue, TSrc> extends ContextKey<TValue, ContextUpKey.Source<TSrc>> {\n\n    /**\n     * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n     *\n     * It is expected to report any updates to this key's value.\n     *\n     * The value of updates key is constructed by {@link grow} function out of the same seed.\n     */\n    readonly upKey: UpKey<TValue, TSrc>;\n\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface UpKey<TValue, TSrc> extends ContextKey<ContextUpKey.Up<TValue>, ContextUpKey.Source<TSrc>> {\n\n    /**\n     * A reference to this key.\n     *\n     * Indicates that this key is updatable too.\n     */\n    readonly upKey: this;\n\n  }\n\n  /**\n   * A key of context value containing an `AfterEvent` keeper of updates of {@link ContextUpKey updatable value}.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SimpleUpKey<TUpdate extends any[], TSrc> extends Base<AfterEvent<TUpdate>, TSrc> {\n\n    readonly upKey: this;\n\n  }\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","import type { AfterEvent } from '@proc7ts/fun-events';\nimport { shareAfter, translateAfter_ } from '@proc7ts/fun-events';\nimport { isPresent } from '@proc7ts/primitives';\nimport { filterIt, mapIt } from '@proc7ts/push-iterator';\nimport type { ContextValues } from '../../context-values';\nimport type { Contextual } from '../../conventional';\nimport { Contextual__symbol, isContextual } from '../../conventional';\n\n/**\n * Creates an event processor that {@link applyContextTo} applies context to values and their {@link Contextual\n * contextual references} incoming from {@link AfterEvent} keeper.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param context - A context to apply.\n *\n * @returns A mapping function of `AfterEvent` keeper of values, their contextual references, or `null`/`undefined`\n * elements to `AfterEvent` keeper of resolved values.\n */\nexport function applyContextAfter<T, TCtx extends ContextValues = ContextValues>(\n    context: TCtx,\n): (this: void, source: AfterEvent<(T | Contextual<T, TCtx> | null | undefined)[]>) => AfterEvent<T[]> {\n\n  const processor = applyContextAfter_<T, TCtx>(context);\n\n  return source => shareAfter(processor(source));\n}\n\n/**\n * Creates an event processor that {@link applyContextTo} applies context to values and their {@link Contextual\n * contextual references} incoming from {@link AfterEvent} keeper, and does not share the outgoing events supply.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references to resolve the latter before providing to context.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param context - A context to apply.\n *\n * @returns A mapping function of `AfterEvent` keeper of values, their contextual references, or `null`/`undefined`\n * elements to `AfterEvent` keeper of resolved values.\n */\nexport function applyContextAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    T,\n    TCtx extends ContextValues = ContextValues>(\n    context: TCtx,\n): (this: void, source: AfterEvent<(T | Contextual<T, TCtx> | null | undefined)[]>) => AfterEvent<T[]> {\n  return translateAfter_((send, ...values) => send(\n      ...filterIt<T | null | undefined, T>(\n          mapIt(\n              values,\n              (value): T | null | undefined => isContextual(value)\n                  ? value[Contextual__symbol](context)\n                  : value,\n          ),\n          isPresent,\n      ),\n  ));\n}\n","import { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextValues } from '../context-values';\nimport type { ContextKeyDefault, ContextValueSlot } from '../key';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an {@link ContextKeyError}.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.SimpleUpKey<\n      [(this: void, ...args: TArgs) => TRet],\n      (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key)\n        || (() => {\n          throw new ContextKeyError(this);\n        });\n    this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(\n        digAfter((...fns): AfterEvent<[(this: void, ...args: TArgs) => TRet]> => {\n          if (fns.length) {\n            return afterThe(fns[fns.length - 1]);\n          }\n\n          if (slot.hasFallback && slot.or) {\n            return slot.or;\n          }\n\n          return afterThe(this.byDefault(slot.context, this));\n        }),\n    )));\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          ContextUpKey.Source<(this: void, ...args: TArgs) => TRet>,\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","import { AfterEvent, afterEventBy, afterThe, digAfter, supplyAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from '../conventional';\nimport type { ContextKeyDefault, ContextValueSlot } from '../key';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextUpRef<TValue> = ContextUpRef<AfterEvent<[TValue]>, TValue>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an {@link ContextKeyError} error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextUpKey<TValue>\n    extends ContextUpKey<AfterEvent<[TValue]>, TValue>\n    implements SingleContextUpRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TValue>;\n        byDefault?: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[TValue]>,\n          ContextUpKey.Source<TValue>,\n          AfterEvent<TValue[]>>,\n  ): void {\n\n    const value = slot.seed.do(digAfter((...sources: TValue[]): AfterEvent<TValue[]> => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return afterThe(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[TValue]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        if (defaultValue != null) {\n          backup = afterThe(defaultValue);\n        }\n      }\n      if (backup) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<[TValue]>(({ supply }) => {\n        supply.off(new ContextKeyError(this));\n      });\n    }));\n\n    slot.insert(value.do<AfterEvent<TValue[]>>(\n        supplyAfter(slot.context.get(ContextSupply)),\n    ));\n  }\n\n}\n\n","import type { ContextModule } from './context-module';\n\n/**\n * An error indicating context module dependency load failure.\n */\nexport class ContextModuleDependencyError extends Error {\n\n  /**\n   * Constructs context module dependency load error.\n   *\n   * @param module - A module failed to load.\n   * @param reasons - An array of dependency/reason pairs caused the load failure.\n   * @param message - An error message.\n   */\n  constructor(\n      readonly module: ContextModule,\n      readonly reasons: readonly (readonly [ContextModule, unknown?])[] = [],\n      readonly message: string = contextModuleDependencyErrorMessage(module, reasons),\n  ) {\n    super(message);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction contextModuleDependencyErrorMessage(\n    module: ContextModule,\n    dependencies: readonly (readonly [ContextModule, unknown?])[],\n): string {\n\n  const reasons = dependencies.reduce(\n      (out, [dep, reason]) => {\n        if (out) {\n          out += ', ';\n        } else {\n          out = ': ';\n        }\n        if (reason !== undefined) {\n          out += `${dep} failed to load (${reason})`;\n        } else {\n          out += `${dep} not loaded`;\n        }\n\n        return out;\n      },\n      '',\n  );\n\n  return `Failed to load ${module}${reasons}`;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  mapAfter_,\n  OnEvent,\n  onEventBy,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop, valueProvider } from '@proc7ts/primitives';\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport type { ContextRequest } from '../../context-request';\nimport type { ContextValues } from '../../context-values';\nimport { ContextSupply } from '../../conventional';\nimport type { ContextRegistry } from '../../registry';\nimport type { ContextModule } from './context-module';\n\n/**\n * @internal\n */\nexport class ContextModuleUsage {\n\n  private readonly _impl: ValueTracker<ContextModule | undefined>;\n  private readonly _rev: ValueTracker<ContextModuleRev>;\n  private _useCounter = 0;\n\n  private _setup!: () => void;\n\n  constructor(context: ContextValues, readonly module: ContextModule) {\n    this._impl = trackValue();\n    this._rev = trackValue({\n      status: {\n        module: this.module,\n        provided: false,\n        used: false,\n        settled: false,\n        ready: false,\n      },\n      supply: neverSupply(),\n    });\n\n    const contextSupply = context.get(ContextSupply);\n\n    contextSupply.cuts(this._impl);\n    contextSupply.cuts(this._rev);\n\n    this._impl.read(module => {\n\n      const prevSupply = this._rev.it.supply;\n\n      if (module) {\n        this._load(module);\n      }\n\n      prevSupply.off();\n    });\n  }\n\n  createHandle(): ContextModule.Handle {\n\n    const read: AfterEvent<[ContextModule.Status]> = this._rev.read.do(\n        mapAfter_(({ status }) => status),\n    );\n\n    const handle: ContextModule.Handle = {\n      read,\n      [AfterEvent__symbol]: valueProvider(read),\n      use: (user?: SupplyPeer) => this._use(handle, user),\n    };\n\n    return handle;\n  }\n\n  setup(context: ContextValues, registry: ContextRegistry): void {\n    this._setup = () => {\n\n      const rev = this._rev.it;\n      const { status: { module }, supply } = rev;\n\n      if (module !== this.module) {\n        // Load implementation module instead.\n        // The implementation module expected to be provided already.\n        context.get(module).use(supply).read({\n          supply,\n          receive: (_ctx, { settled, ready, error }) => {\n            this._updateStatus(rev, settled, ready, error);\n          },\n        });\n      } else {\n        loadContextModule(context, registry, rev)\n            .then(({ whenReady }) => {\n              this._updateStatus(rev, true, false);\n              return whenReady;\n            })\n            .then(() => this._updateStatus(rev, true, true))\n            .catch(error => rev.supply.off(error));\n      }\n    };\n  }\n\n  implementBy(impl: AfterEvent<[ContextModule?]>): void {\n    this._impl.by(impl);\n  }\n\n  private _updateStatus(\n      rev: ContextModuleRev,\n      settled: boolean,\n      ready: boolean,\n      error?: unknown,\n  ): void {\n    // Ensure updating the correct revision.\n    if (this._rev.it.supply !== rev.supply) {\n      // If revision changed, then drop the obsolete one.\n      rev.supply.off();\n    } else {\n      this._rev.it = rev = {\n        status: {\n          module: rev.status.module,\n          provided: rev.status.provided,\n          used: true,\n          settled,\n          ready,\n          error,\n        },\n        supply: rev.supply,\n      };\n    }\n  }\n\n  private _load(module: ContextModule): void {\n\n    const supply = new Supply(noop).needs(this._rev).whenOff(error => {\n\n      const rev = this._rev.it;\n\n      if (rev.supply === supply) {\n        this._rev.it = {\n          status: {\n            ...this._rev.it.status,\n            provided: false,\n            settled: false,\n            ready: false,\n            error,\n          },\n          supply,\n        };\n      }\n    });\n\n    const used = !!this._useCounter;\n\n    this._rev.it = {\n      status: {\n        module,\n        provided: true,\n        used,\n        settled: false,\n        ready: false,\n      },\n      supply,\n    };\n\n    if (used) {\n      this._setup();\n    }\n  }\n\n  private _use(handle: ContextModule.Handle, user?: SupplyPeer): ContextModule.Use {\n\n    const supply = new Supply(noop);\n\n    if (user) {\n      supply.needs(user);\n    }\n\n    const read = handle.read.do(supplyAfter(supply));\n    const use: ContextModule.Use = {\n      ...handle,\n      read,\n      whenSettled: ContextModule$Use$when(read, isContextModuleSettled),\n      whenReady: ContextModule$Use$when(read, isContextModuleReady),\n      supply,\n    };\n\n    if (!supply.isOff) {\n      supply.whenOff(error => {\n        if (!--this._useCounter) {\n\n          const rev = this._rev.it;\n\n          this._rev.it = {\n            status: {\n              ...rev.status,\n              used: false,\n              settled: false,\n              ready: false,\n              error,\n            },\n            supply: new Supply(noop).off(error),\n          };\n\n          rev.supply.off(error);\n        }\n      });\n\n      if (!this._useCounter++) {\n        // Mark the module used and set it up.\n\n        const rev = this._rev.it;\n\n        this._rev.it = {\n          status: {\n            ...rev.status,\n            used: true,\n          },\n          supply: rev.supply,\n        };\n\n        this._setup();\n      }\n    }\n\n    return use;\n  }\n\n}\n\n/**\n * @internal\n */\ninterface ContextModuleRev {\n\n  readonly status: ContextModule.Status;\n  readonly supply: Supply;\n\n}\n\n/**\n * @internal\n */\nasync function loadContextModule(\n    context: ContextValues,\n    registry: ContextRegistry,\n    { status: { module }, supply }: ContextModuleRev,\n): Promise<ContextModuleInit> {\n\n  const moduleInit = new ContextModuleInit(module);\n\n  await module.setup({\n\n    module,\n    supply,\n\n    get(request: ContextRequest<any>) {\n      return context.get(request);\n    },\n\n    provide(spec): Supply {\n      return registry.provide(spec).needs(supply);\n    },\n\n    initBy(init: (this: void) => (void | PromiseLike<unknown>)) {\n      moduleInit.initBy(init);\n    },\n\n  });\n\n  return moduleInit;\n}\n\nclass ContextModuleInit {\n\n  readonly whenReady: Promise<unknown>;\n  private _whenDone: Promise<unknown> = Promise.resolve();\n  private _ready!: (result?: PromiseLike<unknown>) => void;\n\n  constructor(private readonly _module: ContextModule) {\n    this.whenReady = new Promise(resolve => this._ready = resolve);\n  }\n\n  initBy(init: (this: void) => void | PromiseLike<unknown>): void {\n\n    const rev: Promise<unknown> = this._whenDone = this._whenDone\n        .then(init)\n        .finally(() => this._done(rev));\n\n  }\n\n  private _done(rev: Promise<unknown>): void {\n    if (this._whenDone === rev) {\n      this._ready(rev);\n      this.initBy = _init => {\n        throw new TypeError(`${this._module} initialized already, and does not accept new initializers`);\n      };\n    }\n  }\n\n}\n\nfunction ContextModule$Use$when(\n    status: AfterEvent<[ContextModule.Status]>,\n    test: (status: ContextModule.Status) => boolean,\n): OnEvent<[ContextModule.Status]> {\n  return onEventBy(receiver => status({\n    supply: receiver.supply,\n    receive: (context, status) => {\n      if (test(status)) {\n        receiver.receive(context, status);\n        receiver.supply.off();\n      } else if (status.error) {\n        receiver.supply.off(status.error);\n      }\n    },\n  }));\n}\n\nfunction isContextModuleSettled({ settled }: ContextModule.Status): boolean {\n  return settled;\n}\n\nfunction isContextModuleReady({ ready }: ContextModule.Status): boolean {\n  return ready;\n}\n","import type { AfterEvent } from '@proc7ts/fun-events';\nimport { mapAfter_ } from '@proc7ts/fun-events';\nimport type { ContextValueSlot } from '../../key';\nimport { ContextUpKey } from '../context-up-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleUsage } from './context-module-usage.impl';\n\n/**\n * @internal\n */\nexport class ContextModuleKey extends ContextUpKey<ContextModule.Handle, ContextModule> {\n\n  constructor(name: string, private readonly _module: ContextModule) {\n    super(name);\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ContextModule.Handle,\n          ContextUpKey.Source<ContextModule>,\n          AfterEvent<ContextModule[]>>,\n  ): void {\n\n    const usage = new ContextModuleUsage(slot.context, this._module);\n\n    slot.insert(usage.createHandle());\n    slot.setup(({ context, registry }) => usage.setup(context, registry));\n\n    usage.implementBy(implementContextModule(this._module, slot.seed));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction implementContextModule(\n    module: ContextModule,\n    impls: AfterEvent<[ContextModule]>,\n): AfterEvent<[ContextModule | undefined]> {\n  return impls.do(\n      mapAfter_((...candidates) => {\n\n        let impl: ContextModule | undefined;\n\n        for (let i = candidates.length - 1; i >= 0; --i) {\n          impl = candidates[i];\n          if (impl !== module) {\n            break;\n          }\n        }\n\n        return impl;\n      }),\n  );\n}\n","import type { OnEvent } from '@proc7ts/fun-events';\nimport { isDefined, noop, setOfElements, valueProvider } from '@proc7ts/primitives';\nimport { itsElements, valueIt } from '@proc7ts/push-iterator';\nimport type { Supply } from '@proc7ts/supply';\nimport type { ContextRegistry } from '../../registry';\nimport type { ContextUpKey } from '../context-up-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleDependencyError } from './context-module-dependency-error';\nimport { ContextModuleKey } from './context-module-key.impl';\n\n/**\n * @internal\n */\nexport const ContextModule$impl__symbol = (/*#__PURE__*/ Symbol('ContextModule.impl'));\n\n/**\n * @internal\n */\nexport class ContextModule$ {\n\n  readonly key: ContextUpKey<ContextModule.Handle, ContextModule>;\n  readonly has: ReadonlySet<ContextModule>;\n  readonly needs: ReadonlySet<ContextModule>;\n\n  private readonly _setup: (\n      this: void,\n      setup: ContextModule.Setup,\n  ) => void | PromiseLike<unknown>;\n\n  constructor(module: ContextModule, readonly name: string, readonly options: ContextModule.Options) {\n    this.key = new ContextModuleKey(`${name}:module`, module);\n\n    const { needs, has, setup } = options;\n\n    this.has = setOfElements(has).add(module);\n    this.needs = setOfElements(needs);\n    this._setup = setup ? setup.bind(options) : noop;\n  }\n\n  replace(\n      module: ContextModule,\n      registry: ContextRegistry,\n      supply: Supply,\n  ): void {\n    for (const replaced of module.has) {\n      if (replaced !== module) {\n        registry.provide({ a: replaced, is: module }).needs(supply);\n      }\n    }\n  }\n\n  async setup(setup: ContextModule.Setup): Promise<void> {\n\n    const deps = contextModuleDeps(setup);\n\n    // Await for module dependencies to be settled.\n    if (!await loadContextModuleDeps(setup, deps, whenContextModuleSettled)) {\n      return;\n    }\n\n    setup.initBy(async () => {\n      // Initialize module dependencies.\n      await loadContextModuleDeps(setup, deps, whenContextModuleReady);\n    });\n\n    await this._setup(setup);\n  }\n\n}\n\ninterface ContextModuleDep {\n  readonly dep: ContextModule;\n  readonly use: ContextModule.Use;\n}\n\nfunction contextModuleDeps(setup: ContextModule.Setup): readonly ContextModuleDep[] {\n\n  const { module, supply } = setup;\n\n  return itsElements(\n      valueIt(\n          module.needs,\n          dep => dep !== module\n              && setup.provide(dep).needs(supply)\n              && {\n                dep,\n                use: setup.get(dep).use(setup),\n              },\n      ),\n  );\n}\n\nfunction loadContextModuleDeps(\n    setup: ContextModule.Setup,\n    deps: readonly ContextModuleDep[],\n    whenLoaded: (use: ContextModule.Use) => OnEvent<[ContextModule.Status]>,\n): Promise<boolean> {\n\n  const { module, supply } = setup;\n  const notLoaded = valueProvider(false);\n  const whenDone = supply.whenDone().then(notLoaded, notLoaded);\n\n  return Promise.race([\n    whenDone,\n    Promise\n        .all(\n            deps\n                .map(\n                    ({ dep, use }) => whenLoaded(use).then(\n                        noop,\n                        error => [dep, error] as const,\n                    ),\n                ),\n        )\n        .then(\n            (results): true | ContextModuleDependencyError => {\n\n              const failures = results.filter<readonly [ContextModule, unknown]>(isDefined);\n\n              return failures.length\n                  ? new ContextModuleDependencyError(module, failures) // Prevent unhandled promise rejection\n                  : true as const;\n            },\n        ),\n  ]).then(\n      result => {\n        if (typeof result !== 'boolean') {\n          // Fail to load module if at leas one of its dependencies failed.\n          return Promise.reject(result);\n        }\n\n        return result;\n      },\n  );\n}\n\nfunction whenContextModuleSettled(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenSettled;\n}\n\nfunction whenContextModuleReady(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenReady;\n}\n","import type { AfterEvent, EventKeeper, OnEvent } from '@proc7ts/fun-events';\nimport type { Supply, SupplyPeer } from '@proc7ts/supply';\nimport type { ContextValues } from '../../context-values';\nimport { ContextKey__symbol } from '../../key';\nimport type { ContextRegistry, ContextValueSpec } from '../../registry';\nimport { ContextBuilder, ContextBuilder__symbol } from '../../registry';\nimport type { ContextUpKey, ContextUpRef } from '../context-up-key';\nimport { ContextModule$, ContextModule$impl__symbol } from './context-module.impl';\n\n/**\n * Context module.\n *\n * Modules intended to extend the context dynamically.\n *\n * The module is a context value reference that can be used to provide module instance and access its\n * {@link ContextModule.Handle handle}.\n *\n * Usage example:\n * ```typescript\n * // Construct new module.\n * const myModule = new ContextModule('my module', {\n *   setup(setup) {\n *     // Provide the values\n *     setup.provide({ a: Foo, is: 'foo' });\n *   },\n * });\n *\n * // Load the module\n * const myModuleSupply = contextRegistry.provide(myModule);\n *\n * // Start using the module\n * const myModuleUse = await context.get(myModule).use();\n *\n * // Await for the module to load\n * await myModuleUse.whenReady;\n *\n * // Access the value provided by module.\n * console.log(context.get(Foo));\n *\n * // Stop using the module\n * myModuleUse.supply.off();\n *\n * // Unload the module declaration.\n * myModuleSupply.off();\n * ```\n */\nexport class ContextModule implements ContextUpRef<ContextModule.Handle, ContextModule>, ContextBuilder {\n\n  /**\n   * @internal\n   */\n  private readonly [ContextModule$impl__symbol]: ContextModule$;\n\n  /**\n   * Constructs context module.\n   *\n   * @param name - Human-readable module name.\n   * @param options - Module construction options.\n   */\n  constructor(name: string, options: ContextModule.Options = {}) {\n    this[ContextModule$impl__symbol] = new ContextModule$(this, name, options);\n  }\n\n  /**\n   * A key of context module.\n   */\n  get [ContextKey__symbol](): ContextUpKey<ContextModule.Handle, ContextModule> {\n    return this[ContextModule$impl__symbol].key;\n  }\n\n  /**\n   * Human-readable module name.\n   */\n  get name(): string {\n    return this[ContextModule$impl__symbol].name;\n  }\n\n  /**\n   * The modules this one requires.\n   *\n   * Assigned by {@link ContextModule.Options.needs} option.\n   */\n  get needs(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].needs;\n  }\n\n  /**\n   * The modules this one provides.\n   *\n   * Assigned by {@link ContextModule.Options.has} option.\n   *\n   * Always contains the module itself.\n   */\n  get has(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].has;\n  }\n\n  /**\n   * Provides this module and {@link has module replacements}.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry): Supply {\n\n    const supply = registry.provide({ a: this, is: this });\n\n    this[ContextModule$impl__symbol].replace(this, registry, supply);\n\n    return supply;\n  }\n\n  /**\n   * Sets up the module.\n   *\n   * This method is called when loading the module. It is used e.g. to provide more values for the context.\n   *\n   * By default:\n   *\n   * 1. Satisfies module {@link needs dependencies} by setting them up.\n   *\n   *    The dependency considered satisfied when it is {@link ContextModule.Status.settled settled}.\n   *\n   * 2. {@link ContextModule.Setup.initBy Initializes} the module by initializing the dependencies.\n   *\n   *    The dependency considered initialized when it is {@link ContextModule.Status.ready ready for use}.\n   *\n   * 3. Performs the module setup by invoking the {@link ContextModule.Options.setup} method.\n   *\n   * @param setup - Context module setup.\n   *\n   * @returns A promise resolved when the module is set up asynchronously.\n   */\n  setup(setup: ContextModule.Setup): Promise<void> {\n    return this[ContextModule$impl__symbol].setup(setup);\n  }\n\n  toString(): string {\n    return `ContextModule(${this.name})`;\n  }\n\n}\n\nexport namespace ContextModule {\n\n  /**\n   * Context module construction options.\n   */\n  export interface Options {\n\n    /**\n     * A module or modules the constructed one requires.\n     *\n     * The listed modules will be loaded prior to loading the constructed one.\n     */\n    readonly needs?: ContextModule | readonly ContextModule[];\n\n    /**\n     * A module or modules the constructed one provides.\n     *\n     * When specified, the constructed module will be loaded _instead_ of the listed ones.\n     *\n     * The module always provides itself.\n     */\n    readonly has?: ContextModule | readonly ContextModule[];\n\n    /**\n     * Sets up constructed module.\n     *\n     * This method is called when loading the module. It is used e.g. to provide more values for the context.\n     *\n     * @param setup - Context module setup.\n     *\n     * @returns Either nothing to set up the module synchronously, or a promise-like instance resolved when the module\n     * is set up asynchronously.\n     */\n    setup?(setup: ContextModule.Setup): void | PromiseLike<unknown>;\n\n  }\n\n  /**\n   * Context module setup.\n   *\n   * Passed to {@link ContextModule.setup module setup method} in order to access and provide the necessary values.\n   *\n   * @typeParam TCtx - Target context type.\n   */\n  export interface Setup extends ContextValues, SupplyPeer {\n\n    /**\n     * The module to set up.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Module supply.\n     *\n     * This supply will be cut off once the module is unloaded.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Provides context value.\n     *\n     * The value provider will be removed automatically once the module is unloaded.\n     *\n     * @typeParam TSrc - Source value type.\n     * @typeParam TDeps - Dependencies tuple type.\n     * @param spec - Context value specifier.\n     *\n     * @returns Provider supply instance that removes just added context value provider once cut off.\n     */\n    provide<TSrc, TDeps extends any[]>(\n        spec: ContextValueSpec<ContextValues, unknown, TSrc, TDeps>,\n    ): Supply;\n\n    /**\n     * Registers the module initializer.\n     *\n     * The module initializer registration is only valid during its {@link ContextModule.setup setup}.\n     *\n     * The registered initializers executed after successful module {@link ContextModule.setup}. The modules\n     * is considered {@link ContextModule.Status.ready ready for use} only when all registered initializers succeed.\n     *\n     * The registered initializers executed serially. I.e. then next one does not start until the previous one succeeds.\n     *\n     * It is an error calling this method when the module initialized already.\n     *\n     * @param init - The module initialization function, that returns nothing when the module initialization\n     * completed synchronously, or a promise-like instance resolved when the module initialization completed\n     * asynchronously.\n     */\n    initBy(init: (this: void) => void | PromiseLike<unknown>): void;\n\n  }\n\n  /**\n   * A handle of dynamically loaded context module.\n   *\n   * This value is available in {@link ContextValues.get returned from context} under the module instance used as a key.\n   *\n   * Implements an `EventKeeper` interface by sending a {@link ContextModule.Status module load status} updates.\n   */\n  export interface Handle extends EventKeeper<[ContextModule.Status]> {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * Initiate the module use.\n     *\n     * @param user - Module user. Contains a supply required by {@link Use.supply module use supply}. The module use\n     * stops once the user supply is cut off.\n     *\n     * @returns A module usage instance.\n     */\n    use(user?: SupplyPeer): Use;\n\n  }\n\n  /**\n   * An instance of the module use.\n   *\n   * The module is active while it is in use. I.e. at least one `Use` instance exists and active.\n   *\n   * The use is active util its {@link supply} is cut off.\n   *\n   * The module use instance can be used as its handle too.\n   */\n  export interface Use extends Handle, SupplyPeer {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     *\n     * Cuts off the supply when context module no longer {@link supply used}.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module settlement event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.settled\n     * settled}, but possibly before it is {@link ContextModule.Status.ready ready}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenSettled: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module readiness event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.ready ready\n     * for use}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenReady: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * Module use supply.\n     *\n     * The module use stops once this supply is cut off.\n     */\n    readonly supply: Supply;\n\n  }\n\n  /**\n   * Context module load status.\n   *\n   * This status is reported by {@link ContextModule.Handle loaded module handle}.\n   */\n  export interface Status {\n\n    /**\n     * Loaded module.\n     *\n     * Note that it may differ from the one requested to load. E.g. when another module {@link ContextModule.Options.has\n     * provides} it.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Whether the module implementation is provided.\n     */\n    readonly provided: boolean;\n\n    /**\n     * Whether the module is {@link Handle.use used} at least once.\n     */\n    readonly used: boolean;\n\n    /**\n     * Whether the module is settled.\n     *\n     * The module is settled when its {@link ContextModule.setup set up} is complete.\n     */\n    readonly settled: boolean;\n\n    /**\n     * Whether the module is loaded and ready for use.\n     *\n     * The module is ready when it is {@link settled}, and all of its {@link ContextModule.Setup.initBy initializers}\n     * succeed.\n     */\n    readonly ready: boolean;\n\n    /**\n     * Error occurred while loading the module.\n     */\n    readonly error?: unknown;\n\n  }\n\n}\n"],"names":["ContextKeyError","Error","[object Object]","key","message","super","this","ContextKey__symbol","Symbol","ContextKey","name","ContextSeedKey","seedKey","opts","seeder","seed","isEmpty","hasFallback","insert","ContextValues","Contextual__symbol","isContextual","value","applyContextTo","context","valueProvider","SimpleContextSeeder","provider","entry","_providers","unshift","Supply","splice","lastIndexOf","initial","length","noop","makeSeed","lazyValue","bind","undefined","seeds","map","push","combineSimpleSeeds","first","second","SimpleSeedKey","SimpleContextKey","SingleContextKey","byDefault","slot","ContextSupplyKey","supply","or","alwaysSupply","ContextSupply","ContextBuilder__symbol","ContextSeeders","_initial","Map","found","_issuers","get","issuer","set","factory","isValueSpecWithDeps","spec","ContextValueSlot$","seeders","_opts","newSeed","_constructed","grow","setup","prevSetup","_setup","ContextRegistry","_seeders","isContextBuilder","a","by","isValueSpecByProvider","with","deps","dep","isConstantValueSpec","is","isValueSpecViaAlias","via","ctx","isValueSpecAsInstance","isSelfInstanceValueSpec","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","provide","newValues","registry","values","cached","constructed","_grow","newContextValues","other","otherSeeds","combine","contextDestroyed","reason","flatUpSources","translateAfter","send","sources","itsElements","overElementsOf","ContextUpSeeder","trackValue","providers","it","whenOff","delete","afterThe","providersTracker","read","do","digAfter_","size","afterEach","mapIt","overIterator","prov","toUpSrcKeeper","upSrcKeepers","src","isAfterEvent","ContextSeed$UpKey","upKey","ContextUpKey$UpKey","_key","fillBy","supplyAfter","ContextUpKey","applyContextAfter","processor","translateAfter_","filterIt","isPresent","applyContextAfter_","source","shareAfter","FnContextKey","createUpKey","digAfter","fns","delegated","fn","args","SingleContextUpKey","backup","defaultValue","afterEventBy","off","ContextModuleDependencyError","module","reasons","dependencies","reduce","out","contextModuleDependencyErrorMessage","ContextModuleUsage","_impl","_rev","status","provided","used","settled","ready","neverSupply","contextSupply","cuts","prevSupply","_load","mapAfter_","handle","AfterEvent__symbol","use","user","_use","rev","receive","_ctx","error","_updateStatus","async","moduleInit","ContextModuleInit","request","needs","init","initBy","loadContextModule","then","whenReady","catch","impl","_useCounter","whenSettled","ContextModule$Use$when","isContextModuleSettled","isContextModuleReady","isOff","_module","Promise","resolve","_ready","_whenDone","finally","_done","_init","test","onEventBy","receiver","ContextModuleKey","usage","createHandle","implementBy","candidates","i","ContextModule$impl__symbol","ContextModule$","options","has","setOfElements","add","replaced","valueIt","contextModuleDeps","loadContextModuleDeps","whenContextModuleSettled","whenContextModuleReady","whenLoaded","notLoaded","whenDone","race","all","results","failures","filter","isDefined","result","reject","ContextModule","replace"],"mappings":"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"}