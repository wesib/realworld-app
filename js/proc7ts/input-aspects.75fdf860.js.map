{"version":3,"file":"input-aspects.75fdf860.js","sources":["../../../../../proc7ts/input-aspects/src/aspect.ts","../../../../../proc7ts/input-aspects/src/aspect.impl.ts","../../../../../proc7ts/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../../../proc7ts/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../../../proc7ts/input-aspects/src/converter.ts","../../../../../proc7ts/input-aspects/src/control.ts","../../../../../proc7ts/input-aspects/src/controls/value-of.control.ts","../../../../../proc7ts/input-aspects/src/controls/abstract.control.ts","../../../../../proc7ts/input-aspects/src/containers/container.control.ts","../../../../../proc7ts/input-aspects/src/containers/parents.aspect.ts","../../../../../proc7ts/input-aspects/src/element.control.ts","../../../../../proc7ts/input-aspects/src/data/mode.aspect.ts","../../../../../proc7ts/input-aspects/src/data/data.aspect.ts","../../../../../proc7ts/input-aspects/src/containers/group.control.ts","../../../../../proc7ts/input-aspects/src/validation/require-nothing.validator.ts","../../../../../proc7ts/input-aspects/src/validation/validator.ts","../../../../../proc7ts/input-aspects/src/validation/validator.impl.ts","../../../../../proc7ts/input-aspects/src/validation/validation.aspect.ts","../../../../../proc7ts/input-aspects/src/validation/require-all.validator.ts","../../../../../proc7ts/input-aspects/src/validation/require-present.validator.ts","../../../../../proc7ts/input-aspects/src/submit.aspect.ts","../../../../../proc7ts/input-aspects/src/data/modes/mode-by-form.ts","../../../../../proc7ts/input-aspects/src/data/modes/mode-by-validity.ts","../../../../../proc7ts/input-aspects/src/elements/abstract-element.control.ts","../../../../../proc7ts/input-aspects/src/elements/text.control.ts","../../../../../proc7ts/input-aspects/src/elements/focus/focus.aspect.ts","../../../../../proc7ts/input-aspects/src/elements/focus/status.aspect.ts","../../../../../proc7ts/input-aspects/src/elements/forms/form-element.control.ts","../../../../../proc7ts/input-aspects/src/elements/forms/submit-button.control.ts","../../../../../proc7ts/input-aspects/src/elements/style/styled-element.aspect.ts","../../../../../proc7ts/input-aspects/src/elements/style/css-classes.aspect.ts","../../../../../proc7ts/input-aspects/src/elements/style/css-error.ts","../../../../../proc7ts/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Value, Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by [[InControl.convert]] method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<To, ConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of [[convertTo]] when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<Value>): Applied<Value, Instance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<OfValue, Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from '@proc7ts/call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance, Kind>,\n    build: <V>(this: void, control: InControl<V>, origin?: InControl<any>) => Instance,\n    instance?: Instance,\n    origin?: InControl<any>,\n): InAspect.Applied<Value, Instance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<To>(target: InControl<To>): InAspect.Applied<To, Instance> {\n      return inAspectSameOrBuild<To, Instance, Kind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<Value>): InAspect.Applied<Value, Instance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as Instance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance | null, Kind>,\n    instance: Instance | null = null,\n): InAspect.Applied<Value, Instance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<any, Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * [[InNamespaceAliaser.to]] converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @param nsAlias  Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from '@proc7ts/render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by [[InRenderScheduler.to]] converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @param scheduler  Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(scheduler: InRenderScheduler): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { filterIt, flatMapIt, itsReduction, mapIt } from '@proc7ts/a-iterable';\nimport { isPresent, noop, valueProvider } from '@proc7ts/call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Conversion<From, To>\n    | InConverter.Factory<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<From, To>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Conversion<From, To> =\n      | InConverter.Value.Conversion<From, To>\n      | InConverter.Aspect.Conversion<To>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Value<From, To> =\n      | InConverter.Value.Factory<From, To>\n      | InConverter.Value.Conversion<From, To>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To = From> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Conversion<From, To>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: To): From;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To = From> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<Value>(\n    ...converters: InConverter.Aspect<Value, Value>[]\n): InConverter.Aspect.Factory<Value, Value>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter.Value<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Value.Factory<From, To>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter?: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> {\n\n  type AspectApplicator = <Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<From, To> => {\n\n    const conversion = converter(from, to);\n    const conversions = flatMapIt<InConverter.Conversion<From, To>>([\n        [conversion],\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    ]);\n\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<From, To>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeparam Value  Input value type.\n * @param aspects  Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<Value>(\n    aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[],\n): InConverter.Aspect.Factory<Value> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<Value>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion  Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return !(conversion as any).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Value<From, To>,\n): InConverter.Value.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { asis, noop } from '@proc7ts/call-thru';\nimport {\n  EventEmitter,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get [EventSupply__symbol](): EventSupply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<Value, Value>[]\n  ): InControl<Value>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   * @param and  Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      by: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<To>;\n\n  convert<To>(\n      by?: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<Value> | InControl<To> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<From, To> extends InControl<To> {\n\n  private readonly _supply: EventSupply;\n  private readonly _on = new EventEmitter<[To, To]>();\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(src: InControl<From>, by: InConverter.Factory<From, To>) {\n    super();\n    this._supply = eventSupply().needs(src);\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: From) => To;\n    let get: (value: To) => From;\n    let convertAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    if (isInAspectConversion(conversion)) {\n      set = asis as (value: From) => To;\n      get = asis as (value: To) => From;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    eventSupplyOf(this._it).needs(this._supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  on(): OnEvent<[To, To]>;\n  on(receiver: EventReceiver<[To, To]>): EventSupply;\n  on(receiver?: EventReceiver<[To, To]>): OnEvent<[To, To]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { EventReceiver, EventSupply, eventSupply, EventSupply__symbol, OnEvent } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nclass InSameValueControl<Value> extends InControl<Value> {\n\n  private _supply?: EventSupply;\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply || (this._supply = eventSupply().needs(this._control));\n  }\n\n  get it(): Value {\n    return this._control.it;\n  }\n\n  set it(value: Value) {\n    this._control.it = value;\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._control.on().F)(receiver);\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @param control  Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<Value>(control: InControl<Value>): InControl<Value> {\n  return new InSameValueControl(control);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n *\n * @category Control\n */\nexport abstract class AbstractInControl<Value> extends InControl<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<Value>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends AbstractInControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * Builds an `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container updates sender.\n   */\n  abstract on(): OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * Starts sending container updates to the given receiver.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * @param receiver  Target container updates receiver.\n   *\n   * @returns Container updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InContainer.Entry[], InContainer.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container contents snapshot keeper.\n   */\n  abstract read(): AfterEvent<[InContainer.Snapshot]>;\n\n  /**\n   * Starts sending container contents and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of container snapshot updates.\n   *\n   * @returns Container contents supply.\n   */\n  abstract read(receiver: EventReceiver<[InContainer.Snapshot]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read();\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of parent updates.\n   */\n  abstract on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * Starts sending parent updates to the given `receiver`.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * @param receiver  Target parent updates receiver.\n   *\n   * @returns Parent updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of control parents.\n   */\n  abstract read(): AfterEvent<[InParents.All]>;\n\n  /**\n   * Starts sending control parents and updates to the given `receiver`\n   *\n   * @param receiver  Target control parents receiver.\n   *\n   * @returns Control parents supply.\n   */\n  abstract read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read();\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    eventSupplyOf(this._on).needs(this._control);\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n  on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InParents.Entry[], InParents.Entry[]]>,\n  ): OnEvent<[InParents.Entry[], InParents.Entry[]]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  read(): AfterEvent<[InParents.All]>;\n  read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n  read(receiver?: EventReceiver<[InParents.All]>): AfterEvent<[InParents.All]> | EventSupply {\n\n    const allParents = (): IterableIterator<InParents.Entry> => this._map.keys();\n\n    return (this.read = afterSent<[InParents.All]>(\n        this.on().thru(allParents),\n        () => [allParents()],\n    ).F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { AfterEvent, EventReceiver, EventSupply } from '@proc7ts/fun-events';\nimport { DomEventDispatcher } from '@proc7ts/fun-events/dom';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends AbstractInControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of user input.\n   *\n   * @returns `AfterEvent` keeper of user input.\n   */\n  abstract input(): AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * Starts sending user input and updates to the given `receiver`.\n   *\n   * @param receiver  Target user input receiver.\n   *\n   * @returns User input supply.\n   */\n  abstract input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<Value, any>,\n        ) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { flatMapIt } from '@proc7ts/a-iterable';\nimport { nextArgs, NextCall, nextSkip, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * Creates an `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of input mode updates.\n   */\n  abstract on(): OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * Starts sending input mode updates to the given `receiver`\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * @param receiver  Target input mode updates receiver.\n   *\n   * @returns Input mode updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input mode.\n   */\n  abstract read(): AfterEvent<[InMode.Value]>;\n\n  /**\n   * Starts sending input mode and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of input mode.\n   *\n   * @returns Input mode supply.\n   */\n  abstract read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read();\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._tracker);\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n    case 'off':\n    case 'ro':\n    case '-on':\n    case '-ro':\n      break;\n    default:\n      value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    return (this.on = this._tracker.on().F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on().thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keepThru(\n        (set: Set<AfterEvent<[InMode.Value]>>) => nextAfterEvent(afterEach(...set)),\n        mergeInModes,\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): EventSupply {\n\n    const supply = eventSupply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    eventSupplyOf(this.own).needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read().keepThru_(parentsInMode));\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  read(): AfterEvent<[InMode.Value]>;\n  read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n  read(receiver?: EventReceiver<[InMode.Value]>): AfterEvent<[InMode.Value]> | EventSupply {\n\n    let last: InMode.Value = 'on';\n\n    return (this.read = afterSent<[InMode.Value]>(\n            afterAll({\n              derived: this._derived.read,\n              own: this.own,\n            }).thru(\n                ({\n                  derived: [derived],\n                  own: [own],\n                }) => {\n\n                  let next: InMode.Value;\n\n                  if (own === 'off' || derived === 'off') {\n                    next = 'off';\n                  } else {\n\n                    let off = false;\n\n                    if (own[0] === '-') {\n                      off = true;\n                      own = own.substring(1) as InMode.Value;\n                    }\n                    if (derived[0] === '-') {\n                      off = true;\n                      derived = derived.substring(1) as InMode.Value;\n                    }\n                    next = derived === 'ro' ? 'ro' : own;\n                    if (off) {\n                      next = '-' + next as InMode.Value;\n                    }\n                  }\n\n                  return last === next ? nextSkip() : nextArgs(last = next);\n                },\n            ),\n            valuesProvider<[InMode.Value]>(last),\n        ).F\n    )(receiver);\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    let lastUpdate: InMode.Value = 'on';\n\n    return (this.on = this.read().thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    }).F)(receiver);\n  }\n\n  derive(source: InMode.Source): EventSupply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control))\n            .tillOff(this._control),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n  case 'off':\n    element.setAttribute('disabled', '');\n    break;\n  case 'ro':\n  case '-ro':\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    element.setAttribute('readonly', '');\n    break;\n  default:\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('readonly', '');\n    element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): NextCall<OnEventCallChain, [InMode.Value]> {\n\n  const parentList = Array.from(parents);\n\n  if (!parentList.length) {\n    return nextArgs('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return nextAfterEvent(afterEach(...parentModes).keepThru_(mergeInModes));\n}\n\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...flatMapIt<InMode.Value>(modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes  Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n    case 'off':\n      return 'off';\n    case 'ro':\n      ro = true;\n      break;\n    case '-on':\n      off = true;\n      break;\n    case '-ro':\n      off = true;\n      ro = true;\n      break;\n    case 'on':\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { afterAll, AfterEvent } from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <V>(ctrl: InControl<V>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).keepThru(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? nextArgs(value as any)\n            : nextArgs(),\n    ));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<Value, InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from '@proc7ts/a-iterable';\nimport { nextArg, nextArgs, NextCall, noop } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  nextAfterEvent,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<Instance, Model, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  abstract on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n\n  abstract read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  abstract read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): EventSupply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<Model>): EventSupply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof Model): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<Model> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, InGroupEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, InGroupEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, InGroupEntry][],\n      removed: [keyof Model, InGroupEntry][],\n  ): EventSupply {\n\n    const replaced = this._map.get(key);\n    let supply: EventSupply;\n\n    if (control) {\n      supply = eventSupply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = noEventSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]>,\n      supply: EventSupply,\n  ): InGroupEntry {\n    return [\n      control,\n      eventSupply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof Model, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof Model, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n  clear(): [keyof Model, InGroupEntry][] {\n\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, InGroupEntry][], [keyof Model, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const applyModelToControls = (model: Model): void => {\n      this.read().once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<Model>(this);\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>,\n  ): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]> | EventSupply {\n    return (this.on = this._updates.on().thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ).F)(receiver);\n  }\n\n  read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n  read(receiver?: EventReceiver<[InGroup.Snapshot<Model>]>): AfterEvent<[InGroup.Snapshot<Model>]> | EventSupply {\n    return (this.read = afterSent<[InGroup.Snapshot<Model>]>(\n        this._updates.on().thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()],\n    ).F)(receiver);\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined,\n  ): EventSupply {\n\n    const group = this._group;\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n    let supply: EventSupply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = eventSupply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: Model | undefined;\n\n      added.forEach(<K extends keyof Model>(keyAndEntry: [keyof Model, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [K, [InControl<Model[K]>, EventSupply]];\n\n        control.aspect(InParents)\n            .add({ parent: group })\n            .needs(supply)\n            .cuts(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(<K extends keyof Model>(keyAndEntry: [keyof Model, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [K, [InControl<Model[K]>, EventSupply]];\n\n        control.read().tillOff(supply).to(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, InGroupEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(\n      model: Model,\n      opts: {\n        readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    eventSupplyOf(this).whenOff(() => this.controls.clear());\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._model);\n  }\n\n  get it(): Model {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  on(): OnEvent<[Model, Model]>;\n  on(receiver: EventReceiver<[Model, Model]>): EventSupply;\n  on(receiver?: EventReceiver<[Model, Model]>): OnEvent<[Model, Model]> | EventSupply {\n    return (this.on = this._model.on().F)(receiver);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keepThru_(\n      readInGroupData,\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    },\n): NextCall<OnEventCallChain, [InData.DataType<Model>?]> {\n  if (!InMode.hasData(mode)) {\n    return nextArgs();\n  }\n\n  const csData = {} as { [key in keyof Model]: InData<any> };\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return nextAfterEvent(afterAll(csData).keepThru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(\n        overEntries(controlsData),\n        <K extends keyof Model>(keyAndControlData: [keyof Model, [InData.DataType<any>?]]) => {\n\n          const [key, [controlData]] = keyAndControlData as [K, [Model[K]?]];\n\n          data[key] = controlData;\n        },\n    );\n\n    return nextArg(data as InData.DataType<Model>);\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(\n    model: Model,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n    } = {},\n): InGroup<Model> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<OfValue extends object ? OfValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { AfterEvent, afterThe } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst RequireNothing$ = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return RequireNothing$;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { CallChain, nextArgs, NextCall, valueProvider } from '@proc7ts/call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>,\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read().keepThru(simpleInValidator(control, validator));\n}\n\n/**\n * @internal\n */\nfunction simpleInValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): (value: Value) => NextCall<CallChain, InValidation.Message[]> {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : nextArgs(messages);\n  };\n}\n","import { flatMapIt, itsEach } from '@proc7ts/a-iterable';\nimport { asis, noop, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this._messages = afterEventBy<InValidation.Message[]>(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider()).to(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator.to(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share().tillOff(control);\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from '@proc7ts/a-iterable';\nimport { nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEventCallChain,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild<Value, InValidation<Value>, 'validation'>(\n        control,\n        InValidation,\n        <V>(ctrl: InControl<V>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<V>(ctrl);\n\n          if (origin) {\n\n            const from = origin.aspect(InValidation);\n\n            validation.by(from.read().keepThru(result => nextArgs(...result.messages())));\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @return `AfterEvent` keeper of validation result keeper.\n   */\n  abstract read(): AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Starts sending validation result and updates to the given `receiver`\n   *\n   * @param receiver  Target validation result receiver.\n   *\n   * @returns Validation results supply.\n   */\n  abstract read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read();\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes  Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code, [message]);\n              }\n            }\n          });\n\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        },\n    );\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): IterableIterator<InValidation.Message> {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n  read(): AfterEvent<[InValidation.Result]>;\n  read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n  read(receiver?: EventReceiver<[InValidation.Result]>): AfterEvent<[InValidation.Result]> | EventSupply {\n    return (this.read = afterSupplied(this._messages).keepThru(inValidationResult).F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read().keepThru(\n      nestedInValidations,\n      combineInValidationResults,\n  );\n}\n\n/**\n * @internal\n */\nfunction nestedInValidations(\n    controls: InContainer.Snapshot,\n): NextCall<OnEventCallChain, [InValidation.Result][]> {\n  return nextAfterEvent(afterEach(...mapIt(controls, control => control.aspect(InValidation))));\n}\n\n/**\n * @internal\n */\nfunction combineInValidationResults(\n    ...results: [InValidation.Result][]\n): NextCall<OnEventCallChain, InValidation.Message[]> {\n  return nextArgs<InValidation.Message[]>(\n      ...flatMapIt(mapIt(results, result => result[0])),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { EventKeeper } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read().keepThru(value => value ? nextArgs() : { missing: 'missing' })\n      : requirePresent;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { itsEvery, mapIt } from '@proc7ts/a-iterable';\nimport { nextArgs } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  eventSupplyOf,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrBuild } from './aspect.impl';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors  Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...mapIt(errors, message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason  A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * [input data]: InData\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InSubmit<Value> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of submit status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of submit status flags.\n   */\n  abstract read(): AfterEvent<[InSubmit.Flags]>;\n\n  /**\n   * Starts sending submit status flags and updates to the given `receiver`\n   *\n   * @param receiver  Target submit status flags receiver.\n   *\n   * @returns Submit status flags supply.\n   */\n  abstract read(receiver: EventReceiver<[InSubmit.Flags]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read();\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @param submitter  A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Result  Submit result value type.\n   */\n  export type Submitter<Value, Result> =\n  /**\n   * @param data  Input data to submit.\n   * @param control  Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          this: void,\n          data: Value extends undefined ? never : Value,\n          control: InControl<Value>,\n      ) => Promise<Result>;\n\n}\n\nclass InControlSubmit<Value> extends InSubmit<Value> {\n\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read().keepThru(\n        messages => nextArgs(...messages),\n    ));\n  }\n\n  read(): AfterEvent<[InSubmit.Flags]>;\n  read(receiver: EventReceiver<[InSubmit.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InSubmit.Flags]>): AfterEvent<[InSubmit.Flags]> | EventSupply {\n    return (this.read = afterAll({\n      flags: this._flags,\n      data: this._control.aspect(InData),\n      messages: this._control.aspect(InValidation),\n    })\n        .tillOff(this._control)\n        .keepThru(\n            ({\n              flags: [flags],\n              data: [data],\n              messages: [messages],\n            }): InSubmit.Flags => ({\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n              ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n              submitted: flags.submitted,\n              busy: flags.busy,\n            }),\n        ).F)(receiver);\n  }\n\n  async submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result> {\n    if (eventSupplyOf(this._control).isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    function submitData(): Promise<Value extends undefined ? never : Value> {\n      return new Promise((resolve, reject) => {\n        afterAll({\n          data: control.aspect(InData),\n          flags: submit,\n        }).once(({ data: [d], flags: [{ ready }] }) => {\n          if (!ready) {\n            reject(new InSubmitRejectedError('notReady'));\n          } else {\n            resolve(d as any);\n          }\n        });\n      });\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form  Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady  Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid  Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy  Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read().keepThru(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid  Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore  Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read().keepThru(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { asis, nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  afterSent,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n} from '@proc7ts/fun-events';\nimport { DomEventDispatcher } from '@proc7ts/fun-events/dom';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport class AbstractInElement<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: AbstractInElement<Value, Elt>) => Value;\n  private readonly _set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private _value: Value;\n  private _update: (value: Value, oldValue: Value) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element  HTML input element the constructed control is based on.\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get  Input value getter.\n   * @param set  Input value setter.\n   */\n  constructor(\n      readonly element: Elt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n        readonly get: (this: AbstractInElement<Value, Elt>) => Value;\n        readonly set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: Value, oldValue: Value): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    eventSupplyOf(this.events).needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    function update(input: InElement.Input<Value>, oldValue: Value): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._input);\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  input(): AfterEvent<[InElement.Input<Value>]>;\n  input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n  input(receiver?: EventReceiver<[InElement.Input<Value>]>): AfterEvent<[InElement.Input<Value>]> | EventSupply {\n    return (this.input = afterSent<[InElement.Input<Value>]>(\n        this._input.on().thru(asis), // remove the second parameter\n        () => [{ value: this.it }],\n    ).F)(receiver);\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._input.on().thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    ).F)(receiver);\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update  Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<Value>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input').to(onInput);\n    this.events.on('change').to(onInput);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { noop } from '@proc7ts/call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot = element.getRootNode\n        ? element.getRootNode() as unknown as DocumentOrShadowRoot\n        : element.ownerDocument;\n\n    this._it = trackValue(owner.activeElement === element);\n    eventSupplyOf(this).needs(inElement);\n\n    events.on('focus').to(() => this._it.it = true);\n    events.on('blur').to(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._it);\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  on(): OnEvent<[boolean, boolean]>;\n  on(receiver: EventReceiver<[boolean, boolean]>): EventSupply;\n  on(receiver?: EventReceiver<[boolean, boolean]>): OnEvent<[boolean, boolean]> | EventSupply {\n    return (this.on = this._it.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { itsEach, mapIt } from '@proc7ts/a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  eventSupplyOf,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * Builds `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input status flags.\n   */\n  abstract read(): AfterEvent<[InStatus.Flags]>;\n\n  /**\n   * Starts sending input status flags and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of input status flags.\n   *\n   * @returns Input status flags supply.\n   */\n  abstract read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read();\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    eventSupplyOf(this._flags).needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = this._flags.read().F)(receiver);\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input().keepThru(({ event }) => !!event) : afterThe(false),\n  }).keepThru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  );\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = containerInStatusFlags(this._container).F)(receiver);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markEdited(edited),\n        ),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markTouched(touched),\n        ),\n    );\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read().tillOff(container).keepThru_(\n      (snapshot: InContainer.Snapshot) => nextAfterEvent(afterEach(...inControlStatuses(snapshot))),\n      combineInStatusFlags,\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { eventSupplyOf } from '@proc7ts/fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by [[inFormElement]] function.\n *\n * @category Control\n * @typeparam Elt  A type of HTML form element.\n */\nexport type InFormElement<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element  HTML element to create control for.\n * @param options  Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<Elt extends HTMLElement>(\n    element: Elt,\n    options: InFormElement.Options,\n): InFormElement<Elt> {\n\n  const { form, aspects, modes } = options;\n  const control = new AbstractInElement<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, modes));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { eventSupplyOf } from '@proc7ts/fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form submit button control.\n *\n * It is connected to control to submit (form) and may change submit button state depending on form submit status.\n * E.g. by disabling it when submit is {@link InSubmit.Flags.ready not ready}, or while {@link InSubmit.Flags.busy\n * submitting} the form.\n *\n * Submit button control can be created by [[inSubmitButton]] function.\n *\n * @category Control\n * @typeparam Elt  A type of submit button element.\n */\nexport type InSubmitButton<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InSubmitButton {\n\n  /**\n   * Submit button control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to submit button control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `off` (disable) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `off` (disabled) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element  Submit button element to create control for.\n * @param options  Submit button control options.\n *\n * @returns New submit button control.\n */\nexport function inSubmitButton<Elt extends HTMLElement>(\n    element: Elt,\n    options: InSubmitButton.Options,\n): InSubmitButton<Elt> {\n\n  const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n  const control = new AbstractInElement<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, { notReady, invalid, busy }));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull as InAspect.Applied<any, InStyledElement | null>;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @param element  A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(element: InStyledElement | null = null): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/a-iterable';\nimport { noop } from '@proc7ts/call-thru';\nimport { DeltaSet } from '@proc7ts/delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventKeeper,\n  EventNotifier,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { css__naming, isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { RenderSchedule } from '@proc7ts/render-scheduler';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of CSS classes map.\n   */\n  abstract read(): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Starts sending CSS classes for styled element and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of CSS classes map.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @returns `AfterEvent` keeper of added and removed classes.\n   */\n  abstract track(): AfterEvent<[readonly string[], readonly string[]]>;\n\n  /**\n   * Starts sending current, added and removed CSS classes to the given `receiver`\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @param receiver  Target receiver of added and removed CSS classes.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element  Target element to apply CSS classes to.\n   * @param schedule  DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by [[InNamespaceAliaser]] aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  private readonly _sources = trackValue<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]>([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n\n    eventSupplyOf(_control).whenOff(reason => this.done(reason));\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  read(): AfterEvent<[InCssClasses.Map]>;\n  read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n  read(receiver?: EventReceiver<[InCssClasses.Map]>): AfterEvent<[InCssClasses.Map]> | EventSupply {\n    return (this.read = this._sources.read().tillOff(this._control).keepThru_(\n        ([sources]) => nextAfterEvent(afterEach(...sources.keys())),\n        (...classes) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        },\n    ).F)(receiver);\n  }\n\n  track(): AfterEvent<[readonly string[], readonly string[]]>;\n  track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n  track(\n      receiver?: EventReceiver<[readonly string[], readonly string[]]>,\n  ): AfterEvent<[readonly string[], readonly string[]]> | EventSupply {\n    return (this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    }).F)(receiver);\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).keepThru(\n        (...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        },\n    );\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const inSupply = eventSupplyOf(this._control);\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source).to({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): EventSupply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark  Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when  {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  let marks: InCssClasses.Spec[];\n\n  if (!mark) {\n    marks = defaultInCssErrorMarks;\n  } else if (Array.isArray(mark)) {\n    marks = mark.length ? mark : defaultInCssErrorMarks;\n  } else {\n    marks = [mark];\n  }\n\n  return control => control.aspect(InValidation).read().keepThru(\n      errors => hasError(errors) ? nextArgs(...marks) : nextArgs(),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { afterAll } from '@proc7ts/fun-events';\nimport { NamespaceDef, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InValidation } from '../../validation';\nimport { InStatus } from '../focus';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns  A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keepThru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          return nextArgs(...names);\n        },\n    );\n  };\n}\n"],"names":["InAspect__symbol","Symbol","inAspectNull","instance","convertTo","noop","inAspectSameOrBuild","control","aspectKey","build","origin","undefined","target","attachTo","aspect","inAspectSameOrNull","valueProvider","inAspectValue","[object Object]","this","InputAspects__NS","NamespaceDef","InNamespaceAliaser__aspect","applyTo","newNamespaceAliaser","InNamespaceAliaser","to","nsAlias","applyAspect","InRenderScheduler__aspect","newRenderSchedule","InRenderScheduler","scheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","length","aspectConverters","mapIt","from","conversion","conversions","flatMapIt","filterIt","acf","isPresent","itsReduction","prev","cv","isInAspectConversion","set","bind","get","intoConvertedAspects","aspects","value","Array","isArray","noopInConversion","InControl","ValueTracker","Map","_aspect","aspectKeyOrSetup","aspectSetup","by","and","InConverted","existing","_aspects","applied","_applyAspect","src","super","EventEmitter","_supply","eventSupply","needs","backward","lastRev","convertAspect","asis","fallback","_it","trackValue","it","eventSupplyOf","on","newValue","oldValue","_on","send","cuts","rev","EventSupply__symbol","prevValue","prevRev","receiver","F","InSameValueControl","_control","AbstractInControl","_aspectConversion","InContainer__aspect","InContainer","InContainerControls","OnEvent__symbol","AfterEvent__symbol","read","InParents__aspect","InControlParents","InParents","entry","existingSupply","_map","supply","delete","parent","allParents","keys","afterSent","thru","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","reason","own","done","OwnModeTracker","element","_tracker","getAttribute","initialInMode","DerivedInModes","Set","sources","_all","valuesProvider","keepThru","nextAfterEvent","afterEach","mergeInModes","source","add","derive","InParentsAspect","keepThru_","parentsInMode","setAttribute","removeAttribute","applyInMode","last","afterAll","derived","_derived","next","off","substring","nextSkip","nextArgs","lastUpdate","old","afterSupplied","isEventKeeper","tillOff","parents","parentList","parentModes","map","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","InGroupControls","key","inControlReplacedReason","InGroupSnapshot","iterator","itsIterable","values","entries","InGroupMap","_controls","added","removed","replaced","newEntry","sendUpdate","push","modify","noEventSupply","remove","whenOff","_shot","itsEach","k","e","InGroupControlControls","_group","model","once","snapshot","withValues","overEntries","has","_updates","controlEntryToGroupEntry","keyOrControls","newControl","group","newModel","forEach","keyAndEntry","applyControlsToModel","clear","InGroupControl","opts","_model","controls","cs","readInGroupData","csData","controlsData","data","keyAndControlData","controlData","nextArg","inGroup","RequireNothing$","afterThe","requireNothing","inValidator","validator","messages","validate","simpleInValidator","dontRemove","InValidationMessages","emitter","validators","validatorMessages","_messages","afterEventBy","resultSupply","validatorSupply","size","share","InValidation__aspect","InValidation","validation","InControlValidation","result","noInValidationErrors","ok","hasBut","InValidationErrors","message","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","container","nestedInValidations","combineInValidationResults","nestedInValidationMessages","numValidators","requireAll","results","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","Error","errors","submit","InSubmitRejectedError","rejected","submitted","busy","_errors","flags","_flags","ready","itsEvery","submitter","isOff","Promise","resolve","reject","d","error","toInSubmitMessages","inModeByForm","form","notReady","invalid","inModeByValidity","ignore","validity","AbstractInElement","self","_get","_set","_value","doUpdate","_update","update","input","correction","_input","events","DomEventDispatcher","listenForInput","onInput","event","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","ownerDocument","activeElement","ctx","onRecurrent","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","c","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","options","inSubmitButton","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","schedule","_schedule","controlSchedule","_sources","classes","mergeInCssClassesMap","track","DeltaSet","EventNotifier","classesSent","flag","name","delta","redelta","undelta","specs","names","isQualifiedName","css__naming","inSupply","classesSupply","context","receive","classList","updateClasses","node","defaultInCssErrorMarks","defaultInCssHasError","inCssError","mark","when","hasError","marks","inCssInfo","ns","cls","md","vl","st","valid"],"mappings":"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"}