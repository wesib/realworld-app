{"version":3,"file":"fun-events.f7c44dc9.js","sources":["../../../../../proc7ts/fun-events/src/base/event-keeper.ts","../../../../../proc7ts/fun-events/src/base/event-receiver.ts","../../../../../proc7ts/fun-events/src/base/event-notifier.impl.ts","../../../../../proc7ts/fun-events/src/base/event-notifier.ts","../../../../../proc7ts/fun-events/src/base/event-sender.ts","../../../../../proc7ts/fun-events/src/base/send-events-to.ts","../../../../../proc7ts/fun-events/src/impl/after-event.no-fallback.ts","../../../../../proc7ts/fun-events/src/impl/event-dig.ts","../../../../../proc7ts/fun-events/src/impl/on-event.do.ts","../../../../../proc7ts/fun-events/src/impl/on-event.supplier.ts","../../../../../proc7ts/fun-events/src/impl/once-event.ts","../../../../../proc7ts/fun-events/src/impl/on-event.then.ts","../../../../../proc7ts/fun-events/src/impl/share-events.ts","../../../../../proc7ts/fun-events/src/impl/supply-events.ts","../../../../../proc7ts/fun-events/src/impl/translate-events.ts","../../../../../proc7ts/fun-events/src/base/impl/never-receive.ts","../../../../../proc7ts/fun-events/src/after-event.ts","../../../../../proc7ts/fun-events/src/keepers/after-all.ts","../../../../../proc7ts/fun-events/src/keepers/after-each.ts","../../../../../proc7ts/fun-events/src/keepers/after-sent.ts","../../../../../proc7ts/fun-events/src/keepers/after-supplied.ts","../../../../../proc7ts/fun-events/src/keepers/after-the.ts","../../../../../proc7ts/fun-events/src/on-event.ts","../../../../../proc7ts/fun-events/src/processors/consume-events.ts","../../../../../proc7ts/fun-events/src/processors/share-after.ts","../../../../../proc7ts/fun-events/src/processors/dig-after.ts","../../../../../proc7ts/fun-events/src/senders/event-emitter.ts","../../../../../proc7ts/fun-events/src/senders/on-never.ts","../../../../../proc7ts/fun-events/src/senders/on-supplied.ts","../../../../../proc7ts/fun-events/src/senders/on-any.ts","../../../../../proc7ts/fun-events/src/senders/on-promise.ts","../../../../../proc7ts/fun-events/src/base/impl/always-receive-value.ts","../../../../../proc7ts/fun-events/src/processors/share-on.ts","../../../../../proc7ts/fun-events/src/processors/dig-on.ts","../../../../../proc7ts/fun-events/src/processors/translate-on.ts","../../../../../proc7ts/fun-events/src/processors/map-after.ts","../../../../../proc7ts/fun-events/src/processors/map-on.ts","../../../../../proc7ts/fun-events/src/processors/once-after.ts","../../../../../proc7ts/fun-events/src/processors/once-on.ts","../../../../../proc7ts/fun-events/src/processors/supply-on.ts","../../../../../proc7ts/fun-events/src/processors/resolve-on-ordered.ts","../../../../../proc7ts/fun-events/src/processors/resolve-on.ts","../../../../../proc7ts/fun-events/src/processors/supply-after.ts","../../../../../proc7ts/fun-events/src/processors/translate-after.ts","../../../../../proc7ts/fun-events/src/processors/value-on.ts","../../../../../proc7ts/fun-events/src/state/state-path.ts","../../../../../proc7ts/fun-events/src/state/state-tracker.ts","../../../../../proc7ts/fun-events/src/value/value-tracker.ts","../../../../../proc7ts/fun-events/src/value/track-value.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\n\n/**\n * A key of {@link EventKeeper} method returning its {@link AfterEvent} instance.\n *\n * @category Core\n */\nexport const AfterEvent__symbol = (/*#__PURE__*/ Symbol('after-event'));\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<TEvent extends any[]> {\n\n  /**\n   * Returns an {@link AfterEvent} instance of this event keeper.\n   *\n   * @returns {@link AfterEvent} instance registering event receivers sent by this keeper.\n   */\n  [AfterEvent__symbol](): AfterEvent<TEvent>;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeParam TKeeper - Target event keeper.\n   */\n  export type Event<TKeeper extends EventKeeper<any>> = TKeeper extends EventKeeper<infer TEvent> ? TEvent : never;\n\n}\n\n/**\n * Checks whether the given object implements an {@link EventKeeper} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param value - An object to check.\n *\n * @returns `true` if `value` contains an {@link AfterEvent__symbol} property, or `false` otherwise.\n */\nexport function isEventKeeper<TEvent extends any[]>(value: object): value is EventKeeper<TEvent> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\n\n/**\n * Event receiver is called on each event sent by {@link EventSender} when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of {@link EventReceiver.Object.receive} method.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<TEvent extends any[]> = EventReceiver.Function<TEvent> | EventReceiver.Object<TEvent>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<TEvent extends any[]> =\n  /**\n   * @param event - An event represented by function call arguments.\n   */\n      (this: void, ...event: TEvent) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<TEvent extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link Supply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context - An event processing context.\n     * @param event - An event represented as the rest of arguments.\n     */\n    receive(context: Context<TEvent>, ...event: TEvent): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by {@link eventReceiver} function.\n   *\n   * In contrast to {@link EventReceiver.Object} this one always has a supply.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<TEvent extends any[]> extends Object<TEvent> {\n\n    readonly supply: Supply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to {@link EventReceiver.Object} receivers.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<TEvent extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver - Recurrent events receiver function.\n     */\n    onRecurrent(receiver: EventReceiver.Function<TEvent>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n * @param receiver - An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<TEvent extends any[]>(receiver: EventReceiver<TEvent>): EventReceiver.Generic<TEvent> {\n\n  let generic: {\n    readonly supply: Supply;\n    receive: (context: EventReceiver.Context<TEvent>, ...event: TEvent) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: new Supply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || new Supply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","import { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @internal\n * @param receivers - An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nexport function receiveByEach<TEvent extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<TEvent>>,\n): (this: void, ...event: TEvent) => void {\n\n  let send: (this: void, event: TEvent) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: TEvent): void {\n\n    let actualReceivers = receivers;\n    const received: TEvent[] = [];\n\n    send = (recurrent: TEvent) => received.push(recurrent);\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n  }\n}\n\n/**\n * @internal\n */\nfunction processEvent<TEvent extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<TEvent>>,\n    event: TEvent,\n): EventReceiver.Generic<TEvent>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<TEvent>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<TEvent> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an {@link EventSender} interface though. Use an {@link EventEmitter} if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link Supply.off cut off}.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<TEvent extends any[]> implements SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _rcs?: Set<EventReceiver.Generic<TEvent>>;\n\n  readonly supply: Supply;\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event - An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: TEvent) => void;\n\n  constructor() {\n\n    const rcs = this._rcs = new Set<EventReceiver.Generic<TEvent>>();\n\n    this.send = receiveByEach(rcs);\n    this.supply = new Supply(() => {\n      rcs.clear();\n      delete this._rcs;\n    });\n  }\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcs ? this._rcs.size : 0;\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * @param receiver - A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<TEvent>): Supply {\n\n    const generic = eventReceiver(receiver);\n    const supply = generic.supply.needs(this);\n    const receivers = this._rcs;\n\n    if (receivers && !supply.isOff) {\n      receivers.add(generic);\n      supply.whenOff(() => receivers.delete(generic));\n    }\n\n    return supply;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { OnEvent } from '../on-event';\n\n/**\n * A key of {@link EventSender} method returning its {@link OnEvent} instance.\n *\n * @category Core\n */\nexport const OnEvent__symbol = (/*#__PURE__*/ Symbol('on-event'));\n\n/**\n * A sender of events.\n *\n * Contains an {@link OnEvent} instance registering event receivers.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<TEvent extends any[]> {\n\n  /**\n   * Returns an {@link OnEvent} instance of this event sender.\n   *\n   * @returns {@link OnEvent} instance registering event receivers sent by this sender.\n   */\n  [OnEvent__symbol](): OnEvent<TEvent>;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeParam TSender - Target event sender.\n   */\n  export type Event<TSender extends EventSender<any>> = TSender extends EventSender<infer TEvent> ? TEvent : never;\n\n}\n\n/**\n * Checks whether the given object implements an {@link EventSender} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param value - An object to check.\n *\n * @returns `true` if `value` contains {@link OnEvent__symbol} property, or `false` otherwise.\n */\nexport function isEventSender<TEvent extends any[]>(value: object): value is EventSender<TEvent> {\n  return OnEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/primitives';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event sender targeted specific receiver.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n *\n * @param receiver - Target event receiver.\n *\n * @returns A function accepting events and sending them to target `receiver`.\n */\nexport function sendEventsTo<TEvent extends any[]>(\n    receiver: EventReceiver<TEvent>,\n): (this: void, ...event: TEvent) => void {\n\n  const generic = eventReceiver(receiver);\n  let send: (...event: TEvent) => void = receiveByEach([generic]);\n\n  generic.supply.whenOff(() => send = noop);\n\n  return (...event) => send(...event);\n}\n","/**\n * @internal\n */\nexport function AfterEvent$noFallback(): never {\n  throw new Error('No events to send');\n}\n","import { neverSupply, Supply } from '@proc7ts/primitives';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function eventDig<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    input: OnEvent<TInEvent>,\n    extract: (this: void, ...event: TInEvent) => OnEvent<TOutEvent> | void | undefined,\n): (receiver: EventReceiver.Generic<TOutEvent>) => void {\n  return (receiver: EventReceiver.Generic<TOutEvent>) => {\n\n    let nestedSupply = neverSupply();\n\n    input({\n\n      supply: receiver.supply,\n\n      receive: (_context, ...event: TInEvent) => {\n\n        const prevSupply = nestedSupply;\n        const extracted = extract(...event);\n\n        try {\n          nestedSupply = extracted\n              ? extracted({\n\n                supply: new Supply().needs(receiver.supply),\n\n                receive(context, ...event: TOutEvent) {\n                  receiver.receive(context, ...event);\n                },\n\n              })\n              : neverSupply();\n        } finally {\n          prevSupply.off();\n        }\n      },\n    });\n  };\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function OnEvent$do<TEvent extends any[]>(\n    this: OnEvent<TEvent>,\n    ...processors: ((this: void, arg: any) => any)[]\n): any {\n  return processors.reduce((arg, action) => action(arg), this);\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function OnEvent$supplier<T extends OnEvent<any>>(this: T): T {\n  return this;\n}\n","import { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function onceEvent<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    supplier({\n      supply: receiver.supply,\n      receive: (context, ...event) => {\n        receiver.receive(context, ...event);\n        receiver.supply.off();\n      },\n    });\n  };\n}\n","import { Supply } from '@proc7ts/primitives';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\nimport { onceEvent } from './once-event';\n\n/**\n * @internal\n */\nexport function OnEvent$then<TEvent extends any[], TResult1 = TEvent[0], TResult2 = never>(\n    this: OnEvent<TEvent>,\n    onEvent?: ((...value: TEvent) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n): Promise<TResult1 | TResult2> {\n  return new Promise((resolve, reject) => {\n    onceEvent(this)({\n      supply: onCutOff\n          ? new Supply(reason => {\n            try {\n              resolve(onCutOff(reason));\n            } catch (e) {\n              reject(e);\n            }\n          })\n          : new Supply(reject),\n      receive: onEvent\n          ? (_ctx, ...event): void => {\n            try {\n              resolve(onEvent(...event));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          : ((_ctx, event: TEvent[0]) => resolve(event)) as (\n              _ctx: EventReceiver.Context<TEvent>,\n              ...event: TEvent[]\n          ) => void,\n    });\n  });\n}\n","import { Supply } from '@proc7ts/primitives';\nimport { EventNotifier, EventReceiver, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function shareEvents<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n\n  const shared = new EventNotifier<TEvent>();\n  let sharedSupply: Supply;\n  let initialEvents: TEvent[] | undefined;\n\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    if (!shared.size) {\n      initialEvents = [];\n      sharedSupply = new Supply(() => initialEvents = undefined);\n\n      supplier({\n        supply: sharedSupply,\n        receive(_ctx, ...event) {\n          if (initialEvents) {\n            if (shared.size) {\n              // More events received\n              // Stop sending initial ones\n              initialEvents = undefined;\n            } else {\n              // Record events received during first receiver registration\n              // to send them to all receivers until more event received\n              initialEvents.push(event);\n            }\n          }\n          shared.send(...event);\n        },\n      });\n    }\n\n    receiver.supply.needs(sharedSupply);\n    shared.on(receiver).whenOff((reason?: any) => {\n      if (!shared.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatch = sendEventsTo(receiver);\n\n      initialEvents.forEach(event => dispatch(...event));\n    }\n  };\n}\n","import { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function supplyEvents<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    if (dependentSupply) {\n      supplier({\n        supply: new Supply().needs(required).cuts(dependentSupply),\n        receive: (receiver.receive as (...args: any[]) => void).bind(receiver),\n      });\n    } else {\n      receiver.supply.needs(required);\n      supplier(receiver);\n    }\n  };\n}\n","import { EventReceiver, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function translateEvents<TInEvent extends any[], TOutEvent extends any[]>(\n    supplier: OnEvent<TInEvent>,\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (receiver: EventReceiver.Generic<TOutEvent>) => void {\n  return receiver => {\n\n    const dispatch = sendEventsTo(receiver);\n\n    supplier({\n      supply: receiver.supply,\n      receive: (_ctx, ...event: TInEvent) => {\n        translate(dispatch, ...event);\n      },\n    });\n  };\n}\n","import { EventReceiver } from '../event-receiver';\n\n/**\n * @internal\n */\nexport function neverReceiveBecause(reason?: any): (receiver: EventReceiver.Generic<any>) => void {\n  return ({ supply }) => supply.off(reason);\n}\n\n/**\n * @internal\n */\nexport function neverReceive({ supply }: EventReceiver.Generic<any>): void {\n  supply.off();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { AfterEvent__symbol, EventKeeper, eventReceiver, EventReceiver, OnEvent__symbol } from './base';\nimport { AfterEvent$noFallback, OnEvent$do, OnEvent$supplier, OnEvent$then } from './impl';\nimport { OnEvent } from './on-event';\n\n/**\n * Signature of {@link EventKeeper} implementation able to register the receivers of kept and upcoming events.\n *\n * The registered event receiver receives the kept event immediately upon registration, and all upcoming events\n * after that until the returned event supply is cut off.\n *\n * To convert a plain event receiver registration function to {@link AfterEvent} an {@link afterEventBy} function can\n * be used.\n *\n * May be constructed using {@link afterEventBy} function.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface AfterEvent<TEvent extends any[]> extends OnEvent<TEvent>, EventKeeper<TEvent> {\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver - Target receiver of events.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  (receiver: EventReceiver<TEvent>): Supply;\n\n  [AfterEvent__symbol](): this;\n\n}\n\n/**\n * Converts a plain event receiver registration function to {@link AfterEvent} keeper with a fallback.\n *\n * The event constructed by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<TEvent extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<TEvent>) => void,\n    fallback: (this: void) => TEvent = AfterEvent$noFallback,\n): AfterEvent<TEvent> {\n\n  let lastEvent: TEvent | undefined;\n  let numReceivers = 0;\n\n  const afterEvent = ((receiver: EventReceiver<TEvent>): Supply => {\n\n    let dest: (context: EventReceiver.Context<TEvent>, ...event: TEvent) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = new Supply().needs(generic.supply);\n    let reported = false;\n\n    register({\n      supply,\n      receive: (context, ...event: TEvent) => {\n        reported = true;\n        lastEvent = event;\n        dest(context, ...event);\n      },\n    });\n    ++numReceivers;\n\n    if (!supply.isOff || reported) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(lastEvent || (lastEvent = fallback())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(reason => {\n      if (!--numReceivers) {\n        lastEvent = undefined;\n      }\n      generic.supply.off(reason);\n    });\n\n    return supply;\n  }) as AfterEvent<TEvent>;\n\n  afterEvent[OnEvent__symbol] = OnEvent$supplier;\n  afterEvent.do = OnEvent$do;\n  afterEvent.then = OnEvent$then;\n  afterEvent[AfterEvent__symbol] = OnEvent$supplier;\n\n  return afterEvent;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { onceEvent, shareEvents } from '../impl';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeParam TSrcMap - A type of `sources` map.\n * @param sources - A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nexport function afterAll<TSrcMap extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: TSrcMap,\n): AfterEvent<[{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  const registerReceiver = (\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }]>,\n  ): void => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result = {} as { [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> };\n\n    keys.forEach(<TSrcKey extends keyof TSrcMap>(key: TSrcKey) => {\n      supply.needs(sources[key][AfterEvent__symbol]()((...event: EventKeeper.Event<TSrcMap[TSrcKey]>) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(result);\n    }\n  };\n\n  const latestEvent = (): [{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }] => {\n\n    const result = {} as { [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> };\n\n    keys.forEach(\n        <TSrcKey extends keyof TSrcMap>(key: TSrcKey) => onceEvent(sources[key][AfterEvent__symbol]())({\n          supply: new Supply(),\n          receive: (_ctx, ...event: EventKeeper.Event<TSrcMap[TSrcKey]>) => result[key as keyof TSrcMap] = event,\n        }),\n    );\n\n    return [result];\n  };\n\n  return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { onceEvent, shareEvents } from '../impl';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeParam TEvent - A type of events sent by each source.\n * @param sources - An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nexport function afterEach<TEvent extends any[]>(...sources: EventKeeper<TEvent>[]): AfterEvent<TEvent[]> {\n\n  const registerReceiver = (receiver: EventReceiver.Generic<TEvent[]>): void => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: TEvent[] = [];\n\n    sources.forEach((source, index) => {\n      supply.needs(source[AfterEvent__symbol]()((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(...result);\n    }\n  };\n\n  const latestEvent = (): TEvent[] => {\n\n    const result: TEvent[] = [];\n\n    sources.forEach(\n        source => onceEvent(source[AfterEvent__symbol]())({\n          supply: new Supply(),\n          receive: (_ctx, ...event) => result.push(event),\n        }),\n    );\n\n    return result;\n  };\n\n  return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { EventSender, OnEvent__symbol } from '../base';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param sender - An event sender.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<TEvent extends any[]>(\n    sender: EventSender<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent> {\n  return afterEventBy(receiver => sender[OnEvent__symbol]()(receiver), fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventSupplier, isEventKeeper } from '../base';\nimport { afterSent } from './after-sent';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param keeper - A keeper of events.\n *\n * @returns An {@link AfterEvent} keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<TEvent extends any[]>(keeper: EventKeeper<TEvent>): AfterEvent<TEvent>;\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `supplier`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `supplier` sends one.\n *\n * This is a synonym of {@link afterSent}, unless `supplier` is an {@link EventKeeper}.\n *\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `supplier`. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `supplier`, or `initial` one.\n */\nexport function afterSupplied<TEvent extends any[]>(\n    supplier: EventSupplier<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent>;\n\nexport function afterSupplied<TEvent extends any[]>(\n    supplier: EventSupplier<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent> {\n  return isEventKeeper(supplier) ? supplier[AfterEvent__symbol]() : afterSent(supplier, fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, valueProvider } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\n\n/**\n * Builds an {@link AfterEvent} keeper of the given `event`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param event - An event that will be sent to all receivers upon registration.\n *\n * @returns An {@link AfterEvent} keeper that always sends the given `event`.\n */\nexport function afterThe<TEvent extends any[]>(...event: TEvent): AfterEvent<TEvent> {\n  return afterEventBy(noop, valueProvider(event));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { eventReceiver, EventReceiver, EventSender, OnEvent__symbol } from './base';\nimport { OnEvent$do, OnEvent$supplier, OnEvent$then } from './impl';\n\n/**\n * Signature of {@link EventSender} implementation able to register event receivers.\n *\n * The registered event receiver starts receiving upcoming events until the returned event supply is cut off.\n *\n * Contains additional event processing methods.\n *\n * May be constructed using {@link onEventBy} function.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface OnEvent<TEvent extends any[]> extends EventSender<TEvent> {\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver - Target receiver of events.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  (receiver: EventReceiver<TEvent>): Supply;\n\n  [OnEvent__symbol](): this;\n\n  /**\n   * Applies the given processor to events.\n   *\n   * @typeParam TResult - Action result type.\n   * @param processor - An event processor accepting this supplier as its only parameter, and returning application\n   * result.\n   *\n   * @returns Processing result.\n   */\n  do<TResult>(\n      processor: (this: void, supplier: this) => TResult,\n  ): TResult;\n\n  /**\n   * Applies the given processors to events.\n   *\n   * The value returned from each processor application is passed as argument to the next one. The value returned from\n   * the last processor application is the result of this method call.\n   *\n   * @typeParam TResult1 - The first processor application result type.\n   * @typeParam TResult1 - The second processor application result type.\n   * @param processor1 - An event processor accepting this supplier as its only parameter, and returning application\n   * result.\n   * @param processor2 - An event processor accepting the first one's application result as its only parameter, and\n   * returning its own application result.\n   *\n   * @returns The last processor application result.\n   */\n  do<\n      TResult1,\n      TResult2,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n  ): TResult2;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n  ): TResult3;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n  ): TResult4;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n  ): TResult5;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n  ): TResult6;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n  ): TResult7;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n  ): TResult8;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n  ): TResult9;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n  ): TResult10;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n  ): TResult11;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      TResult12,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n      processor12: (this: void, arg: TResult11) => TResult12,\n  ): TResult12;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      TResult12,\n      TResult13,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n      processor12: (this: void, arg: TResult11) => TResult12,\n      processor13: (this: void, arg: TResult12) => TResult13,\n  ): TResult13;\n\n  /**\n   * Attaches callbacks to the next event and/or supply cut off reason.\n   *\n   * This method makes event sender act as promise-like for the first parameter of the next event. Thus it is possible\n   * e.g. to use it in `await` expression.\n   *\n   * @param onEvent - The callback to execute when next event received.\n   * @param onCutOff - The callback to execute when supply is cut off before the next event received.\n   *\n   * @returns A Promise for the next event.\n   */\n  then<TResult1 = TEvent extends [infer F, ...any[]] ? F : undefined, TResult2 = never>(\n      onEvent?: ((...event: TEvent) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n      onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2>;\n\n}\n\n/**\n * Converts a plain event receiver registration function to {@link OnEvent} sender.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An {@link OnEvent} sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<TEvent extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<TEvent>) => void,\n): OnEvent<TEvent> {\n\n  const onEvent = ((receiver: EventReceiver<TEvent>): Supply => {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      register(generic);\n    }\n\n    return supply;\n  }) as OnEvent<TEvent>;\n\n  onEvent[OnEvent__symbol] = OnEvent$supplier;\n  onEvent.do = OnEvent$do;\n  onEvent.then = OnEvent$then;\n\n  return onEvent;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { OnEvent } from '../on-event';\n\n/**\n * Creates an event processor that consumes incoming events.\n *\n * @category Core\n * @typeParam TEvent - Incoming event type. This is a list of consumer function parameter types.\n * @param consume - A function consuming events. This function may return a {@link SupplyPeer peer of event supply},\n * e.g. when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n *\n * @returns A function accepting incoming event supplier and returning event supply that will stop consuming events once\n * cut off.\n */\nexport function consumeEvents<TEvent extends any[]>(\n    consume: (this: void, ...event: TEvent) => SupplyPeer | void | undefined,\n): (this: void, input: OnEvent<TEvent>) => Supply {\n  return input => {\n\n    let consumerSupply = neverSupply();\n\n    // Do not use `.cuts()` here as `consumerSupply` is mutable\n    const supply = new Supply(reason => consumerSupply.off(reason));\n\n    input({\n      supply,\n      receive(_ctx, ...event: TEvent) {\n\n        const prevSupply = consumerSupply;\n\n        try {\n          consumerSupply = (consume(...event) || neverSupply()).supply;\n        } finally {\n          if (consumerSupply !== prevSupply) {\n            prevSupply.off();\n          }\n        }\n      },\n    });\n\n    return supply;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { shareEvents } from '../impl';\n\n/**\n * A processor of events incoming from {@link AfterEvent} keeper that shares outgoing events supply among all registered\n * receivers.\n *\n * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * event supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to share events from.\n *\n * @returns An {@link AfterEvent} keeper sharing a common supply of events.\n */\nexport function shareAfter<TEvent extends any[]>(supplier: AfterEvent<TEvent>): AfterEvent<TEvent> {\n  return afterEventBy(shareEvents(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { EventKeeper } from '../base';\nimport { eventDig } from '../impl';\nimport { afterSupplied } from '../keepers';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link AfterEvent} keeper.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function digAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const processor = digAfter_(extract);\n\n  return input => shareAfter(processor(input));\n}\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link AfterEvent} keeper,\n * and does not share the outgoing events supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function digAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const extractKeeper = (...events: TInEvent): AfterEvent<TOutEvent> | void => {\n\n    const extracted = extract(...events);\n\n    return extracted && afterSupplied(extracted);\n  };\n\n  return input => afterEventBy(eventDig(input, extractKeeper));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventNotifier, EventSender, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Event emitter is a handy implementation of {@link OnEvent} sender.\n *\n * Extends {@link EventNotifier} by making its {@link EventNotifier.on} method implement an {@link OnEvent} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<TEvent extends any[]> extends EventNotifier<TEvent> implements EventSender<TEvent> {\n\n  /**\n   * {@link OnEvent} sender of {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   */\n  readonly on: OnEvent<TEvent> = onEventBy(receiver => super.on(receiver));\n\n  [OnEvent__symbol](): OnEvent<TEvent> {\n    return this.on;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverReceive } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * An {@link OnEvent} sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = (/*#__PURE__*/ onEventBy(neverReceive));\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent__symbol, EventSupplier, isEventSender, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * Builds an {@link OnEvent} sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n *\n * @returns An {@link OnEvent} sender of events originated from the given `supplier`.\n */\nexport function onSupplied<TEvent extends any[]>(supplier: EventSupplier<TEvent>): OnEvent<TEvent> {\n  return isEventSender(supplier) ? supplier[OnEvent__symbol]() : supplier[AfterEvent__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { EventReceiver, EventSupplier } from '../base';\nimport { shareEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onNever } from './on-never';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an {@link OnEvent} sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param suppliers - Original event suppliers.\n *\n * @returns An {@link OnEvent} sender of all supplied events.\n */\nexport function onAny<TEvent extends any[]>(...suppliers: EventSupplier<TEvent>[]): OnEvent<TEvent> {\n  if (!suppliers.length) {\n    return onNever as OnEvent<TEvent>;\n  }\n\n  return onEventBy(shareEvents(onEventBy<TEvent>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any): void => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<TEvent>, ...event: TEvent): void => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier)({\n          supply: new Supply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  })));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventReceiver } from '../base';\nimport { alwaysReceiveValue, neverReceiveBecause } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Represents a promise as event sender.\n *\n * When the `promise` resolves successfully the resolved value is sent to registered event receivers. The events\n * supply is {@link Supply.off cut off} immediately after that without any reason specified.\n *\n * When the `promise` is rejected the events supply is {@link Supply.off cut off} with promise rejection reason.\n *\n * @category Core\n * @typeParam T - A type of value the promise is resolved to.\n * @param promise - The promise to represent as event sender.\n *\n * @returns An {@link OnEvent} sender of the given `promise` settlement event.\n */\nexport function onPromise<T>(promise: Promise<T>): OnEvent<[T]> {\n\n  let receive = (receiver: EventReceiver.Generic<[T]>): void => {\n    promise.then(() => receive(receiver), () => receive(receiver));\n  };\n\n  promise.then(value => {\n    receive = alwaysReceiveValue(value);\n  }).catch(e => {\n    receive = neverReceiveBecause(e);\n  });\n\n  return onEventBy(receiver => receive(receiver));\n}\n","import { EventReceiver } from '../event-receiver';\nimport { sendEventsTo } from '../send-events-to';\n\n/**\n * @internal\n */\nexport function alwaysReceiveValue<T>(value: T): (receiver: EventReceiver.Generic<[T]>) => void {\n  return receiver => {\n    try {\n      sendEventsTo(receiver)(value);\n      receiver.supply.off();\n    } catch (e) {\n      receiver.supply.off(e);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { shareEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor of events incoming from {@link OnEvent} sender that shares outgoing events supply among all registered\n * receivers.\n *\n * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to share events from.\n *\n * @returns An {@link OnEvent} sender sharing a common supply of events.\n */\nexport function shareOn<TEvent extends any[]>(supplier: OnEvent<TEvent>): OnEvent<TEvent> {\n  return onEventBy(shareEvents(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventSupplier } from '../base';\nimport { eventDig } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onSupplied } from '../senders';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that extracts event senders from incoming events.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nexport function digOn<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventSupplier<TOutEvent> | void | undefined,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const processor = digOn_(extract);\n\n  return input => shareOn(processor(input));\n}\n\n/**\n * Creates an event processor that extracts event senders from incoming events, and does not share the outgoing events\n * supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nexport function digOn_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventSupplier<TOutEvent> | void | undefined,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const extractSender = (...event: TInEvent): OnEvent<TOutEvent> | void => {\n\n    const extracted = extract(...event);\n\n    return extracted && onSupplied(extracted);\n  };\n\n  return input => onEventBy(eventDig(input, extractSender));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { translateEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nexport function translateOn<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const mapper = translateOn_(translate);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nexport function translateOn_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n  return input => onEventBy(translateEvents(input, translate));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { translateEvents } from '../impl';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that converts events incoming from {@link AfterEvent} keeper with the given converter\n * function.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]>;\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function and fallback.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n * @param fallback - A function creating a fallback of outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback: () => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]>;\n\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback?: () => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]> {\n\n  const mapper = mapAfter_(convert, fallback!);\n\n  return input => shareAfter(mapper(input));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]>;\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function and fallback, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n * @param fallback - A function creating a fallback of outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback: () => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]>;\n\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback?: () => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]> {\n  return input => afterEventBy(\n      translateEvents(\n          input,\n          (send, ...event) => send(convert(...event)),\n      ),\n      fallback && (() => [fallback()]),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { translateEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapOn<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TResult]> {\n\n  const mapper = mapOn_(convert);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nexport function mapOn_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TResult]> {\n  return input => onEventBy(translateEvents(\n      input,\n      (send, ...event) => send(convert(...event)),\n  ));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { onceEvent } from '../impl';\n\n/**\n * A processor of the first event incoming from {@link AfterEvent} keeper.\n *\n * Cuts off the outgoing events supply after sending the first event.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to receive an event from.\n *\n * @returns New keeper of the first event.\n */\nexport function onceAfter<TEvent extends any[]>(supplier: AfterEvent<TEvent>): AfterEvent<TEvent> {\n  return afterEventBy(onceEvent(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\nimport { onceEvent } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor of the first event incoming from {@link OnEvent} sender.\n *\n * Cuts off the outgoing event supply after sending the first event.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to receive an event from.\n *\n * @returns New sender of the first event.\n */\nexport function onceOn<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): OnEvent<TEvent> | AfterEvent<TEvent> {\n  return onEventBy(onceEvent(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { supplyEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Creates an event processor that passes events incoming from {@link OnEvent} sender until the `required` supply is\n * cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nexport function supplyOn<TEvent extends any[]>(\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<TEvent> {\n  return (input: OnEvent<TEvent>) => onEventBy(supplyEvents(input, required, dependentSupply));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { mapOn } from './map-on';\nimport { resolveOn } from './resolve-on';\nimport { supplyOn } from './supply-on';\n\n/**\n * A processor that asynchronously resolves incoming events and sends them in the order they are received.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Mat send events in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut off if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Core\n * @typeParam TEvent - Resolved event type.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nexport function resolveOnOrdered<TEvent>(\n    from: OnEvent<[PromiseLike<TEvent> | TEvent]>,\n): OnEvent<[TEvent, ...TEvent[]]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    const sourceSupply = new Supply();\n    let numInProcess = 0;\n    const source = from.do(\n        supplyOn(supply, sourceSupply),\n        mapOn(event => {\n          ++numInProcess;\n          return event;\n        }),\n    );\n    let received: TEvent[] = [];\n    let numSent = 1;\n    let numReceived = 0;\n\n    sourceSupply.whenOff(reason => {\n      if (!numInProcess) {\n        supply.off(reason);\n      }\n    });\n\n    resolveOn(source)({\n      supply,\n      receive(_ctx, event, index) {\n\n        const i = index - numSent;\n\n        received[i] = event;\n        ++numReceived;\n        if (numReceived > i) {\n\n          let toSend: TEvent[];\n\n          if (numReceived === received.length) {\n            // Can send all received events\n            toSend = received;\n            received = [];\n          } else {\n            // Can send events up to `i`\n            toSend = received.splice(0, i + 1);\n          }\n          numSent += toSend.length;\n          numReceived -= toSend.length;\n          numInProcess -= toSend.length;\n\n          dispatch(...(toSend as [TEvent, ...TEvent[]]));\n          if (!numInProcess && sourceSupply.isOff) {\n            receiver.supply.needs(sourceSupply);\n          }\n        }\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor that asynchronously resolves incoming events and sends then in the order of their resolution.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Core\n * @typeParam T - A type of values the promises resolve to.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nexport function resolveOn<T>(from: OnEvent<[PromiseLike<T> | T]>): OnEvent<[T, number]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    let lastIndex = 0;\n\n    from({\n      supply,\n      receive(_ctx, promise) {\n\n        const index = ++lastIndex;\n\n        Promise.resolve()\n            .then(() => promise)\n            .then(\n                event => dispatch(event, index),\n                reason => supply.off(reason),\n            );\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { supplyEvents } from '../impl';\n\n/**\n * Creates an event processor that passes events incoming from {@link AfterEvent} keeper until the `required` supply\n * is cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nexport function supplyAfter<TEvent extends any[]>(\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n  return (input: AfterEvent<TEvent>) => afterEventBy(supplyEvents(input, required, dependentSupply));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { translateEvents } from '../impl';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that translates events incoming from {@link AfterEvent} keeper.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating outgoing event fallback.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const mapper = translateAfter_(translate, fallback!);\n\n  return input => shareAfter(mapper(input));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link AfterEvent} keeper, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating outgoing event fallback.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `translate` function. A receiver registration would lead to an error otherwise.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n  return input => afterEventBy(translateEvents(input, translate), fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { OnEvent } from '../on-event';\nimport { shareOn } from './share-on';\nimport { translateOn_ } from './translate-on';\n\n/**\n * Creates an event processor that sends the values of incoming events.\n *\n * Events are valued by provided `value` function. The `null`, `undefined`, and `false` values are dropped.\n *\n * @category Core\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nexport function valueOn<TEvent extends any[], TValue>(\n    valueOf: (this: void, ...event: TEvent) => TValue | false | null | undefined,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TValue]> {\n\n  const mapper = valueOn_(valueOf);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that sends the values of incoming events, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nexport function valueOn_<TEvent extends any[], TValue>(// eslint-disable-line @typescript-eslint/naming-convention\n    valueOf: (this: void, ...event: TEvent) => TValue | false | null | undefined,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TValue]> {\n  return translateOn_((send, ...event) => {\n\n    const value = valueOf(...event);\n\n    if (value != null && value !== false) {\n      send(value);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @typeParam TKey - A type of path key.\n * @param key - A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<TKey extends PropertyKey>(key: TKey): readonly [TKey];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path - Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return (Array.isArray(path) ? path : [path]) as StatePath.Normalized;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { EventSender, OnEvent__symbol } from '../base';\nimport { onEventBy } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\n/**\n * @internal\n */\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath.Normalized, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): Supply {\n\n    const supply = this.emitter.on(receiver);\n\n    return new Supply(reason => {\n      supply.off(reason);\n      this._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: unknown): void {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.supply.off(reason);\n  }\n\n  private _remove(key: PropertyKey): void {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty(): void {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): Supply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<T>(path: StatePath.Normalized, newValue: T, oldValue: T): void {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: unknown): void {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\n/**\n * @internal\n */\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <T>(\n      this: void,\n      path: StatePath,\n      newValue: T,\n      oldValue: T,\n  ) => void;\n\n  readonly onUpdate: OnStateUpdate = onEventBy<[StatePath.Normalized, any, any]>(\n      receiver => this._trackers.on(this._path, receiver),\n  );\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n    this.update = <T>(path: StatePath, newValue: T, oldValue: T) => {\n      this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n    };\n  }\n\n  get _tracker(): this {\n    return this;\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: unknown): void {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under {@link StatePath}.\n *\n * When node modified a {@link StateTracker.update} should be called. Then all state update receivers registered by\n * {@link StateTracker.onUpdate} will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath.Normalized, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns State updates sender.\n   */\n  get onUpdate(): OnStateUpdate {\n    return this._tracker.onUpdate;\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with {@link onUpdate} will receive this update.\n   *\n   * @typeParam T - A type of changed value.\n   * @param key - Changed value key.\n   * @param newValue - New value.\n   * @param oldValue - Previous value.\n   */\n  get update(): <T>(\n      this: void,\n      path: StatePath,\n      newValue: T,\n      oldValue: T,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path - A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason - An optional reason to stop tracking.\n   */\n  done(reason?: unknown): void {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  isEventKeeper,\n  OnEvent__symbol,\n} from '../base';\nimport { OnEvent } from '../on-event';\nimport { consumeEvents } from '../processors';\nimport { onSupplied } from '../senders';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an {@link EventSender} interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an {@link EventKeeper} interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeParam T - Tracked value type.\n */\nexport abstract class ValueTracker<T> implements EventSender<[T, T]>, EventKeeper<[T]>, SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _by = neverSupply();\n\n  /**\n   * {@link OnEvent} sender of value changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Value changes sender.\n   */\n  abstract readonly on: OnEvent<[T, T]>;\n\n  /**\n   * {@link AfterEvent} keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Current value keeper.\n   */\n  readonly read: AfterEvent<[T]> = afterEventBy(\n      receiver => this.on(receiveNewValue(receiver)),\n      () => [this.it],\n  );\n\n  [OnEvent__symbol](): OnEvent<[T, T]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * An event supply of this value tracker.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier - The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeParam TSrcEvent - Source event type.\n   * @param supplier - The event supplier to extract value suppliers from.\n   * @param extract - A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: TSrcEvent) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const acceptValuesFrom = (sender: EventSupplier<[T]>): Supply => {\n\n      const onValue = isEventKeeper(sender) ? sender[AfterEvent__symbol]() : sender[OnEvent__symbol]();\n\n      return onValue(value => this.it = value);\n    };\n\n    this.byNone();\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<TSrcEvent>;\n\n      this._by = onSupplied(container).do(consumeEvents((...event) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      }));\n    }\n\n    this._by.whenOff(() => this._by = neverSupply());\n\n    return this;\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason - Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction receiveNewValue<T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[T, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { EventKeeper } from '../base';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * @internal\n */\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._on.supply;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial - Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial - Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier - The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeParam TSrc - Source value type.\n * @param supplier - The event keeper to extract value keepers from.\n * @param extract - A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, TSrc extends any[]>(\n    supplier: EventKeeper<TSrc>,\n    extract: (this: void, ...event: TSrc) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, TSrc extends any[]>(\n    supplier: EventKeeper<TSrc> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: TSrc) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as ValueTracker<T>).by(\n      supplier as EventKeeper<TSrc>,\n      extract as (this: void, ...event: TSrc) => EventKeeper<[T]>,\n  );\n}\n"],"names":["AfterEvent__symbol","Symbol","isEventKeeper","value","eventReceiver","receiver","generic","supply","Supply","[object Object]","_context","event","context","this","isOff","receive","whenOff","noop","receiveByEach","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","push","processEvent","shift","recurrentReceivers","idx","length","recurrentReceiver","recurrentEvent","EventNotifier","rcs","_rcs","Set","clear","size","needs","add","delete","OnEvent__symbol","isEventSender","sendEventsTo","AfterEvent$noFallback","Error","eventDig","input","extract","nestedSupply","neverSupply","prevSupply","extracted","off","OnEvent$do","processors","reduce","arg","action","OnEvent$supplier","onceEvent","supplier","OnEvent$then","onEvent","onCutOff","Promise","resolve","reject","reason","e","_ctx","shareEvents","shared","sharedSupply","initialEvents","undefined","on","dispatch","forEach","supplyEvents","required","dependentSupply","cuts","bind","translateEvents","translate","neverReceive","afterEventBy","register","fallback","lastEvent","numReceivers","afterEvent","dest","reported","do","then","afterAll","sources","keys","Object","result","key","afterEach","source","index","afterSent","sender","afterSupplied","afterThe","valueProvider","onEventBy","consumeEvents","consume","consumerSupply","shareAfter","digAfter","processor","digAfter_","extractKeeper","events","EventEmitter","super","onNever","onSupplied","onAny","suppliers","remained","removeSupplier","onPromise","promise","alwaysReceiveValue","catch","shareOn","digOn_","extractSender","translateOn","mapper","translateOn_","mapAfter","convert","mapAfter_","mapOn","mapOn_","onceAfter","onceOn","supplyOn","resolveOnOrdered","from","sourceSupply","numInProcess","numSent","numReceived","lastIndex","resolveOn","i","toSend","splice","supplyAfter","translateAfter","translateAfter_","valueOn","valueOf","valueOn_","statePath","path","Array","isArray","PathEntry","_drop","Map","emitter","newValue","oldValue","nested","_nested","get","slice","_dropIfEmpty","dontCreateMissing","found","created","_remove","set","values","done","Trackers","_entry","_root","entry","nest","SubStateTracker","_trackers","_path","update","_tracker","onUpdate","StateTracker","subTracker","track","ValueTracker","valueReceiver","onRecurrent","recurrentValue","it","read","acceptValuesFrom","byNone","container","_by","TrackedValue","_it","_on","trackValue","initial","trackValueBy","by"],"mappings":"wEAWaA,EAAoCC,OAAO,wBA0CxCC,EAAoCC,GAClD,OAAOH,KAAsBG,WCqEfC,EAAoCC,GAElD,IAAIC,EA6BJ,OAvBEA,EADsB,mBAAbD,EACC,CACRE,OAAQ,IAAIC,EACZC,QAAQC,KAAaC,GACnBN,KAAYM,KAIN,CACRJ,OAAQF,EAASE,QAAU,IAAIC,EAC/BC,QAAQG,KAAYD,GACbE,KAAKN,OAAOO,OAGfT,EAASU,QAAQH,KAAYD,KAQrCL,EAAQC,OAAOS,SAAQ,IAAMV,EAAQS,QAAUE,IAExCX,WChJOY,EACZC,GAGF,IAAIC,EAIJ,SAASC,EAAiBV,GAExB,IAAIW,EAAkBH,EACtB,MAAMI,EAAqB,GAE3BH,EAAQI,GAAsBD,EAASE,KAAKD,GAE5C,IACE,OAAU,CACRF,EAAkBI,EAAaJ,EAAiBX,GAEhD,MAAMa,EAAYD,EAASI,QAE3B,IAAKH,EACH,MAGFb,EAAQa,WAGVJ,EAAOC,IAtBX,MAAO,IAAIV,IAAUS,EAAKT,GA8B5B,SAASe,EACLP,EACAR,GAGF,MAAMiB,EAAsD,GAE5D,IAAK,MAAMvB,KAAYc,EAAW,CAEhC,MAAMU,EAAMD,EAAmBE,OAE/BF,EAAmBH,KAAKpB,GAExB,MAAMO,EAAyC,CAC7CH,YAAYsB,GACVH,EAAmBC,GAAOzB,EAAc,CACtCG,OAAQF,EAASE,OACjBE,QAAQC,KAAasB,GACnBD,KAAqBC,QAM7B3B,EAASU,QAAQH,KAAYD,GAG/B,OAAOiB,QCtDIK,EAgBXxB,cAEE,MAAMyB,EAAMrB,KAAKsB,KAAO,IAAIC,IAE5BvB,KAAKO,KAAOF,EAAcgB,GAC1BrB,KAAKN,OAAS,IAAIC,GAAO,KACvB0B,EAAIG,eACGxB,KAAKsB,QAOhBG,WACE,OAAOzB,KAAKsB,KAAOtB,KAAKsB,KAAKG,KAAO,EAYtC7B,GAAGJ,GAED,MAAMC,EAAUF,EAAcC,GACxBE,EAASD,EAAQC,OAAOgC,MAAM1B,MAC9BM,EAAYN,KAAKsB,KAOvB,OALIhB,IAAcZ,EAAOO,QACvBK,EAAUqB,IAAIlC,GACdC,EAAOS,SAAQ,IAAMG,EAAUsB,OAAOnC,MAGjCC,SC9DEmC,EAAiCzC,OAAO,qBAyCrC0C,EAAoCxC,GAClD,OAAOuC,KAAmBvC,WCnCZyC,EACZvC,GAGF,MAAMC,EAAUF,EAAcC,GAC9B,IAAIe,EAAmCF,EAAc,CAACZ,IAItD,OAFAA,EAAQC,OAAOS,SAAQ,IAAMI,EAAOH,IAE7B,IAAIN,IAAUS,KAAQT,YCxBfkC,IACd,MAAM,IAAIC,MAAM,8BCGFC,EAIZC,EACAC,GAEF,OAAQ5C,IAEN,IAAI6C,EAAeC,IAEnBH,EAAM,CAEJzC,OAAQF,EAASE,OAEjBQ,QAAS,CAACL,KAAaC,KAErB,MAAMyC,EAAaF,EACbG,EAAYJ,KAAWtC,GAE7B,IACEuC,EAAeG,EACTA,EAAU,CAEV9C,QAAQ,IAAIC,GAAS+B,MAAMlC,EAASE,QAEpCE,QAAQG,KAAYD,GAClBN,EAASU,QAAQH,KAAYD,MAI/BwC,YAENC,EAAWE,oBCnCLC,KAETC,GAEL,OAAOA,EAAWC,QAAO,CAACC,EAAKC,IAAWA,EAAOD,IAAM7C,eCJzC+C,IACd,OAAO/C,cCAOgD,EACZC,GAEF,OAAQzD,IACNyD,EAAS,CACPvD,OAAQF,EAASE,OACjBQ,QAAS,CAACH,KAAYD,KACpBN,EAASU,QAAQH,KAAYD,GAC7BN,EAASE,OAAO+C,mBCNRS,EAEZC,EACAC,GAEF,OAAO,IAAIC,SAAQ,CAACC,EAASC,KAC3BP,EAAUhD,KAAVgD,CAAgB,CACdtD,OACM,IAAIC,EADFyD,EACSI,IACX,IACEF,EAAQF,EAASI,IACjB,MAAOC,GACPF,EAAOE,KAGEF,GACjBrD,QAASiD,EACH,CAACO,KAAS5D,KACV,IACEwD,EAAQH,KAAWrD,IACnB,MAAO2D,GACPF,EAAOE,MAGPC,EAAM5D,IAAqBwD,EAAQxD,iBCzBjC6D,EACZV,GAGF,MAAMW,EAAS,IAAIxC,EACnB,IAAIyC,EACAC,EAEJ,OAAQtE,IA+BN,GA9BKoE,EAAOnC,OACVqC,EAAgB,GAChBD,EAAe,IAAIlE,GAAO,IAAMmE,OAAgBC,IAEhDd,EAAS,CACPvD,OAAQmE,EACRjE,QAAQ8D,KAAS5D,GACXgE,IACEF,EAAOnC,KAGTqC,OAAgBC,EAIhBD,EAAclD,KAAKd,IAGvB8D,EAAOrD,QAAQT,OAKrBN,EAASE,OAAOgC,MAAMmC,GACtBD,EAAOI,GAAGxE,GAAUW,SAASqD,IACtBI,EAAOnC,MACVoC,EAAapB,IAAIe,MAIjBM,EAAe,CAGjB,MAAMG,EAAWlC,EAAavC,GAE9BsE,EAAcI,SAAQpE,GAASmE,KAAYnE,gBC5CjCqE,EACZlB,EACAmB,EACAC,GAEF,OAAQ7E,IACF6E,EACFpB,EAAS,CACPvD,QAAQ,IAAIC,GAAS+B,MAAM0C,GAAUE,KAAKD,GAC1CnE,QAAUV,EAASU,QAAqCqE,KAAK/E,MAG/DA,EAASE,OAAOgC,MAAM0C,GACtBnB,EAASzD,cCdCgF,EACZvB,EACAwB,GAEF,OAAOjF,IAEL,MAAMyE,EAAWlC,EAAavC,GAE9ByD,EAAS,CACPvD,OAAQF,EAASE,OACjBQ,QAAS,CAACwD,KAAS5D,KACjB2E,EAAUR,KAAanE,gBCLf4E,GAAahF,OAAEA,IAC7BA,EAAO+C,eCwCOkC,EACZC,EACAC,EAAmC7C,GAGrC,IAAI8C,EACAC,EAAe,EAEnB,MAAMC,EAAexF,IAEnB,IAAIyF,EAA2E7E,EAC/E,MAAMX,EAAUF,EAAcC,GAE9B,GAAIC,EAAQC,OAAOO,MACjB,OAAOR,EAAQC,OAGjB,MAAMA,GAAS,IAAIC,GAAS+B,MAAMjC,EAAQC,QAC1C,IAAIwF,GAAW,EA+Bf,OA7BAN,EAAS,CACPlF,OAAAA,EACAQ,QAAS,CAACH,KAAYD,KACpBoF,GAAW,EACXJ,EAAYhF,EACZmF,EAAKlF,KAAYD,QAGnBiF,EAEGrF,EAAOO,QAASiF,IACnBzF,EAAQS,QACJ,CACEN,YAAYe,GACVsE,EAAO,CAACpF,KAAaC,IAAUa,KAAab,QAG5CgF,IAAcA,EAAYD,MAElCI,EAAO,CAAClF,KAAYD,IAAUL,EAAQS,QAAQH,KAAYD,IAG5DJ,EAAOS,SAAQqD,MACNuB,IACLD,OAAYf,GAEdtE,EAAQC,OAAO+C,IAAIe,MAGd9D,GAQT,OALAsF,EAAWnD,GAAmBkB,EAC9BiC,EAAWG,GAAKzC,EAChBsC,EAAWI,KAAOlC,EAClB8B,EAAW7F,GAAsB4D,EAE1BiC,WC3FOK,EACZC,GAGF,MAAMC,EAAOC,OAAOD,KAAKD,GAqCzB,OAAOX,EAAahB,EAAYgB,GAlC5BnF,IAGF,MAAME,OAAEA,GAAWF,EACbyE,EAAWlC,EAAavC,GAC9B,IAAIe,EAAmBH,EACvB,MAAMqF,EAAS,GAEfF,EAAKrB,SAAwCwB,IAC3ChG,EAAOgC,MAAM4D,EAAQI,GAAKvG,IAAbmG,EAAmC,IAAIxF,KAClD2F,EAAOC,GAAO5F,EACdS,OACCmB,MAAMhC,OAGNA,EAAOO,QACVM,EAAO,IAAM0D,EAASwB,OAIN,KAElB,MAAMA,EAAS,GASf,OAPAF,EAAKrB,SAC+BwB,GAAiB1C,EAAUsC,EAAQI,GAAKvG,KAAvB6D,CAA8C,CAC7FtD,OAAQ,IAAIC,EACZO,QAAS,CAACwD,KAAS5D,IAA+C2F,EAAOC,GAAwB5F,MAIhG,CAAC2F,iBCtCIE,KAAmCL,GAmCjD,OAAOX,EAAahB,EAAYgB,GAjCNnF,IAExB,MAAME,OAAEA,GAAWF,EACbyE,EAAWlC,EAAavC,GAC9B,IAAIe,EAAmBH,EACvB,MAAMqF,EAAmB,GAEzBH,EAAQpB,SAAQ,CAAC0B,EAAQC,KACvBnG,EAAOgC,MAAMkE,EAAOzG,IAAPyG,EAA6B,IAAI9F,KAC5C2F,EAAOI,GAAS/F,EAChBS,OACCmB,MAAMhC,OAGNA,EAAOO,QACVM,EAAO,IAAM0D,KAAYwB,OAIT,KAElB,MAAMA,EAAmB,GASzB,OAPAH,EAAQpB,SACJ0B,GAAU5C,EAAU4C,EAAOzG,KAAjB6D,CAAwC,CAChDtD,OAAQ,IAAIC,EACZO,QAAS,CAACwD,KAAS5D,IAAU2F,EAAO7E,KAAKd,OAIxC2F,gBC9BKK,EACZC,EACAlB,GAEF,OAAOF,GAAanF,GAAYuG,EAAOlE,IAAPkE,CAA0BvG,IAAWqF,YCavDmB,EACZ/C,EACA4B,GAEF,OAAOxF,EAAc4D,GAAYA,EAAS9D,KAAwB2G,EAAU7C,EAAU4B,YC1BxEoB,KAAkCnG,GAChD,OAAO6E,EAAavE,EAAM8F,EAAcpG,aC4S1BqG,EACZvB,GAGF,MAAMzB,EAAY3D,IAEhB,MAAMC,EAAUF,EAAcC,IACxBE,OAAEA,GAAWD,EAMnB,OAJKC,EAAOO,OACV2E,EAASnF,GAGJC,GAOT,OAJAyD,EAAQtB,GAAmBkB,EAC3BI,EAAQgC,GAAKzC,EACbS,EAAQiC,KAAOlC,EAERC,WC/TOiD,EACZC,GAEF,OAAOlE,IAEL,IAAImE,EAAiBhE,IAGrB,MAAM5C,EAAS,IAAIC,GAAO6D,GAAU8C,EAAe7D,IAAIe,KAkBvD,OAhBArB,EAAM,CACJzC,OAAAA,EACAE,QAAQ8D,KAAS5D,GAEf,MAAMyC,EAAa+D,EAEnB,IACEA,GAAkBD,KAAWvG,IAAUwC,KAAe5C,eAElD4G,IAAmB/D,GACrBA,EAAWE,UAMZ/C,YCvBK6G,EAAiCtD,GAC/C,OAAO0B,EAAahB,EAAYV,aCAlBuD,EAIZpE,GAGF,MAAMqE,EAAYC,EAAUtE,GAE5B,OAAOD,GAASoE,EAAWE,EAAUtE,aAgBvBuE,EAIZtE,GAGF,MAAMuE,EAAgB,IAAIC,KAExB,MAAMpE,EAAYJ,KAAWwE,GAE7B,OAAOpE,GAAawD,EAAcxD,IAGpC,OAAOL,GAASwC,EAAazC,EAASC,EAAOwE,UC9ClCE,UAA2CzF,EAAxDxB,kCAOWI,QAAsBmG,GAAU3G,GAAYsH,MAAM9C,GAAGxE,KAE9DI,CAACiC,KACC,OAAO7B,KAAKgE,UCbH+C,EAAuCZ,EAAUzB,YCI9CsC,EAAiC/D,GAC/C,OAAOnB,EAAcmB,GAAYA,EAASpB,KAAqBoB,EAAS9D,cCK1D8H,KAA+BC,GAC7C,OAAKA,EAAUjG,OAIRkF,EAAUxC,EAAYwC,GAAkB3G,IAE7C,MAAME,OAAEA,GAAWF,EACnB,IAAI2H,EAAWD,EAAUjG,OACzB,MAAMmG,EAAkB5D,MACf2D,GACLzH,EAAO+C,IAAIe,IAGTtD,EAAU,CAACH,KAA2CD,KAC1DN,EAASU,QAAQH,KAAYD,IAG/BoH,EAAUhD,SACNjB,GAAY+D,EAAW/D,EAAX+D,CAAqB,CAC/BtH,OAAQ,IAAIC,EAAOyH,GAAgB1F,MAAMhC,GACzCQ,QAAAA,WAnBC6G,WCFKM,EAAaC,GAE3B,IAAIpH,EAAWV,IACb8H,EAAQlC,MAAK,IAAMlF,EAAQV,KAAW,IAAMU,EAAQV,MAStD,OANA8H,EAAQlC,MAAK9F,IACXY,WCvBkCZ,GACpC,OAAOE,IACL,IACEuC,EAAavC,EAAbuC,CAAuBzC,GACvBE,EAASE,OAAO+C,MAChB,MAAOgB,GACPjE,EAASE,OAAO+C,IAAIgB,KDiBZ8D,CAAmBjI,MAC5BkI,OAAM/D,QfzByBD,EAAAA,Ee0BFC,EAA9BvD,EfzBK,EAAGR,OAAAA,KAAaA,EAAO+C,IAAIe,Me4B3B2C,GAAU3G,GAAYU,EAAQV,cEbvBiI,EAA8BxE,GAC5C,OAAOkD,EAAUxC,EAAYV,aCyBfyE,EAIZtF,GAGF,MAAMuF,EAAgB,IAAI7H,KAExB,MAAM0C,EAAYJ,KAAWtC,GAE7B,OAAO0C,GAAawE,EAAWxE,IAGjC,OAAOL,GAASgE,EAAUjE,EAASC,EAAOwF,aCxC5BC,EAIZnD,GAGF,MAAMoD,EAASC,EAAarD,GAE5B,OAAOtC,GAASsF,EAAQI,EAAO1F,aAiBjB2F,EAIZrD,GAEF,OAAOtC,GAASgE,EAAU3B,EAAgBrC,EAAOsC,aCZnCsD,EACZC,EACAnD,GAGF,MAAMgD,EAASI,EAAUD,EAASnD,GAElC,OAAO1C,GAASoE,EAAWsB,EAAO1F,aAmCpB8F,EACZD,EACAnD,GAEF,OAAO1C,GAASwC,EACZH,EACIrC,GACA,CAAC5B,KAAST,IAAUS,EAAKyH,KAAWlI,MAExC+E,QAAmB,CAACA,gBCzEVqD,EACZF,GAGF,MAAMH,EAASM,EAAOH,GAEtB,OAAO7F,GAASsF,EAAQI,EAAO1F,aAcjBgG,EACZH,GAEF,OAAO7F,GAASgE,EAAU3B,EACtBrC,GACA,CAAC5B,KAAST,IAAUS,EAAKyH,KAAWlI,gBC1B1BsI,EAAgCnF,GAC9C,OAAO0B,EAAa3B,EAAUC,aCAhBoF,EACZpF,GAEF,OAAOkD,EAAUnD,EAAUC,aCAbqF,EACZlE,EACAC,GAEF,OAAQlC,GAA2BgE,EAAUhC,EAAahC,EAAOiC,EAAUC,aCC7DkE,EACZC,GAEF,OAAOrC,GAAU3G,IAEf,MAAME,OAAEA,GAAWF,EACbyE,EAAWlC,EAAavC,GAExBiJ,EAAe,IAAI9I,EACzB,IAAI+I,EAAe,EACnB,MAAM9C,EAAS4C,EAAKrD,GAChBmD,EAAS5I,EAAQ+I,GACjBP,GAAMpI,MACF4I,EACK5I,MAGb,IAAIY,EAAqB,GACrBiI,EAAU,EACVC,EAAc,EAElBH,EAAatI,SAAQqD,IACdkF,GACHhJ,EAAO+C,IAAIe,eC5BUgF,GAC3B,OAAOrC,GAAU3G,IAEf,MAAME,OAAEA,GAAWF,EACbyE,EAAWlC,EAAavC,GAE9B,IAAIqJ,EAAY,EAEhBL,EAAK,CACH9I,OAAAA,EACAE,QAAQ8D,EAAM4D,GAEZ,MAAMzB,IAAUgD,EAEhBxF,QAAQC,UACH8B,MAAK,IAAMkC,IACXlC,MACGtF,GAASmE,EAASnE,EAAO+F,KACzBrC,GAAU9D,EAAO+C,IAAIe,WDcjCsF,CAAUlD,EAAVkD,CAAkB,CAChBpJ,OAAAA,EACAE,QAAQ8D,EAAM5D,EAAO+F,GAEnB,MAAMkD,EAAIlD,EAAQ8C,EAIlB,GAFAjI,EAASqI,GAAKjJ,IACZ8I,EACEA,EAAcG,EAAG,CAEnB,IAAIC,EAEAJ,IAAgBlI,EAASO,QAE3B+H,EAAStI,EACTA,EAAW,IAGXsI,EAAStI,EAASuI,OAAO,EAAGF,EAAI,GAElCJ,GAAWK,EAAO/H,OAClB2H,GAAeI,EAAO/H,OACtByH,GAAgBM,EAAO/H,OAEvBgD,KAAa+E,IACRN,GAAgBD,EAAaxI,OAChCT,EAASE,OAAOgC,MAAM+G,mBE1DlBS,EACZ9E,EACAC,GAEF,OAAQlC,GAA8BwC,EAAaR,EAAahC,EAAOiC,EAAUC,aCiCnE8E,EAIZ1E,EACAI,GAGF,MAAMgD,EAASuB,EAAgB3E,EAAWI,GAE1C,OAAO1C,GAASoE,EAAWsB,EAAO1F,aA2EpBiH,EAIZ3E,EACAI,GAEF,OAAO1C,GAASwC,EAAaH,EAAgBrC,EAAOsC,GAAYI,YClIlDwE,GACZC,GAGF,MAAMzB,EAAS0B,GAASD,GAExB,OAAOnH,GAASsF,EAAQI,EAAO1F,aAcjBoH,GACZD,GAEF,OAAOxB,GAAa,CAACvH,KAAST,KAE5B,MAAMR,EAAQgK,KAAWxJ,GAEZ,MAATR,IAA2B,IAAVA,GACnBiB,EAAKjB,eCDKkK,GAAUC,GACxB,OAAQC,MAAMC,QAAQF,GAAQA,EAAO,CAACA,GClCxC,MAAMG,GAKJhK,YAA6BiK,GAAA7J,WAAA6J,EAHpB7J,aAAU,IAAI6G,EACN7G,aAAU,IAAI8J,IAG7B9J,KAAK+J,QAAQ/F,IAAG,CAACyF,EAAMO,EAAUC,KAE/B,MAAMvE,EAAM+D,EAAK,GACXS,EAASlK,KAAKmK,QAAQC,IAAI1E,GAE5BwE,GACFA,EAAOH,QAAQxJ,KAAKkJ,EAAKY,MAAM,GAAIL,EAAUC,MAKnDrK,GAAGJ,GAED,MAAME,EAASM,KAAK+J,QAAQ/F,GAAGxE,GAE/B,OAAO,IAAIG,GAAO6D,IAChB9D,EAAO+C,IAAIe,GACXxD,KAAKsK,kBACJ5I,MAAMhC,GASXE,KAAK8F,EAAkB6E,GAErB,MAAMC,EAAQxK,KAAKmK,QAAQC,IAAI1E,GAE/B,GAAI8E,GAASD,EACX,OAAOC,EAGT,MAAMC,EAAU,IAAIb,IAAU,IAAM5J,KAAK0K,QAAQhF,KAIjD,OAFA1F,KAAKmK,QAAQQ,IAAIjF,EAAK+E,GAEfA,EAGT7K,KAAK4D,GACH,IAAK,MAAM0G,KAAUlK,KAAKmK,QAAQS,SAChCV,EAAOW,KAAKrH,GAEdxD,KAAK+J,QAAQrK,OAAO+C,IAAIe,GAGlB5D,QAAQ8F,GACd1F,KAAKmK,QAAQvI,OAAO8D,GACpB1F,KAAKsK,eAGC1K,gBACDI,KAAKmK,QAAQ1I,MAAQzB,KAAK+J,QAAQtI,MAAQ,GAC7CzB,KAAK6J,SASX,MAAMiB,GAANlL,cAEmBI,WAAQ,IAAI4J,GAAUxJ,GAEvCR,GAAG6J,EAA4BjK,GAC7B,OAAOQ,KAAK+K,OAAOtB,GAAMzF,GAAGxE,GAG9BI,KAAQ6J,EAA4BO,EAAaC,GAC/CjK,KAAKgL,MAAMjB,QAAQxJ,KAAKkJ,EAAMO,EAAUC,GAG1CrK,KAAK6J,EAA4BjG,GAE/B,MAAMyH,EAAQjL,KAAK+K,OAAOtB,GAAM,GAE5BwB,GACFA,EAAMJ,KAAKrH,GAQP5D,OAAO6J,EAA4Bc,GAEzC,IAAIU,EAAQjL,KAAKgL,MAEjB,IAAK,MAAMtF,KAAO+D,EAAM,CAEtB,MAAMS,EAASe,EAAMC,KAAKxF,EAAK6E,GAE/B,IAAKL,EACH,OAGFe,EAAQf,EAGV,OAAOe,GAQX,MAAME,GAaJvL,YAA6BwL,EAAsCC,GAAtCrL,eAAAoL,EAAsCpL,WAAAqL,EAJ1DrL,cAA0BmG,GAC/B3G,GAAYQ,KAAKoL,UAAUpH,GAAGhE,KAAKqL,MAAO7L,KAI5CQ,KAAKsL,OAAS,CAAI7B,EAAiBO,EAAaC,KAC9CjK,KAAKoL,UAAU7K,KAAK,IAAIP,KAAKqL,SAAU7B,GAAUC,IAAQO,EAAUC,IAIvEsB,eACE,OAAOvL,KAGTJ,CAACiC,KACC,OAAO7B,KAAKwL,SAGd5L,MAAM6J,GAEJ,OADAA,EAAOD,GAAUC,IACPxI,OAGH,IAAIkK,GAAgBnL,KAAKoL,UAAW,IAAIpL,KAAKqL,SAAU5B,IAFrDzJ,KAKXJ,KAAK4D,GACHxD,KAAKoL,UAAUP,KAAK7K,KAAKqL,MAAO7H,UAevBiI,GAAb7L,cAKWI,cAA4B,IAAImL,GAAgB,IAAIL,GAAY,IAWzEU,eACE,OAAOxL,KAAKuL,SAASC,SAGvB5L,CAACiC,KACC,OAAO7B,KAAKwL,SAcdF,aAME,OAAOtL,KAAKuL,SAASD,OAUvB1L,MAAM6J,GAEJ,MAAMiC,EAAa1L,KAAKuL,SAASI,MAAMlC,GAEvC,OAAOiC,IAAe1L,KAAKuL,SAAWvL,KAAO0L,EAU/C9L,KAAK4D,GACHxD,KAAKuL,SAASV,KAAKrH,UC7NDoI,GAAtBhM,cAKUI,SAAMsC,IAkBLtC,UAAwB2E,GAC7BnF,IAAYQ,OAAAA,KAAKgE,GAuHd,CACLtE,QAHAmM,EArHsCrM,GAwHhBE,OACtBE,QAAQG,EAASiK,GACf6B,EAAc3L,QACV,CACEN,YAAYsB,GACVnB,EAAQ+L,aAAYC,GAAkB7K,EAAkB6K,OAG5D/B,MAZV,IACI6B,KApHE,IAAM,CAAC7L,KAAKgM,MAGhBpM,CAACiC,KACC,OAAO7B,KAAKgE,GAGdpE,CAACT,KACC,OAAOa,KAAKiM,KAiDdrM,GACIqD,EACAb,GAGF,MAAM8J,EAAoBnG,IAER1G,EAAc0G,GAAUA,EAAO5G,KAAwB4G,EAAOlE,OAE/DvC,GAASU,KAAKgM,GAAK1M,IAIpC,GADAU,KAAKmM,SACA/J,EAKE,CAEL,MAAMgK,EAAYnJ,EAElBjD,KAAKqM,IAAMrF,EAAWoF,GAAWjH,GAAGiB,GAAc,IAAItG,KAEpD,MAAMiG,EAAS3D,KAAWtC,GAE1B,GAAIiG,EACF,OAAOmG,EAAiBnG,WAdhB,CAEZ,MAAMA,EAAS9C,EAEfjD,KAAKqM,IAAMH,EAAiBnG,GAmB9B,OAFA/F,KAAKqM,IAAIlM,SAAQ,IAAMH,KAAKqM,IAAM/J,MAE3BtC,KAYTJ,OAAO4D,GAEL,OADAxD,KAAKqM,IAAI5J,IAAIe,GACNxD,MCrJX,MAAMsM,WAAwBV,GAI5BhM,YAAoB2M,GAClBzF,QADkB9G,SAAAuM,EAFHvM,SAAM,IAAI6G,EAM3BnH,aACE,OAAOM,KAAKwM,IAAI9M,OAGlBsE,SACE,OAAOhE,KAAKwM,IAAIxI,GAGlBgI,SACE,OAAOhM,KAAKuM,IAGdP,OAAO1M,GAEL,MAAM2K,EAAWjK,KAAKuM,IAElBtC,IAAa3K,IACfU,KAAKuM,IAAMjN,EACXU,KAAKwM,IAAIjM,KAAKjB,EAAO2K,cAyBXwC,GAAcC,GAC5B,OAAO,IAAIJ,GAAgBI,YAuCbC,GACZ1J,EACAb,GAEF,OAAQqK,KAAiCG,GACrC3J,EACAb"}