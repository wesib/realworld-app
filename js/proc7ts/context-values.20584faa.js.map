{"version":3,"file":"context-values.20584faa.js","sources":["../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/key/context-key.ts","../../../../../proc7ts/context-values/src/key/context-seed-key.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/singleton/simple-context-key.ts","../../../../../proc7ts/context-values/src/singleton/single-context-key.ts","../../../../../proc7ts/context-values/src/conventional/context-supply.ts","../../../../../proc7ts/context-values/src/registry/context-builder.ts","../../../../../proc7ts/context-values/src/registry/context-seeders.impl.ts","../../../../../proc7ts/context-values/src/registry/context-value-spec.ts","../../../../../proc7ts/context-values/src/registry/context-values.impl.ts","../../../../../proc7ts/context-values/src/registry/context-registry.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module-dependency-error.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module-usage.impl.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module-key.impl.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module.impl.ts","../../../../../proc7ts/context-values/src/updatable/modules/context-module.ts"],"sourcesContent":["import type { ContextKey } from './key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key - Missing value key.\n   * @param message - Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","import type { ContextRef } from '../context-ref';\nimport type { ContextSeedKey } from './context-seed-key';\nimport type { ContextValueSlot } from './context-value-slot';\n\n/**\n * A symbol of the property containing a {@link ContextKey} instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('ContextKey'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by {@link ContextKey.grow} method.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same {@link seedKey} to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name - Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot - Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n","import type { ContextValues } from '../context-values';\nimport { ContextKey } from './context-key';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValueSlot } from './context-value-slot';\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key - A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx - Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","import type { ContextRequest } from './context-request';\nimport type { ContextSupply } from './conventional';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n\nexport interface ContextValues {\n\n  /**\n   * Context values supply.\n   *\n   * When provided, this value is available under {@link ContextSupply} key, unless overridden.\n   */\n  readonly supply?: ContextSupply;\n\n}\n","import { lazyValue, noop, Supply } from '@proc7ts/primitives';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeeder } from '../key';\nimport { ContextKey, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: (readonly [ContextValueProvider<TSrc, TCtx>])[] = [];\n\n  provide(provider: ContextValueProvider<TSrc, TCtx>): Supply {\n\n    // Ensure the same provider may be registered multiple times\n    const entry: readonly [ContextValueProvider<TSrc, TCtx>] = [provider];\n\n    this._providers.unshift(entry);\n\n    return new Supply(() => this._providers.splice(this._providers.lastIndexOf(entry), 1));\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (\n        [provider]: readonly [ContextValueProvider<TSrc, TCtx>],\n    ): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc - Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from '../key';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","import type { Supply } from '@proc7ts/primitives';\nimport { alwaysSupply } from '@proc7ts/primitives';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextValueSlot } from '../key';\nimport { SimpleContextKey } from '../singleton';\n\n/**\n * Context values supply.\n *\n * It is used to signal when context is no longer used (e.g. destroyed).\n *\n * A context value provider can (and probably should) destroy the provided value in such case.\n */\nexport type ContextSupply = Supply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || slot.context.supply\n        || (slot.hasFallback ? slot.or : alwaysSupply()),\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `SupplyPeer` interface. Defaults to supply-always\n * otherwise.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","import type { Supply } from '@proc7ts/primitives';\nimport type { ContextValues } from '../context-values';\nimport type { ContextRegistry } from './context-registry';\n\n/**\n * A key of {@link ContextBuilder context builder} method that provides context values.\n */\nexport const ContextBuilder__symbol = (/*#__PURE__*/ Symbol('ContextBuilder'));\n\n/**\n * Context builder.\n *\n * Able to provide arbitrary context values.\n *\n * @typeParam TCtx - Supported context type.\n */\nexport interface ContextBuilder<TCtx extends ContextValues = ContextValues> {\n\n  /**\n   * Provides context values with the given registry.\n   *\n   * @param registry - A context registry to provide values with.\n   *\n   * @returns A supply instance that removes the added context value providers once cut off.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry<TCtx>): Supply;\n\n}\n","import type { ContextValues } from '../context-values';\nimport type { ContextKey, ContextSeeder, ContextSeedKey } from '../key';\nimport type { ContextSeeds } from './context-seeds';\n\n/**\n * @internal\n */\nexport type SeedIssuer<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n  seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n  factory: (this: void, context: TCtx) => TSeed,\n];\n\n/**\n * @internal\n */\nexport class ContextSeeders<TCtx extends ContextValues> {\n\n  private readonly _issuers = new Map<ContextSeedKey<any, any>, SeedIssuer<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  issuer<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedIssuer<TCtx, TSrc, TSeed> {\n\n    const found: SeedIssuer<TCtx, TSrc, TSeed> | undefined = this._issuers.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const issuer: SeedIssuer<TCtx, TSrc, TSeed> = [\n      seeder,\n      context => seeder.seed(context, this._initial(seedKey, context)),\n    ];\n\n    this._issuers.set(seedKey, issuer);\n\n    return issuer;\n  }\n\n  newSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.issuer(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n","import { valueProvider } from '@proc7ts/primitives';\nimport type { ContextRequest } from '../context-request';\nimport type { ContextValues } from '../context-values';\nimport type { ContextBuilder } from './context-builder';\nimport type { ContextTarget } from './context-target';\nimport type { ContextValueProvider } from './context-value-provider';\n\n/**\n * Context value specifier.\n *\n * Either explicit one, or a {@link ContextBuilder context builder}.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TSrc = TValue,\n    TDeps extends any[] = unknown[]> =\n    | ContextValueSpec.Explicit<TCtx, TValue, TSrc, TDeps>\n    | ContextBuilder<TCtx>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * Explicit context value specifier.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type Explicit<\n      TCtx extends ContextValues,\n      TValue,\n      TSrc = TValue,\n      TDeps extends any[] = unknown[]> =\n      | ContextValueSpec.IsConstant<TSrc>\n      | ContextValueSpec.ViaAlias<TSrc>\n      | ContextValueSpec.ByProvider<TCtx, TSrc>\n      | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>\n      | ContextValueSpec.AsInstance<TCtx, TSrc>\n      | ContextValueSpec.SelfInstance<TCtx, TSrc>\n      | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>\n      | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps>;\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface IsConstant<TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface ViaAlias<TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TSrc, TCtx>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export interface ByProviderWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface AsInstanceWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export interface SelfInstanceWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @param spec - Explicit context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.Explicit<TCtx, TValue, TSrc, TDeps>,\n): ContextValueSpec.ByProvider<TCtx, TSrc> {\n  if (isValueSpecByProvider(spec)) {\n    if (!isValueSpecWithDeps<TCtx, TSrc, TDeps>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstantValueSpec<TSrc>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (isValueSpecViaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (isValueSpecAsInstance<TCtx, TSrc, TDeps>(spec)) {\n    if (isSelfInstanceValueSpec<TCtx, TSrc, TDeps>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!isValueSpecWithDeps<TCtx, TSrc, TDeps>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction isValueSpecByProvider<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc>\n    | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecAsInstance<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc>\n    | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction isSelfInstanceValueSpec<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc>\n    | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc> | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps>,\n): ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>;\n}\n\n/**\n * @internal\n */\nfunction isConstantValueSpec<TSrc>(\n    spec: ContextValueSpec<any, unknown, TSrc, any>,\n): spec is ContextValueSpec.IsConstant<TSrc> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecViaAlias<TSrc>(\n    spec: ContextValueSpec<any, unknown, TSrc, any>,\n): spec is ContextValueSpec.ViaAlias<TSrc> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc> | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>,\n): spec is ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): boolean {\n  return 'with' in spec;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextRequest } from '../context-request';\nimport { ContextValues } from '../context-values';\nimport type { ContextSeeder, ContextValueSetup, ContextValueSlot } from '../key';\nimport { ContextKey, ContextKey__symbol } from '../key';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeders } from './context-seeders.impl';\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seeders: ContextSeeders<TCtx>,\n): ContextValues {\n\n  const values = new Map<ContextKey<any>, any>();\n\n  class ContextValues$ extends ContextValues {\n\n    get<TValue, TSrc>(\n        this: TCtx,\n        { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n        opts?: ContextRequest.Opts<TValue>,\n    ): TValue | null | undefined {\n\n      const cached = values.get(key);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      const [constructed, setup] = new ContextValueSlot$(seeders, this, key, opts)._grow();\n\n      if (setup) {\n        values.set(key, constructed);\n        setup({\n          key,\n          context: this,\n          registry: registry as ContextRegistry<any>,\n        });\n      }\n\n      return constructed;\n    }\n\n  }\n\n  return new ContextValues$();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n  readonly hasFallback: boolean;\n  readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n  readonly seed: TSeed;\n  private _constructed: TValue | null | undefined = null;\n  private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n  constructor(\n      seeders: ContextSeeders<TCtx>,\n      readonly context: TCtx,\n      readonly key: ContextKey<TValue, TSrc, TSeed>,\n      private readonly _opts: ContextRequest.Opts<TValue> = {},\n  ) {\n\n    const [seeder, seed] = seeders.newSeed<TSrc, TSeed>(context, key);\n\n    this.seeder = seeder;\n    this.seed = seed;\n    this.hasFallback = 'or' in _opts; // Fallback _may_ have `undefined` value.\n  }\n\n  get or(): TValue | null | undefined {\n    return this._opts.or; // Access here, as fallback value accessor may be implemented as getter.\n  }\n\n  insert(value: TValue | null | undefined): void {\n    this._constructed = value;\n  }\n\n  fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n    grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n    return this._constructed;\n  }\n\n  setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n    const prevSetup = this._setup;\n\n    this._setup = opts => {\n      prevSetup(opts);\n      setup(opts);\n    };\n  }\n\n  _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n    this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n    if (this._constructed != null) {\n      return [this._constructed, this._setup];\n    }\n    if (!this.hasFallback) {\n      throw new ContextKeyError(this.key);\n    }\n\n    return [this.or];\n  }\n\n}\n","import { noop, Supply } from '@proc7ts/primitives';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeedKey } from '../key';\nimport { ContextKey__symbol } from '../key';\nimport { ContextBuilder, ContextBuilder__symbol } from './context-builder';\nimport { ContextSeeders } from './context-seeders.impl';\nimport type { ContextSeeds } from './context-seeds';\nimport { ContextValueSpec, contextValueSpec } from './context-value-spec';\nimport { newContextValues } from './context-values.impl';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx - Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeders: ContextSeeders<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial - An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n    this._seeders = new ContextSeeders<TCtx>(\n        initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop,\n    );\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   * @param spec - Context value specifier.\n   *\n   * @returns Provider supply instance that removes just added context value provider once cut off.\n   */\n  provide<TSrc, TDeps extends any[]>(spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>): Supply {\n    if (isContextBuilder(spec)) {\n      return spec[ContextBuilder__symbol](this);\n    }\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeders.issuer(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context - Target context.\n   * @param key - Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeders.issuer(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider originated from this registry.\n   *\n   * @returns Mandatory context seeds provider.\n   */\n  seeds(): ContextSeeds.Mandatory<TCtx> {\n    return (seedKey, context) => this.seed(context, seedKey);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context - Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeders);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other - Another context value registry or context seeds provider.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx> | ContextSeeds<TCtx>): ContextRegistry<TCtx> {\n\n    const otherSeeds: ContextSeeds<TCtx> = typeof other === 'function' ? other : other.seeds();\n\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const second = otherSeeds(key, context);\n      const [seeder, factory] = this._seeders.issuer(key);\n      const first = factory(context);\n\n      return second ? seeder.combine(first, second, context) : first;\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isContextBuilder<TCtx extends ContextValues, TValue, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, TValue, TSrc, TDeps>,\n): spec is ContextBuilder<TCtx> {\n  return typeof (spec as Partial<ContextBuilder<TCtx>>)[ContextBuilder__symbol] === 'function';\n}\n","/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason - Context destruction reason.\n */\nexport function contextDestroyed(reason: unknown = new TypeError('Context destroyed')): () => never {\n  return () => {\n    throw reason;\n  };\n}\n","import {\n  afterEach,\n  AfterEvent,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  isAfterEvent,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { itsElements, mapIt, overElementsOf, overIterator } from '@proc7ts/push-iterator';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextValues } from '../context-values';\nimport { ContextSupply } from '../conventional';\nimport type { ContextSeeder, ContextValueSlot } from '../key';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nconst flatUpSources: <TSrc>(this: void, input: AfterEvent<TSrc[][]>) => AfterEvent<TSrc[]> = (\n    /*#__PURE__*/ translateAfter((send, ...sources) => send(...itsElements(overElementsOf(...sources))))\n);\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers = trackValue<[Map<Supply, ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>>]>(\n      [new Map()],\n  );\n\n  provide(provider: ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>): Supply {\n\n    const [providers] = this._providers.it;\n    const supply = new Supply();\n\n    providers.set(supply, provider);\n    this._providers.it = [providers];\n\n    return supply.whenOff(() => {\n\n      const [providers] = this._providers.it;\n\n      providers.delete(supply);\n\n      this._providers.it = [providers];\n    });\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(first, second).do(flatUpSources);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<[Map<Supply, ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>>]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read.do(\n      digAfter_(\n          ([providers]): AfterEvent<TSrc[][]> => !providers.size\n              ? afterThe()\n              : afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overIterator(() => providers.values()),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n      ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | ContextUpKey.Source<TSrc>): AfterEvent<TSrc[]> {\n  return isAfterEvent(src)\n      ? src\n      : (src != null ? afterThe(src) : afterThe());\n}\n\n/**\n * @internal\n */\nclass ContextSeed$UpKey<TSrc>\n    extends ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, ContextUpKey.Source<TSrc>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKey$UpKey<TUpdate extends any[], TSrc>\n    extends ContextKey<AfterEvent<TUpdate>, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n\n  readonly grow: (\n      slot: ContextValueSlot<\n          AfterEvent<TUpdate>,\n          ContextUpKey.Source<TSrc>,\n          AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<unknown, TSrc>,\n      grow: (\n          slot: ContextValueSlot<\n              AfterEvent<TUpdate>,\n              ContextUpKey.Source<TSrc>,\n              AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value: AfterEvent<TUpdate> | null | undefined = slot.fillBy(grow);\n\n      if (value != null) {\n        slot.insert(value.do(\n            supplyAfter(slot.context.get(ContextSupply)),\n        ));\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts a {@link ContextUpKey.Source} instances as source values.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc>, ContextUpKey.Base<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by {@link grow} function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeed$UpKey<TSrc>(this);\n  }\n\n  /**\n   * Creates a key of context value containing an `AfterEvent` keeper of updates to the value of this key.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @param grow - A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey<TUpdate extends any[]>(\n      grow: (\n          slot: ContextValueSlot<\n              AfterEvent<TUpdate>,\n              ContextUpKey.Source<TSrc>,\n              AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n    return new ContextUpKey$UpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A source value accepted by {@link ContextUpKey updatable context key}.\n   *\n   * Either a single source value, or an `AfterEvent` keeper of source values.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export type Source<TSrc> = TSrc | AfterEvent<TSrc[]>;\n\n  /**\n   * A type of context value updates tracker.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue - Original context value type.\n   */\n  export type Up<TValue> = TValue extends EventKeeper<any> ? TValue : AfterEvent<[TValue]>;\n\n  /**\n   * Base interface of updatable context value key.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface Base<TValue, TSrc> extends ContextKey<TValue, ContextUpKey.Source<TSrc>> {\n\n    /**\n     * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n     *\n     * It is expected to report any updates to this key's value.\n     *\n     * The value of updates key is constructed by {@link grow} function out of the same seed.\n     */\n    readonly upKey: UpKey<TValue, TSrc>;\n\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface UpKey<TValue, TSrc> extends ContextKey<ContextUpKey.Up<TValue>, ContextUpKey.Source<TSrc>> {\n\n    /**\n     * A reference to this key.\n     *\n     * Indicates that this key is updatable too.\n     */\n    readonly upKey: this;\n\n  }\n\n  /**\n   * A key of context value containing an `AfterEvent` keeper of updates of {@link ContextUpKey updatable value}.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SimpleUpKey<TUpdate extends any[], TSrc> extends Base<AfterEvent<TUpdate>, TSrc> {\n\n    readonly upKey: this;\n\n  }\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","import { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextValues } from '../context-values';\nimport type { ContextKeyDefault, ContextValueSlot } from '../key';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an {@link ContextKeyError}.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.SimpleUpKey<\n      [(this: void, ...args: TArgs) => TRet],\n      (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key)\n        || (() => {\n          throw new ContextKeyError(this);\n        });\n    this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(\n        digAfter((...fns): AfterEvent<[(this: void, ...args: TArgs) => TRet]> => {\n          if (fns.length) {\n            return afterThe(fns[fns.length - 1]);\n          }\n\n          if (slot.hasFallback && slot.or) {\n            return slot.or;\n          }\n\n          return afterThe(this.byDefault(slot.context, this));\n        }),\n    )));\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          ContextUpKey.Source<(this: void, ...args: TArgs) => TRet>,\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","import { AfterEvent, afterEventBy, afterThe, digAfter, supplyAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from '../conventional';\nimport type { ContextKeyDefault, ContextValueSlot } from '../key';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextUpRef<TValue> = ContextUpRef<AfterEvent<[TValue]>, TValue>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an {@link ContextKeyError} error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextUpKey<TValue>\n    extends ContextUpKey<AfterEvent<[TValue]>, TValue>\n    implements SingleContextUpRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TValue>;\n        byDefault?: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[TValue]>,\n          ContextUpKey.Source<TValue>,\n          AfterEvent<TValue[]>>,\n  ): void {\n\n    const value = slot.seed.do(digAfter((...sources: TValue[]): AfterEvent<TValue[]> => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return afterThe(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[TValue]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        if (defaultValue != null) {\n          backup = afterThe(defaultValue);\n        }\n      }\n      if (backup) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<[TValue]>(({ supply }) => {\n        supply.off(new ContextKeyError(this));\n      });\n    }));\n\n    slot.insert(value.do<AfterEvent<TValue[]>>(\n        supplyAfter(slot.context.get(ContextSupply)),\n    ));\n  }\n\n}\n\n","import type { ContextModule } from './context-module';\n\n/**\n * An error indicating context module dependency load failure.\n */\nexport class ContextModuleDependencyError extends Error {\n\n  /**\n   * Constructs context module dependency load error.\n   *\n   * @param module - A module failed to load.\n   * @param reasons - An array of dependency/reason pairs caused the load failure.\n   * @param message - An error message.\n   */\n  constructor(\n      readonly module: ContextModule,\n      readonly reasons: readonly (readonly [ContextModule, unknown?])[] = [],\n      readonly message: string = contextModuleDependencyErrorMessage(module, reasons),\n  ) {\n    super(message);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction contextModuleDependencyErrorMessage(\n    module: ContextModule,\n    dependencies: readonly (readonly [ContextModule, unknown?])[],\n): string {\n\n  const reasons = dependencies.reduce(\n      (out, [dep, reason]) => {\n        if (out) {\n          out += ', ';\n        } else {\n          out = ': ';\n        }\n        if (reason !== undefined) {\n          out += `${dep} failed to load (${reason})`;\n        } else {\n          out += `${dep} not loaded`;\n        }\n\n        return out;\n      },\n      '',\n  );\n\n  return `Failed to load ${module}${reasons}`;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  mapAfter_,\n  OnEvent,\n  onEventBy,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { neverSupply, Supply, SupplyPeer, valueProvider } from '@proc7ts/primitives';\nimport type { ContextRequest } from '../../context-request';\nimport type { ContextValues } from '../../context-values';\nimport { ContextSupply } from '../../conventional';\nimport type { ContextRegistry } from '../../registry';\nimport type { ContextModule } from './context-module';\n\n/**\n * @internal\n */\nexport class ContextModuleUsage {\n\n  private readonly _impl: ValueTracker<ContextModule | undefined>;\n  private readonly _rev: ValueTracker<ContextModuleRev>;\n  private _useCounter = 0;\n\n  private _setup!: () => void;\n\n  constructor(context: ContextValues, readonly module: ContextModule) {\n    this._impl = trackValue();\n    this._rev = trackValue({\n      status: {\n        module: this.module,\n        provided: false,\n        used: false,\n        settled: false,\n        ready: false,\n      },\n      supply: neverSupply(),\n    });\n\n    const contextSupply = context.get(ContextSupply);\n\n    contextSupply.cuts(this._impl);\n    contextSupply.cuts(this._rev);\n\n    this._impl.read(module => {\n\n      const prevSupply = this._rev.it.supply;\n\n      if (module) {\n        this._load(module);\n      }\n\n      prevSupply.off();\n    });\n  }\n\n  createHandle(): ContextModule.Handle {\n\n    const read: AfterEvent<[ContextModule.Status]> = this._rev.read.do(\n        mapAfter_(({ status }) => status),\n    );\n\n    const handle: ContextModule.Handle = {\n      read,\n      [AfterEvent__symbol]: valueProvider(read),\n      use: (user?: SupplyPeer) => this._use(handle, user),\n    };\n\n    return handle;\n  }\n\n  setup(context: ContextValues, registry: ContextRegistry): void {\n    this._setup = () => {\n\n      const rev = this._rev.it;\n      const { status: { module }, supply } = rev;\n\n      if (module !== this.module) {\n        // Load implementation module instead.\n        // The implementation module expected to be provided already.\n        context.get(module).use(supply).read({\n          supply,\n          receive: (_ctx, { settled, ready, error }) => {\n            this._updateStatus(rev, settled, ready, error);\n          },\n        });\n      } else {\n        loadContextModule(context, registry, rev)\n            .then(({ whenReady }) => {\n              this._updateStatus(rev, true, false);\n              return whenReady;\n            })\n            .then(() => this._updateStatus(rev, true, true))\n            .catch(error => rev.supply.off(error));\n      }\n    };\n  }\n\n  implementBy(impl: AfterEvent<[ContextModule?]>): void {\n    this._impl.by(impl);\n  }\n\n  private _updateStatus(\n      rev: ContextModuleRev,\n      settled: boolean,\n      ready: boolean,\n      error?: unknown,\n  ): void {\n    // Ensure updating the correct revision.\n    if (this._rev.it.supply !== rev.supply) {\n      // If revision changed, then drop the obsolete one.\n      rev.supply.off();\n    } else {\n      this._rev.it = rev = {\n        status: {\n          module: rev.status.module,\n          provided: rev.status.provided,\n          used: true,\n          settled,\n          ready,\n          error,\n        },\n        supply: rev.supply,\n      };\n    }\n  }\n\n  private _load(module: ContextModule): void {\n\n    const supply = new Supply().needs(this._rev).whenOff(error => {\n\n      const rev = this._rev.it;\n\n      if (rev.supply === supply) {\n        this._rev.it = {\n          status: {\n            ...this._rev.it.status,\n            provided: false,\n            settled: false,\n            ready: false,\n            error,\n          },\n          supply,\n        };\n      }\n    });\n\n    const used = !!this._useCounter;\n\n    this._rev.it = {\n      status: {\n        module,\n        provided: true,\n        used,\n        settled: false,\n        ready: false,\n      },\n      supply,\n    };\n\n    if (used) {\n      this._setup();\n    }\n  }\n\n  private _use(handle: ContextModule.Handle, user?: SupplyPeer): ContextModule.Use {\n\n    const supply = new Supply();\n\n    if (user) {\n      supply.needs(user);\n    }\n\n    const read = handle.read.do(supplyAfter(supply));\n    const use: ContextModule.Use = {\n      ...handle,\n      read,\n      whenSettled: ContextModule$Use$when(read, isContextModuleSettled),\n      whenReady: ContextModule$Use$when(read, isContextModuleReady),\n      supply,\n    };\n\n    if (!supply.isOff) {\n      supply.whenOff(error => {\n        if (!--this._useCounter) {\n\n          const rev = this._rev.it;\n\n          this._rev.it = {\n            status: {\n              ...rev.status,\n              used: false,\n              settled: false,\n              ready: false,\n              error,\n            },\n            supply: new Supply().off(error),\n          };\n\n          rev.supply.off(error);\n        }\n      });\n\n      if (!this._useCounter++) {\n        // Mark the module used and set it up.\n\n        const rev = this._rev.it;\n\n        this._rev.it = {\n          status: {\n            ...rev.status,\n            used: true,\n          },\n          supply: rev.supply,\n        };\n\n        this._setup();\n      }\n    }\n\n    return use;\n  }\n\n}\n\n/**\n * @internal\n */\ninterface ContextModuleRev {\n\n  readonly status: ContextModule.Status;\n  readonly supply: Supply;\n\n}\n\n/**\n * @internal\n */\nasync function loadContextModule(\n    context: ContextValues,\n    registry: ContextRegistry,\n    { status: { module }, supply }: ContextModuleRev,\n): Promise<ContextModuleInit> {\n\n  const moduleInit = new ContextModuleInit(module);\n\n  await module.setup({\n\n    module,\n    supply,\n\n    get(request: ContextRequest<any>) {\n      return context.get(request);\n    },\n\n    provide(spec): Supply {\n      return registry.provide(spec).needs(supply);\n    },\n\n    initBy(init: (this: void) => (void | PromiseLike<unknown>)) {\n      moduleInit.initBy(init);\n    },\n\n  });\n\n  return moduleInit;\n}\n\nclass ContextModuleInit {\n\n  readonly whenReady: Promise<unknown>;\n  private _whenDone: Promise<unknown> = Promise.resolve();\n  private _ready!: (result?: PromiseLike<unknown>) => void;\n\n  constructor(private readonly _module: ContextModule) {\n    this.whenReady = new Promise(resolve => this._ready = resolve);\n  }\n\n  initBy(init: (this: void) => void | PromiseLike<unknown>): void {\n\n    const rev: Promise<unknown> = this._whenDone = this._whenDone\n        .then(init)\n        .finally(() => this._done(rev));\n\n  }\n\n  private _done(rev: Promise<unknown>): void {\n    if (this._whenDone === rev) {\n      this._ready(rev);\n      this.initBy = _init => {\n        throw new TypeError(`${this._module} initialized already, and does not accept new initializers`);\n      };\n    }\n  }\n\n}\n\nfunction ContextModule$Use$when(\n    status: AfterEvent<[ContextModule.Status]>,\n    test: (status: ContextModule.Status) => boolean,\n): OnEvent<[ContextModule.Status]> {\n  return onEventBy(receiver => status({\n    supply: receiver.supply,\n    receive: (context, status) => {\n      if (test(status)) {\n        receiver.receive(context, status);\n        receiver.supply.off();\n      } else if (status.error) {\n        receiver.supply.off(status.error);\n      }\n    },\n  }));\n}\n\nfunction isContextModuleSettled({ settled }: ContextModule.Status): boolean {\n  return settled;\n}\n\nfunction isContextModuleReady({ ready }: ContextModule.Status): boolean {\n  return ready;\n}\n","import type { AfterEvent } from '@proc7ts/fun-events';\nimport { mapAfter_ } from '@proc7ts/fun-events';\nimport type { ContextValueSlot } from '../../key';\nimport { ContextUpKey } from '../context-up-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleUsage } from './context-module-usage.impl';\n\n/**\n * @internal\n */\nexport class ContextModuleKey extends ContextUpKey<ContextModule.Handle, ContextModule> {\n\n  constructor(name: string, private readonly _module: ContextModule) {\n    super(name);\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ContextModule.Handle,\n          ContextUpKey.Source<ContextModule>,\n          AfterEvent<ContextModule[]>>,\n  ): void {\n\n    const usage = new ContextModuleUsage(slot.context, this._module);\n\n    slot.insert(usage.createHandle());\n    slot.setup(({ context, registry }) => usage.setup(context, registry));\n\n    usage.implementBy(implementContextModule(this._module, slot.seed));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction implementContextModule(\n    module: ContextModule,\n    impls: AfterEvent<[ContextModule]>,\n): AfterEvent<[ContextModule | undefined]> {\n  return impls.do(\n      mapAfter_((...candidates) => {\n\n        let impl: ContextModule | undefined;\n\n        for (let i = candidates.length - 1; i >= 0; --i) {\n          impl = candidates[i];\n          if (impl !== module) {\n            break;\n          }\n        }\n\n        return impl;\n      }),\n  );\n}\n","import type { OnEvent } from '@proc7ts/fun-events';\nimport { isDefined, noop, setOfElements, Supply, valueProvider } from '@proc7ts/primitives';\nimport { itsElements, valueIt } from '@proc7ts/push-iterator';\nimport type { ContextRegistry } from '../../registry';\nimport type { ContextUpKey } from '../context-up-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleDependencyError } from './context-module-dependency-error';\nimport { ContextModuleKey } from './context-module-key.impl';\n\n/**\n * @internal\n */\nexport const ContextModule$impl__symbol = (/*#__PURE__*/ Symbol('ContextModule.impl'));\n\n/**\n * @internal\n */\nexport class ContextModule$ {\n\n  readonly key: ContextUpKey<ContextModule.Handle, ContextModule>;\n  readonly has: ReadonlySet<ContextModule>;\n  readonly needs: ReadonlySet<ContextModule>;\n\n  private readonly _setup: (\n      this: void,\n      setup: ContextModule.Setup,\n  ) => void | PromiseLike<unknown>;\n\n  constructor(module: ContextModule, readonly name: string, readonly options: ContextModule.Options) {\n    this.key = new ContextModuleKey(`${name}:module`, module);\n\n    const { needs, has, setup } = options;\n\n    this.has = setOfElements(has).add(module);\n    this.needs = setOfElements(needs);\n    this._setup = setup ? setup.bind(options) : noop;\n  }\n\n  replace(\n      module: ContextModule,\n      registry: ContextRegistry,\n      supply: Supply,\n  ): void {\n    for (const replaced of module.has) {\n      if (replaced !== module) {\n        registry.provide({ a: replaced, is: module }).needs(supply);\n      }\n    }\n  }\n\n  async setup(setup: ContextModule.Setup): Promise<void> {\n\n    const deps = contextModuleDeps(setup);\n\n    // Await for module dependencies to be settled.\n    if (!await loadContextModuleDeps(setup, deps, whenContextModuleSettled)) {\n      return;\n    }\n\n    setup.initBy(async () => {\n      // Initialize module dependencies.\n      await loadContextModuleDeps(setup, deps, whenContextModuleReady);\n    });\n\n    await this._setup(setup);\n  }\n\n}\n\ninterface ContextModuleDep {\n  readonly dep: ContextModule;\n  readonly use: ContextModule.Use;\n}\n\nfunction contextModuleDeps(setup: ContextModule.Setup): readonly ContextModuleDep[] {\n\n  const { module, supply } = setup;\n\n  return itsElements(\n      valueIt(\n          module.needs,\n          dep => dep !== module\n              && setup.provide(dep).needs(supply)\n              && {\n                dep,\n                use: setup.get(dep).use(setup),\n              },\n      ),\n  );\n}\n\nfunction loadContextModuleDeps(\n    setup: ContextModule.Setup,\n    deps: readonly ContextModuleDep[],\n    whenLoaded: (use: ContextModule.Use) => OnEvent<[ContextModule.Status]>,\n): Promise<boolean> {\n\n  const { module, supply } = setup;\n  const notLoaded = valueProvider(false);\n  const whenDone = supply.whenDone().then(notLoaded, notLoaded);\n\n  return Promise.race([\n    whenDone,\n    Promise\n        .all(\n            deps\n                .map(\n                    ({ dep, use }) => whenLoaded(use).then(\n                        noop,\n                        error => [dep, error] as const,\n                    ),\n                ),\n        )\n        .then(\n            (results): true | ContextModuleDependencyError => {\n\n              const failures = results.filter<readonly [ContextModule, unknown]>(isDefined);\n\n              return failures.length\n                  ? new ContextModuleDependencyError(module, failures) // Prevent unhandled promise rejection\n                  : true as const;\n            },\n        ),\n  ]).then(\n      result => {\n        if (typeof result !== 'boolean') {\n          // Fail to load module if at leas one of its dependencies failed.\n          return Promise.reject(result);\n        }\n\n        return result;\n      },\n  );\n}\n\nfunction whenContextModuleSettled(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenSettled;\n}\n\nfunction whenContextModuleReady(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenReady;\n}\n","import type { AfterEvent, EventKeeper, OnEvent } from '@proc7ts/fun-events';\nimport type { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport type { ContextValues } from '../../context-values';\nimport { ContextKey__symbol } from '../../key';\nimport type { ContextRegistry, ContextValueSpec } from '../../registry';\nimport { ContextBuilder, ContextBuilder__symbol } from '../../registry';\nimport type { ContextUpKey, ContextUpRef } from '../context-up-key';\nimport { ContextModule$, ContextModule$impl__symbol } from './context-module.impl';\n\n/**\n * Context module.\n *\n * Modules intended to extend the context dynamically.\n *\n * The module is a context value reference that can be used to provide module instance and access its\n * {@link ContextModule.Handle handle}.\n *\n * Usage example:\n * ```typescript\n * // Construct new module.\n * const myModule = new ContextModule('my module', {\n *   setup(setup) {\n *     // Provide the values\n *     setup.provide({ a: Foo, is: 'foo' });\n *   },\n * });\n *\n * // Load the module\n * const myModuleSupply = contextRegistry.provide(myModule);\n *\n * // Start using the module\n * const myModuleUse = await context.get(myModule).use();\n *\n * // Await for the module to load\n * await myModuleUse.whenReady;\n *\n * // Access the value provided by module.\n * console.log(context.get(Foo));\n *\n * // Stop using the module\n * myModuleUse.supply.off();\n *\n * // Unload the module declaration.\n * myModuleSupply.off();\n * ```\n */\nexport class ContextModule implements ContextUpRef<ContextModule.Handle, ContextModule>, ContextBuilder {\n\n  /**\n   * @internal\n   */\n  private readonly [ContextModule$impl__symbol]: ContextModule$;\n\n  /**\n   * Constructs context module.\n   *\n   * @param name - Human-readable module name.\n   * @param options - Module construction options.\n   */\n  constructor(name: string, options: ContextModule.Options = {}) {\n    this[ContextModule$impl__symbol] = new ContextModule$(this, name, options);\n  }\n\n  /**\n   * A key of context module.\n   */\n  get [ContextKey__symbol](): ContextUpKey<ContextModule.Handle, ContextModule> {\n    return this[ContextModule$impl__symbol].key;\n  }\n\n  /**\n   * Human-readable module name.\n   */\n  get name(): string {\n    return this[ContextModule$impl__symbol].name;\n  }\n\n  /**\n   * The modules this one requires.\n   *\n   * Assigned by {@link ContextModule.Options.needs} option.\n   */\n  get needs(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].needs;\n  }\n\n  /**\n   * The modules this one provides.\n   *\n   * Assigned by {@link ContextModule.Options.has} option.\n   *\n   * Always contains the module itself.\n   */\n  get has(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].has;\n  }\n\n  /**\n   * Provides this module and {@link has module replacements}.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry): Supply {\n\n    const supply = registry.provide({ a: this, is: this });\n\n    this[ContextModule$impl__symbol].replace(this, registry, supply);\n\n    return supply;\n  }\n\n  /**\n   * Sets up the module.\n   *\n   * This method is called when loading the module. It is used e.g. to provide more values for the context.\n   *\n   * By default:\n   *\n   * 1. Satisfies module {@link needs dependencies} by setting them up.\n   *\n   *    The dependency considered satisfied when it is {@link ContextModule.Status.settled settled}.\n   *\n   * 2. {@link ContextModule.Setup.initBy Initializes} the module by initializing the dependencies.\n   *\n   *    The dependency considered initialized when it is {@link ContextModule.Status.ready ready for use}.\n   *\n   * 3. Performs the module setup by invoking the {@link ContextModule.Options.setup} method.\n   *\n   * @param setup - Context module setup.\n   *\n   * @returns A promise resolved when the module is set up asynchronously.\n   */\n  setup(setup: ContextModule.Setup): Promise<void> {\n    return this[ContextModule$impl__symbol].setup(setup);\n  }\n\n  toString(): string {\n    return `ContextModule(${this.name})`;\n  }\n\n}\n\nexport namespace ContextModule {\n\n  /**\n   * Context module construction options.\n   */\n  export interface Options {\n\n    /**\n     * A module or modules the constructed one requires.\n     *\n     * The listed modules will be loaded prior to loading the constructed one.\n     */\n    readonly needs?: ContextModule | readonly ContextModule[];\n\n    /**\n     * A module or modules the constructed one provides.\n     *\n     * When specified, the constructed module will be loaded _instead_ of the listed ones.\n     *\n     * The module always provides itself.\n     */\n    readonly has?: ContextModule | readonly ContextModule[];\n\n    /**\n     * Sets up constructed module.\n     *\n     * This method is called when loading the module. It is used e.g. to provide more values for the context.\n     *\n     * @param setup - Context module setup.\n     *\n     * @returns Either nothing to set up the module synchronously, or a promise-like instance resolved when the module\n     * is set up asynchronously.\n     */\n    setup?(setup: ContextModule.Setup): void | PromiseLike<unknown>;\n\n  }\n\n  /**\n   * Context module setup.\n   *\n   * Passed to {@link ContextModule.setup module setup method} in order to access and provide the necessary values.\n   *\n   * @typeParam TCtx - Target context type.\n   */\n  export interface Setup extends ContextValues, SupplyPeer {\n\n    /**\n     * The module to set up.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Module supply.\n     *\n     * This supply will be cut off once the module is unloaded.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Provides context value.\n     *\n     * The value provider will be removed automatically once the module is unloaded.\n     *\n     * @typeParam TSrc - Source value type.\n     * @typeParam TDeps - Dependencies tuple type.\n     * @param spec - Context value specifier.\n     *\n     * @returns Provider supply instance that removes just added context value provider once cut off.\n     */\n    provide<TSrc, TDeps extends any[]>(\n        spec: ContextValueSpec<ContextValues, unknown, TSrc, TDeps>,\n    ): Supply;\n\n    /**\n     * Registers the module initializer.\n     *\n     * The module initializer registration is only valid during its {@link ContextModule.setup setup}.\n     *\n     * The registered initializers executed after successful module {@link ContextModule.setup}. The modules\n     * is considered {@link ContextModule.Status.ready ready for use} only when all registered initializers succeed.\n     *\n     * The registered initializers executed serially. I.e. then next one does not start until the previous one succeeds.\n     *\n     * It is an error calling this method when the module initialized already.\n     *\n     * @param init - The module initialization function, that returns nothing when the module initialization\n     * completed synchronously, or a promise-like instance resolved when the module initialization completed\n     * asynchronously.\n     */\n    initBy(init: (this: void) => void | PromiseLike<unknown>): void;\n\n  }\n\n  /**\n   * A handle of dynamically loaded context module.\n   *\n   * This value is available in {@link ContextValues.get returned from context} under the module instance used as a key.\n   *\n   * Implements an `EventKeeper` interface by sending a {@link ContextModule.Status module load status} updates.\n   */\n  export interface Handle extends EventKeeper<[ContextModule.Status]> {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * Initiate the module use.\n     *\n     * @param user - Module user. Contains a supply required by {@link Use.supply module use supply}. The module use\n     * stops once the user supply is cut off.\n     *\n     * @returns A module usage instance.\n     */\n    use(user?: SupplyPeer): Use;\n\n  }\n\n  /**\n   * An instance of the module use.\n   *\n   * The module is active while it is in use. I.e. at least one `Use` instance exists and active.\n   *\n   * The use is active util its {@link supply} is cut off.\n   *\n   * The module use instance can be used as its handle too.\n   */\n  export interface Use extends Handle, SupplyPeer {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     *\n     * Cuts off the supply when context module no longer {@link supply used}.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module settlement event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.settled\n     * settled}, but possibly before it is {@link ContextModule.Status.ready ready}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenSettled: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module readiness event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.ready ready\n     * for use}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenReady: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * Module use supply.\n     *\n     * The module use stops once this supply is cut off.\n     */\n    readonly supply: Supply;\n\n  }\n\n  /**\n   * Context module load status.\n   *\n   * This status is reported by {@link ContextModule.Handle loaded module handle}.\n   */\n  export interface Status {\n\n    /**\n     * Loaded module.\n     *\n     * Note that it may differ from the one requested to load. E.g. when another module {@link ContextModule.Options.has\n     * provides} it.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Whether the module implementation is provided.\n     */\n    readonly provided: boolean;\n\n    /**\n     * Whether the module is {@link Handle.use used} at least once.\n     */\n    readonly used: boolean;\n\n    /**\n     * Whether the module is settled.\n     *\n     * The module is settled when its {@link ContextModule.setup set up} is complete.\n     */\n    readonly settled: boolean;\n\n    /**\n     * Whether the module is loaded and ready for use.\n     *\n     * The module is ready when it is {@link settled}, and all of its {@link ContextModule.Setup.initBy initializers}\n     * succeed.\n     */\n    readonly ready: boolean;\n\n    /**\n     * Error occurred while loading the module.\n     */\n    readonly error?: unknown;\n\n  }\n\n}\n"],"names":["ContextKeyError","Error","[object Object]","key","message","super","this","ContextKey__symbol","Symbol","ContextKey","name","ContextSeedKey","seedKey","opts","seeder","seed","isEmpty","hasFallback","insert","ContextValues","SimpleContextSeeder","provider","entry","_providers","unshift","Supply","splice","lastIndexOf","context","initial","length","noop","makeSeed","lazyValue","bind","undefined","seeds","map","push","combineSimpleSeeds","first","second","value","SimpleSeedKey","SimpleContextKey","SingleContextKey","byDefault","slot","ContextSupplyKey","supply","or","alwaysSupply","ContextSupply","ContextBuilder__symbol","ContextSeeders","_initial","Map","found","_issuers","get","issuer","set","factory","isValueSpecWithDeps","spec","ContextValueSlot$","seeders","_opts","newSeed","_constructed","grow","setup","prevSetup","_setup","ContextRegistry","_seeders","isContextBuilder","a","by","isValueSpecByProvider","with","deps","dep","isConstantValueSpec","is","valueProvider","isValueSpecViaAlias","via","ctx","isValueSpecAsInstance","isSelfInstanceValueSpec","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","provide","newValues","registry","values","cached","constructed","_grow","newContextValues","other","otherSeeds","combine","contextDestroyed","reason","flatUpSources","translateAfter","send","sources","itsElements","overElementsOf","ContextUpSeeder","trackValue","providers","it","whenOff","delete","afterThe","providersTracker","read","do","digAfter_","size","afterEach","mapIt","overIterator","prov","toUpSrcKeeper","upSrcKeepers","src","isAfterEvent","ContextSeed$UpKey","upKey","ContextUpKey$UpKey","_key","fillBy","supplyAfter","ContextUpKey","FnContextKey","createUpKey","digAfter","fns","delegated","fn","args","SingleContextUpKey","backup","defaultValue","afterEventBy","off","ContextModuleDependencyError","module","reasons","dependencies","reduce","out","contextModuleDependencyErrorMessage","ContextModuleUsage","_impl","_rev","status","provided","used","settled","ready","neverSupply","contextSupply","cuts","prevSupply","_load","mapAfter_","handle","AfterEvent__symbol","use","user","_use","rev","receive","_ctx","error","_updateStatus","async","moduleInit","ContextModuleInit","request","needs","init","initBy","loadContextModule","then","whenReady","catch","impl","_useCounter","whenSettled","ContextModule$Use$when","isContextModuleSettled","isContextModuleReady","isOff","_module","Promise","resolve","_ready","_whenDone","finally","_done","_init","test","onEventBy","receiver","ContextModuleKey","usage","createHandle","implementBy","candidates","i","ContextModule$impl__symbol","ContextModule$","options","has","setOfElements","add","replaced","valueIt","contextModuleDeps","loadContextModuleDeps","whenContextModuleSettled","whenContextModuleReady","whenLoaded","notLoaded","whenDone","race","all","results","failures","filter","isDefined","result","reject","ContextModule","replace"],"mappings":"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"}