{"version":3,"file":"context-values.1da2f733.js","sources":["../../../../../proc7ts/context-values/src/context-key.ts","../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/context-seed-registry.impl.ts","../../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../../proc7ts/context-values/src/context-registry.ts","../../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../../proc7ts/context-values/src/single-context-key.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-supply.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextRegistry } from './context-registry';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [ContextKey] instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('context-key'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot  Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value slot to put the grown value into.\n *\n * An instance of the value slot is passed to [[ContextKey.grow]] method to provide the necessary context and optionally\n * accept a new value.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport type ContextValueSlot<TValue, TSrc, TSeed> =\n    | ContextValueSlot.WithFallback<TValue, TSrc, TSeed>\n    | ContextValueSlot.WithoutFallback<TValue, TSrc, TSeed>;\n\nexport namespace ContextValueSlot {\n\n  /**\n   * Base context value slot interface.\n   *\n   * @typeParam TValue  Context value type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Target context.\n     */\n    readonly context: ContextValues;\n\n    /**\n     * A key to associated value with.\n     */\n    readonly key: ContextKey<TValue, TSrc, TSeed>;\n\n    /**\n     * Context value seeder.\n     */\n    readonly seeder: ContextSeeder<ContextValues, TSrc, TSeed>;\n\n    /**\n     * Context value seed.\n     */\n    readonly seed: TSeed;\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     */\n    readonly hasFallback: boolean;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     *\n     * Always `undefined` when {@link hasFallback there is no fallback}.\n     */\n    readonly or: TValue | null | undefined;\n\n    /**\n     * Insert the value into the slot.\n     *\n     * The value will be associated with key after [[ContextKey.grow]] method exit.\n     *\n     * Supersedes a previously inserted value.\n     *\n     * @param value  A value to associate with the key, or `null`/`undefined` to not associate any value.\n     */\n    insert(value: TValue | null | undefined): void;\n\n    /**\n     * Fills this slot by the given function.\n     *\n     * @param grow  A function accepting a value slot as its only parameter.\n     *\n     * @returns A value associated with target key by the given function, or `null`/`undefined` when no value\n     * associated.\n     */\n    fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined;\n\n    /**\n     * Registers a setup procedure issued when context value associated with target key.\n     *\n     * Setup will be issued at most once per context. Setup won't be issued if no value {@link insert inserted}.\n     *\n     * @param setup  Context value setup procedure.\n     */\n    setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void;\n\n  }\n\n  /**\n   * Base context value slot with fallback value.\n   *\n   * @typeParam TValue  Context value type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface WithFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `true`\n     */\n    readonly hasFallback: true;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     */\n    readonly or: TValue | null | undefined;\n\n  }\n\n  export interface WithoutFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `false`\n     */\n    readonly hasFallback: false;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Always `undefined`.\n     */\n    readonly or: undefined;\n\n  }\n\n}\n\n/**\n * Context value setup procedure signature.\n *\n * A function with this signature can be passed to {@link ContextValueSlot.Base.setup} method to be issued when\n * the value associated with target key.\n */\nexport type ContextValueSetup<TValue, TSrc, TSeed> =\n/**\n * @param key  A key the value associated with.\n * @param context  Target context the value associated with.\n * @param registry  A registry of context value providers. This context is shared among all contexts\n * {@link ContextRegistry.newValues created} by it.\n */\n    (\n        this: void,\n        {\n          key,\n          context,\n          registry,\n        }: {\n          key: ContextKey<TValue, TSrc, TSeed>;\n          context: ContextValues;\n          registry: ContextRegistry;\n        }\n    ) => void;\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TValue  Context value type.\n * @typeParam TKey  Context key type.\n */\nexport type ContextKeyDefault<TValue, TKey extends ContextKey<unknown, unknown>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: TKey) => TValue | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSetup, ContextValueSlot } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextRegistry } from './context-registry';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport type SeedFactory<TCtx extends ContextValues, TSeed> = (this: void, context: TCtx) => TSeed;\n\n/**\n * @internal\n */\nexport type SeedData<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n    seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n    factory: SeedFactory<TCtx, TSeed>,\n];\n\n/**\n * @internal\n */\nexport class ContextSeedRegistry<TCtx extends ContextValues> {\n\n  private readonly _byKey = new Map<ContextSeedKey<any, any>, SeedData<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  seedData<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedData<TCtx, TSrc, TSeed> {\n\n    const found: SeedData<TCtx, TSrc, TSeed> | undefined = this._byKey.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const factory: SeedFactory<TCtx, TSeed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seedData: SeedData<TCtx, TSrc, TSeed> = [seeder, factory];\n\n    this._byKey.set(seedKey, seedData);\n\n    return seedData;\n  }\n\n  /**\n   * @internal\n   */\n  findSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.seedData(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seedRegistry: ContextSeedRegistry<TCtx>,\n): ContextValues {\n\n    const values = new Map<ContextKey<any>, any>();\n\n    class Values extends ContextValues {\n\n        get<TValue, TSrc>(\n            this: TCtx,\n            { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n            opts?: ContextRequest.Opts<TValue>,\n        ): TValue | null | undefined {\n\n            const cached = values.get(key);\n\n            if (cached != null) {\n                return cached;\n            }\n\n            const [constructed, setup] = new ContextValueSlot$(seedRegistry, this, key, opts)._grow();\n\n            if (setup) {\n                values.set(key, constructed);\n                setup({\n                    key,\n                    context: this,\n                    registry: registry as ContextRegistry<any> as ContextRegistry,\n                });\n            }\n\n            return constructed;\n        }\n\n    }\n\n    return new Values();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n    readonly hasFallback: boolean;\n    readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n    readonly seed: TSeed;\n    private _constructed: TValue | null | undefined = null;\n    private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n    constructor(\n        registry: ContextSeedRegistry<TCtx>,\n        readonly context: TCtx,\n        readonly key: ContextKey<TValue, TSrc, TSeed>,\n        private readonly _opts: ContextRequest.Opts<TValue> = {},\n    ) {\n\n        const [seeder, seed] = registry.findSeed<TSrc, TSeed>(context, key);\n\n        this.seeder = seeder;\n        this.seed = seed;\n        this.hasFallback = 'or' in _opts;\n    }\n\n    get or(): TValue | null | undefined {\n        return this._opts.or;\n    }\n\n    insert(value: TValue | null | undefined): void {\n        this._constructed = value;\n    }\n\n    fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n        grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n        return this._constructed;\n    }\n\n    setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n        const prevSetup = this._setup;\n\n        this._setup = opts => {\n            prevSetup(opts);\n            setup(opts);\n        };\n    }\n\n    _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n        this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n        if (this._constructed != null) {\n            return [this._constructed, this._setup];\n        }\n        if (!this.hasFallback) {\n            throw new ContextKeyError(this.key);\n        }\n\n        return [this.or];\n    }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/primitives';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TSrc  Source value type.\n */\nexport type ContextValueProvider<TCtx extends ContextValues, TSrc> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: TCtx) => TSrc | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TValue  Context value type.\n * @typeParam TDeps  Dependencies tuple type.\n * @typeParam TSrc  Source value type.\n * @typeParam TSeed  Value seed type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TDeps extends any[] = unknown[],\n    TSrc = TValue,\n    TSeed = unknown> =\n    | ContextValueSpec.IsConstant<TSrc, TSeed>\n    | ContextValueSpec.ViaAlias<TSrc, TSeed>\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface IsConstant<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface ViaAlias<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc, TSeed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx  Context type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TCtx, TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface ByProviderWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx  Context type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx  Context type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx  Context type.\n * @typeParam TValue  Context value type.\n * @typeParam TDeps  Dependencies tuple type.\n * @typeParam TSrc  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, TValue, TDeps, TSrc, TSeed>,\n): ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> {\n  if (byProvider(spec)) {\n    if (!withDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstant<TSrc, TSeed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n    if (selfInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed> | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>,\n): ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.IsConstant<TSrc, TSeed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.ViaAlias<TSrc, TSeed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKey__symbol, ContextSeedKey } from './context-key';\nimport { ContextSeedRegistry, newContextValues } from './context-seed-registry.impl';\nimport { ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx  Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeds: ContextSeedRegistry<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n\n    let initialSeeds: ContextSeeds<TCtx>;\n\n    if (initial == null) {\n      initialSeeds = noop;\n    } else if (typeof initial === 'function') {\n      initialSeeds = initial;\n    } else {\n      initialSeeds = seedKey => initial.get(seedKey);\n    }\n\n    this._seeds = new ContextSeedRegistry<TCtx>(initialSeeds);\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TDeps  Dependencies tuple type.\n   * @typeParam TSrc  Source value type.\n   * @typeParam TSeed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<TDeps extends any[], TSrc, TSeed>(spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeds.seedData<TSrc, TSeed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeds.seedData(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeds);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx>): ContextRegistry<TCtx> {\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const [seeder, factory] = this._seeds.seedData(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: ContextValueProvider<TCtx, TSrc>[] = [];\n\n  provide(provider: ContextValueProvider<TCtx, TSrc>): () => void {\n    this._providers.unshift(provider);\n    return () => {\n\n      const found = this._providers.lastIndexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (provider: ContextValueProvider<TCtx, TSrc>): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc  Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue  Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue  Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason  Context destruction reason.\n */\nexport function contextDestroyed(reason?: any): () => never {\n  return () => {\n    throw reason ?? new TypeError('Context destroyed');\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { EventSupply, EventSupply__symbol, EventSupplyPeer } from '@proc7ts/fun-events';\nimport { ContextValueSlot } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { SimpleContextKey } from '../simple-context-key';\n\n/**\n * Context values supply.\n *\n * When available as context value, it is used to indicate the context is no longer used (e.g. destroyed).\n *\n * A context value provider can destroy the value it provides when this supply is cut off.\n */\nexport type ContextSupply = EventSupply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || (slot.hasFallback ? slot.or : null)\n        || (slot.context as Partial<EventSupplyPeer>)[EventSupply__symbol],\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is not guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `EventSupplyPeer` interface.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { CallChain, nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { mapIt, overArray, overElementsOf } from '@proc7ts/push-iterator';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSlot } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(\n        first,\n        second,\n    ).keepThru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>[]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read().keepThru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | TSrc | EventKeeper<TSrc[]>): AfterEvent<TSrc[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<TSrc>(src: TSrc | EventKeeper<TSrc[]>): src is EventKeeper<TSrc[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as object);\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<TSrc>(...sources: TSrc[][]): NextCall<CallChain, TSrc[]> {\n  return nextArgs(...overElementsOf(...sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<TSrc>\n    extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, TSrc | EventKeeper<TSrc[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<TValue, TSrc>\n    extends ContextKey<ContextUpKey.Up<TValue>, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  readonly grow: (\n      slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<TValue, TSrc>,\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value = slot.fillBy(grow);\n\n      if (value) {\n\n        const supply = slot.context.get(ContextSupply, { or: null });\n\n        if (supply) {\n          slot.insert(value.tillOff(supply) as ContextUpKey.Up<TValue>);\n        }\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue  Context value type.\n * @typeParam TSrc  Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[grow]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey<TSrc>(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.UpKey<TValue, TSrc> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue  Original context value type.\n   */\n  export type Up<TValue> = TValue extends AfterEvent<any>\n      ? TValue\n      : (TValue extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[TValue]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeParam TValue  Context value type.\n   * @typeParam TSrc  Source value type.\n   */\n  export type UpKey<TValue, TSrc> = ContextKey<ContextUpKey.Up<TValue>, TSrc>;\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc  Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs  Function arguments tuple type.\n * @typeParam TRet  Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs  Function arguments tuple type.\n * @typeParam TRet  Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        slot => {\n          slot.insert(slot.seed.keepThru(\n              (...fns) => {\n                if (fns.length) {\n                  return fns[fns.length - 1];\n                }\n\n                if (slot.hasFallback && slot.or) {\n                  return nextAfterEvent(slot.or);\n                }\n\n                return nextAfterEvent(afterThe(this.byDefault(slot.context, this)));\n              },\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          EventKeeper<((this: void, ...args: TArgs) => TRet)[]> | ((this: void, ...args: TArgs) => TRet),\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { nextArg } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from './context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeParam TValue  Context value type.\n */\nexport type SingleContextUpRef<TValue> = ContextUpRef<AfterEvent<[TValue]>, TValue>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue  Context value type.\n */\nexport class SingleContextUpKey<TValue>\n    extends ContextUpKey<AfterEvent<[TValue]>, TValue>\n    implements SingleContextUpRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TValue>;\n        byDefault?: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<AfterEvent<[TValue]>, EventKeeper<TValue[]> | TValue, AfterEvent<TValue[]>>,\n  ): void {\n\n    const value = slot.seed.keepThru((...sources: TValue[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[TValue]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        backup = defaultValue && afterThe(defaultValue);\n      }\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[TValue]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n\n    const supply = slot.context.get(ContextSupply, { or: null });\n\n    slot.insert(supply ? value.tillOff(supply) : value);\n  }\n\n}\n\n"],"names":["ContextKey__symbol","Symbol","ContextKey","[object Object]","name","this","ContextSeedKey","key","super","seedKey","opts","seeder","seed","isEmpty","hasFallback","insert","ContextKeyError","Error","message","ContextValues","ContextSeedRegistry","_initial","Map","found","_byKey","get","seedData","context","set","factory","ContextValueSlot$","registry","_opts","noop","findSeed","or","value","_constructed","grow","setup","prevSetup","_setup","withDeps","spec","ContextRegistry","initial","initialSeeds","_seeds","a","by","byProvider","with","deps","map","dep","isConstant","is","valueProvider","viaAlias","via","ctx","asInstance","selfInstance","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","provide","newValues","bind","seedRegistry","values","cached","constructed","_grow","newContextValues","other","combine","SimpleContextSeeder","provider","_providers","unshift","lastIndexOf","splice","length","makeSeed","lazyValue","undefined","seeds","push","combineSimpleSeeds","first","second","SimpleSeedKey","SimpleContextKey","SingleContextKey","byDefault","slot","contextDestroyed","reason","ContextSupplyKey","EventSupply__symbol","ContextSupply","ContextUpSeeder","trackValue","it","providers","indexOf","slice","concat","afterThe","providersTracker","read","keepThru","nextAfterEvent","afterEach","mapIt","overArray","prov","toUpSrcKeeper","nextArgs","flatUpSources","upSrcKeepers","src","isEventKeeper","isUpSrcKeeper","afterSupplied","sources","overElementsOf","ContextSeedUpKey","upKey","ContextUpKeyUpKey","_key","fillBy","supply","tillOff","ContextUpKey","FnContextKey","createUpKey","fns","delegated","to","fn","whenOff","args","SingleContextUpKey","nextArg","backup","defaultValue","afterEventBy"],"mappings":"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"}