{"version":3,"file":"context-values.dc14f6d9.js","sources":["../../../../../proc7ts/context-values/src/context-key.ts","../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/context-registry.ts","../../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../../proc7ts/context-values/src/single-context-key.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-supply.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextRegistry } from './context-registry';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot  Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<Value, Src, Seed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value slot to put the grown value into.\n *\n * An instance of the value slot is passed to [[ContextKey.grow]] method to provide the necessary context and optionally\n * accept a new value.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSlot<Value, Src, Seed> =\n    | ContextValueSlot.WithFallback<Value, Src, Seed>\n    | ContextValueSlot.WithoutFallback<Value, Src, Seed>;\n\nexport namespace ContextValueSlot {\n\n  /**\n   * Base context value slot interface.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface Base<Value, Src, Seed> {\n\n    /**\n     * Target context.\n     */\n    readonly context: ContextValues;\n\n    /**\n     * A key to associated value with.\n     */\n    readonly key: ContextKey<Value, Src, Seed>;\n\n    /**\n     * Context value seeder.\n     */\n    readonly seeder: ContextSeeder<ContextValues, Src, Seed>;\n\n    /**\n     * Context value seed.\n     */\n    readonly seed: Seed;\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     */\n    readonly hasFallback: boolean;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     *\n     * Always `undefined` when {@link hasFallback there is no fallback}.\n     */\n    readonly or: Value | null | undefined;\n\n    /**\n     * Insert the value into the slot.\n     *\n     * The value will be associated with key after [[ContextKey.grow]] method exit.\n     *\n     * Supersedes a previously inserted value.\n     *\n     * @param value  A value to associate with the key, or `null`/`undefined` to not associate any value.\n     */\n    insert(value: Value | null | undefined): void;\n\n    /**\n     * Fills this slot by the given function.\n     *\n     * @param grow  A function accepting a value slot as its only parameter.\n     *\n     * @returns A value associated with target key by the given function, or `null`/`undefined` when no value\n     * associated.\n     */\n    fillBy(grow: (this: void, slot: ContextValueSlot<Value, Src, Seed>) => void): Value | null | undefined;\n\n    /**\n     * Registers a setup procedure issued when context value associated with target key.\n     *\n     * Setup will be issued at most once per context. Setup won't be issued if no value {@link insert inserted}.\n     *\n     * @param setup  Context value setup procedure.\n     */\n    setup(setup: ContextValueSetup<Value, Src, Seed>): void;\n\n  }\n\n  /**\n   * Base context value slot with fallback value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface WithFallback<Value, Src, Seed> extends Base<Value, Src, Seed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `true`\n     */\n    readonly hasFallback: true;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     */\n    readonly or: Value | null | undefined;\n\n  }\n\n  export interface WithoutFallback<Value, Src, Seed> extends Base<Value, Src, Seed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `false`\n     */\n    readonly hasFallback: false;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Always `undefined`.\n     */\n    readonly or: undefined;\n\n  }\n\n}\n\n/**\n * Context value setup procedure signature.\n *\n * A function with this signature can be passed to {@link ContextValueSlot.Base.setup} method to be issued when\n * the value associated with target key.\n */\nexport type ContextValueSetup<Value, Src, Seed> =\n/**\n * @param key  A key the value associated with.\n * @param context  Target context the value associated with.\n * @param registry  A registry of context value providers. This context is shared among all contexts\n * {@link ContextRegistry.newValues created} by it.\n */\n    (\n        this: void,\n        {\n          key,\n          context,\n          registry,\n        }: {\n          key: ContextKey<Value, Src, Seed>;\n          context: ContextValues;\n          registry: ContextRegistry;\n        }\n    ) => void;\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow(opts: ContextValueSlot<Seed, Src, Seed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: Ctx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: Ctx) {\n        return new DepType(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSetup, ContextValueSlot } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\n/**\n * @internal\n */\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n    return this.newValues(cache).get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, setup] = growValue(context, key, opts);\n\n        if (cache && setup) {\n          values.set(key, constructed);\n          setup({\n            key,\n            context: this,\n            registry: registry as ContextRegistry<any>,\n          });\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> = {},\n    ): [Value | null | undefined, ContextValueSetup<Value, Src, Seed>?] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let constructed: Value | null | undefined;\n      const hasFallback = 'or' in opts;\n      let setupValue: ContextValueSetup<Value, Src, Seed> = noop;\n      const slot: ContextValueSlot.Base<Value, Src, Seed> = {\n        context,\n        key,\n        seeder,\n        seed,\n        hasFallback,\n        get or() {\n          return opts.or;\n        },\n        insert(value) {\n          constructed = value;\n        },\n        fillBy(grow) {\n          grow(slot as ContextValueSlot<Value, Src, Seed>);\n          return constructed;\n        },\n        setup(setup) {\n\n          const prevSetup = setupValue;\n\n          setupValue = opts => {\n            prevSetup(opts);\n            setup(opts);\n          };\n        },\n      };\n      key.grow(slot as ContextValueSlot<Value, Src, Seed>);\n\n      if (constructed != null) {\n        return [constructed, setupValue];\n      }\n      if (!hasFallback) {\n        throw new ContextKeyError(key);\n      }\n\n      return [opts.or];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n    return new ContextRegistry(<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx) => {\n\n      const [seeder, factory] = this._seeding(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src, SimpleContextKey.Seed<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.unshift(provider);\n    return () => {\n\n      const found = this._providers.lastIndexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial?: SimpleContextKey.Seed<Src>): SimpleContextKey.Seed<Src> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (provider: ContextValueProvider<Ctx, Src>): SimpleContextKey.Seed<Src> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<Src>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<Src>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<Src>,\n      second: SimpleContextKey.Seed<Src>,\n  ): SimpleContextKey.Seed<Src> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<Src>(\n    seeds: readonly SimpleContextKey.Seed<Src>[],\n): SimpleContextKey.Seed<Src> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, SimpleContextKey.Seed<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, SimpleContextKey.Seed<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, SimpleContextKey.Seed<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<Src, SimpleContextKey.Seed<Src>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeparam Src  Source vale type.\n   */\n  export type Seed<Src> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when when absent.\n   */\n      (this: void) => Src | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextRef<Value> = ContextRef<Value, Value>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, SimpleContextKey.Seed<Value>>;\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<Value, Value, SimpleContextKey.Seed<Value>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason  Context destruction reason.\n */\nexport function contextDestroyed(reason?: any): () => never {\n  return () => {\n    throw reason ?? new TypeError('Context destroyed');\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { EventSupply, EventSupply__symbol, EventSupplyPeer } from '@proc7ts/fun-events';\nimport { ContextValueSlot } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { SimpleContextKey } from '../simple-context-key';\n\n/**\n * Context values supply.\n *\n * When available as context value, it is used to indicate the context is no longer used (e.g. destroyed).\n *\n * A context value provider can destroy the value it provides when this supply is cut off.\n */\nexport type ContextSupply = EventSupply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || (slot.hasFallback ? slot.or : null)\n        || (slot.context as Partial<EventSupplyPeer>)[EventSupply__symbol],\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is not guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `EventSupplyPeer` interface.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { flatMapIt, mapIt, overArray } from '@proc7ts/a-iterable';\nimport { CallChain, nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSlot } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keepThru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read().keepThru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<Src>(...sources: Src[][]): NextCall<CallChain, Src[]> {\n  return nextArgs<Src[]>(...flatMapIt<Src>(sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<Src>\n    extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpKey.SeedKey<Src> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport interface ContextUpRef<Value, Src> extends ContextRef<Value, Src | EventKeeper<Src[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<Value, Src>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<Value, Src>\n    extends ContextKey<ContextUpKey.Up<Value>, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  readonly grow: (\n      slot: ContextValueSlot<ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<Value, Src>,\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value = slot.fillBy(grow);\n\n      if (value) {\n\n        const supply = slot.context.get(ContextSupply, { or: null });\n\n        if (supply) {\n          slot.insert(value.tillOff(supply) as ContextUpKey.Up<Value>);\n        }\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src> {\n\n  readonly seedKey: ContextUpKey.SeedKey<Src>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[grow]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<Value, Src>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<Src>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey<Src>(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => void,\n  ): ContextUpKey.UpKey<Value, Src> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeparam Value  Original context value type.\n   */\n  export type Up<Value> = Value extends AfterEvent<any>\n      ? Value\n      : (Value extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[Value]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   */\n  export type UpKey<Value, Src> = ContextKey<ContextUpKey.Up<Value>, Src>;\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeparam Src  Source value type.\n   */\n  export interface SeedKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport type FnContextRef<Args extends any[], Ret = void> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: Args) => Ret)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        slot => {\n          slot.insert(slot.seed.keepThru(\n              (...fns) => {\n                if (fns.length) {\n                  return fns[fns.length - 1];\n                }\n\n                if (slot.hasFallback && slot.or) {\n                  return nextAfterEvent(slot.or);\n                }\n\n                return nextAfterEvent(afterThe(this.byDefault(slot.context, this)));\n              },\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: Args) => Ret;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { nextArg, noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from './context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextUpRef<Value> = ContextUpRef<AfterEvent<[Value]>, Value>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<Value>;\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): void {\n\n    const value = slot.seed.keepThru((...sources: Value[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[Value]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        backup = defaultValue && afterThe(defaultValue);\n      }\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n\n    const supply = slot.context.get(ContextSupply, { or: null });\n\n    slot.insert(supply ? value.tillOff(supply) : value);\n  }\n\n}\n\n"],"names":["ContextKey__symbol","Symbol","ContextKey","[object Object]","name","this","ContextSeedKey","key","super","seedKey","opts","seeder","seed","isEmpty","hasFallback","insert","ContextKeyError","Error","message","withDeps","spec","ContextValues","ContextRegistry","initial","Map","_initial","noop","get","a","by","byProvider","with","deps","context","map","dep","isConstant","is","value","valueProvider","viaAlias","via","ctx","asInstance","selfInstance","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","_seeding","provide","found","_seeds","seeding","set","factory","cache","newValues","bind","_nonCachedValues","values","registry","Values","cached","constructed","setup","findSeed","setupValue","slot","or","fillBy","grow","prevSetup","growValue","other","combine","SimpleContextSeeder","provider","_providers","unshift","lastIndexOf","splice","length","makeSeed","lazyValue","undefined","seeds","push","combineSimpleSeeds","first","second","SimpleSeedKey","SimpleContextKey","SingleContextKey","byDefault","contextDestroyed","reason","ContextSupplyKey","EventSupply__symbol","ContextSupply","ContextUpSeeder","trackValue","it","providers","indexOf","slice","concat","afterThe","providersTracker","read","keepThru","nextAfterEvent","afterEach","mapIt","overArray","prov","toUpSrcKeeper","nextArgs","flatUpSources","upSrcKeepers","src","isEventKeeper","isUpSrcKeeper","afterSupplied","sources","flatMapIt","ContextSeedUpKey","upKey","ContextUpKeyUpKey","_key","supply","tillOff","ContextUpKey","FnContextKey","createUpKey","fns","delegated","to","fn","whenOff","args","SingleContextUpKey","nextArg","backup","defaultValue","afterEventBy"],"mappings":"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"}