{"version":3,"file":"context-values.3377d707.js","sources":["../../../../../proc7ts/context-values/src/context-key.ts","../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/context-registry.ts","../../../../../proc7ts/context-values/src/iterative-context-key.ts","../../../../../proc7ts/context-values/src/multi-context-key.ts","../../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../../proc7ts/context-values/src/single-context-key.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-supply.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @typeparam Ctx  Context type.\n   * @param opts  Context value growth options.\n   *\n   * @returns Single context value, or `undefined` if there is no default value.\n   */\n  abstract grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Value, Src, Seed>): Value | null | undefined;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value growth options.\n *\n * An instance of these options is passed to [[ContextKey.grow]] method to provide the necessary value growth context.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport interface ContextValueOpts<Ctx extends ContextValues, Value, Src, Seed> {\n\n  /**\n   * Target context.\n   */\n  readonly context: Ctx;\n\n  /**\n   * Context value seeder.\n   */\n  readonly seeder: ContextSeeder<Ctx, Src, Seed>;\n\n  /**\n   * Context value seed.\n   */\n  readonly seed: Seed;\n\n  /**\n   * A fallback value to use if there is no value associated with the given key.\n   *\n   * Can be `null` or `undefined`.\n   */\n  readonly or?: Value | null;\n\n  /**\n   * Handles missing context value.\n   *\n   * It can be called to prefer a fallback value over the default one specified in the value key.\n   *\n   * @param defaultProvider  Default value provider. It is called unless a fallback value is specified.\n   * If it returns a non-null/non-undefined value, then the returned value will be associated with the context key.\n   */\n  byDefault(defaultProvider: () => Value | null | undefined): Value | null | undefined;\n\n}\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Seed, Src, Seed>): Seed | null | undefined {\n\n    const { seeder, seed } = opts;\n\n    return seeder.isEmpty(seed) ? opts.byDefault(() => seed) : seed;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: Ctx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: Ctx) {\n        return new DepType(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\n/**\n * @internal\n */\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n    return this.newValues(cache).get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, defaultUsed] = growValue(context, key, opts);\n\n        if (cache && !defaultUsed) {\n          values.set(key, constructed);\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> | undefined,\n    ): [Value | null | undefined, boolean] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let defaultUsed = false;\n\n      const valueOpts: {\n        -readonly [K in keyof ContextValueOpts<Ctx, Value, Src, Seed>]: ContextValueOpts<Ctx, Value, Src, Seed>[K];\n      } = {\n        context,\n        seeder,\n        seed,\n        byDefault: (opts && 'or' in opts)\n            ? () => {\n              defaultUsed = true;\n              return opts.or;\n            }\n            : defaultProvider => {\n\n              const defaultValue = defaultProvider();\n\n              if (defaultValue == null) {\n                throw new ContextKeyError(key);\n              }\n\n              return defaultValue;\n            },\n      };\n\n      if (opts && 'or' in opts) {\n        valueOpts.or = opts.or;\n      }\n\n      return [\n        key.grow(valueOpts),\n        defaultUsed,\n      ];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n    return new ContextRegistry(<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx) => {\n\n      const [seeder, factory] = this._seeding(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { filterIt, flatMapIt, itsEmpty, mapIt, overNone } from '@proc7ts/a-iterable';\nimport { isPresent, lazyValue } from '@proc7ts/call-thru';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass IterativeContextSeeder<Ctx extends ContextValues, Src> implements ContextSeeder<Ctx, Src, Iterable<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.push(provider);\n    return () => {\n\n      const found = this._providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: Iterable<Src> = overNone()): Iterable<Src> {\n    return flatMapIt([\n      initial,\n      iterativeSeed(context, this._providers),\n    ]);\n  }\n\n  isEmpty(seed: Iterable<Src>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: Iterable<Src>, second: Iterable<Src>): Iterable<Src> {\n    return flatMapIt([first, second]);\n  }\n\n}\n\n/**\n * @internal\n */\nclass IterativeSeedKey<Src> extends ContextSeedKey<Src, Iterable<Src>> {\n\n  seeder<Ctx extends ContextValues>(): IterativeContextSeeder<Ctx, Src> {\n    return new IterativeContextSeeder();\n  }\n\n}\n\n/**\n * Iterative context value key implementation.\n *\n * Collects value sources as iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class IterativeContextKey<Value, Src = Value> extends ContextKey<Value, Src, Iterable<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, Iterable<Src>>;\n\n  /**\n   * Constructs iterative context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, Iterable<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new IterativeSeedKey(this);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction iterativeSeed<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providers: readonly ContextValueProvider<Ctx, Src>[],\n): Iterable<Src> {\n  return filterIt<Src | null | undefined, Src>(\n      mapIt(\n          providers.map(provider => lazyValue(provider.bind(undefined, context))), // lazily evaluated providers\n          provider => provider(),\n      ),\n      isPresent,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valuesProvider } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextValues } from './context-values';\nimport { IterativeContextKey } from './iterative-context-key';\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport type MultiContextRef<Src> = ContextRef<readonly Src[], Src>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport class MultiContextKey<Src>\n    extends IterativeContextKey<readonly Src[], Src>\n    implements MultiContextRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<Src, Iterable<Src>>;\n        byDefault?: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, readonly Src[], Src, Iterable<Src>>,\n  ): readonly Src[] | null | undefined {\n\n    const result = Array.from(opts.seed);\n\n    if (result.length) {\n      return result;\n    }\n\n    return opts.byDefault(() => {\n\n      const defaultSources = this.byDefault(opts.context, this);\n\n      if (defaultSources) {\n        return Array.from(defaultSources);\n      }\n\n      return;\n    });\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src, SimpleContextKey.Seed<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.unshift(provider);\n    return () => {\n\n      const found = this._providers.lastIndexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial?: SimpleContextKey.Seed<Src>): SimpleContextKey.Seed<Src> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (provider: ContextValueProvider<Ctx, Src>): SimpleContextKey.Seed<Src> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<Src>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<Src>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<Src>,\n      second: SimpleContextKey.Seed<Src>,\n  ): SimpleContextKey.Seed<Src> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<Src>(\n    seeds: readonly SimpleContextKey.Seed<Src>[],\n): SimpleContextKey.Seed<Src> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, SimpleContextKey.Seed<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, SimpleContextKey.Seed<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, SimpleContextKey.Seed<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, SimpleContextKey.Seed<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeparam Src  Source vale type.\n   */\n  export type Seed<Src> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when when absent.\n   */\n      (this: void) => Src | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextValues } from './context-values';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextRef<Value> = ContextRef<Value, Value>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, SimpleContextKey.Seed<Value>>;\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, Value, Value, SimpleContextKey.Seed<Value>>,\n  ): Value | null | undefined {\n\n    const value = opts.seed();\n\n    if (value != null) {\n      return value;\n    }\n\n    return opts.byDefault(() => this.byDefault(opts.context, this));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason  Context destruction reason.\n */\nexport function contextDestroyed(reason?: any): () => never {\n  return () => {\n    throw reason ?? new TypeError('Context destroyed');\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { EventSupply, EventSupply__symbol, EventSupplyPeer } from '@proc7ts/fun-events';\nimport { ContextValueOpts } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextValues } from '../context-values';\nimport { SimpleContextKey } from '../simple-context-key';\n\n/**\n * Context values supply.\n *\n * When available as context value, it is used to indicate the context is no longer used (e.g. destroyed).\n *\n * A context value provider can destroy the value it provides when this supply is cut off.\n */\nexport type ContextSupply = EventSupply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): ContextSupply | null | undefined {\n    return opts.seed()\n        || opts.or\n        || (opts.context as Partial<EventSupplyPeer>)[EventSupply__symbol]\n        || opts.byDefault(noop);\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is not guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `EventSupplyPeer` interface.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { flatMapIt, mapIt, overArray } from '@proc7ts/a-iterable';\nimport { CallChain, nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keepThru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read().keepThru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<Src>(...sources: Src[][]): NextCall<CallChain, Src[]> {\n  return nextArgs<Src[]>(...flatMapIt<Src>(sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<Src>\n    extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpKey.SeedKey<Src> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport interface ContextUpRef<Value, Src> extends ContextRef<Value, Src | EventKeeper<Src[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<Value, Src>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<Value, Src>\n    extends ContextKey<ContextUpKey.Up<Value>, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  readonly grow: <Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ) => ContextUpKey.Up<Value>;\n\n  get seedKey(): ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<Value, Src>,\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ) {\n    super(_key.name + ':up');\n    this.grow = opts => {\n\n      const value = grow(opts);\n      const supply = opts.context.get(ContextSupply, { or: null });\n\n      return supply ? value.tillOff(supply) as ContextUpKey.Up<Value> : value;\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src> {\n\n  readonly seedKey: ContextUpKey.SeedKey<Src>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[grow]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<Value, Src>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextUpKey.SeedKey<Src>) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey<Src>(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ): ContextUpKey.UpKey<Value, Src> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeparam Value  Original context value type.\n   */\n  export type Up<Value> = Value extends AfterEvent<any>\n      ? Value\n      : (Value extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[Value]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   */\n  export type UpKey<Value, Src> = ContextKey<ContextUpKey.Up<Value>, Src>;\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeparam Src  Source value type.\n   */\n  export interface SeedKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ContextKeyDefault, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport type FnContextRef<Args extends any[], Ret = void> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: Args) => Ret)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n                return fns[fns.length - 1];\n              }\n\n              const defaultProvider = (): AfterEvent<[(this: void, ...args: Args) => Ret]> => afterThe(this.byDefault(\n                  opts.context,\n                  this,\n              ));\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): (this: void, ...args: Args) => Ret {\n\n    let delegated: (this: void, ...args: Args) => Ret;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    return (...args) => delegated(...args);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { nextArg, noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ContextKeyDefault, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextUpRef<Value> = ContextUpRef<AfterEvent<[Value]>, Value>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<Value>;\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): AfterEvent<[Value]> {\n\n    const value = opts.seed.keepThru((...sources: Value[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue && afterThe(defaultValue);\n      });\n\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n\n    const supply = opts.context.get(ContextSupply, { or: null });\n\n    return supply ? value.tillOff(supply) : value;\n  }\n\n}\n\n"],"names":["ContextKey__symbol","Symbol","ContextKey","[object Object]","name","this","ContextSeedKey","key","super","seedKey","opts","seeder","seed","isEmpty","byDefault","ContextKeyError","Error","message","contextValueSpec","spec","byProvider","withDeps","a","by","with","deps","context","map","dep","get","isConstant","is","value","valueProvider","viaAlias","via","ctx","asInstance","selfInstance","Object","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","ContextValues","ContextRegistry","initial","Map","_initial","noop","_seeding","provide","found","_seeds","seeding","set","factory","cache","newValues","bind","_nonCachedValues","values","registry","Values","cached","constructed","defaultUsed","findSeed","valueOpts","or","defaultProvider","defaultValue","grow","growValue","other","combine","IterativeContextSeeder","provider","_providers","push","indexOf","splice","overNone","flatMapIt","iterativeSeed","itsEmpty","first","second","IterativeSeedKey","IterativeContextKey","providers","filterIt","mapIt","lazyValue","undefined","isPresent","MultiContextKey","valuesProvider","result","Array","from","length","defaultSources","SimpleContextSeeder","unshift","lastIndexOf","makeSeed","seeds","combineSimpleSeeds","SimpleSeedKey","SimpleContextKey","SingleContextKey","contextDestroyed","reason","ContextSupplyKey","EventSupply__symbol","ContextSupply","ContextUpSeeder","trackValue","it","slice","concat","afterThe","providersTracker","read","keepThru","nextAfterEvent","afterEach","overArray","prov","toUpSrcKeeper","nextArgs","flatUpSources","upSrcKeepers","src","isEventKeeper","isUpSrcKeeper","afterSupplied","sources","ContextSeedUpKey","upKey","ContextUpKeyUpKey","_key","supply","tillOff","ContextUpKey","FnContextKey","createUpKey","fns","delegated","to","fn","whenOff","args","SingleContextUpKey","nextArg","backup","afterEventBy"],"mappings":"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"}