{"version":3,"file":"push-iterator.38276a56.js","sources":["../../../../../proc7ts/push-iterator/src/push-iterable.ts","../../../../../proc7ts/push-iterator/src/base/is-push-iterable.ts","../../../../../proc7ts/push-iterator/src/base/iterator-of.ts","../../../../../proc7ts/push-iterator/src/base/make-push-iterable.ts","../../../../../proc7ts/push-iterator/src/base/push-iterated.ts","../../../../../proc7ts/push-iterator/src/base/make-push-iterator.ts","../../../../../proc7ts/push-iterator/src/base/push-head.ts","../../../../../proc7ts/push-iterator/src/base/array-iterator.impl.ts","../../../../../proc7ts/push-iterator/src/construction/over-array.ts","../../../../../proc7ts/push-iterator/src/consumption/its-iterated.ts","../../../../../proc7ts/push-iterator/src/consumption/its-each.ts","../../../../../proc7ts/push-iterator/src/consumption/its-elements.ts","../../../../../proc7ts/push-iterator/src/consumption/its-every.ts","../../../../../proc7ts/push-iterator/src/consumption/its-first.ts","../../../../../proc7ts/push-iterator/src/base/raw-iterator.impl.ts","../../../../../proc7ts/push-iterator/src/consumption/its-head.ts","../../../../../proc7ts/push-iterator/src/consumption/its-reduction.ts","../../../../../proc7ts/push-iterator/src/construction/over-none.ts","../../../../../proc7ts/push-iterator/src/construction/over-iterator.ts","../../../../../proc7ts/push-iterator/src/construction/over-elements-of.ts","../../../../../proc7ts/push-iterator/src/construction/over-iterable.ts","../../../../../proc7ts/push-iterator/src/construction/over-one.ts","../../../../../proc7ts/push-iterator/src/transformation/filter-array.ts","../../../../../proc7ts/push-iterator/src/transformation/filter-it.ts","../../../../../proc7ts/push-iterator/src/transformation/transformation.impl.ts","../../../../../proc7ts/push-iterator/src/transformation/flat-map-array.ts","../../../../../proc7ts/push-iterator/src/transformation/flat-map-it.ts","../../../../../proc7ts/push-iterator/src/transformation/map-it.ts","../../../../../proc7ts/push-iterator/src/objects/over-entries.ts","../../../../../proc7ts/push-iterator/src/objects/over-keys.ts","../../../../../proc7ts/push-iterator/src/call-thru/thru-it.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterator } from './push-iterator';\n\n/**\n * A key of {@link PushIterable} iteration method.\n */\nexport const PushIterator__symbol = (/*#__PURE__*/ Symbol('push-iterator'));\n\n/**\n * An iterable implementing push iteration protocol.\n *\n * @typeParam T  Iterated elements type.\n */\nexport interface PushIterable<T> extends Iterable<T> {\n\n  /**\n   * Creates a {@link PushIterator push iterator} over elements of this iterable.\n   *\n   * @returns New push iterator instance.\n   */\n  [Symbol.iterator](): PushIterator<T>;\n\n  /**\n   * Iterates over elements of this push iterable.\n   *\n   * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n   * `true` or `false`.\n   *\n   * Calling this method with `accept` parameter is a faster alternative to creating a push iterator and iterating with\n   * it.\n   *\n   * Calling this method without arguments is the same as calling `[Symbol.iterator]()` one.\n   *\n   * @param accept  A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<T>): PushIterator<T>;\n\n}\n\nexport namespace PushIterable {\n\n  /**\n   * A signature of function conforming to push iteration protocol.\n   *\n   * Used as `PushIterable[PushIterator__symbol]` method implementation when passed to {@link makePushIterable}\n   * function.\n   *\n   * @typeParam T  Iterated elements type.\n   */\n  export type Iterate<T> =\n  /**\n   * @param accept  A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n      (this: void, accept?: PushIterator.Acceptor<T>) => PushIterator<T>;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Checks whether the given iterable conforms to {@link PushIterable push iteration protocol}.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to check.\n *\n * @returns `true` if the given `iterable` has a {@link PushIterator__symbol [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterable: Iterable<T>): iterable is PushIterable<T>;\n\n/**\n * Checks whether the given iterator conforms to {@link PushIterable push iteration protocol}.\n *\n * @typeParam T  Iterated elements type.\n * @param iterator  An iterator to check.\n *\n * @returns `true` if the given `iterator` has a {@link PushIterator__symbol [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterator: Iterator<T>): iterator is PushIterator<T>;\n\nexport function isPushIterable<T>(iterable: Iterable<T> | Iterator<T>): iterable is PushIterator<T> {\n  return !!(iterable as any)[PushIterator__symbol];\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterator over elements of the given push `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  A push iterable to construct iterator of.\n *\n * @returns Push iterator.\n */\nexport function iteratorOf<T>(iterable: PushIterable<T>): PushIterator<T>;\n\n/**\n * Creates an iterable iterator over elements of the given `iterable` supporting iterable iteration.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  A push iterable to construct iterator of.\n *\n * @returns Iterable iterator.\n */\nexport function iteratorOf<T>(iterable: { [Symbol.iterator](): IterableIterator<T> }): IterableIterator<T>;\n\n/**\n * Creates iterator over elements of the given `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to construct iterator of.\n *\n * @returns Either push or raw iterator.\n */\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T>;\n\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterable implementation.\n *\n * @typeParam T  Iterated elements type.\n * @param iterate  A function iterating over iterable elements conforming to {@link PushIterable.Iterate} requirements.\n *\n * @returns New push iterable instance performing iteration by `forNext` function.\n */\nexport function makePushIterable<T>(iterate: PushIterable.Iterate<T>): PushIterable<T> {\n  return {\n    [Symbol.iterator]: PushIterable$iterator,\n    [PushIterator__symbol]: iterate,\n  };\n}\n\n/**\n * @internal\n */\nfunction PushIterable$iterator<T>(this: PushIterable<T>): PushIterator<T> {\n  return this[PushIterator__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `!iterable[PushIterator__symbol](accept).isOver()`.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  A push iterable to iterate elements of.\n * @param accept  A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function pushIterated<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  return !iterable[PushIterator__symbol](accept).isOver();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { pushIterated } from './push-iterated';\n\n/**\n * Creates a push iterator implementation.\n *\n * @typeParam T  Iterated elements type.\n * @param forNext  A function iterating over elements conforming to push iteration protocol.\n *\n * @returns New push iterator instance performing iteration by `forNext` function.\n */\nexport function makePushIterator<T>(forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if (accept && !forNext(accept)) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n    }\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next: PushIterator$next,\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function PushIterator$iterator<T>(this: T): T {\n  return this;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$next<T>(this: PushIterator<T>): IteratorResult<T> {\n  for (; ;) {\n\n    let result: IteratorYieldResult<T> | undefined;\n    const over = !pushIterated(\n        this,\n        value => {\n          result = { value };\n          return true;\n        },\n    );\n\n    if (result) {\n      return result;\n    }\n    if (over) {\n      return { done: true } as IteratorReturnResult<T>;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function PushIterator$noNext<T>(): IteratorReturnResult<T> {\n  return { done: true } as IteratorReturnResult<T>;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$dontIterate<T>(\n    _accept?: PushIterator.Acceptor<T>, // unused parameter to prevent deoptimization\n): void {\n  /* do not iterate */\n}\n\n/**\n * @internal\n */\nexport const emptyPushIterator: PushIterator<any> & PushIterable<any> = {\n  [Symbol.iterator]: PushIterator$iterator,\n  [PushIterator__symbol](\n      _accept, // unused parameter to prevent deoptimization\n  ) {\n    return this;\n  },\n  next: () => ({ done: true } as IteratorReturnResult<unknown>),\n  isOver: () => true,\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over the head elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `iterable[PushIterator__symbol](accept)`.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  A push iterable to iterate elements of.\n * @param accept  A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function pushHead<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return iterable[PushIterator__symbol](accept);\n}\n","import { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport {\n  emptyPushIterator,\n  PushIterator$dontIterate,\n  PushIterator$iterator,\n  PushIterator$noNext,\n} from './make-push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverArray<T>(array: ArrayLike<T>): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= array.length) {\n        return false;\n      }\n      for (; ;) {\n\n        const goOn = accept(array[i++]);\n\n        if (i >= array.length || goOn === false) {\n          return false;\n        }\n        if (goOn === true) {\n          return true;\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return emptyPushIterator;\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      if (i < array.length) {\n        return { value: array[i++] };\n      }\n\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n\n      return { done: true } as IteratorReturnResult<T>;\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { iterateOverArray } from '../base/array-iterator.impl';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable push iterable} over elements of array-like structure.\n *\n * @typeParam T  Array elements type.\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns New push iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): PushIterable<T> {\n  return makePushIterable<T>(iterateOverArray(array));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushIterated} function, this one accepts any iterable instance.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to iterate elements of.\n * @param accept  A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function itsIterated<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  if (isPushIterable(iterable)) {\n    return pushIterated(iterable, accept);\n  }\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushIterated(it, accept);\n  }\n\n  for (; ;) {\n\n    const next = it.next();\n\n    if (next.done) {\n      return false;\n    }\n\n    const status = accept(next.value);\n\n    if (typeof status === 'boolean') {\n      return status;\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  itsIterated(iterable, element => { action(element); });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * @internal\n */\nconst itsElements$defaultConverter = <T, R>(element: T): R => element as unknown as R;\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable.\n *\n * Calling this function result to the same result as calling `Array.from(source)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T  Iterated elements type.\n * @param source  A source iterable to copy elements from.\n *\n * @returns New array of `source` elements.\n */\nexport function itsElements<T>(source: Iterable<T>): T[];\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable converted by the given\n * converter function.\n *\n * Calling this function result to the same result as calling `Array.from(source, convert)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T  Iterated elements type.\n * @typeParam R  Resulting array elements type.\n * @param source  A source iterable to convert elements from.\n * @param convert  A function that produces an element of result array, taking element of `source` iterable as the only\n * parameter.\n *\n * @returns New array of elements converted from `source` ones.\n */\nexport function itsElements<T, R>(source: Iterable<T>, convert: (this: void, element: T) => R): R[];\n\nexport function itsElements<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => R = itsElements$defaultConverter,\n): R[] {\n  if (isPushIterable(source)) {\n    return pushedElements(source, convert);\n  }\n\n  const it = iteratorOf(source);\n\n  return isPushIterable(it) ? pushedElements(it, convert) : Array.from(source, convert);\n}\n\n/**\n * @internal\n */\nfunction pushedElements<T, R>(\n    it: PushIterable<T>,\n    convert: (this: void, element: T) => R,\n): R[] {\n\n  const result: R[] = [];\n\n  pushIterated(it, element => { result.push(convert(element)); });\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(\n    iterable: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): boolean {\n\n  let allMatch = true;\n\n  itsIterated(\n      iterable,\n      element => {\n        allMatch = !!test(element);\n        if (!allMatch) {\n          return false;\n        }\n        return;\n      },\n  );\n\n  return allMatch;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Extracts the first element of the given `iterable`, if any.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  if (isPushIterable(iterable)) {\n    return pushedFirst(iterable);\n  }\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? pushedFirst(it) : rawFirst(it);\n}\n\n/**\n * @internal\n */\nfunction pushedFirst<T>(it: PushIterable<T>): T | undefined {\n\n  let first: T | undefined;\n\n  pushIterated(\n      it,\n      element => {\n        first = element;\n        return false;\n      },\n  );\n\n  return first;\n}\n\n/**\n * @internal\n */\nfunction rawFirst<T>(it: Iterator<T>): T | undefined {\n\n  const result = it.next();\n\n  return result.done ? undefined : result.value;\n}\n","import { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from './make-push-iterator';\n\n/**\n * @internal\n */\nexport function toPushIterator<T>(it: Iterator<T>, forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if ((over = !!accept && !forNext(accept))) {\n      iterate = PushIterator$dontIterate;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      next = PushIterator$noNext;\n    }\n  };\n  let next = (): IteratorResult<T> => {\n\n    const res = it.next();\n\n    if (res.done) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n    }\n\n    return res;\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next() {\n      return next();\n    },\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function rawIteratorPusher<T>(it: Iterator<T>): PushIterator.Pusher<T> {\n  return accept => {\n    for (; ;) {\n\n      const res = it.next();\n\n      if (res.done) {\n        return false;\n      }\n\n      const status = accept(res.value);\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushHead } from '../base';\nimport { iterateOverArray } from '../base/array-iterator.impl';\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushHead} function, this one accepts any iterable instance.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to iterate elements of.\n * @param accept  A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function itsHead<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  if (isPushIterable(iterable)) {\n    return pushHead(iterable, accept);\n  }\n  if (Array.isArray(iterable)) {\n    return arrayHead(iterable, accept);\n  }\n  return rawIterableHead(iterable, accept);\n}\n\n/**\n * @internal\n */\nfunction arrayHead<T>(array: ArrayLike<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return array.length ? iterateOverArray(array)(accept) : emptyPushIterator;\n}\n\n/**\n * @internal\n */\nfunction rawIterableHead<T>(\n    iterable: Iterable<T>,\n    accept: PushIterator.Acceptor<T>,\n): PushIterator<T> {\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushHead(it, accept);\n  }\n\n  const forEach = rawIteratorPusher(it);\n\n  return forEach(accept) ? toPushIterator(it, forEach) : emptyPushIterator;\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeParam T  Iterated elements type.\n * @typeParam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: R, element: T) => R,\n    initialValue: R,\n): R {\n\n  let reduced = initialValue;\n\n  itsIterated(iterable, element => { reduced = reducer(reduced, element); });\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Returns a {@link PushIterator push iterable iterator} without elements.\n *\n * @typeParam T  Iterated elements type.\n *\n * @returns Empty push iterable and push iterator instance.\n */\nexport function overNone<T>(): PushIterable<T> & PushIterator<T> {\n  return emptyPushIterator;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, makePushIterable } from '../base';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable push iterable} over elements of iterator created by the given function.\n *\n * @typeParam T  Iterated elements type.\n * @param iterate  A function creating new iterator.\n *\n * @returns New push iterable over elements of created iterator.\n */\nexport function overIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable<T> {\n  return makePushIterable(iterateOverRawIterator(iterate));\n}\n\n/**\n * @internal\n */\nfunction iterateOverRawIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable.Iterate<T> {\n  return accept => {\n\n    const it = iterate();\n\n    if (isPushIterable(it)) {\n      return it[PushIterator__symbol](accept);\n    }\n\n    const forNext = rawIteratorPusher(it);\n\n    return accept && !forNext(accept) ? overNone() : toPushIterator(it, forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable, makePushIterator } from '../base';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { overIterable } from './over-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable push iterable} over elements of other iterables.\n *\n * @typeParam T  Iterated elements type.\n * @param sources  Source iterables to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `sources`.\n */\nexport function overElementsOf<T>(...sources: readonly Iterable<T>[]): PushIterable<T> {\n  return sources.length > 1\n      ? makePushIterable(iterateOverSubElements(sources))\n      : (sources.length\n          ? overIterable(sources[0])\n          : overNone());\n}\n\n/**\n * @internal\n */\nfunction iterateOverSubElements<T>(sources: readonly Iterable<T>[]): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let src: Iterable<T> = sources[0];\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        let status: boolean | void;\n        const srcTail = itsHead(src, element => status = accept(element));\n\n        if (srcTail.isOver()) {\n          if (++i >= sources.length) {\n            return false;\n          }\n\n          src = sources[i];\n        } else {\n          src = srcTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { iteratorOf } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { overArray } from './over-array';\nimport { overIterator } from './over-iterator';\n\n/**\n * Creates a {@link PushIterable push iterable} over elements of the given raw iterable.\n *\n * @typeParam T  Iterated elements type.\n * @param iterable  An iterable to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `iterable`.\n */\nexport function overIterable<T>(iterable: Iterable<T>): PushIterable<T> {\n  return Array.isArray(iterable)\n      ? overArray<T>(iterable)\n      : overIterator(() => iteratorOf(iterable));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { PushIterator$iterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable push iterable} over one value.\n *\n * @typeParam T  Iterated element value type.\n * @param value  A value to iterate over.\n *\n * @returns New push iterable over the given value.\n */\nexport function overOne<T>(value: T): PushIterable<T> {\n  return makePushIterable(iterateOverOneValue(value));\n}\n\n/**\n * @internal\n */\nfunction iterateOverOneValue<T>(value: T): PushIterable.Iterate<T> {\n  return accept => {\n    if (accept) {\n      accept(value);\n      return overNone();\n    }\n\n    let over = false;\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        if (over) {\n          return overNone();\n        }\n        if (accept) {\n          over = true;\n          accept(value);\n          return overNone();\n        }\n        return this;\n      },\n      next() {\n        if (over) {\n          return { done: over } as IteratorReturnResult<undefined>;\n        }\n\n        over = true;\n\n        return { value };\n      },\n      isOver: () => over,\n    };\n\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from '../base/make-push-iterator';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable push iterable} with all `array` elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T  A type of array elements.\n * @param array  A source array.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\n/**\n * Creates a {@link PushIterable push iterable} with all `array` elements extending the given type.\n *\n * @typeParam T  A type of array elements.\n * @typeParam R  Target type.\n * @param array  A source array.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T, R extends T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => element is R,\n): PushIterable<R>;\n\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(iterateOverFilteredArray(array, test));\n}\n\n/**\n * @internal\n */\nfunction iterateOverFilteredArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n        if (i >= array.length) {\n          return false;\n        }\n\n        const value = array[i++];\n\n        if (test(value)) {\n\n          const status = accept(value);\n\n          if (typeof status === 'boolean') {\n            return status;\n          }\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return overNone();\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      for (; ;) {\n        if (i >= array.length) {\n          over = true;\n          iterate = PushIterator$dontIterate;\n          next = PushIterator$noNext;\n          return { done: true } as IteratorReturnResult<T>;\n        }\n\n        const value = array[i++];\n\n        if (test(value)) {\n          return { value };\n        }\n      }\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable push iterable} with all `source` iterable elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\n/**\n * Creates a {@link PushIterable push iterable} with all `source` iterable elements extending the given type.\n *\n * @typeParam T  A type of source elements.\n * @typeParam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T, R extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is R,\n): PushIterable<R>;\n\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? filterPusher(source, test) : filterRawPusher(source, test);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction filterPusher<T>(\n    source: PushIterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n  return accept => {\n\n    const tail = pushHead(\n        source,\n        element => {\n          if (test(element)) {\n            return accept(element);\n          }\n          return;\n        },\n    );\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction filterRawPusher<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return filterPusher(it, test);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const value = next.value;\n\n      if (test(value)) {\n\n        const status = accept(value);\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    }\n  };\n}\n","/**\n * @internal\n */\nexport const flatMapIt$defaultConverter = <T, R>(element: T): Iterable<R> => element as unknown as Iterable<R>;\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable, makePushIterator } from '../base';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { flatMapIt$defaultConverter } from './transformation.impl';\n\n/**\n * Flattens the source `array` of iterables into new {@link PushIterable push iterable}.\n *\n * Calling this function is the same as calling `flatMapArray(source, element => element)`.\n *\n * @typeParam T  A type of converted elements.\n * @param array  A source array-like instance of iterables.\n *\n * @returns New push iterable with each element of `array` being the flattened.\n */\nexport function flatMapArray<T>(array: ArrayLike<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the source `array` using a mapping function, then flattens the result into new\n * {@link PushIterable push iterable}.\n *\n * @typeParam T  A type of array elements.\n * @typeParam R  A type of converted elements.\n * @param array  A source array-like instance of iterables.\n * @param convert  A function that produces new iterable, taking array element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapArray<T, R>(\n    array: ArrayLike<T>,\n    convert: (this: void, element: T) => Iterable<R>,\n): PushIterable<R>;\n\nexport function flatMapArray<T, R>(\n    array: ArrayLike<T>,\n    convert: (this: void, element: T) => Iterable<R> = flatMapIt$defaultConverter,\n): PushIterable<R> {\n  return makePushIterable(iterateOverFlattenedArray(array, convert));\n}\n\n/**\n * @internal\n */\nfunction iterateOverFlattenedArray<T, R>(\n    array: ArrayLike<T>,\n    convert: (this: void, element: T) => Iterable<R>,\n): PushIterable.Iterate<R> {\n  return accept => {\n\n    let i = 0;\n    let subs: Iterable<R> | undefined;\n\n    const forNext = (accept: PushIterator.Acceptor<R>): boolean => {\n      if (i >= array.length) {\n        return false;\n      }\n      if (!subs) {\n        subs = convert(array[i]);\n      }\n\n      for (; ;) {\n\n        let status: boolean | void;\n        const subsTail: PushIterator<R> = itsHead<R>(subs, element => status = accept(element));\n\n        if (subsTail.isOver()) {\n          if (++i >= array.length) {\n            return false;\n          }\n          subs = convert(array[i]);\n        } else {\n          subs = subsTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { flatMapIt$defaultConverter } from './transformation.impl';\n\n/**\n * Flattens the source iterable of iterables into new {@link PushIterable push iterable}.\n *\n * Calling this function is the same as calling `flatMapIt(source, element => element)`.\n *\n * @typeParam T  A type of converted elements.\n * @param source  A source iterable of iterables.\n *\n * @returns New push iterable with each element of `source` being the flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into new\n * {@link PushIterable push iterable}.\n *\n * @typeParam T  A type of source elements.\n * @typeParam R  A type of converted elements.\n * @param source  A source iterable of iterables.\n * @param convert  A function that produces new iterable, taking the source element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R>,\n): PushIterable<R>;\n\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R> = flatMapIt$defaultConverter,\n): PushIterable<R> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? flatMapPusher(source, convert) : flatMapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction flatMapPusher<T, R>(\n    source: PushIterable<T>,\n    convert: (this: void, element: T) => Iterable<R>,\n): PushIterator.Pusher<R> {\n\n  let subs: Iterable<R> | undefined;\n  let lastSrc = false;\n\n  return accept => {\n    for (; ;) {\n      while (!subs) {\n\n        const sourceTail = pushHead(source, src => {\n          subs = convert(src);\n          return true;\n        });\n\n        source = sourceTail;\n\n        if (sourceTail.isOver()) {\n          if (!subs) {\n            return false;\n          }\n          lastSrc = true;\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<R> = itsHead(subs, element => status = accept(element));\n\n      if (subsTail.isOver()) {\n        subs = undefined;\n        if (lastSrc) {\n          return false;\n        }\n      } else {\n        subs = subsTail;\n      }\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapRawPusher<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R>,\n): PushIterator.Pusher<R> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return flatMapPusher(it, convert);\n  }\n\n  let subs: Iterable<R> | undefined;\n\n  return accept => {\n    for (; ;) {\n      if (!subs) {\n\n        const next = it.next();\n\n        if (next.done) {\n          return false;\n        }\n\n        subs = convert(next.value);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<R> = itsHead(subs, element => status = accept(element));\n\n      subs = subsTail.isOver() ? undefined : subsTail;\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable push iterable} with the results of calling a provided function on every element of the\n * `source` iterable.\n *\n * @typeParam T  A type of source elements.\n * @typeParam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nexport function mapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => R,\n): PushIterable<R> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? mapPusher(source, convert) : mapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction mapPusher<R, T>(\n    source: PushIterable<T>,\n    convert: (this: void, element: T) => R,\n): PushIterator.Pusher<R> {\n  return accept => {\n\n    const tail = pushHead(source, element => accept(convert(element)));\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction mapRawPusher<R, T>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => R,\n): PushIterator.Pusher<R> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return mapPusher(it, convert);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const status = accept(convert(next.value));\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport { mapIt } from '../transformation';\nimport type { ObjectEntry } from './object-entry';\nimport { overKeys } from './over-keys';\n\n/**\n * Creates a {@link PushIterable push iterable} over the property key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam T  Object type.\n *\n * @param source  An object to select keys and values from.\n *\n * @returns New push iterable of object property entries.\n */\nexport function overEntries<T extends object>(source: T): PushIterable<ObjectEntry<T>> {\n  return mapIt(\n      overKeys(source),\n      key => [key, source[key]],\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { overArray } from '../construction';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable push iterable} over keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam T  Source object type.\n * @param source  An object to select keys from.\n *\n * @returns New push iterable over own object keys retrieved by `Reflect.ownKeys()`.\n */\nexport function overKeys<T extends object>(source: T): PushIterable<keyof T> {\n  return overArray(Reflect.ownKeys(source) as (keyof T)[]);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator/call-thru\n */\nimport { isNextCall, NextCall__symbol } from '@proc7ts/call-thru';\nimport { overOne } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport { flatMapArray, flatMapIt } from '../transformation';\nimport type { IterableCallChain } from './iterable-call-chain';\n\ntype Args<TReturn> = IterableCallChain.Args<TReturn>;\ntype Out<TReturn> = IterableCallChain.Out<TReturn>;\n\n/**\n * Passes each element of the given iterable trough the {@link IterableCallChain chain of transformation passes}.\n *\n * The passes are preformed by `@proc7ts/call-thru`.\n *\n * @returns An push iterable of transformed elements.\n */\nexport function thruIt<\n    T, TReturn1\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n): PushIterable<Out<TReturn1>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n): PushIterable<Out<TReturn2>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n): PushIterable<Out<TReturn3>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    TArgs11 extends Args<TReturn10>, TReturn11,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n    pass11: (this: void, ...args: TArgs11) => TReturn11,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    TArgs11 extends Args<TReturn10>, TReturn11,\n    TArgs12 extends Args<TReturn11>, TReturn12,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n    pass11: (this: void, ...args: TArgs11) => TReturn11,\n    pass12: (this: void, ...args: TArgs12) => TReturn12,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<\n    T, TReturn1,\n    TArgs2 extends Args<TReturn1>, TReturn2,\n    TArgs3 extends Args<TReturn2>, TReturn3,\n    TArgs4 extends Args<TReturn3>, TReturn4,\n    TArgs5 extends Args<TReturn4>, TReturn5,\n    TArgs6 extends Args<TReturn5>, TReturn6,\n    TArgs7 extends Args<TReturn6>, TReturn7,\n    TArgs8 extends Args<TReturn7>, TReturn8,\n    TArgs9 extends Args<TReturn8>, TReturn9,\n    TArgs10 extends Args<TReturn9>, TReturn10,\n    TArgs11 extends Args<TReturn10>, TReturn11,\n    TArgs12 extends Args<TReturn11>, TReturn12,\n    TArgs13 extends Args<TReturn12>, TReturn13,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => TReturn1,\n    pass2: (this: void, ...args: TArgs2) => TReturn2,\n    pass3: (this: void, ...args: TArgs3) => TReturn3,\n    pass4: (this: void, ...args: TArgs4) => TReturn4,\n    pass5: (this: void, ...args: TArgs5) => TReturn5,\n    pass6: (this: void, ...args: TArgs6) => TReturn6,\n    pass7: (this: void, ...args: TArgs7) => TReturn7,\n    pass8: (this: void, ...args: TArgs8) => TReturn8,\n    pass9: (this: void, ...args: TArgs9) => TReturn9,\n    pass10: (this: void, ...args: TArgs10) => TReturn10,\n    pass11: (this: void, ...args: TArgs11) => TReturn11,\n    pass12: (this: void, ...args: TArgs12) => TReturn12,\n    pass13: (this: void, ...args: TArgs13) => TReturn13,\n): PushIterable<Out<TReturn4>>;\n\nexport function thruIt<T, TReturn>(\n    it: Iterable<T>,\n    ...passes: ((...args: any[]) => any)[]\n): PushIterable<TReturn> {\n\n  const chain = (outcome: PushIterable<any>[], index: number): IterableCallChain => {\n\n    const lastPass = index >= passes.length;\n\n    ++index;\n\n    const pass = index < passes.length ? passes[index] : () => { /* empty pass */ };\n    const handleResult = (outcome: PushIterable<any>[], callResult: any, arg: any): void => {\n      if (isNextCall(callResult)) {\n        callResult[NextCall__symbol](chain(outcome, index), pass);\n      } else if (lastPass) {\n        outcome.push(overOne(arg));\n      } else {\n        chain(outcome, index).pass(pass, callResult);\n      }\n    };\n\n    return ({\n      call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n        handleResult(outcome, fn(...args), args);\n      },\n      pass<A>(fn: (arg: A) => any, arg: A): void {\n        handleResult(outcome, fn(arg), arg);\n      },\n      skip() {/* skip item */},\n      iterate<I>(fn: (this: void, arg: I) => void, iterable: Iterable<I>): void {\n        outcome.push(flatMapIt(\n            iterable,\n            item => {\n\n              const itemOutcome: PushIterable<any>[] = [];\n\n              handleResult(itemOutcome, fn(item), item);\n\n              return flatMapArray(itemOutcome);\n            },\n        ));\n      },\n    });\n  };\n\n  const finalOutcome: PushIterable<any>[] = [];\n\n  chain(finalOutcome, 0).iterate(passes[0], it);\n\n  return flatMapArray<TReturn>(finalOutcome);\n}\n"],"names":["PushIterator__symbol","Symbol","isPushIterable","iterable","iteratorOf","iterator","makePushIterable","iterate","[object Object]","PushIterable$iterator","this","pushIterated","accept","isOver","makePushIterator","forNext","over","PushIterator$dontIterate","PushIterator$iterator","next","PushIterator$next","result","value","done","PushIterator$noNext","_accept","emptyPushIterator","pushHead","iterateOverArray","array","i","length","goOn","overArray","itsIterated","it","status","itsEach","action","element","itsElements$defaultConverter","itsElements","source","convert","pushedElements","Array","from","push","itsEvery","test","allMatch","itsFirst","pushedFirst","undefined","rawFirst","first","toPushIterator","res","rawIteratorPusher","itsHead","isArray","arrayHead","forEach","rawIterableHead","itsReduction","reducer","initialValue","reduced","overNone","overIterator","iterateOverRawIterator","overElementsOf","sources","src","srcTail","iterateOverSubElements","overOne","iterateOverOneValue","filterArray","iterateOverFilteredArray","filterIt","filterPusher","filterRawPusher","tail","flatMapIt$defaultConverter","flatMapArray","subs","subsTail","iterateOverFlattenedArray","flatMapIt","flatMapPusher","flatMapRawPusher","lastSrc","sourceTail","mapIt","mapPusher","mapRawPusher","overEntries","Reflect","ownKeys","overKeys","key","thruIt","passes","chain","outcome","index","lastPass","pass","handleResult","callResult","arg","isNextCall","NextCall__symbol","fn","args","item","itemOutcome","finalOutcome"],"mappings":"yDASaA,EAAsCC,OAAO,0BCqB1CC,EAAkBC,GAChC,QAAUA,EAAiBH,YCYbI,EAAcD,GAC5B,OAAOA,EAASF,OAAOI,qBC7BTC,EAAoBC,GAClC,MAAO,CACLC,CAACP,OAAOI,UAAWI,EACnBD,CAACR,GAAuBO,GAO5B,SAASE,IACP,OAAOC,KAAKV,cCHEW,EAAgBR,EAA2BS,GACzD,OAAQT,EAASH,GAAsBY,GAAQC,kBCRjCC,EAAoBC,GAElC,IAAIC,GAAO,EACPT,EAAWK,IACTA,IAAWG,EAAQH,KACrBI,GAAO,EACPT,EAAUU,IAId,MAAO,CACLT,CAACP,OAAOI,UAAWa,EACnBV,CAACR,GAAsBY,GAErB,OADAL,EAAQK,GACDF,MAETS,KAAMC,EACNP,OAAQ,IAAMG,YAOFE,IACd,OAAOR,cAMOU,IACd,OAAU,CAER,IAAIC,EACJ,MAAML,GAAQL,EACVD,MACAY,IACED,EAAS,CAAEC,MAAAA,IACJ,KAIb,GAAID,EACF,OAAOA,EAET,GAAIL,EACF,MAAO,CAAEO,MAAM,aAQLC,IACd,MAAO,CAAED,MAAM,YAMDN,EACZQ,IAQG,MAAMC,EAA2D,CACtElB,CAACP,OAAOI,UAAWa,EACnBV,CAACR,GACGyB,GAEF,OAAOf,MAETS,KAAM,MAASI,MAAM,IACrBV,OAAQ,KAAM,YCxEAc,EAAYxB,EAA2BS,GACrD,OAAOT,EAASH,GAAsBY,YCZxBgB,EAAoBC,GAClC,OAAOjB,IAEL,IAAIkB,EAAI,EACR,MAAMf,EAAWH,IACf,GAAIkB,GAAKD,EAAME,OACb,OAAO,EAET,OAAU,CAER,MAAMC,EAAOpB,EAAOiB,EAAMC,MAE1B,GAAIA,GAAKD,EAAME,SAAmB,IAATC,EACvB,OAAO,EAET,IAAa,IAATA,EACF,OAAO,IAKb,GAAIpB,IAAWG,EAAQH,GACrB,OAAOc,EAGT,IAAIV,GAAO,EACPT,EAAWK,IACTA,IAAWG,EAAQH,KACrBI,GAAO,EACPT,EAAUU,EAEVE,EAAOK,IAGPL,EAAO,IACLW,EAAID,EAAME,OACL,CAAET,MAAOO,EAAMC,OAGxBd,GAAO,EACPT,EAAUU,EACVE,EAAOK,EAEA,CAAED,MAAM,IAGjB,MAAO,CACLf,CAACP,OAAOI,UAAWa,EACnBV,CAACR,GAAsBY,GAErB,OADAL,EAAQK,GACDF,MAETS,KAAM,IAAMA,IACZN,OAAQ,IAAMG,aCjDJiB,EAAaJ,GAC3B,OAAOvB,EAAoBsB,EAAiBC,aCM9BK,EAAe/B,EAAuBS,GACpD,GAAIV,EAAeC,GACjB,OAAOQ,EAAaR,EAAUS,GAGhC,MAAMuB,EAAK/B,EAAWD,GAEtB,GAAID,EAAeiC,GACjB,OAAOxB,EAAawB,EAAIvB,GAG1B,OAAU,CAER,MAAMO,EAAOgB,EAAGhB,OAEhB,GAAIA,EAAKI,KACP,OAAO,EAGT,MAAMa,EAASxB,EAAOO,EAAKG,OAE3B,GAAsB,kBAAXc,EACT,OAAOA,YC/BGC,EAAWlC,EAAuBmC,GAChDJ,EAAY/B,GAAUoC,IAAaD,EAAOC,MCL5C,MAAMC,EAAsCD,GAAkBA,WAgC9CE,EACZC,EACAC,EAAyCH,GAE3C,GAAItC,EAAewC,GACjB,OAAOE,EAAeF,EAAQC,GAGhC,MAAMR,EAAK/B,EAAWsC,GAEtB,OAAOxC,EAAeiC,GAAMS,EAAeT,EAAIQ,GAAWE,MAAMC,KAAKJ,EAAQC,GAM/E,SAASC,EACLT,EACAQ,GAGF,MAAMtB,EAAc,GAIpB,OAFAV,EAAawB,GAAII,IAAalB,EAAO0B,KAAKJ,EAAQJ,OAE3ClB,WClDO2B,EACZ7C,EACA8C,GAGF,IAAIC,GAAW,EAaf,OAXAhB,EACI/B,GACAoC,IAEE,GADAW,IAAaD,EAAKV,IACbW,EACH,OAAO,KAMRA,WCpBOC,EAAYhD,GAC1B,GAAID,EAAeC,GACjB,OAAOiD,EAAYjD,GAGrB,MAAMgC,EAAK/B,EAAWD,GAEtB,OAAOD,EAAeiC,GAAMiB,EAAYjB,GAwB1C,SAAqBA,GAEnB,MAAMd,EAASc,EAAGhB,OAElB,OAAOE,EAAOE,UAAO8B,EAAYhC,EAAOC,MA5BMgC,CAASnB,GAMzD,SAASiB,EAAejB,GAEtB,IAAIoB,EAUJ,OARA5C,EACIwB,GACAI,IACEgB,EAAQhB,GACD,KAINgB,WCjCOC,EAAkBrB,EAAiBpB,GAEjD,IAAIC,GAAO,EACPT,EAAWK,KACRI,IAASJ,IAAWG,EAAQH,MAC/BL,EAAUU,EAEVE,EAAOK,IAGPL,EAAO,KAET,MAAMsC,EAAMtB,EAAGhB,OAQf,OANIsC,EAAIlC,OACNP,GAAO,EACPT,EAAUU,EACVE,EAAOK,GAGFiC,GAGT,MAAO,CACLjD,CAACP,OAAOI,UAAWa,EACnBV,CAACR,GAAsBY,GAErB,OADAL,EAAQK,GACDF,MAETS,KAAI,IACKA,IAETN,OAAQ,IAAMG,YAOF0C,EAAqBvB,GACnC,OAAOvB,IACL,OAAU,CAER,MAAM6C,EAAMtB,EAAGhB,OAEf,GAAIsC,EAAIlC,KACN,OAAO,EAGT,MAAMa,EAASxB,EAAO6C,EAAInC,OAE1B,GAAsB,kBAAXc,EACT,OAAOA,aCjCCuB,EAAWxD,EAAuBS,GAChD,OAAIV,EAAeC,GACVwB,EAASxB,EAAUS,GAExBiC,MAAMe,QAAQzD,GASpB,SAAsB0B,EAAqBjB,GACzC,OAAOiB,EAAME,OAASH,EAAiBC,EAAjBD,CAAwBhB,GAAUc,EAT/CmC,CAAU1D,EAAUS,GAe/B,SACIT,EACAS,GAGF,MAAMuB,EAAK/B,EAAWD,GAEtB,GAAID,EAAeiC,GACjB,OAAOR,EAASQ,EAAIvB,GAGtB,MAAMkD,EAAUJ,EAAkBvB,GAElC,OAAO2B,EAAQlD,GAAU4C,EAAerB,EAAI2B,GAAWpC,EA1BhDqC,CAAgB5D,EAAUS,YCdnBoD,EACZ7D,EACA8D,EACAC,GAGF,IAAIC,EAAUD,EAId,OAFAhC,EAAY/B,GAAUoC,IAAa4B,EAAUF,EAAQE,EAAS5B,MAEvD4B,WCdOC,IACd,OAAO1C,WCEO2C,EAAgB9D,GAC9B,OAAOD,EAMT,SAAmCC,GACjC,OAAOK,IAEL,MAAMuB,EAAK5B,IAEX,GAAIL,EAAeiC,GACjB,OAAOA,EAAGnC,GAAsBY,GAGlC,MAAMG,EAAU2C,EAAkBvB,GAElC,OAAOvB,IAAWG,EAAQH,GAAUwD,IAAaZ,EAAerB,EAAIpB,IAjB9CuD,CAAuB/D,aCAjCgE,KAAqBC,GACnC,OAAOA,EAAQzC,OAAS,EAClBzB,EASR,SAAmCkE,GACjC,OAAO5D,IAEL,IAAIkB,EAAI,EACJ2C,EAAmBD,EAAQ,GAE/B,MAAMzD,EAAWH,IACf,OAAU,CAGR,IAAIwB,EACJ,MAAMsC,EAAUf,EAAQc,GAAKlC,GAAWH,EAASxB,EAAO2B,KAExD,GAAImC,EAAQ7D,SAAU,CACpB,KAAMiB,GAAK0C,EAAQzC,OACjB,OAAO,EAGT0C,EAAMD,EAAQ1C,QAEd2C,EAAMC,EAGR,GAAsB,kBAAXtC,EACT,OAAOA,IAKb,OAAOxB,IAAWG,EAAQH,GAAUwD,IAAatD,EAAiBC,IAtC7C4D,CAAuBH,IACvCA,EAAQzC,QCLe5B,EDMPqE,EAAQ,GCLxB3B,MAAMe,QAAQzD,GACf8B,EAAa9B,GACbkE,GAAa,IAAMjE,EAAWD,MDI1BiE,QCPoBjE,WCChByE,EAAWtD,GACzB,OAAOhB,EAMT,SAAgCgB,GAC9B,OAAOV,IACL,GAAIA,EAEF,OADAA,EAAOU,GACA8C,IAGT,IAAIpD,GAAO,EAEX,MAAO,CACLR,CAACP,OAAOI,UAAWa,EACnBV,CAACR,GAAsBY,GACrB,OAAII,EACKoD,IAELxD,GACFI,GAAO,EACPJ,EAAOU,GACA8C,KAEF1D,MAETS,KAAI,IACEH,EACK,CAAEO,KAAMP,IAGjBA,GAAO,EAEA,CAAEM,MAAAA,IAEXT,OAAQ,IAAMG,IArCM6D,CAAoBvD,aC0B9BwD,EACZjD,EACAoB,GAEF,OAAO3C,EAMT,SACIuB,EACAoB,GAEF,OAAOrC,IAEL,IAAIkB,EAAI,EACR,MAAMf,EAAWH,IACf,OAAU,CACR,GAAIkB,GAAKD,EAAME,OACb,OAAO,EAGT,MAAMT,EAAQO,EAAMC,KAEpB,GAAImB,EAAK3B,GAAQ,CAEf,MAAMc,EAASxB,EAAOU,GAEtB,GAAsB,kBAAXc,EACT,OAAOA,KAMf,GAAIxB,IAAWG,EAAQH,GACrB,OAAOwD,IAGT,IAAIpD,GAAO,EACPT,EAAWK,IACTA,IAAWG,EAAQH,KACrBI,GAAO,EACPT,EAAUU,EAEVE,EAAOK,IAGPL,EAAO,KACT,OAAU,CACR,GAAIW,GAAKD,EAAME,OAIb,OAHAf,GAAO,EACPT,EAAUU,EACVE,EAAOK,EACA,CAAED,MAAM,GAGjB,MAAMD,EAAQO,EAAMC,KAEpB,GAAImB,EAAK3B,GACP,MAAO,CAAEA,MAAAA,KAKf,MAAO,CACLd,CAACP,OAAOI,UAAWa,EACnBV,CAACR,GAAsBY,GAErB,OADAL,EAAQK,GACDF,MAETS,KAAM,IAAMA,IACZN,OAAQ,IAAMG,IArEM+D,CAAyBlD,EAAOoB,aCN1C+B,EACZtC,EACAO,GAEF,OAAO3C,GAAiBM,IAEtB,MAAMG,EAAUb,EAAewC,GAAUuC,EAAavC,EAAQO,GAkClE,SACIP,EACAO,GAGF,MAAMd,EAAK/B,EAAWsC,GAEtB,GAAIxC,EAAeiC,GACjB,OAAO8C,EAAa9C,EAAIc,GAG1B,OAAOrC,IACL,OAAU,CAER,MAAMO,EAAOgB,EAAGhB,OAEhB,GAAIA,EAAKI,KACP,OAAO,EAGT,MAAMD,EAAQH,EAAKG,MAEnB,GAAI2B,EAAK3B,GAAQ,CAEf,MAAMc,EAASxB,EAAOU,GAEtB,GAAsB,kBAAXc,EACT,OAAOA,KA7DyD8C,CAAgBxC,EAAQO,GAE9F,OAAOrC,IAAWG,EAAQH,GAAUwD,IAAatD,EAAiBC,MAOtE,SAASkE,EACLvC,EACAO,GAEF,OAAOrC,IAEL,MAAMuE,EAAOxD,EACTe,GACAH,IACE,GAAIU,EAAKV,GACP,OAAO3B,EAAO2B,MAQtB,OAFAG,EAASyC,GAEDA,EAAKtE,UCzEV,MAAMuE,EAAoC7C,GAA4BA,WCoC7D8C,EACZxD,EACAc,EAAmDyC,GAErD,OAAO9E,EAMT,SACIuB,EACAc,GAEF,OAAO/B,IAEL,IACI0E,EADAxD,EAAI,EAGR,MAAMf,EAAWH,IACf,GAAIkB,GAAKD,EAAME,OACb,OAAO,EAMT,IAJKuD,IACHA,EAAO3C,EAAQd,EAAMC,OAGb,CAER,IAAIM,EACJ,MAAMmD,EAA4B5B,EAAW2B,GAAM/C,GAAWH,EAASxB,EAAO2B,KAE9E,GAAIgD,EAAS1E,SAAU,CACrB,KAAMiB,GAAKD,EAAME,OACf,OAAO,EAETuD,EAAO3C,EAAQd,EAAMC,SAErBwD,EAAOC,EAGT,GAAsB,kBAAXnD,EACT,OAAOA,IAKb,OAAOxB,IAAWG,EAAQH,GAAUwD,IAAatD,EAAiBC,IA3C5CyE,CAA0B3D,EAAOc,aCJ3C8C,EACZ/C,EACAC,EAAmDyC,GAErD,OAAO9E,GAAiBM,IAEtB,MAAMG,EAAUb,EAAewC,GAAUgD,EAAchD,EAAQC,GA2DnE,SACID,EACAC,GAGF,MAAMR,EAAK/B,EAAWsC,GAEtB,GAAIxC,EAAeiC,GACjB,OAAOuD,EAAcvD,EAAIQ,GAG3B,IAAI2C,EAEJ,OAAO1E,IACL,OAAU,CACR,IAAK0E,EAAM,CAET,MAAMnE,EAAOgB,EAAGhB,OAEhB,GAAIA,EAAKI,KACP,OAAO,EAGT+D,EAAO3C,EAAQxB,EAAKG,OAItB,IAAIc,EACJ,MAAMmD,EAA4B5B,EAAQ2B,GAAM/C,GAAWH,EAASxB,EAAO2B,KAG3E,GADA+C,EAAOC,EAAS1E,cAAWwC,EAAYkC,EACjB,kBAAXnD,EACT,OAAOA,IA3F+DuD,CAAiBjD,EAAQC,GAEnG,OAAO/B,IAAWG,EAAQH,GAAUwD,IAAatD,EAAiBC,MAOtE,SAAS2E,EACLhD,EACAC,GAGF,IAAI2C,EACAM,GAAU,EAEd,OAAOhF,IACL,OAAU,CACR,MAAQ0E,GAAM,CAEZ,MAAMO,EAAalE,EAASe,GAAQ+B,IAClCa,EAAO3C,EAAQ8B,IACR,KAKT,GAFA/B,EAASmD,EAELA,EAAWhF,SAAU,CACvB,IAAKyE,EACH,OAAO,EAETM,GAAU,GAKd,IAAIxD,EACJ,MAAMmD,EAA4B5B,EAAQ2B,GAAM/C,GAAWH,EAASxB,EAAO2B,KAE3E,GAAIgD,EAAS1E,UAEX,GADAyE,OAAOjC,EACHuC,EACF,OAAO,OAGTN,EAAOC,EAGT,GAAsB,kBAAXnD,EACT,OAAOA,aC1EC0D,EACZpD,EACAC,GAEF,OAAOrC,GAAiBM,IAEtB,MAAMG,EAAUb,EAAewC,GAAUqD,EAAUrD,EAAQC,GA0B/D,SACID,EACAC,GAGF,MAAMR,EAAK/B,EAAWsC,GAEtB,GAAIxC,EAAeiC,GACjB,OAAO4D,EAAU5D,EAAIQ,GAGvB,OAAO/B,IACL,OAAU,CAER,MAAMO,EAAOgB,EAAGhB,OAEhB,GAAIA,EAAKI,KACP,OAAO,EAGT,MAAMa,EAASxB,EAAO+B,EAAQxB,EAAKG,QAEnC,GAAsB,kBAAXc,EACT,OAAOA,IAjD2D4D,CAAatD,EAAQC,GAE3F,OAAO/B,IAAWG,EAAQH,GAAUwD,IAAatD,EAAiBC,MAOtE,SAASgF,EACLrD,EACAC,GAEF,OAAO/B,IAEL,MAAMuE,EAAOxD,EAASe,GAAQH,GAAW3B,EAAO+B,EAAQJ,MAIxD,OAFAG,EAASyC,GAEDA,EAAKtE,mBC1BDoF,EAA8BvD,GAC5C,OAAOoD,WCJkCpD,GACzC,OAAOT,EAAUiE,QAAQC,QAAQzD,IDI7B0D,CAAS1D,IACT2D,GAAO,CAACA,EAAK3D,EAAO2D,eEoPVC,EACZnE,KACGoE,GAGL,MAAMC,EAAQ,CAACC,EAA8BC,KAE3C,MAAMC,EAAWD,GAASH,EAAOxE,OAI3B6E,IAFJF,EAEmBH,EAAOxE,OAASwE,EAAOG,GAAS,OAC/CG,EAAe,CAACJ,EAA8BK,EAAiBC,KAC/DC,EAAWF,GACbA,EAAWG,GAAkBT,EAAMC,EAASC,GAAQE,GAC3CD,EACTF,EAAQ1D,KAAK6B,EAAQmC,IAErBP,EAAMC,EAASC,GAAOE,KAAKA,EAAME,IAIrC,OACEtG,KAAsB0G,EAAyBC,GAC7CN,EAAaJ,EAASS,KAAMC,GAAOA,IAErC3G,KAAQ0G,EAAqBH,GAC3BF,EAAaJ,EAASS,EAAGH,GAAMA,IAEjCvG,SACAA,QAAW0G,EAAkC/G,GAC3CsG,EAAQ1D,KAAK0C,EACTtF,GACAiH,IAEE,MAAMC,EAAmC,GAIzC,OAFAR,EAAaQ,EAAaH,EAAGE,GAAOA,GAE7B/B,EAAagC,UAO1BC,EAAoC,GAI1C,OAFAd,EAAMc,EAAc,GAAG/G,QAAQgG,EAAO,GAAIpE,GAEnCkD,EAAsBiC"}