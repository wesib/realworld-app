{"version":3,"file":"context-values.bb33d989.js","sources":["../../../../../proc7ts/context-values/src/context-builder.ts","../../../../../proc7ts/context-values/src/context-key.ts","../../../../../proc7ts/context-values/src/context-key-error.ts","../../../../../proc7ts/context-values/src/context-seeders.impl.ts","../../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../../proc7ts/context-values/src/context-values.ts","../../../../../proc7ts/context-values/src/context-values.impl.ts","../../../../../proc7ts/context-values/src/context-registry.ts","../../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../../proc7ts/context-values/src/context-supply.ts","../../../../../proc7ts/context-values/src/single-context-key.ts","../../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../../proc7ts/context-values/src/updatable/context-module-dependency-error.ts","../../../../../proc7ts/context-values/src/updatable/context-module-usage.impl.ts","../../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../../proc7ts/context-values/src/updatable/context-module-key.impl.ts","../../../../../proc7ts/context-values/src/updatable/context-module.impl.ts","../../../../../proc7ts/context-values/src/updatable/context-module.ts","../../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { Supply } from '@proc7ts/primitives';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextValues } from './context-values';\n\n/**\n * A key of {@link ContextBuilder context builder} method that provides context values.\n */\nexport const ContextBuilder__symbol = (/*#__PURE__*/ Symbol('context-value-registrar'));\n\n/**\n * Context builder.\n *\n * Able to provide arbitrary context values.\n *\n * @typeParam TCtx - Supported context type.\n */\nexport interface ContextBuilder<TCtx extends ContextValues = ContextValues> {\n\n  /**\n   * Provides context values with the given registry.\n   *\n   * @param registry - A context registry to provide values with.\n   *\n   * @returns A supply instance that removes the added context value providers once cut off.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry<TCtx>): Supply;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { ContextRef } from './context-ref';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [ContextKey] instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('context-key'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by {@link ContextKey.grow} method.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same {@link seedKey} to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name - Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot - Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value slot to put the grown value into.\n *\n * An instance of the value slot is passed to {@link ContextKey.grow} method to provide the necessary context\n * and optionally accept a new value.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport type ContextValueSlot<TValue, TSrc, TSeed> =\n    | ContextValueSlot.WithFallback<TValue, TSrc, TSeed>\n    | ContextValueSlot.WithoutFallback<TValue, TSrc, TSeed>;\n\nexport namespace ContextValueSlot {\n\n  /**\n   * Base context value slot interface.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Target context.\n     */\n    readonly context: ContextValues;\n\n    /**\n     * A key to associated value with.\n     */\n    readonly key: ContextKey<TValue, TSrc, TSeed>;\n\n    /**\n     * Context value seeder.\n     */\n    readonly seeder: ContextSeeder<ContextValues, TSrc, TSeed>;\n\n    /**\n     * Context value seed.\n     */\n    readonly seed: TSeed;\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     */\n    readonly hasFallback: boolean;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     *\n     * Always `undefined` when {@link hasFallback there is no fallback}.\n     */\n    readonly or: TValue | null | undefined;\n\n    /**\n     * Insert the value into the slot.\n     *\n     * The value will be associated with key after {@link ContextKey.grow} method exit.\n     *\n     * Supersedes a previously inserted value.\n     *\n     * @param value - A value to associate with the key, or `null`/`undefined` to not associate any value.\n     */\n    insert(value: TValue | null | undefined): void;\n\n    /**\n     * Fills this slot by the given function.\n     *\n     * @param grow - A function accepting a value slot as its only parameter.\n     *\n     * @returns A value associated with target key by the given function, or `null`/`undefined` when no value\n     * associated.\n     */\n    fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined;\n\n    /**\n     * Registers a setup procedure issued when context value associated with target key.\n     *\n     * Setup will be issued at most once per context. Setup won't be issued if no value {@link insert inserted}.\n     *\n     * @param setup - Context value setup procedure.\n     */\n    setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void;\n\n  }\n\n  /**\n   * Base context value slot with fallback value.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface WithFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `true`\n     */\n    readonly hasFallback: true;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     */\n    readonly or: TValue | null | undefined;\n\n  }\n\n  export interface WithoutFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `false`\n     */\n    readonly hasFallback: false;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Always `undefined`.\n     */\n    readonly or: undefined;\n\n  }\n\n}\n\n/**\n * Context value setup procedure signature.\n *\n * A function with this signature can be passed to {@link ContextValueSlot.Base.setup} method to be issued when\n * the value associated with target key.\n */\nexport type ContextValueSetup<TValue, TSrc, TSeed> =\n/**\n * @param key - A key the value associated with.\n * @param context - Target context the value associated with.\n * @param registry - A registry of context value providers. This context is shared among all contexts\n * {@link ContextRegistry.newValues created} by it.\n */\n    (\n        this: void,\n        {\n          key,\n          context,\n          registry,\n        }: {\n          key: ContextKey<TValue, TSrc, TSeed>;\n          context: ContextValues;\n          registry: ContextRegistry;\n        }\n    ) => void;\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TKey - Context key type.\n */\nexport type ContextKeyDefault<TValue, TKey extends ContextKey<unknown, unknown>> =\n/**\n * @param context - Target context.\n * @param key - Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: TKey) => TValue | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key - A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx - Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key - Missing value key.\n   * @param message - Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","import type { ContextKey, ContextSeedKey } from './context-key';\nimport type { ContextSeeder, ContextSeeds } from './context-seeder';\nimport type { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport type SeedIssuer<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n  seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n  factory: (this: void, context: TCtx) => TSeed,\n];\n\n/**\n * @internal\n */\nexport class ContextSeeders<TCtx extends ContextValues> {\n\n  private readonly _issuers = new Map<ContextSeedKey<any, any>, SeedIssuer<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  issuer<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedIssuer<TCtx, TSrc, TSeed> {\n\n    const found: SeedIssuer<TCtx, TSrc, TSeed> | undefined = this._issuers.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const issuer: SeedIssuer<TCtx, TSrc, TSeed> = [\n      seeder,\n      context => seeder.seed(context, this._initial(seedKey, context)),\n    ];\n\n    this._issuers.set(seedKey, issuer);\n\n    return issuer;\n  }\n\n  newSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.issuer(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/primitives';\nimport type { ContextBuilder } from './context-builder';\nimport type { ContextRequest, ContextTarget } from './context-ref';\nimport type { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TSrc - Source value type.\n */\nexport type ContextValueProvider<TCtx extends ContextValues, TSrc> =\n/**\n * @param context - Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: TCtx) => TSrc | null | undefined;\n\n/**\n * Context value specifier.\n *\n * Either explicit one, or a {@link ContextBuilder context builder}.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TDeps extends any[] = unknown[],\n    TSrc = TValue,\n    TSeed = unknown> =\n    | ContextValueSpec.Explicit<TCtx, TValue, TDeps, TSrc, TSeed>\n    | ContextBuilder<TCtx>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * Explicit context value specifier.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TValue - Context value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export type Explicit<\n      TCtx extends ContextValues,\n      TValue,\n      TDeps extends any[] = unknown[],\n      TSrc = TValue,\n      TSeed = unknown> =\n      | ContextValueSpec.IsConstant<TSrc, TSeed>\n      | ContextValueSpec.ViaAlias<TSrc, TSeed>\n      | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n      | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>\n      | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n      | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n      | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>\n      | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>;\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface IsConstant<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface ViaAlias<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc, TSeed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TCtx, TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface ByProviderWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface AsInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface SelfInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @typeParam TSrc - Source value type.\n * @param spec - Explicit context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.Explicit<TCtx, TValue, TDeps, TSrc, TSeed>,\n): ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> {\n  if (isValueSpecByProvider(spec)) {\n    if (!isValueSpecWithDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstantValueSpec<TSrc, TSeed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (isValueSpecViaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (isValueSpecAsInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n    if (isSelfInstanceValueSpec<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!isValueSpecWithDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction isValueSpecByProvider<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecAsInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction isSelfInstanceValueSpec<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed> | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>,\n): ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n}\n\n/**\n * @internal\n */\nfunction isConstantValueSpec<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.IsConstant<TSrc, TSeed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecViaAlias<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.ViaAlias<TSrc, TSeed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { ContextRequest } from './context-ref';\nimport type { ContextSupply } from './context-supply';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n\nexport interface ContextValues {\n\n  /**\n   * Context values supply.\n   *\n   * When provided, this value is available under {@link ContextSupply} key, unless overridden.\n   */\n  readonly supply?: ContextSupply;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextKey__symbol, ContextValueSetup, ContextValueSlot } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport type { ContextRef, ContextRequest } from './context-ref';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextSeeders } from './context-seeders.impl';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seeders: ContextSeeders<TCtx>,\n): ContextValues {\n\n  const values = new Map<ContextKey<any>, any>();\n\n  class ContextValues$ extends ContextValues {\n\n    get<TValue, TSrc>(\n        this: TCtx,\n        { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n        opts?: ContextRequest.Opts<TValue>,\n    ): TValue | null | undefined {\n\n      const cached = values.get(key);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      const [constructed, setup] = new ContextValueSlot$(seeders, this, key, opts)._grow();\n\n      if (setup) {\n        values.set(key, constructed);\n        setup({\n          key,\n          context: this,\n          registry: registry as ContextRegistry<any>,\n        });\n      }\n\n      return constructed;\n    }\n\n  }\n\n  return new ContextValues$();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n  readonly hasFallback: boolean;\n  readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n  readonly seed: TSeed;\n  private _constructed: TValue | null | undefined = null;\n  private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n  constructor(\n      seeders: ContextSeeders<TCtx>,\n      readonly context: TCtx,\n      readonly key: ContextKey<TValue, TSrc, TSeed>,\n      private readonly _opts: ContextRequest.Opts<TValue> = {},\n  ) {\n\n    const [seeder, seed] = seeders.newSeed<TSrc, TSeed>(context, key);\n\n    this.seeder = seeder;\n    this.seed = seed;\n    this.hasFallback = 'or' in _opts; // Fallback _may_ have `undefined` value.\n  }\n\n  get or(): TValue | null | undefined {\n    return this._opts.or; // Access here, as fallback value accessor may be implemented as getter.\n  }\n\n  insert(value: TValue | null | undefined): void {\n    this._constructed = value;\n  }\n\n  fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n    grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n    return this._constructed;\n  }\n\n  setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n    const prevSetup = this._setup;\n\n    this._setup = opts => {\n      prevSetup(opts);\n      setup(opts);\n    };\n  }\n\n  _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n    this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n    if (this._constructed != null) {\n      return [this._constructed, this._setup];\n    }\n    if (!this.hasFallback) {\n      throw new ContextKeyError(this.key);\n    }\n\n    return [this.or];\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { ContextBuilder, ContextBuilder__symbol } from './context-builder';\nimport { ContextKey__symbol, ContextSeedKey } from './context-key';\nimport type { ContextSeeds } from './context-seeder';\nimport { ContextSeeders } from './context-seeders.impl';\nimport { ContextValueSpec, contextValueSpec } from './context-value-spec';\nimport type { ContextValues } from './context-values';\nimport { newContextValues } from './context-values.impl';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx - Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeders: ContextSeeders<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial - An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n    this._seeders = new ContextSeeders<TCtx>(\n        initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop,\n    );\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   * @param spec - Context value specifier.\n   *\n   * @returns Provider supply instance that removes just added context value provider once cut off.\n   */\n  provide<TDeps extends any[], TSrc, TSeed>(spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>): Supply {\n    if (isContextBuilder(spec)) {\n      return spec[ContextBuilder__symbol](this);\n    }\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeders.issuer<TSrc, TSeed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context - Target context.\n   * @param key - Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeders.issuer(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider originated from this registry.\n   *\n   * @returns Mandatory context seeds provider.\n   */\n  seeds(): ContextSeeds.Mandatory<TCtx> {\n    return (seedKey, context) => this.seed(context, seedKey);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context - Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeders);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other - Another context value registry or context seeds provider.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx> | ContextSeeds<TCtx>): ContextRegistry<TCtx> {\n\n    const otherSeeds: ContextSeeds<TCtx> = typeof other === 'function' ? other : other.seeds();\n\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const second = otherSeeds(key, context);\n      const [seeder, factory] = this._seeders.issuer(key);\n      const first = factory(context);\n\n      return second ? seeder.combine(first, second, context) : first;\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isContextBuilder<TCtx extends ContextValues, TValue, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, TValue, TDeps, TSrc, TSeed>,\n): spec is ContextBuilder<TCtx> {\n  return typeof (spec as Partial<ContextBuilder<TCtx>>)[ContextBuilder__symbol] === 'function';\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop, Supply } from '@proc7ts/primitives';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValueProvider } from './context-value-spec';\nimport type { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: (readonly [ContextValueProvider<TCtx, TSrc>])[] = [];\n\n  provide(provider: ContextValueProvider<TCtx, TSrc>): Supply {\n\n    // Ensure the same provider may be registered multiple times\n    const entry: readonly [ContextValueProvider<TCtx, TSrc>] = [provider];\n\n    this._providers.unshift(entry);\n\n    return new Supply(() => this._providers.splice(this._providers.lastIndexOf(entry), 1));\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (\n        [provider]: readonly [ContextValueProvider<TCtx, TSrc>],\n    ): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc - Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { Supply } from '@proc7ts/primitives';\nimport { alwaysSupply } from '@proc7ts/primitives';\nimport type { ContextValueSlot } from './context-key';\nimport type { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Context values supply.\n *\n * It is used to signal when context is no longer used (e.g. destroyed).\n *\n * A context value provider can (and probably should) destroy the provided value in such case.\n */\nexport type ContextSupply = Supply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || slot.context.supply\n        || (slot.hasFallback ? slot.or : alwaysSupply()),\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `SupplyPeer` interface. Defaults to supply-always\n * otherwise.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/primitives';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from './context-key';\nimport type { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason - Context destruction reason.\n */\nexport function contextDestroyed(reason: unknown = new TypeError('Context destroyed')): () => never {\n  return () => {\n    throw reason;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events/updatable\n */\nimport type { ContextModule } from './context-module';\n\n/**\n * An error indicating context module dependency load failure.\n */\nexport class ContextModuleDependencyError extends Error {\n\n  /**\n   * Constructs context module dependency load error.\n   *\n   * @param module - A module failed to load.\n   * @param reasons - An array of dependency/reason pairs caused the load failure.\n   * @param message - An error message.\n   */\n  constructor(\n      readonly module: ContextModule,\n      readonly reasons: readonly (readonly [ContextModule, unknown?])[] = [],\n      readonly message: string = contextModuleDependencyErrorMessage(module, reasons),\n  ) {\n    super(message);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction contextModuleDependencyErrorMessage(\n    module: ContextModule,\n    dependencies: readonly (readonly [ContextModule, unknown?])[],\n): string {\n\n  const reasons = dependencies.reduce(\n      (out, [dep, reason]) => {\n        if (out) {\n          out += ', ';\n        } else {\n          out = ': ';\n        }\n        if (reason !== undefined) {\n          out += `${dep} failed to load (${reason})`;\n        } else {\n          out += `${dep} not loaded`;\n        }\n\n        return out;\n      },\n      '',\n  );\n\n  return `Failed to load ${module}${reasons}`;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  mapAfter_,\n  OnEvent,\n  onEventBy,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { neverSupply, Supply, SupplyPeer, valueProvider } from '@proc7ts/primitives';\nimport type { ContextRequest } from '../context-ref';\nimport type { ContextRegistry } from '../context-registry';\nimport { ContextSupply } from '../context-supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextModule } from './context-module';\n\n/**\n * @internal\n */\nexport class ContextModuleUsage {\n\n  private readonly _impl: ValueTracker<ContextModule | undefined>;\n  private readonly _rev: ValueTracker<ContextModuleRev>;\n  private _useCounter = 0;\n\n  private _setup!: () => void;\n\n  constructor(context: ContextValues, readonly module: ContextModule) {\n    this._impl = trackValue();\n    this._rev = trackValue({\n      status: {\n        module: this.module,\n        provided: false,\n        used: false,\n        settled: false,\n        ready: false,\n      },\n      supply: neverSupply(),\n    });\n\n    const contextSupply = context.get(ContextSupply);\n\n    contextSupply.cuts(this._impl);\n    contextSupply.cuts(this._rev);\n\n    this._impl.read(module => {\n\n      const prevSupply = this._rev.it.supply;\n\n      if (module) {\n        this._load(module);\n      }\n\n      prevSupply.off();\n    });\n  }\n\n  createHandle(): ContextModule.Handle {\n\n    const read: AfterEvent<[ContextModule.Status]> = this._rev.read.do(\n        mapAfter_(({ status }) => status),\n    );\n\n    const handle: ContextModule.Handle = {\n      read,\n      [AfterEvent__symbol]: valueProvider(read),\n      use: (user?: SupplyPeer) => this._use(handle, user),\n    };\n\n    return handle;\n  }\n\n  setup(context: ContextValues, registry: ContextRegistry): void {\n    this._setup = () => {\n\n      const rev = this._rev.it;\n      const { status: { module }, supply } = rev;\n\n      if (module !== this.module) {\n        // Load implementation module instead.\n        // The implementation module expected to be provided already.\n        context.get(module).use(supply).read({\n          supply,\n          receive: (_ctx, { settled, ready, error }) => {\n            this._updateStatus(rev, settled, ready, error);\n          },\n        });\n      } else {\n        loadContextModule(context, registry, rev)\n            .then(({ whenReady }) => {\n              this._updateStatus(rev, true, false);\n              return whenReady;\n            })\n            .then(() => this._updateStatus(rev, true, true))\n            .catch(error => rev.supply.off(error));\n      }\n    };\n  }\n\n  implementBy(impl: AfterEvent<[ContextModule?]>): void {\n    this._impl.by(impl);\n  }\n\n  private _updateStatus(\n      rev: ContextModuleRev,\n      settled: boolean,\n      ready: boolean,\n      error?: unknown,\n  ): void {\n    // Ensure updating the correct revision.\n    if (this._rev.it.supply !== rev.supply) {\n      // If revision changed, then drop the obsolete one.\n      rev.supply.off();\n    } else {\n      this._rev.it = rev = {\n        status: {\n          module: rev.status.module,\n          provided: rev.status.provided,\n          used: true,\n          settled,\n          ready,\n          error,\n        },\n        supply: rev.supply,\n      };\n    }\n  }\n\n  private _load(module: ContextModule): void {\n\n    const supply = new Supply().needs(this._rev).whenOff(error => {\n\n      const rev = this._rev.it;\n\n      if (rev.supply === supply) {\n        this._rev.it = {\n          status: {\n            ...this._rev.it.status,\n            provided: false,\n            settled: false,\n            ready: false,\n            error,\n          },\n          supply,\n        };\n      }\n    });\n\n    const used = !!this._useCounter;\n\n    this._rev.it = {\n      status: {\n        module,\n        provided: true,\n        used,\n        settled: false,\n        ready: false,\n      },\n      supply,\n    };\n\n    if (used) {\n      this._setup();\n    }\n  }\n\n  private _use(handle: ContextModule.Handle, user?: SupplyPeer): ContextModule.Use {\n\n    const supply = new Supply();\n\n    if (user) {\n      supply.needs(user);\n    }\n\n    const read = handle.read.do(supplyAfter(supply));\n    const use: ContextModule.Use = {\n      ...handle,\n      read,\n      whenSettled: ContextModule$Use$when(read, isContextModuleSettled),\n      whenReady: ContextModule$Use$when(read, isContextModuleReady),\n      supply,\n    };\n\n    if (!supply.isOff) {\n      supply.whenOff(error => {\n        if (!--this._useCounter) {\n\n          const rev = this._rev.it;\n\n          this._rev.it = {\n            status: {\n              ...rev.status,\n              used: false,\n              settled: false,\n              ready: false,\n              error,\n            },\n            supply: new Supply().off(error),\n          };\n\n          rev.supply.off(error);\n        }\n      });\n\n      if (!this._useCounter++) {\n        // Mark the module used and set it up.\n\n        const rev = this._rev.it;\n\n        this._rev.it = {\n          status: {\n            ...rev.status,\n            used: true,\n          },\n          supply: rev.supply,\n        };\n\n        this._setup();\n      }\n    }\n\n    return use;\n  }\n\n}\n\n/**\n * @internal\n */\ninterface ContextModuleRev {\n\n  readonly status: ContextModule.Status;\n  readonly supply: Supply;\n\n}\n\n/**\n * @internal\n */\nasync function loadContextModule(\n    context: ContextValues,\n    registry: ContextRegistry,\n    { status: { module }, supply }: ContextModuleRev,\n): Promise<ContextModuleInit> {\n\n  const moduleInit = new ContextModuleInit(module);\n\n  await module.setup({\n\n    module,\n    supply,\n\n    get(request: ContextRequest<any>) {\n      return context.get(request);\n    },\n\n    provide(spec): Supply {\n      return registry.provide(spec).needs(supply);\n    },\n\n    initBy(init: (this: void) => (void | PromiseLike<unknown>)) {\n      moduleInit.initBy(init);\n    },\n\n  });\n\n  return moduleInit;\n}\n\nclass ContextModuleInit {\n\n  readonly whenReady: Promise<unknown>;\n  private _whenDone: Promise<unknown> = Promise.resolve();\n  private _ready!: (result?: PromiseLike<unknown>) => void;\n\n  constructor(private readonly _module: ContextModule) {\n    this.whenReady = new Promise(resolve => this._ready = resolve);\n  }\n\n  initBy(init: (this: void) => void | PromiseLike<unknown>): void {\n\n    const rev: Promise<unknown> = this._whenDone = this._whenDone\n        .then(init)\n        .finally(() => this._done(rev));\n\n  }\n\n  private _done(rev: Promise<unknown>): void {\n    if (this._whenDone === rev) {\n      this._ready(rev);\n      this.initBy = _init => {\n        throw new TypeError(`${this._module} initialized already, and does not accept new initializers`);\n      };\n    }\n  }\n\n}\n\nfunction ContextModule$Use$when(\n    status: AfterEvent<[ContextModule.Status]>,\n    test: (status: ContextModule.Status) => boolean,\n): OnEvent<[ContextModule.Status]> {\n  return onEventBy(receiver => status({\n    supply: receiver.supply,\n    receive: (context, status) => {\n      if (test(status)) {\n        receiver.receive(context, status);\n        receiver.supply.off();\n      } else if (status.error) {\n        receiver.supply.off(status.error);\n      }\n    },\n  }));\n}\n\nfunction isContextModuleSettled({ settled }: ContextModule.Status): boolean {\n  return settled;\n}\n\nfunction isContextModuleReady({ ready }: ContextModule.Status): boolean {\n  return ready;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  isEventKeeper,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { itsElements, mapIt, overElementsOf, overIterator } from '@proc7ts/push-iterator';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSlot } from '../context-key';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextSeeder } from '../context-seeder';\nimport { ContextSupply } from '../context-supply';\nimport type { ContextValueProvider } from '../context-value-spec';\nimport type { ContextValues } from '../context-values';\n\n/**\n * @internal\n */\nconst flatUpSources: <TSrc>(this: void, input: AfterEvent<TSrc[][]>) => AfterEvent<TSrc[]> = (\n    /*#__PURE__*/ translateAfter((send, ...sources) => send(...itsElements(overElementsOf(...sources))))\n);\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers = trackValue<[Map<Supply, ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>>]>(\n      [new Map()],\n  );\n\n  provide(provider: ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>): Supply {\n\n    const [providers] = this._providers.it;\n    const supply = new Supply();\n\n    providers.set(supply, provider);\n    this._providers.it = [providers];\n\n    return supply.whenOff(() => {\n\n      const [providers] = this._providers.it;\n\n      providers.delete(supply);\n\n      this._providers.it = [providers];\n    });\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(first, second).do(flatUpSources);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<[Map<Supply, ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>>]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read.do(\n      digAfter_(\n          ([providers]): AfterEvent<TSrc[][]> => !providers.size\n              ? afterThe()\n              : afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overIterator(() => providers.values()),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n      ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | TSrc | EventKeeper<TSrc[]>): AfterEvent<TSrc[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<TSrc>(src: TSrc | EventKeeper<TSrc[]>): src is EventKeeper<TSrc[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as object);\n}\n\n/**\n * @internal\n */\nclass ContextSeed$UpKey<TSrc>\n    extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, TSrc | EventKeeper<TSrc[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKey$UpKey<TUpdate extends any[], TSrc>\n    extends ContextKey<AfterEvent<TUpdate>, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n\n  readonly grow: (\n      slot: ContextValueSlot<AfterEvent<TUpdate>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<unknown, TSrc>,\n      grow: (\n          slot: ContextValueSlot<AfterEvent<TUpdate>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value: EventKeeper<TUpdate> | null | undefined = slot.fillBy(grow);\n\n      if (value != null) {\n        slot.insert(value[AfterEvent__symbol]().do(\n            supplyAfter(slot.context.get(ContextSupply)),\n        ));\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc>, ContextUpKey.Base<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by {@link grow} function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeed$UpKey<TSrc>(this);\n  }\n\n  /**\n   * Creates a key of context value containing an `AfterEvent` keeper of updates to the value of this key.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @param grow - A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey<TUpdate extends any[]>(\n      grow: (\n          slot: ContextValueSlot<AfterEvent<TUpdate>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n    return new ContextUpKey$UpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of context value updates tracker.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue - Original context value type.\n   */\n  export type Up<TValue> = TValue extends EventKeeper<any> ? TValue : AfterEvent<[TValue]>;\n\n  /**\n   * Base interface of updatable context value key.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface Base<TValue, TSrc> extends ContextKey<TValue, TSrc | EventKeeper<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n     *\n     * It is expected to report any updates to this key's value.\n     *\n     * The value of updates key is constructed by {@link grow} function out of the same seed.\n     */\n    readonly upKey: UpKey<TValue, TSrc>;\n\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface UpKey<TValue, TSrc> extends ContextKey<ContextUpKey.Up<TValue>, TSrc | EventKeeper<TSrc[]>> {\n\n    /**\n     * A reference to this key.\n     *\n     * Indicates that this key is updatable too.\n     */\n    readonly upKey: this;\n\n  }\n\n  /**\n   * A key of context value containing an `AfterEvent` keeper of updates of {@link ContextUpKey updatable value}.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SimpleUpKey<TUpdate extends any[], TSrc> extends Base<AfterEvent<TUpdate>, TSrc> {\n\n    readonly upKey: this;\n\n  }\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","import type { AfterEvent, EventKeeper } from '@proc7ts/fun-events';\nimport { mapAfter_ } from '@proc7ts/fun-events';\nimport type { ContextValueSlot } from '../context-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleUsage } from './context-module-usage.impl';\nimport { ContextUpKey } from './context-up-key';\n\n/**\n * @internal\n */\nexport class ContextModuleKey extends ContextUpKey<ContextModule.Handle, ContextModule> {\n\n  constructor(name: string, private readonly _module: ContextModule) {\n    super(name);\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ContextModule.Handle,\n          EventKeeper<ContextModule[]> | ContextModule,\n          AfterEvent<ContextModule[]>>,\n  ): void {\n\n    const usage = new ContextModuleUsage(slot.context, this._module);\n\n    slot.insert(usage.createHandle());\n    slot.setup(({ context, registry }) => usage.setup(context, registry));\n\n    usage.implementBy(implementContextModule(this._module, slot.seed));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction implementContextModule(\n    module: ContextModule,\n    impls: AfterEvent<[ContextModule]>,\n): AfterEvent<[ContextModule | undefined]> {\n  return impls.do(\n      mapAfter_((...candidates) => {\n\n        let impl: ContextModule | undefined;\n\n        for (let i = candidates.length - 1; i >= 0; --i) {\n          impl = candidates[i];\n          if (impl !== module) {\n            break;\n          }\n        }\n\n        return impl;\n      }),\n  );\n}\n","import type { OnEvent } from '@proc7ts/fun-events';\nimport { isDefined, noop, setOfElements, Supply, valueProvider } from '@proc7ts/primitives';\nimport { itsElements, valueIt } from '@proc7ts/push-iterator';\nimport type { ContextRegistry } from '../context-registry';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleDependencyError } from './context-module-dependency-error';\nimport { ContextModuleKey } from './context-module-key.impl';\nimport type { ContextUpKey } from './context-up-key';\n\n/**\n * @internal\n */\nexport const ContextModule$impl__symbol = (/*#__PURE__*/ Symbol('ContextModule.impl'));\n\n/**\n * @internal\n */\nexport class ContextModule$ {\n\n  readonly key: ContextUpKey<ContextModule.Handle, ContextModule>;\n  readonly has: ReadonlySet<ContextModule>;\n  readonly needs: ReadonlySet<ContextModule>;\n\n  private readonly _setup: (\n      this: void,\n      setup: ContextModule.Setup,\n  ) => void | PromiseLike<unknown>;\n\n  constructor(module: ContextModule, readonly name: string, readonly options: ContextModule.Options) {\n    this.key = new ContextModuleKey(`${name}:module`, module);\n\n    const { needs, has, setup } = options;\n\n    this.has = setOfElements(has).add(module);\n    this.needs = setOfElements(needs);\n    this._setup = setup ? setup.bind(options) : noop;\n  }\n\n  replace(\n      module: ContextModule,\n      registry: ContextRegistry,\n      supply: Supply,\n  ): void {\n    for (const replaced of module.has) {\n      if (replaced !== module) {\n        registry.provide({ a: replaced, is: module }).needs(supply);\n      }\n    }\n  }\n\n  async setup(setup: ContextModule.Setup): Promise<void> {\n\n    const deps = contextModuleDeps(setup);\n\n    // Await for module dependencies to be settled.\n    if (!await loadContextModuleDeps(setup, deps, whenContextModuleSettled)) {\n      return;\n    }\n\n    setup.initBy(async () => {\n      // Initialize module dependencies.\n      await loadContextModuleDeps(setup, deps, whenContextModuleReady);\n    });\n\n    await this._setup(setup);\n  }\n\n}\n\ninterface ContextModuleDep {\n  readonly dep: ContextModule;\n  readonly use: ContextModule.Use;\n}\n\nfunction contextModuleDeps(setup: ContextModule.Setup): readonly ContextModuleDep[] {\n\n  const { module, supply } = setup;\n\n  return itsElements(\n      valueIt(\n          module.needs,\n          dep => dep !== module\n              && setup.provide(dep).needs(supply)\n              && {\n                dep,\n                use: setup.get(dep).use(setup),\n              },\n      ),\n  );\n}\n\nfunction loadContextModuleDeps(\n    setup: ContextModule.Setup,\n    deps: readonly ContextModuleDep[],\n    whenLoaded: (use: ContextModule.Use) => OnEvent<[ContextModule.Status]>,\n): Promise<boolean> {\n\n  const { module, supply } = setup;\n  const notLoaded = valueProvider(false);\n  const whenDone = supply.whenDone().then(notLoaded, notLoaded);\n\n  return Promise.race([\n    whenDone,\n    Promise\n        .all(\n            deps\n                .map(\n                    ({ dep, use }) => whenLoaded(use).then(\n                        noop,\n                        error => [dep, error] as const,\n                    ),\n                ),\n        )\n        .then(\n            (results): true | ContextModuleDependencyError => {\n\n              const failures = results.filter<readonly [ContextModule, unknown]>(isDefined);\n\n              return failures.length\n                  ? new ContextModuleDependencyError(module, failures) // Prevent unhandled promise rejection\n                  : true as const;\n            },\n        ),\n  ]).then(\n      result => {\n        if (typeof result !== 'boolean') {\n          // Fail to load module if at leas one of its dependencies failed.\n          return Promise.reject(result);\n        }\n\n        return result;\n      },\n  );\n}\n\nfunction whenContextModuleSettled(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenSettled;\n}\n\nfunction whenContextModuleReady(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenReady;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events/updatable\n */\nimport type { AfterEvent, EventKeeper, OnEvent } from '@proc7ts/fun-events';\nimport type { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { ContextBuilder, ContextBuilder__symbol } from '../context-builder';\nimport { ContextKey__symbol } from '../context-key';\nimport type { ContextRegistry } from '../context-registry';\nimport type { ContextValueSpec } from '../context-value-spec';\nimport type { ContextValues } from '../context-values';\nimport { ContextModule$, ContextModule$impl__symbol } from './context-module.impl';\nimport type { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Context module.\n *\n * Modules intended to extend the context dynamically.\n *\n * The module is a context value reference that can be used to provide module instance and access its\n * {@link ContextModule.Handle handle}.\n *\n * Usage example:\n * ```typescript\n * // Construct new module.\n * const myModule = new ContextModule('my module', {\n *   setup(setup) {\n *     // Provide the values\n *     setup.provide({ a: Foo, is: 'foo' });\n *   },\n * });\n *\n * // Load the module\n * const myModuleSupply = contextRegistry.provide(myModule);\n *\n * // Start using the module\n * const myModuleUse = await context.get(myModule).use();\n *\n * // Await for the module to load\n * await myModuleUse.whenReady;\n *\n * // Access the value provided by module.\n * console.log(context.get(Foo));\n *\n * // Stop using the module\n * myModuleUse.supply.off();\n *\n * // Unload the module declaration.\n * myModuleSupply.off();\n * ```\n */\nexport class ContextModule implements ContextUpRef<ContextModule.Handle, ContextModule>, ContextBuilder {\n\n  /**\n   * @internal\n   */\n  private readonly [ContextModule$impl__symbol]: ContextModule$;\n\n  /**\n   * Constructs context module.\n   *\n   * @param name - Human-readable module name.\n   * @param options - Module construction options.\n   */\n  constructor(name: string, options: ContextModule.Options = {}) {\n    this[ContextModule$impl__symbol] = new ContextModule$(this, name, options);\n  }\n\n  /**\n   * A key of context module.\n   */\n  get [ContextKey__symbol](): ContextUpKey<ContextModule.Handle, ContextModule> {\n    return this[ContextModule$impl__symbol].key;\n  }\n\n  /**\n   * Human-readable module name.\n   */\n  get name(): string {\n    return this[ContextModule$impl__symbol].name;\n  }\n\n  /**\n   * The modules this one requires.\n   *\n   * Assigned by {@link ContextModule.Options.needs} option.\n   */\n  get needs(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].needs;\n  }\n\n  /**\n   * The modules this one provides.\n   *\n   * Assigned by {@link ContextModule.Options.has} option.\n   *\n   * Always contains the module itself.\n   */\n  get has(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].has;\n  }\n\n  /**\n   * Provides this module and {@link has module replacements}.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry): Supply {\n\n    const supply = registry.provide({ a: this, is: this });\n\n    this[ContextModule$impl__symbol].replace(this, registry, supply);\n\n    return supply;\n  }\n\n  /**\n   * Sets up the module.\n   *\n   * This method is called when loading the module. It is used e.g. to provide more values for the context.\n   *\n   * By default:\n   *\n   * 1. Satisfies module {@link needs dependencies} by setting them up.\n   *\n   *    The dependency considered satisfied when it is {@link ContextModule.Status.settled settled}.\n   *\n   * 2. {@link ContextModule.Setup.initBy Initializes} the module by initializing the dependencies.\n   *\n   *    The dependency considered initialized when it is {@link ContextModule.Status.ready ready for use}.\n   *\n   * 3. Performs the module setup by invoking the {@link ContextModule.Options.setup} method.\n   *\n   * @param setup - Context module setup.\n   *\n   * @returns A promise resolved when the module is set up asynchronously.\n   */\n  setup(setup: ContextModule.Setup): Promise<void> {\n    return this[ContextModule$impl__symbol].setup(setup);\n  }\n\n  toString(): string {\n    return `ContextModule(${this.name})`;\n  }\n\n}\n\nexport namespace ContextModule {\n\n  /**\n   * Context module construction options.\n   */\n  export interface Options {\n\n    /**\n     * A module or modules the constructed one requires.\n     *\n     * The listed modules will be loaded prior to loading the constructed one.\n     */\n    readonly needs?: ContextModule | readonly ContextModule[];\n\n    /**\n     * A module or modules the constructed one provides.\n     *\n     * When specified, the constructed module will be loaded _instead_ of the listed ones.\n     *\n     * The module always provides itself.\n     */\n    readonly has?: ContextModule | readonly ContextModule[];\n\n    /**\n     * Sets up constructed module.\n     *\n     * This method is called when loading the module. It is used e.g. to provide more values for the context.\n     *\n     * @param setup - Context module setup.\n     *\n     * @returns Either nothing to set up the module synchronously, or a promise-like instance resolved when the module\n     * is set up asynchronously.\n     */\n    setup?(setup: ContextModule.Setup): void | PromiseLike<unknown>;\n\n  }\n\n  /**\n   * Context module setup.\n   *\n   * Passed to {@link ContextModule.setup module setup method} in order to access and provide the necessary values.\n   *\n   * @typeParam TCtx - Target context type.\n   */\n  export interface Setup extends ContextValues, SupplyPeer {\n\n    /**\n     * The module to set up.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Module supply.\n     *\n     * This supply will be cut off once the module is unloaded.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Provides context value.\n     *\n     * The value provider will be removed automatically once the module is unloaded.\n     *\n     * @typeParam TDeps - Dependencies tuple type.\n     * @typeParam TSrc - Source value type.\n     * @typeParam TSeed - Value seed type.\n     * @param spec - Context value specifier.\n     *\n     * @returns Provider supply instance that removes just added context value provider once cut off.\n     */\n    provide<TDeps extends any[], TSrc, TSeed>(\n        spec: ContextValueSpec<ContextValues, unknown, TDeps, TSrc, TSeed>,\n    ): Supply;\n\n    /**\n     * Registers the module initializer.\n     *\n     * The module initializer registration is only valid during its {@link ContextModule.setup setup}.\n     *\n     * The registered initializers executed after successful module {@link ContextModule.setup}. The modules\n     * is considered {@link ContextModule.Status.ready ready for use} only when all registered initializers succeed.\n     *\n     * The registered initializers executed serially. I.e. then next one does not start until the previous one succeeds.\n     *\n     * It is an error calling this method when the module initialized already.\n     *\n     * @param init - The module initialization function, that returns nothing when the module initialization\n     * completed synchronously, or a promise-like instance resolved when the module initialization completed\n     * asynchronously.\n     */\n    initBy(init: (this: void) => void | PromiseLike<unknown>): void;\n\n  }\n\n  /**\n   * A handle of dynamically loaded context module.\n   *\n   * This value is available in {@link ContextValues.get returned from context} under the module instance used as a key.\n   *\n   * Implements an `EventKeeper` interface by sending a {@link ContextModule.Status module load status} updates.\n   */\n  export interface Handle extends EventKeeper<[ContextModule.Status]> {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * Initiate the module use.\n     *\n     * @param user - Module user. Contains a supply required by {@link Use.supply module use supply}. The module use\n     * stops once the user supply is cut off.\n     *\n     * @returns A module usage instance.\n     */\n    use(user?: SupplyPeer): Use;\n\n  }\n\n  /**\n   * An instance of the module use.\n   *\n   * The module is active while it is in use. I.e. at least one `Use` instance exists and active.\n   *\n   * The use is active util its {@link supply} is cut off.\n   *\n   * The module use instance can be used as its handle too.\n   */\n  export interface Use extends Handle, SupplyPeer {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     *\n     * Cuts off the supply when context module no longer {@link supply used}.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module settlement event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.settled\n     * settled}, but possibly before it is {@link ContextModule.Status.ready ready}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenSettled: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module readiness event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.ready ready\n     * for use}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenReady: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * Module use supply.\n     *\n     * The module use stops once this supply is cut off.\n     */\n    readonly supply: Supply;\n\n  }\n\n  /**\n   * Context module load status.\n   *\n   * This status is reported by {@link ContextModule.Handle loaded module handle}.\n   */\n  export interface Status {\n\n    /**\n     * Loaded module.\n     *\n     * Note that it may differ from the one requested to load. E.g. when another module {@link ContextModule.Options.has\n     * provides} it.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Whether the module implementation is provided.\n     */\n    readonly provided: boolean;\n\n    /**\n     * Whether the module is {@link Handle.use used} at least once.\n     */\n    readonly used: boolean;\n\n    /**\n     * Whether the module is settled.\n     *\n     * The module is settled when its {@link ContextModule.setup set up} is complete.\n     */\n    readonly settled: boolean;\n\n    /**\n     * Whether the module is loaded and ready for use.\n     *\n     * The module is ready when it is {@link settled}, and all of its {@link ContextModule.Setup.initBy initializers}\n     * succeed.\n     */\n    readonly ready: boolean;\n\n    /**\n     * Error occurred while loading the module.\n     */\n    readonly error?: unknown;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport type { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an {@link ContextKeyError}.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.SimpleUpKey<\n      [(this: void, ...args: TArgs) => TRet],\n      (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key)\n        || (() => {\n          throw new ContextKeyError(this);\n        });\n    this.upKey = this.createUpKey(\n        slot => {\n          slot.insert(slot.seed.do(digAfter(\n              (...fns): AfterEvent<[(this: void, ...args: TArgs) => TRet]> => {\n                if (fns.length) {\n                  return afterThe(fns[fns.length - 1]);\n                }\n\n                if (slot.hasFallback && slot.or) {\n                  return slot.or;\n                }\n\n                return afterThe(this.byDefault(slot.context, this));\n              },\n          )));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          EventKeeper<((this: void, ...args: TArgs) => TRet)[]> | ((this: void, ...args: TArgs) => TRet),\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { AfterEvent, afterEventBy, afterThe, digAfter, EventKeeper, supplyAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport type { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from '../context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextUpRef<TValue> = ContextUpRef<AfterEvent<[TValue]>, TValue>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an {@link ContextKeyError} error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextUpKey<TValue>\n    extends ContextUpKey<AfterEvent<[TValue]>, TValue>\n    implements SingleContextUpRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TValue>;\n        byDefault?: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<AfterEvent<[TValue]>, EventKeeper<TValue[]> | TValue, AfterEvent<TValue[]>>,\n  ): void {\n\n    const value = slot.seed.do(digAfter((...sources: TValue[]): AfterEvent<TValue[]> => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return afterThe(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[TValue]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        backup = defaultValue && afterThe(defaultValue);\n      }\n      if (backup != null) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<[TValue]>(() => {\n        throw new ContextKeyError(this);\n      });\n    }));\n\n    slot.insert(value.do<AfterEvent<TValue[]>>(\n        supplyAfter(slot.context.get(ContextSupply)),\n    ));\n  }\n\n}\n\n"],"names":["ContextBuilder__symbol","Symbol","ContextKey__symbol","ContextKey","[object Object]","name","this","ContextSeedKey","key","super","seedKey","opts","seeder","seed","isEmpty","hasFallback","insert","ContextKeyError","Error","message","ContextSeeders","_initial","Map","found","_issuers","get","issuer","context","set","factory","isValueSpecWithDeps","spec","ContextValues","ContextValueSlot$","seeders","_opts","noop","newSeed","or","value","_constructed","grow","setup","prevSetup","_setup","ContextRegistry","initial","_seeders","isContextBuilder","a","by","isValueSpecByProvider","with","deps","map","dep","isConstantValueSpec","is","valueProvider","isValueSpecViaAlias","via","ctx","isValueSpecAsInstance","isSelfInstanceValueSpec","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","provide","newValues","bind","registry","values","cached","constructed","_grow","newContextValues","other","otherSeeds","seeds","second","first","combine","SimpleContextSeeder","provider","entry","_providers","unshift","Supply","splice","lastIndexOf","length","makeSeed","lazyValue","undefined","push","combineSimpleSeeds","SimpleSeedKey","SimpleContextKey","ContextSupplyKey","slot","supply","alwaysSupply","ContextSupply","SingleContextKey","byDefault","contextDestroyed","reason","ContextModuleDependencyError","module","reasons","dependencies","reduce","out","contextModuleDependencyErrorMessage","ContextModuleUsage","_impl","trackValue","_rev","status","provided","used","settled","ready","neverSupply","contextSupply","cuts","read","prevSupply","it","_load","off","do","mapAfter_","handle","AfterEvent__symbol","use","user","_use","rev","receive","_ctx","error","_updateStatus","async","moduleInit","ContextModuleInit","request","needs","init","initBy","loadContextModule","then","whenReady","catch","impl","whenOff","_useCounter","supplyAfter","whenSettled","ContextModule$Use$when","isContextModuleSettled","isContextModuleReady","isOff","_module","Promise","resolve","_ready","_whenDone","finally","_done","_init","test","onEventBy","receiver","flatUpSources","translateAfter","send","sources","itsElements","overElementsOf","ContextUpSeeder","providers","delete","afterThe","providersTracker","digAfter_","size","afterEach","mapIt","overIterator","prov","toUpSrcKeeper","upSrcKeepers","src","isEventKeeper","isUpSrcKeeper","afterSupplied","ContextSeed$UpKey","upKey","ContextUpKey$UpKey","_key","fillBy","ContextUpKey","ContextModuleKey","usage","createHandle","implementBy","candidates","i","ContextModule$impl__symbol","ContextModule$","options","has","setOfElements","add","replaced","valueIt","contextModuleDeps","loadContextModuleDeps","whenContextModuleSettled","whenContextModuleReady","whenLoaded","notLoaded","whenDone","race","all","results","failures","filter","isDefined","result","reject","ContextModule","replace","FnContextKey","createUpKey","digAfter","fns","delegated","fn","args","SingleContextUpKey","backup","defaultValue","afterEventBy"],"mappings":"iTAWaA,EAAwCC,OAAO,2BCC/CC,EAAoCD,OAAO,qBAclCE,EAqBpBC,YAAsBC,GACpBC,KAAKD,KAAOA,EAQdH,IAAKA,KACH,OAAOI,KAUTF,WACE,MAAO,cAAcE,KAAKD,eAkMRE,UAAoCJ,EAOxDC,YAAYI,GACVC,MAAM,GAAGD,EAAIH,aAMfK,cACE,OAAOJ,KAYTF,KAAKO,GAEH,MAAMC,OAAEA,EAAMC,KAAEA,GAASF,EAEpBC,EAAOE,QAAQD,IAERF,EAAKI,aADfJ,EAAKK,OAAOH,UC7RLI,UAAwBC,MAanCd,YAAYI,EAAgCW,EAAU,8BAA8BX,KAClFC,MAAMU,GACNb,KAAKE,IAAMA,SCTFY,EAIXhB,YAA6BiB,GAAAf,cAAAe,EAFZf,cAAW,IAAIgB,IAKhClB,OAAoBM,GAElB,MAAMa,EAAmDjB,KAAKkB,SAASC,IAAIf,GAE3E,GAAIa,EACF,OAAOA,EAGT,MAAMX,EAA2CF,EAAQE,SACnDc,EAAwC,CAC5Cd,EACAe,GAAWf,EAAOC,KAAKc,EAASrB,KAAKe,SAASX,EAASiB,KAKzD,OAFArB,KAAKkB,SAASI,IAAIlB,EAASgB,GAEpBA,EAGTtB,QACIuB,EACAnB,GAGF,MAAME,QAAEA,GAAYF,GACbI,EAAQiB,GAAWvB,KAAKoB,OAAOhB,GAEtC,OAAIA,IAAYF,EAGP,CAACI,EAAQe,EAAQF,IAAIf,IAGvB,CAACE,EAAQiB,EAAQF,KCyW5B,SAASG,EACLC,GAEF,MAAO,SAAUA,QCvZGC,GC2CtB,MAAMC,EASJ7B,YACI8B,EACSP,EACAnB,EACQ2B,EAAqC,IAF7C7B,aAAAqB,EACArB,SAAAE,EACQF,WAAA6B,EAPb7B,kBAA0C,KAC1CA,YAAiD8B,EASvD,MAAOxB,EAAQC,GAAQqB,EAAQG,QAAqBV,EAASnB,GAE7DF,KAAKM,OAASA,EACdN,KAAKO,KAAOA,EACZP,KAAKS,YAAc,OAAQoB,EAG7BG,SACE,OAAOhC,KAAK6B,MAAMG,GAGpBlC,OAAOmC,GACLjC,KAAKkC,aAAeD,EAGtBnC,OAAOqC,GAEL,OADAA,EAAKnC,MACEA,KAAKkC,aAGdpC,MAAMsC,GAEJ,MAAMC,EAAYrC,KAAKsC,OAEvBtC,KAAKsC,OAASjC,IACZgC,EAAUhC,GACV+B,EAAM/B,IAIVP,QAGE,GAFAE,KAAKE,IAAIiC,KAAKnC,MAEW,MAArBA,KAAKkC,aACP,MAAO,CAAClC,KAAKkC,aAAclC,KAAKsC,QAElC,IAAKtC,KAAKS,YACR,MAAM,IAAIE,EAAgBX,KAAKE,KAGjC,MAAO,CAACF,KAAKgC,WC7FJO,EAaXzC,YAAY0C,GACVxC,KAAKyC,SAAW,IAAI3B,EAChB0B,EAC0B,mBAAZA,EAAyBA,EAAWpC,GAAWoC,EAAQrB,IAAIf,GACnE0B,GAcZhC,QAA0C2B,GACxC,GAgFJ,SACIA,GAEF,MAAkF,mBAAnEA,EAAuC/B,GAnFhDgD,CAAiBjB,GACnB,OAAOA,EAAK/B,GAAwBM,MAGtC,MAAQ2C,GAAK7C,CAACF,IAAqBQ,QAAEA,IAAWwC,GAAEA,YHyNlDnB,GAEF,GAkEF,SACIA,GAIF,MAAO,OAAQA,EAvEXoB,CAAsBpB,GAAO,CAC/B,IAAKD,EAA8CC,GACjD,OAAOA,EAGT,MAAMkB,EAAEA,EAACC,GAAEA,EAAIE,KAAMC,GAAStB,EAE9B,MAAO,CACLkB,EAAAA,EACAC,GAAevB,GACNuB,KAAMG,EAAKC,KAAQC,GAA2B5B,EAAQF,IAAI8B,OAIvE,GAiGF,SACIxB,GAEF,MAAO,OAAQA,EApGXyB,CAAiCzB,GAAO,CAE1C,MAAMkB,EAAEA,EAAGQ,GAAIlB,GAAUR,EAEzB,MAAO,CACLkB,EAAAA,EACAC,GAAIQ,EAAcnB,IAGtB,GAiGF,SACIR,GAEF,MAAO,QAASA,EApGZ4B,CAAoB5B,GAAO,CAE7B,MAAMkB,EAAEA,EAACW,IAAEA,GAAQ7B,EAEnB,MAAO,CACLkB,EAAAA,EACAC,GAAGW,GACMA,EAAIpC,IAAImC,IAIrB,GA2CF,SACI7B,GAIF,MAAO,OAAQA,EAhDX+B,CAAgD/B,GAAO,CAIzD,GAkDJ,SACIA,GAIF,QAAS,MAAOA,GA1DVgC,CAAkDhC,KACpDA,EA+DN,SACIA,GAEF,MAAO,IACFA,EACHkB,EAAGlB,EAAKiC,IApECC,CAAalC,KAEjBD,EAA8CC,GAAO,CAExD,MAAQiC,GAAIE,GAASnC,EAErB,MAAO,CACLkB,EAAGlB,EAAKkB,EACRC,GAAGW,GACM,IAAIK,EAAKL,IAKtB,MAAQG,GAAIG,EAASf,KAAMC,GAAStB,EAEpC,MAAO,CACLkB,EAAGlB,EAAKkB,EACRC,GAAevB,GACN,IAAIwC,KAAWd,EAAKC,KAAQC,GAA2B5B,EAAQF,IAAI8B,OAKhF,MAAM,IAAIa,UAAU,sCAAsCC,KAAKC,UAAUvC,MGvRdwC,CAAiBxC,IACnEnB,GAAUN,KAAKyC,SAASrB,OAAoBhB,GAEnD,OAAOE,EAAO4D,QAAQtB,GAWxB9C,KAAkBuB,EAAenB,GAE/B,OAASqB,GAAWvB,KAAKyC,SAASrB,OAAOlB,GAEzC,OAAOqB,EAAQF,GAQjBvB,QACE,MAAO,CAACM,EAASiB,IAAYrB,KAAKO,KAAKc,EAASjB,GAUlDN,OAAOuB,GACL,OAAOrB,KAAKmE,YAAYhD,IAAIiD,KAAK/C,GAQnCvB,YACE,gBDxFAuE,EACAzC,GAGF,MAAM0C,EAAS,IAAItD,IAgCnB,OAAO,IA9BP,cAA6BU,EAE3B5B,KAEMA,CAACF,GAAqBM,GACxBG,GAGF,MAAMkE,EAASD,EAAOnD,IAAIjB,GAE1B,GAAc,MAAVqE,EACF,OAAOA,EAGT,MAAOC,EAAapC,GAAS,IAAIT,EAAkBC,EAAS5B,KAAME,EAAKG,GAAMoE,QAW7E,OATIrC,IACFkC,EAAOhD,IAAIpB,EAAKsE,GAChBpC,EAAM,CACJlC,IAAAA,EACAmB,QAASrB,KACTqE,SAAUA,KAIPG,ICyDFE,CAAiB1E,KAAMA,KAAKyC,UAUrC3C,OAAO6E,GAEL,MAAMC,EAAkD,mBAAVD,EAAuBA,EAAQA,EAAME,QAEnF,OAAO,IAAItC,GAAgB,CAAcrC,EAAkCmB,KAEzE,MAAMyD,EAASF,EAAW1E,EAAKmB,IACxBf,EAAQiB,GAAWvB,KAAKyC,SAASrB,OAAOlB,GACzC6E,EAAQxD,EAAQF,GAEtB,OAAOyD,EAASxE,EAAO0E,QAAQD,EAAOD,EAAQzD,GAAW0D,MC5G/D,MAAME,EAANnF,cAGmBE,gBAA8D,GAE/EF,QAAQoF,GAGN,MAAMC,EAAqD,CAACD,GAI5D,OAFAlF,KAAKoF,WAAWC,QAAQF,GAEjB,IAAIG,GAAO,IAAMtF,KAAKoF,WAAWG,OAAOvF,KAAKoF,WAAWI,YAAYL,GAAQ,KAGrFrF,KAAKuB,EAAemB,GAElB,MAAMiD,OAAEA,GAAWzF,KAAKoF,WAExB,IAAKK,EACH,OAAOjD,GAAWV,EAGpB,MAAM4D,EAAW,EACZR,KAC6BS,EAC9BT,EAASd,UAAKwB,EAAWvE,IAG7B,IAAKmB,GAAsB,IAAXiD,EACd,OAAOC,EAAS1F,KAAKoF,WAAW,IAGlC,MAAMP,EAAuC7E,KAAKoF,WAAWpC,IAAI0C,GAMjE,OAJIlD,GACFqC,EAAMgB,KAAKrD,GAGNsD,EAAmBjB,GAG5B/E,QAAQS,GACN,OAAiB,MAAVA,IAGTT,QACIiF,EACAD,GAEF,OAAIC,IAAUjD,EACLgD,EAELA,IAAWhD,EACNiD,EAEFe,EAAmB,CAAChB,EAAQC,KAQvC,SAASe,EACLjB,GAEF,OAAOc,GAAU,KACf,IAAK,MAAMpF,KAAQsE,EAAO,CAExB,MAAM5C,EAAQ1B,IAEd,GAAa,MAAT0B,EACF,OAAOA,MAUf,MAAM8D,UAA4B9F,EAEhCH,SACE,OAAO,IAAImF,SAeOe,UACVnG,EAUVC,YACIC,GACAK,QACEA,GAGE,IAEND,MAAMJ,GACNC,KAAKI,QAAUA,GAAW,IAAI2F,EAAc/F,OChHhD,MAAMiG,UAAyBD,EAE7BlG,cACEK,MAAM,kBAGRL,KACIoG,GAEFA,EAAKxF,OACDwF,EAAK3F,QACF2F,EAAK7E,QAAQ8E,SACZD,EAAKzF,YAAcyF,EAAKlE,GAAKoE,aAc5BC,MAA8DJ,QCzB9DK,UACDN,EAgBVlG,YACIC,GACAK,QACEA,EAAOmG,UACPA,EAAYzE,GAIV,IAEN3B,MAAMJ,EAAM,CAAEK,QAAAA,IACdJ,KAAKuG,UAAYA,EAGnBzG,KACIoG,GAGF,MAAMjE,EAAQiE,EAAK3F,OAEN,MAAT0B,EACFiE,EAAKxF,OAAOuB,GACFiE,EAAKzF,aACfyF,EAAKxF,OAAOV,KAAKuG,UAAUL,EAAK7E,QAASrB,iBCpD/BwG,EAAiBC,EAAkB,IAAI3C,UAAU,sBAC/D,MAAO,KACL,MAAM2C,SCJGC,UAAqC9F,MAShDd,YACa6G,EACAC,EAA2D,GAC3D/F,EAUf,SACI8F,EACAE,GAGF,MAAMD,EAAUC,EAAaC,QACzB,CAACC,GAAM9D,EAAKwD,MACNM,EACFA,GAAO,KAEPA,EAAM,KAGNA,QADanB,IAAXa,EACK,GAAGxD,qBAAuBwD,KAE1B,GAAGxD,iBAKd,IAGJ,MAAO,kBAAkB0D,IAASC,IAjCHI,CAAoCL,EAAQC,IAEzEzG,MAAMU,GAJKb,YAAA2G,EACA3G,aAAA4G,EACA5G,aAAAa,SCDFoG,EAQXnH,YAAYuB,EAAiCsF,GAAA3G,YAAA2G,EAJrC3G,iBAAc,EAKpBA,KAAKkH,MAAQC,IACbnH,KAAKoH,KAAOD,EAAW,CACrBE,OAAQ,CACNV,OAAQ3G,KAAK2G,OACbW,UAAU,EACVC,MAAM,EACNC,SAAS,EACTC,OAAO,GAETtB,OAAQuB,MAGV,MAAMC,EAAgBtG,EAAQF,IAAIkF,GAElCsB,EAAcC,KAAK5H,KAAKkH,OACxBS,EAAcC,KAAK5H,KAAKoH,MAExBpH,KAAKkH,MAAMW,MAAKlB,IAEd,MAAMmB,EAAa9H,KAAKoH,KAAKW,GAAG5B,OAE5BQ,GACF3G,KAAKgI,MAAMrB,GAGbmB,EAAWG,SAIfnI,eAEE,MAAM+H,EAA2C7H,KAAKoH,KAAKS,KAAKK,GAC5DC,GAAU,EAAGd,OAAAA,KAAaA,KAGxBe,EAA+B,CACnCP,KAAAA,EACA/H,CAACuI,GAAqBjF,EAAcyE,GACpCS,IAAMC,GAAsBvI,KAAKwI,KAAKJ,EAAQG,IAGhD,OAAOH,EAGTtI,MAAMuB,EAAwBgD,GAC5BrE,KAAKsC,OAAS,KAEZ,MAAMmG,EAAMzI,KAAKoH,KAAKW,IACdV,QAAQV,OAAEA,GAAQR,OAAEA,GAAWsC,EAEnC9B,IAAW3G,KAAK2G,OAGlBtF,EAAQF,IAAIwF,GAAQ2B,IAAInC,GAAQ0B,KAAK,CACnC1B,OAAAA,EACAuC,QAAS,CAACC,GAAQnB,QAAAA,EAASC,MAAAA,EAAOmB,MAAAA,MAChC5I,KAAK6I,cAAcJ,EAAKjB,EAASC,EAAOmB,MA2JpDE,eACIzH,EACAgD,GACEgD,QAAQV,OAAEA,GAAQR,OAAEA,IAGxB,MAAM4C,EAAa,IAAIC,EAAkBrC,GAqBzC,aAnBMA,EAAOvE,MAAM,CAEjBuE,OAAAA,EACAR,OAAAA,EAEAhF,IAAI8H,GACK5H,EAAQF,IAAI8H,GAGrB/E,QAAQzC,GACC4C,EAASH,QAAQzC,GAAMyH,MAAM/C,GAGtCrG,OAAOqJ,GACLJ,EAAWK,OAAOD,MAKfJ,EAlLDM,CAAkBhI,EAASgD,EAAUoE,GAChCa,MAAK,EAAGC,UAAAA,MACPvJ,KAAK6I,cAAcJ,GAAK,GAAM,GACvBc,KAERD,MAAK,IAAMtJ,KAAK6I,cAAcJ,GAAK,GAAM,KACzCe,OAAMZ,GAASH,EAAItC,OAAO8B,IAAIW,MAKzC9I,YAAY2J,GACVzJ,KAAKkH,MAAMtE,GAAG6G,GAGR3J,cACJ2I,EACAjB,EACAC,EACAmB,GAGE5I,KAAKoH,KAAKW,GAAG5B,SAAWsC,EAAItC,OAE9BsC,EAAItC,OAAO8B,MAEXjI,KAAKoH,KAAKW,GAAKU,EAAM,CACnBpB,OAAQ,CACNV,OAAQ8B,EAAIpB,OAAOV,OACnBW,SAAUmB,EAAIpB,OAAOC,SACrBC,MAAM,EACNC,QAAAA,EACAC,MAAAA,EACAmB,MAAAA,GAEFzC,OAAQsC,EAAItC,QAKVrG,MAAM6G,GAEZ,MAAMR,GAAS,IAAIb,GAAS4D,MAAMlJ,KAAKoH,MAAMsC,SAAQd,IAEvC5I,KAAKoH,KAAKW,GAEd5B,SAAWA,IACjBnG,KAAKoH,KAAKW,GAAK,CACbV,OAAQ,IACHrH,KAAKoH,KAAKW,GAAGV,OAChBC,UAAU,EACVE,SAAS,EACTC,OAAO,EACPmB,MAAAA,GAEFzC,OAAAA,OAKAoB,IAASvH,KAAK2J,YAEpB3J,KAAKoH,KAAKW,GAAK,CACbV,OAAQ,CACNV,OAAAA,EACAW,UAAU,EACVC,KAAAA,EACAC,SAAS,EACTC,OAAO,GAETtB,OAAAA,GAGEoB,GACFvH,KAAKsC,SAIDxC,KAAKsI,EAA8BG,GAEzC,MAAMpC,EAAS,IAAIb,EAEfiD,GACFpC,EAAO+C,MAAMX,GAGf,MAAMV,EAAOO,EAAOP,KAAKK,GAAG0B,EAAYzD,IAClCmC,EAAyB,IAC1BF,EACHP,KAAAA,EACAgC,YAAaC,EAAuBjC,EAAMkC,GAC1CR,UAAWO,EAAuBjC,EAAMmC,GACxC7D,OAAAA,GAGF,IAAKA,EAAO8D,QACV9D,EAAOuD,SAAQd,IACb,MAAO5I,KAAK2J,YAAa,CAEvB,MAAMlB,EAAMzI,KAAKoH,KAAKW,GAEtB/H,KAAKoH,KAAKW,GAAK,CACbV,OAAQ,IACHoB,EAAIpB,OACPE,MAAM,EACNC,SAAS,EACTC,OAAO,EACPmB,MAAAA,GAEFzC,QAAQ,IAAIb,GAAS2C,IAAIW,IAG3BH,EAAItC,OAAO8B,IAAIW,QAId5I,KAAK2J,eAAe,CAGvB,MAAMlB,EAAMzI,KAAKoH,KAAKW,GAEtB/H,KAAKoH,KAAKW,GAAK,CACbV,OAAQ,IACHoB,EAAIpB,OACPE,MAAM,GAERpB,OAAQsC,EAAItC,QAGdnG,KAAKsC,SAIT,OAAOgG,GAgDX,MAAMU,EAMJlJ,YAA6BoK,GAAAlK,aAAAkK,EAHrBlK,eAA8BmK,QAAQC,UAI5CpK,KAAKuJ,UAAY,IAAIY,SAAQC,GAAWpK,KAAKqK,OAASD,IAGxDtK,OAAOqJ,GAEL,MAAMV,EAAwBzI,KAAKsK,UAAYtK,KAAKsK,UAC/ChB,KAAKH,GACLoB,SAAQ,IAAMvK,KAAKwK,MAAM/B,KAIxB3I,MAAM2I,GACRzI,KAAKsK,YAAc7B,IACrBzI,KAAKqK,OAAO5B,GACZzI,KAAKoJ,OAASqB,IACZ,MAAM,IAAI3G,UAAU,GAAG9D,KAAKkK,wEAOpC,SAASJ,EACLzC,EACAqD,GAEF,OAAOC,GAAUC,GAAYvD,EAAO,CAClClB,OAAQyE,EAASzE,OACjBuC,QAAS,CAACrH,EAASgG,KACbqD,EAAKrD,IACPuD,EAASlC,QAAQrH,EAASgG,GAC1BuD,EAASzE,OAAO8B,OACPZ,EAAOuB,OAChBgC,EAASzE,OAAO8B,IAAIZ,EAAOuB,YAMnC,SAASmB,GAAuBvC,QAAEA,IAChC,OAAOA,EAGT,SAASwC,GAAqBvC,MAAEA,IAC9B,OAAOA,ECnST,MAAMoD,EACYC,GAAe,CAACC,KAASC,IAAYD,KAAQE,EAAYC,KAAkBF,OAM7F,MAAMG,EAANrL,cAGmBE,gBAAamH,EAC1B,CAAC,IAAInG,MAGTlB,QAAQoF,GAEN,MAAOkG,GAAapL,KAAKoF,WAAW2C,GAC9B5B,EAAS,IAAIb,EAKnB,OAHA8F,EAAU9J,IAAI6E,EAAQjB,GACtBlF,KAAKoF,WAAW2C,GAAK,CAACqD,GAEfjF,EAAOuD,SAAQ,KAEpB,MAAO0B,GAAapL,KAAKoF,WAAW2C,GAEpCqD,EAAUC,OAAOlF,GAEjBnG,KAAKoF,WAAW2C,GAAK,CAACqD,MAI1BtL,KAAKuB,EAAemB,EAA8B8I,KAChD,OAAOtL,KAAKgF,QAAQxC,EAgBxB,SACInB,EACAkK,GAEF,OAAOA,EAAiB1D,KAAKK,GACzBsD,GACI,EAAEJ,KAAsCA,EAAUK,KAE5CC,KACKC,EACCA,EACIC,GAAa,IAAMR,EAAU9G,YAC7BuH,GAAQA,EAAKxK,KAEjByK,IAPNR,MAWVT,GAlC2BkB,CAAa1K,EAASrB,KAAKoF,aAG1DtF,UACE,OAAO,EAGTA,QAAQiF,EAA2BD,GACjC,OAAO4G,EAAU3G,EAAOD,GAAQoD,GAAG2C,IAiCvC,SAASiB,EAAoBE,GAC3B,OAAc,MAAPA,EAAcV,IAMvB,SAA6BU,GAC3B,OAAuB,iBAARA,GAAmC,mBAARA,IAAuBC,EAAcD,GAP7CE,CAAcF,GAAOG,EAAcH,GAAOV,EAASU,GAavF,MAAMI,UACMnM,EAGVoM,YACE,OAAOrM,KAGTF,SACE,OAAO,IAAIqL,GAoBf,MAAMmB,WACMzM,EAeVC,YACqByM,EACjBpK,GAIFhC,MAAMoM,EAAKxM,KAAO,OALCC,UAAAuM,EAMnBvM,KAAKmC,KAAO+D,IAEV,MAAMjE,EAAiDiE,EAAKsG,OAAOrK,GAEtD,MAATF,GACFiE,EAAKxF,OAAOuB,EAAMoG,KAAsBH,GACpC0B,EAAY1D,EAAK7E,QAAQF,IAAIkF,OArBvCjG,cACE,OAAOJ,KAAKuM,KAAKnM,QAGnBiM,YACE,OAAOrM,YAkCWyM,WACV5M,EAoBVC,YACIC,GACAK,QACEA,GAGE,IAEND,MAAMJ,GACNC,KAAKI,QAAUA,GAAW,IAAIgM,EAAwBpM,MAW9CF,YACNqC,GAIF,OAAO,IAAImK,GAAmBtM,KAAMmC,UCtO3BuK,WAAyBD,GAEpC3M,YAAYC,EAA+BmK,GACzC/J,MAAMJ,GADmCC,aAAAkK,EAI3CmC,YACE,OAAOrM,KAGTF,KACIoG,GAMF,MAAMyG,EAAQ,IAAI1F,EAAmBf,EAAK7E,QAASrB,KAAKkK,SAa5D,IACIvD,EAZAT,EAAKxF,OAAOiM,EAAMC,gBAClB1G,EAAK9D,OAAM,EAAGf,QAAAA,EAASgD,SAAAA,KAAesI,EAAMvK,MAAMf,EAASgD,KAE3DsI,EAAME,aASNlG,EATyC3G,KAAKkK,QAAShE,EAAK3F,KAYjD2H,GACTC,GAAU,IAAI2E,KAEZ,IAAIrD,EAEJ,IAAK,IAAIsD,EAAID,EAAWrH,OAAS,EAAGsH,GAAK,IACvCtD,EAAOqD,EAAWC,GACdtD,IAAS9C,KAF+BoG,GAO9C,OAAOtD,SC5CR,MAAMuD,GAA4CrN,OAAO,4BAKnDsN,GAWXnN,YAAY6G,EAAgC5G,EAAuBmN,GAAvBlN,UAAAD,EAAuBC,aAAAkN,EACjElN,KAAKE,IAAM,IAAIwM,GAAiB,GAAG3M,WAAe4G,GAElD,MAAMuC,MAAEA,EAAKiE,IAAEA,EAAG/K,MAAEA,GAAU8K,EAE9BlN,KAAKmN,IAAMC,EAAcD,GAAKE,IAAI1G,GAClC3G,KAAKkJ,MAAQkE,EAAclE,GAC3BlJ,KAAKsC,OAASF,EAAQA,EAAMgC,KAAK8I,GAAWpL,EAG9ChC,QACI6G,EACAtC,EACA8B,GAEF,IAAK,MAAMmH,KAAY3G,EAAOwG,IACxBG,IAAa3G,GACftC,EAASH,QAAQ,CAAEvB,EAAG2K,EAAUnK,GAAIwD,IAAUuC,MAAM/C,GAK1DrG,YAAYsC,GAEV,MAAMW,EAsBV,SAA2BX,GAEzB,MAAMuE,OAAEA,EAAMR,OAAEA,GAAW/D,EAE3B,OAAO6I,EACHsC,EACI5G,EAAOuC,OACPjG,GAAOA,IAAQ0D,GACRvE,EAAM8B,QAAQjB,GAAKiG,MAAM/C,IACzB,CACDlD,IAAAA,EACAqF,IAAKlG,EAAMjB,IAAI8B,GAAKqF,IAAIlG,OAjCvBoL,CAAkBpL,SAGpBqL,GAAsBrL,EAAOW,EAAM2K,MAI9CtL,EAAMgH,QAAON,gBAEL2E,GAAsBrL,EAAOW,EAAM4K,aAGrC3N,KAAKsC,OAAOF,KA2BtB,SAASqL,GACLrL,EACAW,EACA6K,GAGF,MAAMjH,OAAEA,EAAMR,OAAEA,GAAW/D,EACrByL,EAAYzK,GAAc,GAC1B0K,EAAW3H,EAAO2H,WAAWxE,KAAKuE,EAAWA,GAEnD,OAAO1D,QAAQ4D,KAAK,CAClBD,EACA3D,QACK6D,IACGjL,EACKC,KACG,EAAGC,IAAAA,EAAKqF,IAAAA,KAAUsF,EAAWtF,GAAKgB,KAC9BxH,GACA8G,GAAS,CAAC3F,EAAK2F,QAI9BU,MACI2E,IAEC,MAAMC,EAAWD,EAAQE,OAA0CC,GAEnE,OAAOF,EAASzI,QACV,IAAIiB,EAA6BC,EAAQuH,QAIxD5E,MACC+E,GACwB,kBAAXA,EAEFlE,QAAQmE,OAAOD,GAGjBA,IAKf,SAASX,GAAyBpF,GAChC,OAAOA,EAAIuB,YAGb,SAAS8D,GAAuBrF,GAC9B,OAAOA,EAAIiB,gBCzFAgF,GAaXzO,YAAYC,EAAcmN,EAAiC,IACzDlN,KAAKgN,IAA8B,IAAIC,GAAejN,KAAMD,EAAMmN,GAMpEtN,IAAKA,KACH,OAAOI,KAAKgN,IAA4B9M,IAM1CH,WACE,OAAOC,KAAKgN,IAA4BjN,KAQ1CmJ,YACE,OAAOlJ,KAAKgN,IAA4B9D,MAU1CiE,UACE,OAAOnN,KAAKgN,IAA4BG,IAM1CrN,CAACJ,GAAwB2E,GAEvB,MAAM8B,EAAS9B,EAASH,QAAQ,CAAEvB,EAAG3C,KAAMmD,GAAInD,OAI/C,OAFAA,KAAKgN,IAA4BwB,QAAQxO,KAAMqE,EAAU8B,GAElDA,EAwBTrG,MAAMsC,GACJ,OAAOpC,KAAKgN,IAA4B5K,MAAMA,GAGhDtC,WACE,MAAO,iBAAiBE,KAAKD,eCxGpB0O,WACDhC,GAqBV3M,YACIC,GACAK,QACEA,EAAOmG,UACPA,EAAYzE,GAIV,IAEN3B,MAAMJ,EAAMK,GACZJ,KAAKuG,UAAY,CAAClF,EAASnB,IAAQqG,EAAUlF,EAASnB,UAEhD,MAAM,IAAIS,EAAgBX,QAEhCA,KAAKqM,MAAQrM,KAAK0O,aACdxI,IACEA,EAAKxF,OAAOwF,EAAK3F,KAAK2H,GAAGyG,GACrB,IAAIC,IACEA,EAAInJ,OACC6F,EAASsD,EAAIA,EAAInJ,OAAS,IAG/BS,EAAKzF,aAAeyF,EAAKlE,GACpBkE,EAAKlE,GAGPsJ,EAAStL,KAAKuG,UAAUL,EAAK7E,QAASrB,cAO3DF,KACIoG,GAMF,IAAI2I,EAEJ3I,EAAK7E,QAAQF,IACTnB,KAAKqM,MACLnG,EAAKzF,YAAc,CAAEuB,GAAe,MAAXkE,EAAKlE,GAAasJ,EAASpF,EAAKlE,IAAMkE,EAAKlE,SAAO4D,EAF/EM,EAII4I,GAAMD,EAAYC,IACpBpF,SACEjD,GAAUoI,EAAYrI,EAAiBC,KAG3CP,EAAKxF,QAAO,IAAIqO,IAASF,KAAaE,YCjF7BC,WACDvC,GAoBV3M,YACIC,GACAK,QACEA,EAAOmG,UACPA,EAAYzE,GAIV,IAEN3B,MAAMJ,EAAMK,GACZJ,KAAKuG,UAAYA,EAvBnB8F,YACE,OAAOrM,KAyBTF,KACIoG,GAGF,MAAMjE,EAAQiE,EAAK3F,KAAK2H,GAAGyG,GAAS,IAAI3D,KACtC,GAAIA,EAAQvF,OAEV,OAAO6F,EAASN,EAAQA,EAAQvF,OAAS,IAI3C,IAAIwJ,EAEJ,GAAI/I,EAAKzF,YACPwO,EAAS/I,EAAKlE,OACT,CAEL,MAAMkN,EAAelP,KAAKuG,UAAUL,EAAK7E,QAASrB,MAElDiP,EAASC,GAAgB5D,EAAS4D,GAEpC,OAAc,MAAVD,EACKA,EAIFE,GAAuB,KAC5B,MAAM,IAAIxO,EAAgBX,aAI9BkG,EAAKxF,OAAOuB,EAAMiG,GACd0B,EAAY1D,EAAK7E,QAAQF,IAAIkF"}