{"version":3,"file":"a-iterable.d8c0bd88.js","sources":["../../../../../proc7ts/a-iterable/src/api.ts","../../../../../proc7ts/a-iterable/src/revertible-iterable.ts","../../../../../proc7ts/a-iterable/src/util.ts","../../../../../proc7ts/a-iterable/src/reverse.ts","../../../../../proc7ts/a-iterable/src/termination.ts","../../../../../proc7ts/a-iterable/src/transform.ts","../../../../../proc7ts/a-iterable/src/thru/thru-it.ts","../../../../../proc7ts/a-iterable/src/a-iterable.ts","../../../../../proc7ts/a-iterable/src/construction.ts","../../../../../proc7ts/a-iterable/src/objects.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\n/**\n * A type of elements of iterable.\n *\n * @typeparam T  A type of iterable.\n */\nexport type IterableElement<T extends Iterable<any>> = T extends Iterable<infer E> ? E : never;\n\n/**\n * Arbitrary class implementing `Iterable` interface.\n *\n * @typeparam T  A type of iterable.\n * @typeparam E  A type of elements to iterate.\n */\nexport interface IterableClass<T extends Iterable<E>, E = IterableElement<T>> extends Function {\n  prototype: T;\n  new (...args: any[]): T;\n}\n\n/**\n * Checks whether the given value is array-like.\n *\n * @param target  A value to check.\n *\n * @returns `true` if the `value` has a `length` property, or `false` otherwise.\n */\nexport function isArrayLike<T>(target: any): target is ArrayLike<T> {\n  return 'length' in target;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\n/**\n * An iterable which elements order can be reversed.\n *\n * Arrays implement this interface.\n */\nexport interface RevertibleIterable<T> extends Iterable<T> {\n\n  /**\n   * Returns an iterable containing this iterable's elements in reverse order.\n   *\n   * Corresponds to `Array.prototype.reverse()`. Note however, that the array counterpart reverses elements _in place_\n   * rather than creating a new array.\n   *\n   * @return Reversed iterable instance.\n   */\n  reverse(): Iterable<T>;\n\n}\n\n/**\n * Checks whether the given iterable is revertible.\n *\n * This is always `true` for arrays.\n *\n * @param iterable  Iterable to check.\n *\n * @returns `true` if `iterable` has a `reverse` property, or `false` otherwise.\n */\nexport function itsRevertible<T>(iterable: Iterable<T>): iterable is RevertibleIterable<T> {\n  return 'reverse' in iterable;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  return function *() { yield* iterable; }();\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>,\n): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>,\n): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (!reverse) {\n    return iterable;\n  }\n\n  const reversible = iterable as RevertibleIterable<T>;\n\n  reversible.reverse = reverse;\n\n  return reversible;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Constructs a reversed iterable.\n *\n * If the `source` iterable is an array-like structure, then uses `reverseArray()` function to revert the constructed\n * iterable.\n * If the `source` iterable is revertible, then uses its `reverse()` method to revert the constructed one.\n * Otherwise stores elements to array and reverts them with `reverseArray()` function.\n *\n * @param source  A source iterable.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseIt<T>(source: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): Iterable<T> {\n  if (isArrayLike(source)) {\n    return reverseArray(source);\n  }\n  if (itsRevertible(source)) {\n\n    const reversed = source.reverse();\n\n    return makeIt(() => itsIterator(reversed));\n  }\n  return reverseArray(Array.from(source));\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): Iterable<T> {\n  return makeIt(\n      function *() {\n\n        const len = array.length;\n\n        for (let i = len - 1; i >= 0; --i) {\n          yield array[i];\n        }\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Tests whether at least one element of the given `iterable` passes the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n * and return `true` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the callback function returned a truthy value for at least one element in the array, or `false`\n * otherwise. Returns `false` for empty iterable.\n */\nexport function itsSome<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (test(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  return itsIterator(iterable).next().value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: R, element: T) => R,\n    initialValue: R,\n): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { asis } from '@proc7ts/call-thru';\nimport { makeIt } from './util';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is R,\n): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (this: void, element: T) => boolean): Iterable<T> {\n  return makeIt(function *() {\n    for (const element of source) {\n      if (test(element)) {\n        yield element;\n      }\n    }\n  });\n}\n\n/**\n * Flattens the source iterable of iterables into a new iterable.\n *\n * Calling this function is the same as calling `flatMapIt(source, asis)`.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable of iterables.\n *\n * @returns A new iterable with each element of `source` being the flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): Iterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => Iterable<R>): Iterable<R>;\n\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R> = asis as (element: T) => Iterable<R>,\n): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield* convert(element);\n    }\n  });\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => R): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield convert(element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { asis, isNextCall, NextCall__symbol, noop } from '@proc7ts/call-thru';\nimport { flatMapIt } from '../transform';\nimport { IterableCallChain } from './iterable-call-chain';\n/** @hidden */\nimport Args = IterableCallChain.Args;\n/** @hidden */\nimport Out = IterableCallChain.Out;\n\n/**\n * Passes each element of the given iterable trough the {@link IterableCallChain chain of transformation passes}.\n *\n * The passes are preformed by `@proc7ts/call-thru`.\n *\n * @returns An iterable of transformed elements.\n */\nexport function thruIt<\n    T, Return1\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n): Iterable<Out<Return1>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n): Iterable<Out<Return2>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n): Iterable<Out<Return3>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    Args13 extends Args<Return12>, Return13,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n    pass13: (this: void, ...args: Args13) => Return13,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<T>(\n    it: Iterable<T>,\n    ...passes: ((...args: any[]) => any)[]\n): Iterable<any> {\n\n  let result: Iterable<any>[] = [];\n  const chain = (index: number): IterableCallChain => {\n\n    const lastPass = index >= passes.length;\n\n    ++index;\n\n    const pass = index < passes.length ? passes[index] : noop;\n    const handleResult = (callResult: any, arg: any): void => {\n      if (isNextCall(callResult)) {\n        callResult[NextCall__symbol](chain(index), pass);\n      } else if (lastPass) {\n        result.push([arg]);\n      } else {\n        chain(index).pass(pass, callResult);\n      }\n    };\n\n    return ({\n      call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n        handleResult(fn(...args), args);\n      },\n      pass<A>(fn: (arg: A) => any, arg: A): void {\n        handleResult(fn(arg), arg);\n      },\n      skip() {/* skip item */},\n      iterate<I>(fn: (this: void, arg: I) => void, iterable: Iterable<I>): void {\n        result.push({\n          *[Symbol.iterator]() {\n            for (const item of iterable) {\n\n              const oldResult = result;\n              const newResult: Iterable<any>[] = [];\n\n              try {\n                result = newResult;\n                handleResult(fn(item), item);\n              } finally {\n                result = oldResult;\n              }\n\n              for (const res of newResult) {\n                yield* res;\n              }\n            }\n          },\n        });\n      },\n    });\n  };\n\n  chain(0).iterate(passes[0], it);\n\n  return flatMapIt(result, asis);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { IterableClass, IterableElement } from './api';\nimport { ArrayLikeIterable } from './array-like-iterable';\nimport { reverseArray, reverseIt } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { itsEach, itsEvery, itsReduction, itsSome } from './termination';\nimport { IterableCallChain, thruIt } from './thru';\nimport { filterIt, flatMapIt, mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n/** @hidden */\nimport Args = IterableCallChain.Args;\n/** @hidden */\nimport Out = IterableCallChain.Out;\n\n/**\n * @internal\n */\nconst ArrayLikeIterableMethods: (keyof ArrayLikeIterable<any>)[] = [\n  'every',\n  'filter',\n  'flatMap',\n  'forEach',\n  'map',\n  'reduce',\n  'reverse',\n  'some',\n];\n\n/**\n * Abstract `Iterable` implementation with array-like iteration operations.\n *\n * @typeparam T  A type of elements.\n */\nexport abstract class AIterable<T> implements ArrayLikeIterable<T> {\n\n  /**\n   * Returns an iterable without elements.\n   *\n   * @returns An empty iterable instance.\n   */\n  static none<T>(): AIterable<T> {\n    return noneAIterable; // eslint-disable-line @typescript-eslint/no-use-before-define\n  }\n\n  /**\n   * Checks whether the given iterable is an array-like one.\n   *\n   * @param source  An iterable to check.\n   *\n   * @returns `true` is the `source` has all `ArrayLikeIterable` methods (like `Array` or `AIterable` instance),\n   * or `false` otherwise.\n   */\n  static is<T>(source: Iterable<T>): source is ArrayLikeIterable<T> {\n    return ArrayLikeIterableMethods.every(name => name in source);\n  }\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source array-like iterable.\n   *\n   * @return A `source` itself.\n   */\n  static of<T>(source: ArrayLikeIterable<T>): typeof source;\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Either `source` itself if it implements `ArrayLikeIterable` already (see `is()` method),\n   * or new [[AIterable]] instance iterating over the `source`.\n   */\n  static of<T>(source: Iterable<T>): AIterable<T>;\n\n  static of<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): ArrayLikeIterable<T> {\n    if (AIterable.is(source)) {\n      return source;\n    }\n    return AIterable.from(source);\n  }\n\n  /**\n   * Creates an `AIterable` instance that iterates over the same elements as the given one.\n   *\n   * Uses [[reverseIt]] function to reverse the constructed iterable.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Always new `AIterable` instance.\n   */\n  static from<T>(source: Iterable<T> | RevertibleIterable<T> | readonly T[]): AIterable<T> {\n    return makeAIterable(() => source, () => reverseIt(source));\n  }\n\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.every()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n   * and return `false` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n   * Returns `true` for empty iterable.\n   */\n  every(test: (this: void, element: T) => boolean): boolean {\n    return itsEvery(this, test);\n  }\n\n  /**\n   * Creates an iterable with all elements that pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n   * It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter(test: (this: void, element: T) => boolean): AIterable<T>;\n\n  /**\n   * Creates an iterable with all elements extending the given type.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @typeparam R  Target type.\n   * @param test  A predicate function to test that element extends the type R. Returns `true` to keep the element, or\n   * `false` otherwise. It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter<R extends T>(test: (this: void, element: T) => element is R): AIterable<R>;\n\n  filter(test: (this: void, element: T) => boolean): AIterable<T> {\n    return makeAIterable(\n        () => filterIt(this, test),\n        () => filterIt(this.reverse(), test),\n    );\n  }\n\n  /**\n   * First maps each element using a mapping function, then flattens the result into a new iterable.\n   *\n   * Corresponds to `Array.prototype.flatMap()`.\n   *\n   * Note that the overridden `flatMap` method of `ArrayLikeIterable` expects an array to be returned from `convert`\n   * callback, while in this method it may return arbitrary iterable.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n   *\n   * @returns A new [[AIterable]] with each element being the flattened result of the `convert` function call.\n   */\n  flatMap<R>(convert: (this: void, element: T) => Iterable<R>): AIterable<R> {\n    return makeAIterable(\n        () => flatMapIt(this, convert),\n        () => flatMapIt(this.reverse(), element => reverseIt(convert(element))),\n    );\n  }\n\n  /**\n   * Performs the given `action` for each element.\n   *\n   * Corresponds to `Array.prototype.forEach()`.\n   *\n   * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n   * parameter.\n   */\n  forEach(action: (this: void, element: T) => void): void {\n    itsEach(this, action);\n  }\n\n  /**\n   * Creates a new iterable with the results of calling a provided function on every element.\n   *\n   * Corresponds to `Array.prototype.map()`.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n   * parameter.\n   *\n   * @return A new [[AIterable]] with each element being the result of the `convert` function call.\n   */\n  map<R>(convert: (this: void, element: T) => R): AIterable<R> {\n    return makeAIterable(\n        () => mapIt(this, convert),\n        () => mapIt(this.reverse(), convert),\n    );\n  }\n\n  /**\n   * Applies a function against an accumulator and each element to reduce elements to a single value.\n   *\n   * Corresponds to `Array.prototype.reduce()`.\n   *\n   * @typeparam R  A type of reduced value.\n   * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n   * @param initialValue  Initial value passed to the first `reducer` call.\n   *\n   * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in this\n   * iterable.\n   */\n  reduce<R>(reducer: (this: void, prev: R, element: T) => R, initialValue: R): R {\n    return itsReduction(this, reducer, initialValue);\n  }\n\n  /**\n   * Constructs an iterable containing this iterable's elements in reverse order.\n   *\n   * By default this method converts iterable to array and then reverts its elements with [[reverseArray]] function.\n   *\n   * @return Reversed [[AIterable]] instance.\n   */\n  reverse(): AIterable<T> {\n    return makeAIterable(() => reverseArray(Array.from(this)), () => this);\n  }\n\n  /**\n   * Tests whether some element passed the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.some()`.\n   *\n   * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n   * and return `true` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for some element, or `false` otherwise.\n   * Returns `false` for empty iterable.\n   */\n  some(test: (this: void, element: T) => boolean): boolean {\n    return itsSome(this, test);\n  }\n\n  /**\n   * Passes each element of this iterable trough a chain of transformation passes.\n   *\n   * The passes are preformed by `@proc7ts/call-thru` library.\n   *\n   * @returns Next iterable of transformed elements.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n  ): AIterable<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AIterable<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AIterable<Out<Return3>>;\n\n  thru<R>(...fns: ((...args: any[]) => any)[]): AIterable<R> {\n\n    const thru = thruIt as any;\n\n    return makeAIterable(() => thru(this, ...fns));\n  }\n\n}\n\n/**\n * @internal\n */\nclass NoneAIterable extends AIterable<any> {\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  *[Symbol.iterator](): Iterator<any> {}\n\n  reverse(): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst noneAIterable = (/*#__PURE__*/ new NoneAIterable());\n\n/**\n * @internal\n */\nfunction makeAIterable<T>(\n    iterate: (this: void) => Iterable<T>,\n    reverse?: (this: void) => Iterable<T>,\n): AIterable<T> {\n\n  class Iterable extends AIterable<T> {\n\n    [Symbol.iterator](): Iterator<T> {\n      return itsIterator(iterate());\n    }\n\n    reverse(): Iterable {\n      if (!reverse) {\n        return super.reverse();\n      }\n      return AIterable.from(makeIt(() => itsIterator(reverse()), () => this));\n    }\n\n  }\n\n  return new Iterable();\n}\n\n/**\n * Extends an iterable class with `AIterable` API.\n *\n * @typeparam C  A type of iterable class to extend.\n * @typeparam E  A type of elements to iterate.\n * @param iterableClass  A class to extend.\n *\n * @returns A new class extending original `iterableClass` and implementing the missing [[AIterable]] methods.\n */\nexport function toAIterable<C extends IterableClass<any, E>, E = IterableElement<InstanceType<C>>>(\n    iterableClass: C,\n): C & IterableClass<AIterable<E>, E> {\n\n  class ExtendedIterable extends iterableClass {\n  }\n\n  const extended = ExtendedIterable;\n  const proto = extended.prototype;\n\n  ArrayLikeIterableMethods.forEach(name => {\n    if (!(name in proto)) {\n      Object.defineProperty(proto, name, {\n        configurable: true,\n        value: AIterable.prototype[name],\n      });\n    }\n  });\n\n  return extended as C & IterableClass<AIterable<E>, E>;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { reverseArray } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * Builds an iterable over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      function *() {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < array.length; ++i) {\n          yield array[i];\n        }\n      },\n      () => reverseArray(array),\n  );\n}\n\n/**\n * @internal\n */\nconst noneIterable: RevertibleIterable<any> = {\n\n  *[Symbol.iterator](): Iterator<any> {/* do not iterate */},\n\n  reverse() { return this; },\n\n};\n\n/**\n * Returns an iterable without elements.\n *\n * @typeparam T  A type of constructed iterable elements.\n *\n * @returns An empty iterable instance revertible to itself.\n */\nexport function overNone<T>(): RevertibleIterable<T> {\n  return noneIterable;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { overArray } from './construction';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Builds an iterable over the keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys from.\n */\nexport function overKeys<T extends object>(target: T): RevertibleIterable<keyof T> {\n  return overArray(Reflect.ownKeys(target) as (keyof T)[]);\n}\n\n/**\n * Object property entry. This is a tuple consisting of property key and value.\n */\nexport type ObjectEntry<T, K extends keyof T = keyof T> = [K, T[K]];\n\n/**\n * Builds an iterable over the key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys and values from.\n */\nexport function overEntries<T extends object>(target: T): RevertibleIterable<ObjectEntry<T>> {\n\n  const keys = overKeys(target);\n\n  function mapToEntries(_keys: Iterable<keyof T>): Iterable<ObjectEntry<T>> {\n    return mapIt(_keys, key => [key, target[key]] as ObjectEntry<T>);\n  }\n\n  return makeIt(() => itsIterator(mapToEntries(keys)), () => mapToEntries(keys.reverse()));\n}\n"],"names":["isArrayLike","target","itsRevertible","iterable","itsIterator","Symbol","iterator","itsIterable","makeIt","iterate","reverse","[object Object]","reversible","reverseIt","source","reverseArray","reversed","Array","from","array","i","length","itsEach","action","element","itsEmpty","next","done","itsEvery","test","itsFirst","value","itsLast","last","itsReduction","reducer","initialValue","reduced","filterIt","flatMapIt","convert","asis","mapIt","thruIt","it","passes","result","chain","index","lastPass","pass","noop","handleResult","callResult","arg","isNextCall","NextCall__symbol","push","fn","args","item","oldResult","newResult","res","ArrayLikeIterableMethods","AIterable","noneAIterable","every","name","is","makeAIterable","this","itsSome","fns","thru","NoneAIterable","Iterable","super","overArray","noneIterable","overNone","overEntries","keys","Reflect","ownKeys","overKeys","mapToEntries","_keys","key"],"mappings":"0EA6BgBA,EAAeC,GAC7B,MAAO,WAAYA,WCELC,EAAiBC,GAC/B,MAAO,YAAaA,WClBNC,EAAeD,GAC7B,OAAOA,EAASE,OAAOC,qBAUTC,EAAeJ,GAC7B,OAAO,kBAAsBA,EAAtB,YA0BOK,EACZC,EACAC,GAGF,MAAMP,EAAwB,CAC5BQ,CAACN,OAAOC,UAAWG,GAGrB,IAAKC,EACH,OAAOP,EAGT,MAAMS,EAAaT,EAInB,OAFAS,EAAWF,QAAUA,EAEdE,WClDOC,EAAaC,GAC3B,GAAId,EAAYc,GACd,OAAOC,EAAaD,GAEtB,GAAIZ,EAAcY,GAAS,CAEzB,MAAME,EAAWF,EAAOJ,UAExB,OAAOF,EAAO,IAAMJ,EAAYY,IAElC,OAAOD,EAAaE,MAAMC,KAAKJ,aAUjBC,EAAgBI,GAC9B,OAAOX,GACH,YAIE,IAAK,IAAIY,EAFGD,EAAME,OAEC,EAAGD,GAAK,IAAKA,QACxBD,EAAMC,eC/BNE,EAAWnB,EAAuBoB,GAChD,IAAK,MAAMC,KAAWrB,EACpBoB,EAAOC,YAWKC,EAAStB,GACvB,QAASC,EAAYD,GAAUuB,OAAOC,cAcxBC,EAAYzB,EAAuB0B,GACjD,IAAK,MAAML,KAAWrB,EACpB,IAAK0B,EAAKL,GACR,OAAO,EAGX,OAAO,WA+BOM,EAAY3B,GAC1B,OAAOC,EAAYD,GAAUuB,OAAOK,eActBC,EAAW7B,GACzB,GAAIH,EAAYG,GACd,OAAOA,EAASA,EAASkB,OAAS,GAEpC,GAAInB,EAAcC,GAChB,OAAO2B,EAAS3B,EAASO,WAG3B,IAAIuB,EAEJ,IAAK,MAAMT,KAAWrB,EACpB8B,EAAOT,EAGT,OAAOS,WAgBOC,EACZ/B,EACAgC,EACAC,GAGF,IAAIC,EAAUD,EAEd,IAAK,MAAMZ,KAAWrB,EACpBkC,EAAUF,EAAQE,EAASb,GAG7B,OAAOa,WClGOC,EAAYxB,EAAqBe,GAC/C,OAAOrB,GAAO,YACZ,IAAK,MAAMgB,KAAWV,EAChBe,EAAKL,WACDA,eA+BEe,EACZzB,EACA0B,EAAmDC,GAErD,OAAOjC,GAAO,YACZ,IAAK,MAAMgB,KAAWV,QACb0B,EAAQhB,eAcLkB,EAAY5B,EAAqB0B,GAC/C,OAAOhC,GAAO,YACZ,IAAK,MAAMgB,KAAWV,QACd0B,EAAQhB,eCwKJmB,EACZC,KACGC,GAGL,IAAIC,EAA0B,GAC9B,MAAMC,EAASC,IAEb,MAAMC,EAAWD,GAASH,EAAOxB,OAI3B6B,IAFJF,EAEmBH,EAAOxB,OAASwB,EAAOG,GAASG,EAC/CC,EAAe,CAACC,EAAiBC,KACjCC,EAAWF,GACbA,EAAWG,GAAkBT,EAAMC,GAAQE,GAClCD,EACTH,EAAOW,KAAK,CAACH,IAEbP,EAAMC,GAAOE,KAAKA,EAAMG,IAI5B,OACE1C,KAAsB+C,EAAyBC,GAC7CP,EAAaM,KAAMC,GAAOA,IAE5BhD,KAAQ+C,EAAqBJ,GAC3BF,EAAaM,EAAGJ,GAAMA,IAExB3C,SACAA,QAAW+C,EAAkCvD,GAC3C2C,EAAOW,KAAK,CACV9C,EAAEN,OAAOC,YACP,IAAK,MAAMsD,KAAQzD,EAAU,CAE3B,MAAM0D,EAAYf,EACZgB,EAA6B,GAEnC,IACEhB,EAASgB,EACTV,EAAaM,EAAGE,GAAOA,WAEvBd,EAASe,EAGX,IAAK,MAAME,KAAOD,QACTC,SAWrB,OAFAhB,EAAM,GAAGtC,QAAQoC,EAAO,GAAID,GAErBL,EAAUO,EAAQL,GChT3B,MAAMuB,EAA6D,CACjE,QACA,SACA,UACA,UACA,MACA,SACA,UACA,cAQoBC,EAOpBtD,cACE,OAAOuD,EAWTvD,UAAaG,GACX,OAAOkD,EAAyBG,MAAMC,GAAQA,KAAQtD,GAsBxDH,UAAaG,GACX,OAAImD,EAAUI,GAAGvD,GACRA,EAEFmD,EAAU/C,KAAKJ,GAYxBH,YAAeG,GACb,OAAOwD,EAAc,IAAMxD,EAAQ,IAAMD,EAAUC,IAgBrDH,MAAMkB,GACJ,OAAOD,EAAS2C,KAAM1C,GA8BxBlB,OAAOkB,GACL,OAAOyC,EACH,IAAMhC,EAASiC,KAAM1C,GACrB,IAAMS,EAASiC,KAAK7D,UAAWmB,IAiBrClB,QAAW6B,GACT,OAAO8B,EACH,IAAM/B,EAAUgC,KAAM/B,GACtB,IAAMD,EAAUgC,KAAK7D,UAAWc,GAAWX,EAAU2B,EAAQhB,MAYnEb,QAAQY,GACND,EAAQiD,KAAMhD,GAchBZ,IAAO6B,GACL,OAAO8B,EACH,IAAM5B,EAAM6B,KAAM/B,GAClB,IAAME,EAAM6B,KAAK7D,UAAW8B,IAgBlC7B,OAAUwB,EAAiDC,GACzD,OAAOF,EAAaqC,KAAMpC,EAASC,GAUrCzB,UACE,OAAO2D,EAAc,IAAMvD,EAAaE,MAAMC,KAAKqD,OAAQ,IAAMA,MAcnE5D,KAAKkB,GACH,gBH9KuB1B,EAAuB0B,GAChD,IAAK,MAAML,KAAWrB,EACpB,GAAI0B,EAAKL,GACP,OAAO,EAGX,OAAO,EGwKEgD,CAAQD,KAAM1C,GAoPvBlB,QAAW8D,GAET,MAAMC,EAAO/B,EAEb,OAAO2B,EAAc,IAAMI,EAAKH,QAASE,KAQ7C,MAAME,UAAsBV,EAG1BtD,EAAEN,OAAOC,aAETK,UACE,OAAO4D,MAQX,MAAML,MAAmCS,EAKzC,SAASL,EACL7D,EACAC,GAGF,MAAMkE,UAAiBX,EAErBtD,CAACN,OAAOC,YACN,OAAOF,EAAYK,KAGrBE,UACE,OAAKD,EAGEuD,EAAU/C,KAAKV,EAAO,IAAMJ,EAAYM,KAAY,IAAM6D,OAFxDM,MAAMnE,WAOnB,OAAO,IAAIkE,WCtgBGE,EAAa3D,GAC3B,OAAOX,GACH,YAEE,IAAK,IAAIY,EAAI,EAAGA,EAAID,EAAME,SAAUD,QAC5BD,EAAMC,KAGhB,IAAML,EAAaI,IAOzB,MAAM4D,EAAwC,CAE5CpE,EAAEN,OAAOC,cAETK,UAAY,OAAO4D,gBAWLS,IACd,OAAOD,WCdOE,EAA8BhF,GAE5C,MAAMiF,WAlBmCjF,GACzC,OAAO6E,EAAUK,QAAQC,QAAQnF,IAiBpBoF,CAASpF,GAEtB,SAASqF,EAAaC,GACpB,OAAO7C,EAAM6C,EAAOC,GAAO,CAACA,EAAKvF,EAAOuF,KAG1C,OAAOhF,EAAO,IAAMJ,EAAYkF,EAAaJ,IAAQ,IAAMI,EAAaJ,EAAKxE"}