{"version":3,"file":"input-aspects.f8acf040.js","sources":["../../../../../frontmeans/input-aspects/src/applied-aspect.ts","../../../../../frontmeans/input-aspects/src/aspect.ts","../../../../../frontmeans/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../../../frontmeans/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../../../frontmeans/input-aspects/src/aspects/role.aspect.ts","../../../../../frontmeans/input-aspects/src/aspect.impl.ts","../../../../../frontmeans/input-aspects/src/noop-converter.impl.ts","../../../../../frontmeans/input-aspects/src/converter.ts","../../../../../frontmeans/input-aspects/src/builder.impl.ts","../../../../../frontmeans/input-aspects/src/builder.ts","../../../../../frontmeans/input-aspects/src/control.impl.ts","../../../../../frontmeans/input-aspects/src/control.ts","../../../../../frontmeans/input-aspects/src/containers/container.control.ts","../../../../../frontmeans/input-aspects/src/containers/parents.aspect.ts","../../../../../frontmeans/input-aspects/src/element.control.ts","../../../../../frontmeans/input-aspects/src/data/mode.aspect.ts","../../../../../frontmeans/input-aspects/src/data/data.aspect.ts","../../../../../frontmeans/input-aspects/src/containers/group.control.ts","../../../../../frontmeans/input-aspects/src/validation/require-nothing.validator.ts","../../../../../frontmeans/input-aspects/src/validation/validator.impl.ts","../../../../../frontmeans/input-aspects/src/validation/validator.ts","../../../../../frontmeans/input-aspects/src/validation/validation.aspect.ts","../../../../../frontmeans/input-aspects/src/validation/require-all.validator.ts","../../../../../frontmeans/input-aspects/src/validation/require-present.validator.ts","../../../../../frontmeans/input-aspects/src/submit.aspect.ts","../../../../../frontmeans/input-aspects/src/data/modes/mode-by-form.ts","../../../../../frontmeans/input-aspects/src/data/modes/mode-by-validity.ts","../../../../../frontmeans/input-aspects/src/elements/abstract-element.control.ts","../../../../../frontmeans/input-aspects/src/elements/text.control.ts","../../../../../frontmeans/input-aspects/src/elements/focus/focus.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/focus/status.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/forms/form-element.control.ts","../../../../../frontmeans/input-aspects/src/elements/forms/submit-button.control.ts","../../../../../frontmeans/input-aspects/src/elements/style/styled-element.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/style/css-classes.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/style/css-error.ts","../../../../../frontmeans/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["import { noop, valueProvider } from '@proc7ts/primitives';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\nconst nullInAspect$: InAspect.Applied<any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * Creates an aspect applied to control with `null` instance value.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n *\n * @returns Applied input aspect.\n */\nexport function nullInAspect<TValue, TInstance>(): InAspect.Applied<TValue, TInstance | null> {\n  return nullInAspect$;\n}\n\n/**\n * Creates an aspect applied to control with known instance.\n *\n * An instance remains as is when converted to another control.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam instance - Known aspect instance type.\n *\n * @returns Applied input aspect.\n */\nexport function knownInAspect<TValue, TInstance>(instance: TInstance): InAspect.Applied<TValue, TInstance> {\n  return {\n    instance,\n    convertTo(_target) {\n      return this as InAspect.Applied<any, TInstance>;\n    },\n  };\n}\n\n/**\n * Creates an aspect applied to control with known inconvertible instance.\n *\n * When converted to another control with the same value, an aspect instance remains as is.\n *\n * When converted to another control with another value, an aspect instance replaced by `null`.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n * @param control - Target control to apply an aspect to.\n * @param aspectKey - Applied aspect key.\n * @param instance - Known aspect instance type. Defaults to `null`.\n *\n * @returns Applied input aspect.\n */\nexport function inconvertibleInAspect<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance | null, TKind>,\n    instance: TInstance | null = null,\n): InAspect.Applied<TValue, TInstance | null> {\n  return builtInAspect$(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * Creates an aspect applied to control with built instance.\n *\n * When converted to another control with the same value, an aspect instance remains as is.\n *\n * When converted to another control with another value, an aspect instance is built again with original control\n * passed to the builder as a second parameter.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n * @param control - Target control to apply an aspect to.\n * @param aspectKey - Applied aspect key.\n * @param build - Aspect instance builder function. Accepts target control and optionally an original one as parameters.\n *\n * @returns Applied input aspect.\n */\nexport function builtInAspect<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance, TKind>,\n    build: <TValue>(this: void, control: InControl<TValue>, origin?: InControl<any>) => TInstance,\n): InAspect.Applied<TValue, TInstance> {\n  return builtInAspect$(control, aspectKey, build);\n}\n\nfunction builtInAspect$<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance, TKind>,\n    build: <TValue>(this: void, control: InControl<TValue>, origin?: InControl<any>) => TInstance,\n    instance?: TInstance,\n    origin?: InControl<any>,\n): InAspect.Applied<TValue, TInstance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n\n  return {\n    instance,\n    convertTo<TTo>(target: InControl<TTo>): InAspect.Applied<TTo, TInstance> {\n      return builtInAspect$<TTo, TInstance, TKind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<TValue>): InAspect.Applied<TValue, TInstance> | undefined {\n      return builtInAspect$(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as TInstance | undefined) || build(target),\n      );\n    },\n  };\n}\n","import { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n */\nexport interface InAspect<TInstance, TKind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeParam TValue - Input value type.\n   * @param control - Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, TInstance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\n/**\n * @category Aspect\n */\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   */\n  export interface Key<TInstance, TKind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<TInstance, TKind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TConvertedInstance - A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<TValue, TInstance, TConvertedInstance extends TInstance = TInstance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: TInstance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by {@link InControl.convert} method.\n     *\n     * @typeParam TTargetValue - Converted input value type.\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<TTargetValue>(target: InControl<TTargetValue>): Applied<TTargetValue, TConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of {@link convertTo} when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<TValue>): Applied<TValue, TInstance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Result<TInstance, TValue, TKind extends Kind> =\n        Applied<TValue, Instance<TInstance, TValue, TKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Instance<TInstance, TValue, TKind extends Kind> =\n        ReturnType<Map<TInstance, TValue>[TKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     */\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): TInstance;\n\n    }\n\n  }\n\n}\n","import { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { knownInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * {@link InNamespaceAliaser.to} converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return knownInAspect(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param nsAlias - Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? knownInAspect(nsAlias) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { knownInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by {@link InRenderScheduler.to} converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return knownInAspect(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param scheduler - Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(scheduler: InRenderScheduler): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? knownInAspect(scheduler) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { AfterEvent, AfterEvent__symbol, EventKeeper, mapAfter_, trackValue } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\n\nconst InRole__aspect: InAspect<InRole<any>, 'role'> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InRole<TValue>> {\n    return {\n      instance: new InControlRole<TValue>(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * A role of input control.\n *\n * Contains arbitrary named roles. A special role `'default'` considered active when no other roles activated.\n *\n * Roles may be used to conditionally activate other input aspects of the control.\n *\n * @typeParam TValue - Input value type.\n */\nexport abstract class InRole<TValue> implements EventKeeper<[InRole.Active]> {\n\n  static get [InAspect__symbol](): InAspect<InRole<any>, 'role'> {\n    return InRole__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of active roles.\n   *\n   * The `[AfterEvent__symbol]` method returns this value.\n   */\n  abstract readonly read: AfterEvent<[InRole.Active]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InRole.Active]> {\n    return this.read;\n  }\n\n  /**\n   * Adds named role to control.\n   *\n   * The named role becomes activate. To deactivate it the returned supply has to be cut off.\n   *\n   * The same role may be added multiple times. In that case the role will be deactivated once all role supplies cut\n   * off.\n   *\n   * @param role - A name of the role to add.\n   *\n   * @returns A role supply. Removes the added role once cut off.\n   */\n  abstract add(role: string): Supply;\n\n  /**\n   * Registers an activator of the given role.\n   *\n   * The given activator would be issued once the given role {@link add activated}. A supply instance returned\n   * by activator call will be cut off once the role deactivated.\n   *\n   * @param role - Target role name.\n   * @param activator - Role activator.\n   *\n   * @returns Activator supply. Removes the registered activator once cut off.\n   */\n  abstract when(role: string, activator: InRole.Activator<TValue>): Supply;\n\n}\n\nexport namespace InRole {\n\n  /**\n   * An activator signature of input control role.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export type Activator<TValue> =\n  /**\n   * @param control - A control the role is activate for.\n   * @param role - Activated role name.\n   * @param active - Active control role.\n   *\n   * @returns Activation supply peer. Its supply will be cut off once the role deactivated or activator removed. It is\n   * expected that this supply performs deactivation once cut off.\n   */\n      (\n          this: void,\n          control: InControl<TValue>,\n          role: string,\n          active: Active,\n      ) => SupplyPeer;\n\n  /**\n   * Active input control role.\n   *\n   * Contains all roles {@link InRole.add added} to control.\n   *\n   * Implements an `Iterable` interface by iterating over all active role names.\n   */\n  export interface Active extends Iterable<string> {\n\n    /**\n     * Checks whether the given role is active.\n     *\n     * @param role - Target role name.\n     *\n     * @returns `true` if the given role is {@link InRole.add added} to controller, or `false` otherwise.\n     */\n    has(role: string): boolean;\n\n  }\n\n}\n\nclass InRole$Active {\n\n  static create(): InRole$Active {\n\n    const result = new InRole$Active(new Map());\n\n    result.add('default', true);\n\n    return result;\n  }\n\n  readonly active: InRole.Active;\n  private _activate: (this: void) => void = noop;\n  private _defaultSupply!: Supply;\n\n  private constructor(\n      readonly roles: Map<string, InRole$Named>,\n  ) {\n    this.active = {\n      [Symbol.iterator]() {\n        return roles.keys();\n      },\n      has(role: string) {\n        return roles.has(role);\n      },\n    };\n  }\n\n  modify(): InRole$Active {\n\n    const result = new InRole$Active(this.roles);\n\n    result._defaultSupply = this._defaultSupply;\n\n    return result;\n  }\n\n  add(role: string, isDefault: boolean): Supply | undefined {\n\n    const named = this.roles.get(role);\n\n    if (named) {\n      // Already active.\n      ++named.active;\n      return;\n    }\n\n    const supply = new Supply();\n\n    this.roles.set(\n        role,\n        {\n          active: 1,\n          supply,\n        },\n    );\n\n    if (isDefault) {\n      this._defaultSupply = supply.whenOff(() => {\n\n        const toRemove = this.roles.get(role)!;\n\n        if (!--toRemove.active) {\n          this.roles.delete(role);\n        }\n      });\n    } else {\n\n      const defaultSupply = this._defaultSupply;\n\n      this.activateBy(() => defaultSupply.off());\n    }\n\n    return supply;\n  }\n\n  remove(role: string, reason: unknown): void {\n\n    const named = this.roles.get(role)!;\n\n    if (--named.active) {\n      // Still active.\n      return;\n    }\n\n    this.roles.delete(role);\n    this.activateBy(() => named.supply.off(reason));\n  }\n\n  activateBy(activator: () => void): void {\n\n    const prevActivator = this._activate;\n\n    this._activate = () => {\n      prevActivator();\n      activator();\n    };\n  }\n\n  activate(): void {\n\n    const activator = this._activate;\n\n    this._activate = noop;\n\n    activator();\n  }\n\n}\n\ninterface InRole$Named {\n  active: number;\n  readonly supply: Supply;\n}\n\nclass InControlRole<TValue> extends InRole<TValue> {\n\n  private readonly _active = trackValue<InRole$Active>(InRole$Active.create());\n  private readonly _activators = new Map<string, Map<Supply, InRole.Activator<TValue>>>();\n  readonly read: AfterEvent<[InRole.Active]>;\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n    this._active.on(active => active.activate());\n    this._active.supply.needs(_control);\n    this.read = this._active.read.do(mapAfter_(({ active }) => active));\n  }\n\n  add(role: string): Supply {\n\n    const active = this._active.it.modify();\n\n    this._add(active, role);\n    this._active.it = active;\n\n    return new Supply(reason => {\n\n      const active = this._active.it.modify();\n\n      active.remove(role, reason);\n      if (!active.roles.size) {\n        // No more active roles left.\n        // Enable `default` role.\n        this._add(active, 'default', true);\n      }\n\n      this._active.it = active;\n    });\n  }\n\n  when(role: string, activator: InRole.Activator<TValue>): Supply {\n\n    let activators = this._activators.get(role);\n\n    if (!activators) {\n      activators = new Map();\n      this._activators.set(role, activators);\n    }\n\n    const supply = new Supply().needs(this._control);\n\n    activators.set(\n        supply,\n        (control, role, active) => activator(control, role, active).supply.needs(supply),\n    );\n    supply.whenOff(() => {\n      activators!.delete(supply);\n      if (!activators!.size) {\n        this._activators.delete(role);\n      }\n    });\n\n    const named = this._active.it.roles.get(role);\n\n    if (named) {\n      // The role already active.\n      // Issue activator immediately.\n      named.supply.cuts(activator(this._control, role, this._active.it.active));\n    }\n\n    return supply;\n  }\n\n  private _add(active: InRole$Active, role: string, isDefault = false): void {\n\n    const activatedSupply = active.add(role, isDefault);\n\n    if (activatedSupply) {\n      // Role activated\n\n      const activators = this._activators.get(role);\n\n      if (activators) {\n        // Issue activators\n        for (const activator of activators.values()) {\n          activatedSupply.cuts(activator(this._control, role, this._active.it.active));\n        }\n      }\n    }\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input role application type.\n       */\n      role(): InRole<TValue>;\n\n    }\n\n  }\n\n}\n","import { InAspect, InAspect__symbol } from './aspect';\n\n/**\n * @internal\n */\nexport function isAspectKey<TInstance, TKind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<TInstance, TKind> {\n  return InAspect__symbol in value;\n}\n","import type { InConverter } from './converter';\n\n/**\n * @internal\n */\nexport const noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(_aspect): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nexport function noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n","import { arrayOfElements, isPresent, noop, valueProvider } from '@proc7ts/primitives';\nimport { filterArray, itsReduction, overElementsOf } from '@proc7ts/push-iterator';\nimport type { InAspect } from './aspect';\nimport type { InControl } from './control';\nimport { noopInConverter } from './noop-converter.impl';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n */\nexport type InConverter<TFrom, TTo> =\n    | InConverter.Conversion<TFrom, TTo>\n    | InConverter.Factory<TFrom, TTo>;\n\n/**\n * @category Converter\n */\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Conversion<TFrom, TTo> =\n      | InConverter.Value.Conversion<TFrom, TTo>\n      | InConverter.Aspect.Conversion<TTo>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Value<TFrom, TTo> =\n      | InConverter.Value.Factory<TFrom, TTo>\n      | InConverter.Value.Conversion<TFrom, TTo>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Aspect<TFrom, TTo = TFrom> =\n      | InConverter.Aspect.Conversion<TTo>\n      | InConverter.Aspect.Factory<TFrom, TTo>;\n\n}\n\n/**\n * @category Converter\n */\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> =\n  /**\n   * @param from - Original input control.\n   * @param to - Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<TFrom>,\n          to: InControl<TTo>,\n      ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export interface Conversion<TFrom, TTo> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value - Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: TFrom): TTo;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value - A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: TTo): TFrom;\n\n  }\n\n}\n\n/**\n * @category Converter\n */\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo = TFrom> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TTo>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Conversion<TValue> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeParam TValue - Input value type.\n * @param converters - Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<TValue>(\n    ...converters: InConverter.Aspect<TValue, TValue>[]\n): InConverter.Aspect.Factory<TValue, TValue>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter?: InConverter<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo>;\n\nexport function intoConvertedBy<TFrom, TTo>(\n    valueOrAspectConverter?: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo> {\n\n  type AspectApplicator = <TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = converters.map<InConverter.Aspect.Factory<TFrom, TTo>>(inConverter);\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<TFrom, TTo> => {\n\n    const conversion = converter(from, to);\n    const conversions = overElementsOf<InConverter.Conversion<TFrom, TTo>>(\n        [conversion],\n        filterArray<InConverter.Aspect.Conversion<TTo> | undefined, InConverter.Aspect.Conversion<TTo>>(\n            aspectConverters.map(acf => acf(from, to)),\n            isPresent,\n        ),\n    );\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<TFrom, TTo>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeParam TValue - Input value type.\n * @param aspects - Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<TValue>(\n    aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[],\n): InConverter.Aspect.Factory<TValue> {\n  return aspects\n      ? intoConvertedBy(...arrayOfElements(aspects))\n      : intoConvertedBy<TValue>();\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion - Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<TFrom, TTo>(\n    conversion: InConverter.Conversion<TFrom, TTo>,\n): conversion is InConverter.Aspect.Conversion<TTo> {\n  return !(conversion as Partial<InConverter.Value.Conversion<TFrom, TTo>>).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Aspect<TFrom, TTo>,\n): InConverter.Aspect.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo>;\n\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo> | InConverter.Aspect.Factory<TFrom, TTo> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","import { InAspect } from './aspect';\nimport { InControl } from './control';\nimport { InConverter, intoConvertedBy } from './converter';\n\n/**\n * @internal\n */\nexport const InBuilder$Impl__symbol = (/*#__PURE__*/ Symbol('InBuilder.impl'));\n\n/**\n * @internal\n */\nexport class InBuilder$Impl<TControl extends InControl<TValue>, TValue> {\n\n  private readonly _aspectsByKey = new Map<InAspect<any, any>, InConverter.Aspect.Factory<TValue>>();\n  private _commonAspects: InConverter.Aspect.Factory<TValue> | undefined = undefined;\n  private _setup: ((control: TControl) => void) | undefined = undefined;\n\n  addAspect(aspect: InAspect<any, any>, converter: InConverter.Aspect<TValue>): void {\n\n    const prev = this._aspectsByKey.get(aspect);\n\n    this._aspectsByKey.set(aspect, prev ? intoConvertedBy(prev, converter) : intoConvertedBy(converter));\n  }\n\n  addAspects(aspects: readonly InConverter.Aspect<TValue>[]): void {\n    this._commonAspects = this._commonAspects\n        ? intoConvertedBy(this._commonAspects, ...aspects)\n        : intoConvertedBy(...aspects);\n  }\n\n  setup(setup: (control: TControl) => void): void {\n\n    const prev = this._setup;\n\n    if (prev) {\n      this._setup = control => {\n        prev(control);\n        setup(control);\n      };\n    } else {\n      this._setup = setup;\n    }\n  }\n\n  build(factory: InControl.Factory<TControl, TValue>): TControl {\n\n    const control = factory({ aspects: this._aspects() });\n\n    // Control setup\n    if (this._setup) {\n      control.setup(this._setup);\n    }\n\n    return control;\n  }\n\n  private _aspects(): InConverter.Aspect<TValue> | undefined {\n    if (this._aspectsByKey.size) {\n\n      const byKey = intoConvertedByKey(this._aspectsByKey);\n\n      return this._commonAspects ? intoConvertedBy(byKey, this._commonAspects) : byKey;\n    }\n\n    return this._commonAspects;\n  }\n\n}\n\nfunction intoConvertedByKey<TValue>(\n    byKey: Map<InAspect<any, any>, InConverter.Aspect.Factory<TValue>>,\n): InConverter.Aspect.Factory<TValue> {\n  return (from, to) => ({\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<any, any>,\n    ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n\n      const converter = byKey.get(aspect);\n\n      return converter && converter(from, to).applyAspect(aspect);\n    },\n  });\n}\n","import { InAspect, InAspect__symbol } from './aspect';\nimport { isAspectKey } from './aspect.impl';\nimport { InBuilder$Impl, InBuilder$Impl__symbol } from './builder.impl';\nimport { InControl } from './control';\nimport { InConverter } from './converter';\n\n/**\n * User input control builder.\n *\n * @category Control\n * @typeParam TControl - Control type.\n * @typeParam TValue - Input value type.\n */\nexport class InBuilder<TControl extends InControl<TValue>, TValue = InControl.ValueType<TControl>> {\n\n  /**\n   * @internal\n   */\n  private readonly [InBuilder$Impl__symbol]: InBuilder$Impl<TControl, TValue> = new InBuilder$Impl();\n\n  /**\n   * Registers an aspect to add to the built control.\n   *\n   * @param aspectKey - A key of aspect to add.\n   * @param converter - An aspect converter to the built control from the {@link inValueOf same-valued one}.\n   *\n   * @returns `this` builder instance.\n   */\n  addAspect(aspectKey: InAspect.Key<any, any>, converter: InConverter.Aspect<TValue>): this {\n    this[InBuilder$Impl__symbol].addAspect(aspectKey[InAspect__symbol], converter);\n    return this;\n  }\n\n  /**\n   * Registers arbitrary aspects to add to the built control.\n   *\n   * These aspects always applied after {@link addAspect concrete} ones.\n   *\n   * @param aspects - Input aspects to add. These are aspect converters to the built control from the {@link inValueOf\n   * same-valued one}.\n   *\n   * @returns `this` builder instance.\n   */\n  addAspects(...aspects: InConverter.Aspect<TValue>[]): this {\n    if (aspects.length) {\n      this[InBuilder$Impl__symbol].addAspects(aspects);\n    }\n    return this;\n  }\n\n  /**\n   * Registers additional setup of the built control.\n   *\n   * The setup is performed when the control {@link build built}.\n   *\n   * @param setup - A function that accepts a built control as its only parameter.\n   *\n   * @returns `this` builder instance.\n   */\n  setup(setup: (this: void, control: TControl) => void): this;\n\n  /**\n   * Registers additional setup of the built control's aspect.\n   *\n   * The setup is performed when the control {@link build built}.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to set up.\n   * @param setup - A function that accepts an applied aspect instance and a built control as parameters.\n   *\n   * @returns `this` builder instance.\n   */\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n      setup: (this: void, aspect: InAspect.Application.Instance<TInstance, TValue, TKind>, control: TControl) => void,\n  ): this;\n\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<TInstance, TKind> | ((this: void, control: TControl) => void),\n      aspectSetup?: (\n          this: void,\n          aspect: InAspect.Application.Instance<TInstance, TValue, TKind>,\n          control: TControl,\n      ) => void,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      this[InBuilder$Impl__symbol].setup(control => control.setup(aspectKeyOrSetup, aspectSetup!));\n    } else {\n      this[InBuilder$Impl__symbol].setup(aspectKeyOrSetup);\n    }\n    return this;\n  }\n\n  /**\n   * Builds control.\n   *\n   * @param factory - Control factory.\n   *\n   * @returns New user input control constructed by the given `factory` and set up with configured aspects and setup\n   * procedures.\n   */\n  build(factory: InControl.Factory<TControl, TValue>): TControl {\n    return this[InBuilder$Impl__symbol].build(factory);\n  }\n\n}\n","import { InAspect } from './aspect';\nimport { InControl } from './control';\nimport { InConverter } from './converter';\n\n/**\n * @internal\n */\nexport const InControl$Aspects__symbol = (/*#__PURE__*/ Symbol('InControl.aspects'));\n\n/**\n * @internal\n */\nexport type InControl$Impl<TControl extends InControl<TValue>, TValue> = TControl & {\n\n  _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      _aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined;\n\n};\n\n/**\n * @internal\n */\nexport class InControl$Aspects<TControl extends InControl<TValue>, TValue> {\n\n  private readonly _byKey = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  constructor(\n      readonly control: InControl$Impl<TControl, TValue>,\n      readonly aspects: InConverter.Aspect.Conversion<TValue>,\n  ) {}\n\n  aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> {\n\n    const applied = this._byKey.get(aspect);\n\n    if (applied) {\n      // Aspect applied already.\n      // Return it.\n      return applied;\n    }\n\n    const application = this.control._applyAspect(aspect)\n        || aspect.applyTo(this.control) as InAspect.Application.Result<TInstance, TValue, TKind>;\n\n    this._byKey.set(aspect, application);\n\n    return application;\n  }\n\n}\n","import { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { arrayOfElements, asis, noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { isAspectKey } from './aspect.impl';\nimport { InControl$Aspects, InControl$Aspects__symbol, InControl$Impl } from './control.impl';\nimport { InConverter, intoConvertedAspects, intoConvertedBy, isInAspectConversion } from './converter';\nimport { noopInConversion } from './noop-converter.impl';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InControl<TValue> extends ValueTracker<TValue> {\n\n  /**\n   * @internal\n   */\n  readonly [InControl$Aspects__symbol]: InControl$Aspects<this, TValue>;\n\n  /**\n   * Constructs user input control.\n   *\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control from the\n   * {@link inValueOf same-valued one}.\n   */\n  constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n      } = {},\n  ) {\n    super();\n\n    const aspectList = arrayOfElements(aspects);\n\n    this[InControl$Aspects__symbol] = new InControl$Aspects(\n        this as unknown as InControl$Impl<this, TValue>,\n        aspectList.length\n            ? intoConvertedAspects(aspectList)(inValueOf(this), this)\n            : noopInConversion,\n    );\n  }\n\n  /**\n   * Input value.\n   */\n  abstract it: TValue;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get supply(): Supply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n  ): InAspect.Application.Instance<TInstance, TValue, TKind> {\n    return this[InControl$Aspects__symbol].aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup - A function that accepts this control as its only parameter.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to set up.\n   * @param setup - A function that accepts an applied aspect instance and this control as parameters.\n   *\n   * @returns `this` control instance.\n   */\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n      setup: (this: void, aspect: InAspect.Application.Instance<TInstance, TValue, TKind>, control: this) => void,\n  ): this;\n\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<TInstance, TKind> | ((this: void, control: this) => void),\n      aspectSetup?: (\n          this: void,\n          aspect: InAspect.Application.Instance<TInstance, TValue, TKind>,\n          control: this,\n      ) => void,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup!(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<TValue, TValue>[]\n  ): InControl<TValue>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control converter.\n   * @param and - Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<TTo>(\n      by: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TTo>;\n\n  convert<TTo>(\n      by?: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TValue> | InControl<TTo> {\n    return new InControl$Converted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspect - An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return this[InControl$Aspects__symbol].aspects.applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeParam TControl - Input control type.\n   */\n  export type ValueType<TControl extends InControl<any>> = TControl extends InControl<infer TValue> ? TValue : never;\n\n  /**\n   * User input control factory signature.\n   *\n   * @typeParam TControl - Control type.\n   * @typeParam TValue - Input value type.\n   */\n  export type Factory<TControl extends InControl<TValue>, TValue = ValueType<TControl>> =\n  /**\n   * @param aspects - Input aspects applied by default. This is an aspect converter to constructed control from the\n   * {@link inValueOf same-valued one}.\n   *\n   * @returns Created control instance.\n   */\n      (\n          this: void,\n          {\n            aspects,\n          }: {\n            readonly aspects?: InConverter.Aspect<TValue>;\n          },\n      ) => TControl;\n\n}\n\n/**\n * @internal\n */\nclass InControl$SameValued<TValue> extends InControl<TValue> {\n\n  private _supply?: Supply;\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._supply || (this._supply = new Supply(noop).needs(this._control));\n  }\n\n  get it(): TValue {\n    return this._control.it;\n  }\n\n  set it(value: TValue) {\n    this._control.it = value;\n  }\n\n  get on(): OnEvent<[TValue, TValue]> {\n    return this._control.on;\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @param control - Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<TValue>(control: InControl<TValue>): InControl<TValue> {\n  return new InControl$SameValued(control);\n}\n\nclass InControl$Converted<TFrom, TTo> extends InControl<TTo> {\n\n  readonly supply: Supply;\n  private readonly _on = new EventEmitter<[TTo, TTo]>();\n  private readonly _it: ValueTracker<[TTo, number]>;\n  protected readonly _applyAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  constructor(src: InControl<TFrom>, by: InConverter.Factory<TFrom, TTo>) {\n    super();\n    this.supply = new Supply().needs(src);\n\n    let lastRev = 0;\n    let backward: TFrom | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: TFrom) => TTo;\n    let get: (value: TTo) => TFrom;\n    let convertAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      set = asis as (value: TFrom) => TTo;\n      get = asis as (value: TTo) => TFrom;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src[InControl$Aspects__symbol].aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src[InControl$Aspects__symbol].aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    this._it.supply.needs(this.supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get it(): TTo {\n    return this._it.it[0];\n  }\n\n  set it(value: TTo) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  get on(): OnEvent<[TTo, TTo]> {\n    return this._on.on;\n  }\n\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { inconvertibleInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inconvertibleInAspect(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InContainer<TValue> extends InControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inconvertibleInAspect(this, InContainer, this) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<TValue> | null;\n\n    }\n\n  }\n\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { knownInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return knownInAspect(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry - Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): Supply;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  readonly read: AfterEvent<[InParents.All]>;\n  private readonly _map = new Map<InParents.Entry, Supply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this._on.supply.needs(this._control);\n\n    const allParents = (): InParents.All => ({\n      [Symbol.iterator]: () => this._map.keys(),\n    });\n\n    this.read = this.on.do(mapAfter(allParents, allParents));\n  }\n\n  add(entry: InParents.Entry): Supply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = new Supply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  get on(): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this._on.on;\n  }\n\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { inconvertibleInAspect } from './applied-aspect';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inconvertibleInAspect(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport abstract class InElement<TValue, TElt = HTMLElement> extends InControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: TElt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<TValue>]>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inconvertibleInAspect(\n            this,\n            InElement,\n            this as InElement<TValue, any>,\n        ) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Input<TValue> {\n\n    /**\n     * The value user entered.\n     */\n    value: TValue;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<TValue> | null;\n\n    }\n\n  }\n\n}\n","import {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  afterThe,\n  digAfter,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  mapAfter,\n  mapOn,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { valuesProvider } from '@proc7ts/primitives';\nimport { itsElements, overElementsOf } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { builtInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InMode> {\n    return builtInAspect(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode - Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source - A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): Supply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason - Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get supply(): Supply {\n    return this._tracker.supply;\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n    case 'off':\n    case 'ro':\n    case '-on':\n    case '-ro':\n      break;\n    default:\n      value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  get on(): OnEvent<[InMode.Value, InMode.Value]> {\n    return this._tracker.on;\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on.do(mapOn(() => this._all)),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.do(\n        digAfter_((set: Set<AfterEvent<[InMode.Value]>>) => afterEach(...set)),\n        mapAfter(mergeInModes),\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): Supply {\n\n    const supply = new Supply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    this.own.supply.needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read.do(digAfter(parentsInMode)));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterAll({\n      derived: this._derived.read,\n      own: this.own,\n    }).do(translateAfter(\n        (\n            send,\n            {\n              derived: [derived],\n              own: [own],\n            },\n        ) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          if (last !== next) {\n            send(last = next);\n          }\n        },\n        valuesProvider<[InMode.Value]>(last),\n    ));\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.do(translateOn((send, value) => {\n\n      const old = lastUpdate;\n\n      if (old !== value) {\n        send(lastUpdate = value, old);\n      }\n    }));\n\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  derive(source: InMode.Source): Supply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control)).do(supplyAfter(this._control)),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off'\n      : (element.getAttribute('readonly') != null ? 'ro' : 'on');\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n  case 'off':\n    element.setAttribute('disabled', '');\n    break;\n  case 'ro':\n  case '-ro':\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    element.setAttribute('readonly', '');\n    break;\n  default:\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('readonly', '');\n    element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): AfterEvent<[InMode.Value]> {\n\n  const parentList = itsElements(parents);\n\n  if (!parentList.length) {\n    return afterThe('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return afterEach(...parentModes).do(mapAfter(mergeInModes));\n}\n\n/**\n * @internal\n * @param modes\n */\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...overElementsOf<InMode.Value>(...modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes - Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n    case 'off':\n      return 'off';\n    case 'ro':\n      ro = true;\n      break;\n    case '-on':\n      off = true;\n      break;\n    case '-ro':\n      off = true;\n      ro = true;\n      break;\n    case 'on':\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","import { afterAll, AfterEvent, mapAfter } from '@proc7ts/fun-events';\nimport { builtInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport type InData<TValue> = AfterEvent<[InData.DataType<TValue>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return builtInAspect(control, InData, <TValue>(ctrl: InControl<TValue>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).do(mapAfter(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? value as any\n            : undefined,\n    )));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<TValue> extends InAspect.Applied<TValue, InData<TValue>, InData<any>> {\n\n  convertTo<TTo>(target: InControl<TTo>): Applied<TTo> | undefined;\n\n}\n\n/**\n * @category Aspect\n */\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export type DataType<TValue> =\n      | (TValue extends object ? { [K in keyof TValue]?: DataType<TValue[K]> } : TValue)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<TValue>;\n\n    }\n\n  }\n\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onceAfter,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport {\n  iteratorOf,\n  itsEach,\n  mapIt,\n  overEntries,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { inconvertibleInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inconvertibleInAspect(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroup<TModel extends object> extends InContainer<TModel> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<TModel>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    return aspect === InGroup__aspect\n        ? inconvertibleInAspect(this, InGroup, this) as InAspect.Application.Result<TInstance, TModel, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export type Controls<TModel> = {\n    readonly [K in keyof TModel]?: InControl<TModel[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   * @typeParam TKey - Model keys type.\n   */\n  export type Entry<TModel, TKey extends keyof TModel = any> = readonly [TKey, InControl<TModel[TKey]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export interface Snapshot<TModel> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<TModel>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key - Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<TModel>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>,\n        EventKeeper<[InGroup.Snapshot<TModel>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @typeParam TKey - Model key type.\n   * @param key - A key of input control to set. I.e. corresponding model property key.\n   * @param control - Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<TKey extends keyof TModel>(key: TKey, control: InControl<TModel[TKey]> | undefined): Supply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls - A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<TModel>): Supply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key - A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof TModel): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<TModel> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, Supply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<TModel> implements InGroup.Snapshot<TModel>, PushIterable<InControl<any>> {\n\n  private readonly _it: PushIterable<InControl<any>>;\n  private readonly _entriesIt: PushIterable<InGroup.Entry<TModel>>;\n\n  constructor(private readonly _map: Map<keyof TModel, InGroupEntry>) {\n    this._it = mapIt(\n        overIterator(() => this._map.values()),\n        ([control]: InGroupEntry) => control,\n    );\n    this._entriesIt = mapIt(this._map, ([key, [control]]) => [key, control]);\n  }\n\n  get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<TModel>[TKey];\n  }\n\n  [Symbol.iterator](): PushIterator<InControl<any>> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InControl<any>>): PushIterator<InControl<any>> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n  entries(): PushIterator<InGroup.Entry<TModel>> {\n    return iteratorOf(this._entriesIt);\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<TModel extends object> {\n\n  readonly _supply = new Supply();\n  private _map = new Map<keyof TModel, InGroupEntry>();\n  private _shot?: InGroupSnapshot<TModel>;\n\n  constructor(private readonly _controls: InGroupControlControls<TModel>) {\n  }\n\n  set<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]> | undefined,\n      added: [keyof TModel, InGroupEntry][],\n      removed: [keyof TModel, InGroupEntry][],\n  ): Supply {\n\n    const replaced = this._map.get(key);\n    let supply: Supply;\n\n    if (control) {\n      supply = new Supply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = neverSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]>,\n      supply: Supply,\n  ): InGroupEntry {\n    return [\n      control,\n      new Supply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof TModel, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof TModel, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<TModel> {\n    return this._shot || (this._shot = new InGroupSnapshot<TModel>(this._map));\n  }\n\n  clear(): [keyof TModel, InGroupEntry][] {\n\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<TModel extends object> extends InGroupControls<TModel> {\n\n  readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n  private readonly _map: InGroupMap<TModel>;\n  private readonly _updates = new EventEmitter<[[keyof TModel, InGroupEntry][], [keyof TModel, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<TModel>) {\n    super();\n\n    const applyModelToControls = (model: TModel): void => {\n      this.read.do(onceAfter)(snapshot => {\n\n        const withValues = new Set<keyof TModel>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<TModel>(this);\n\n    this.on = this._updates.on.do(translateOn(\n        (send, added, removed) => send(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ));\n\n    const takeSnapshot = this._map.snapshot.bind(this._map);\n\n    this.read = this._updates.on.do(mapAfter(\n        takeSnapshot,\n        takeSnapshot,\n    ));\n\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  set<TKey extends keyof TModel>(\n      keyOrControls: TKey | InGroup.Controls<TModel>,\n      newControl?: InControl<TModel[TKey]> | undefined,\n  ): Supply {\n\n    const group = this._group;\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n    let supply: Supply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = new Supply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: TModel | undefined;\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.aspect(InParents).add({ parent: group }).as(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.read.do(supplyAfter(supply))(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<TModel extends object>(\n    [key, [control]]: [keyof TModel, InGroupEntry],\n): InGroup.Entry<TModel> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<TModel extends object> extends InGroup<TModel> {\n\n  private readonly _model: ValueTracker<TModel>;\n  readonly controls: InGroupControlControls<TModel>;\n\n  constructor(\n      model: TModel,\n      opts: {\n        readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    this.supply.whenOff(() => this.controls.clear());\n  }\n\n  get supply(): Supply {\n    return this._model.supply;\n  }\n\n  get it(): TModel {\n    return this._model.it;\n  }\n\n  set it(value: TModel) {\n    this._model.it = value;\n  }\n\n  get on(): OnEvent<[TModel, TModel]> {\n    return this._model.on;\n  }\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<TModel extends object>(group: InGroup<TModel>): InData<TModel> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).do(\n      digAfter_(readInGroupData),\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<TModel extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<TModel>];\n      model: [TModel];\n      mode: [InMode.Value];\n    },\n): AfterEvent<[InData.DataType<TModel>?]> {\n  if (!InMode.hasData(mode)) {\n    return afterThe();\n  }\n\n  const csData = {} as { [key in keyof TModel]: InData<any> };\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof TModel] = control.aspect(InData);\n  });\n\n  return afterAll(csData).do(mapAfter(controlsData => {\n\n    const data: Partial<TModel> = { ...model };\n\n    itsEach(\n        overEntries(controlsData),\n        <TKey extends keyof TModel>(keyAndControlData: readonly [keyof TModel, [InData.DataType<any>?]]) => {\n\n          const [key, [controlData]] = keyAndControlData as readonly [TKey, [TModel[TKey]?]];\n\n          data[key] = controlData;\n        },\n    );\n\n    return data as InData.DataType<TModel>;\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n * @param model - Initial model of the group.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<TModel extends object>(\n    model: TModel,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n    } = {},\n): InGroup<TModel> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<TValue extends object ? TValue : never> | null;\n\n    }\n\n  }\n\n}\n","import { AfterEvent, afterThe } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst RequireNothing$ = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return RequireNothing$;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  shareAfter,\n  supplyAfter,\n} from '@proc7ts/fun-events';\nimport { noop, valuesProvider } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<TValue> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<TValue>) => Supply;\n\n  constructor(control: InControl<TValue>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, Supply>();\n    const validatorMessages = new Map<InValidator<TValue>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => void = noop;\n\n    this._messages = afterEventBy<InValidation.Message[]>(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).do(\n        shareAfter,\n        supplyAfter(control),\n    );\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = new Supply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values());\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","import { AfterEvent, afterSupplied, EventKeeper, isEventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements, valueProvider } from '@proc7ts/primitives';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n */\nexport type InValidator<TValue> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<TValue>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<TValue>;\n\n/**\n * @category Validation\n */\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Simple<TValue> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control - Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<TValue>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validator - Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<TValue>(\n    validator: InValidator<TValue>,\n): (this: void, control: InControl<TValue>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n\n  return control => control.read.do(\n      translateAfter(send => send(...arrayOfElements(validator.validate(control)))),\n  );\n}\n","import {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport {\n  flatMapArray,\n  itsEach,\n  mapIt,\n  overArray,\n  overEntries,\n  overNone,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { builtInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return builtInAspect<TValue, InValidation<TValue>, 'validation'>(\n        control,\n        InValidation,\n        <TValue>(ctrl: InControl<TValue>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<TValue>(ctrl);\n\n          if (origin) {\n            validation.by(\n                origin.aspect(InValidation).read.do(\n                    translateAfter((send, result) => send(...result.messages())),\n                ),\n            );\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InValidation<TValue> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators - Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<TValue>[]): Supply;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code - Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code - Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes - Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result & PushIterable<InValidation.Message> = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n  [PushIterator__symbol](_accept): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result, PushIterable<InValidation.Message> {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _it: PushIterable<InValidation.Message>;\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    this._it = overArray(this._all);\n    messages.forEach(message => {\n\n      let nonEmpty = false;\n\n      itsEach(overEntries(message), ([code, codePresent]) => {\n        if (codePresent) {\n          nonEmpty = true;\n\n          const prev = this._byCode.get(code);\n\n          if (prev) {\n            prev.push(message);\n          } else {\n            this._byCode.set(code, [message]);\n          }\n        }\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (nonEmpty) {\n        this._all.push(message);\n      }\n    });\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InValidation.Message>): PushIterator<InValidation.Message> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages - Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<TValue> extends InValidation<TValue> {\n\n  readonly _messages: InValidationMessages<TValue>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<TValue>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    this.read = afterSupplied(this._messages).do<AfterEvent<[InValidation.Result]>>(\n        mapAfter(inValidationResult),\n    );\n\n    const container = control.aspect(InContainer);\n\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n  }\n\n  by(...validators: InValidator<TValue>[]): Supply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.do(\n      digAfter_(controls => afterEach(...mapIt(controls, control => control.aspect(InValidation)))),\n      translateAfter((send, ...results) => send(...flatMapArray(results, ([result]) => result))),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<TValue>;\n\n    }\n\n  }\n\n}\n","import { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validators - Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<TValue>(...validators: InValidator<TValue>[]): InValidator<TValue> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<TValue>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","import { EventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read.do(\n          translateAfter((send, value) => value ? send() : send({ missing: 'missing' })),\n      )\n      : requirePresent;\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  mapAfter,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { itsEvery } from '@proc7ts/push-iterator';\nimport { builtInAspect } from './applied-aspect';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return builtInAspect(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors - Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...errors.map(message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason - A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InSubmit<TValue> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of submit status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @typeParam TResult - Submit result value type.\n   * @param submitter - A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<TResult>(submitter: InSubmit.Submitter<TValue, TResult>): Promise<TResult>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TResult - Submit result value type.\n   */\n  export type Submitter<TValue, TResult> =\n  /**\n   * @param data - Input data to submit.\n   * @param control - Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          this: void,\n          data: TValue extends undefined ? never : TValue,\n          control: InControl<TValue>,\n      ) => Promise<TResult>;\n\n}\n\nclass InControlSubmit<TValue> extends InSubmit<TValue> {\n\n  readonly read: AfterEvent<[InSubmit.Flags]>;\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n    this.read = afterAll({\n      flags: this._flags,\n      data: this._control.aspect(InData),\n      messages: this._control.aspect(InValidation),\n    }).do(\n        supplyAfter(this._control),\n        mapAfter(({\n          flags: [flags],\n          data: [data],\n          messages: [messages],\n        }): InSubmit.Flags => ({\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n          submitted: flags.submitted,\n          busy: flags.busy,\n        })),\n    );\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read.do(\n        translateAfter((send, messages) => send(...messages)),\n    ));\n  }\n\n  async submit<TResult>(submitter: InSubmit.Submitter<TValue, TResult>): Promise<TResult> {\n    if (this._control.supply.isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    async function submitData(): Promise<TValue extends undefined ? never : TValue> {\n\n      const { data: [d], flags: [{ ready }] } = await afterAll({\n        data: control.aspect(InData),\n        flags: submit,\n      });\n\n      return ready\n          ? d as any\n          : Promise.reject(new InSubmitRejectedError('notReady'));\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<TValue>;\n\n    }\n\n  }\n\n}\n","import { mapAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form - Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady - Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid - Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy - Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read.do(mapAfter(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  ));\n}\n","import { mapAfter } from '@proc7ts/fun-events';\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid - Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore - Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read.do(mapAfter(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  ));\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent, EventEmitter, mapAfter, OnEvent, translateOn } from '@proc7ts/fun-events';\nimport { asis } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport class AbstractInElement<TValue, TElt extends HTMLElement> extends InElement<TValue, TElt> {\n\n  readonly events: DomEventDispatcher;\n  readonly input: AfterEvent<[InElement.Input<TValue>]>;\n  readonly on: OnEvent<[TValue, TValue]>;\n  private readonly _get: (this: AbstractInElement<TValue, TElt>) => TValue;\n  private readonly _set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n  private readonly _input: EventEmitter<[InElement.Input<TValue>, TValue]> = new EventEmitter();\n  private _value: TValue;\n  private _update: (value: TValue, oldValue: TValue) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element - HTML input element the constructed control is based on.\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get - Input value getter.\n   * @param set - Input value setter.\n   */\n  constructor(\n      readonly element: TElt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n        readonly get: (this: AbstractInElement<TValue, TElt>) => TValue;\n        readonly set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: TValue, oldValue: TValue): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    this.events.supply.needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    this.on = this._input.on.do(\n        translateOn((\n            send,\n            { value: newValue },\n            oldValue,\n        ) => newValue !== oldValue && send(newValue, oldValue)),\n    );\n    this.input = this._input.on.do(mapAfter(asis, () => ({ value: this.it })));\n\n    function update(input: InElement.Input<TValue>, oldValue: TValue): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<TValue>, TValue] | undefined;\n\n        // Record corrections\n        self._update = (newValue: TValue, old: TValue) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get supply(): Supply {\n    return this._input.supply;\n  }\n\n  get it(): TValue {\n    return this._get();\n  }\n\n  set it(value: TValue) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update - Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<TValue>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input')(onInput);\n    this.events.on('change')(onInput);\n  }\n\n}\n","import { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\n/**\n * @category Control\n */\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element - Target text input element.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","import { OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { builtInAspect } from '../../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InFocus | null> {\n    return builtInAspect(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when {@link InElement} aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot = element.getRootNode\n        ? element.getRootNode() as unknown as DocumentOrShadowRoot\n        : element.ownerDocument;\n\n    this._it = trackValue(owner.activeElement === element);\n    this.supply.needs(inElement);\n\n    events.on('focus')(() => this._it.it = true);\n    events.on('blur')(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get supply(): Supply {\n    return this._it.supply;\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  get on(): OnEvent<[boolean, boolean]> {\n    return this._it.on;\n  }\n\n}\n","import {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  onceAfter,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { itsEach, mapIt } from '@proc7ts/push-iterator';\nimport { builtInAspect } from '../../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InStatus> {\n    return builtInAspect(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched - Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited - Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.supply.needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  get read(): AfterEvent<[InStatus.Flags]> {\n    return this._flags.read;\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.do(mapAfter(({ event }) => !!event)) : afterThe(false),\n  }).do(mapAfter(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  ));\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n    this.read = containerInStatusFlags(this._container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markEdited(edited),\n    ));\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markTouched(touched),\n    ));\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.do(\n      supplyAfter(container),\n      digAfter_((snapshot: InContainer.Snapshot) => afterEach(...inControlStatuses(snapshot))),\n      mapAfter(combineInStatusFlags),\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by {@link inFormElement} function.\n *\n * @category Control\n * @typeParam TElt - A type of HTML form element.\n */\nexport type InFormElement<TElt extends HTMLElement = HTMLElement> = InElement<void, TElt>;\n\n/**\n * @category Control\n */\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by {@link inModeByForm}.\n     */\n    readonly modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element - HTML element to create control for.\n * @param options - Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<TElt extends HTMLElement>(\n    element: TElt,\n    options: InFormElement.Options,\n): InFormElement<TElt> {\n\n  const { form, aspects, modes } = options;\n  const control = new AbstractInElement<void, TElt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  control.supply.needs(form);\n\n  return control.setup(InMode, mode => mode.derive(inModeByForm(form, modes)));\n}\n","import { noop } from '@proc7ts/primitives';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form submit button control.\n *\n * It is connected to submittable control (e.g. a form) and makes a button status reflect a form submit status.\n * E.g. by disabling the button when submit is {@link InSubmit.Flags.ready not ready}, or while\n * {@link InSubmit.Flags.busy submitting} the form.\n *\n * Submit button control can be created by {@link inSubmitButton} function.\n *\n * The value of the submit button is always `undefined`, so it is never submitted.\n *\n * @category Control\n * @typeParam TElt - A type of submit button element.\n */\nexport type InSubmitButton<TElt extends HTMLElement = HTMLElement> = InElement<void, TElt>;\n\n/**\n * @category Control\n */\nexport namespace InSubmitButton {\n\n  /**\n   * Submit button control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to submit button control by {@link inModeByForm}.\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `off` (disable) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `off` (disabled) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element - Submit button element to create control for.\n * @param options - Submit button control options.\n *\n * @returns New submit button control.\n */\nexport function inSubmitButton<TElt extends HTMLElement>(\n    element: TElt,\n    options: InSubmitButton.Options,\n): InSubmitButton<TElt> {\n\n  const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n  const control = new AbstractInElement<void, TElt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  control.supply.needs(form);\n  control.setup(InMode, mode => mode.derive(inModeByForm(form, { notReady, invalid, busy })));\n\n  return control;\n}\n","import { knownInAspect, nullInAspect } from '../../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? knownInAspect(element.element) : nullInAspect();\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param element - A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(element: InStyledElement | null = null): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? knownInAspect(element) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { css__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport { DeltaSet } from '@proc7ts/delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  EventNotifier,\n  isEventKeeper,\n  mapAfter,\n  mapAfter_,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * An `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   */\n  abstract readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source - A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): Supply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element - Target element to apply CSS classes to.\n   * @param schedule - DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): Supply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason - An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by {@link InNamespaceAliaser} aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n  private readonly _sources = trackValue<[Map<AfterEvent<[InCssClasses.Map]>, Supply>]>([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    _control.supply.whenOff(reason => this.done(reason));\n\n    this.read = this._sources.read.do(\n        supplyAfter(this._control),\n        digAfter_(([sources]) => afterEach(...sources.keys())),\n        mapAfter_((...classes: [InCssClasses.Map][]) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        }),\n    );\n\n    this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    });\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).do(\n        mapAfter((...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        }),\n    );\n  }\n\n  add(source: InCssClasses.Source): Supply {\n\n    const inSupply = this._control.supply;\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = new Supply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source)({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).do(shareAfter);\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): Supply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","import { translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark - Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input aspects namespace} is used by default.\n * @param when - {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | readonly InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  return control => control.aspect(InValidation).read.do(translateAfter(\n      (send, errors) => hasError(errors) ? send(...inCssErrorMarks(mark)) : send(),\n  ));\n}\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: readonly InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction inCssErrorMarks(mark?: InCssClasses.Spec | readonly InCssClasses.Spec[]): readonly InCssClasses.Spec[] {\n  if (!mark) {\n    return defaultInCssErrorMarks;\n  }\n\n  const marks = arrayOfElements(mark);\n\n  return marks.length ? marks : defaultInCssErrorMarks;\n}\n","import { NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { afterAll, translateAfter } from '@proc7ts/fun-events';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InValidation } from '../../validation';\nimport { InStatus } from '../focus';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `has-focus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns - A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).do(translateAfter(\n        (send, { md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          send(...names);\n        },\n    ));\n  };\n}\n"],"names":["nullInAspect$","instance","convertTo","noop","nullInAspect","knownInAspect","[object Object]","_target","this","inconvertibleInAspect","control","aspectKey","builtInAspect$","valueProvider","builtInAspect","build","origin","undefined","target","attachTo","aspect","InAspect__symbol","Symbol","InputAspects__NS","NamespaceDef","InNamespaceAliaser__aspect","applyTo","newNamespaceAliaser","InNamespaceAliaser","to","nsAlias","applyAspect","InRenderScheduler__aspect","newRenderSchedule","InRenderScheduler","scheduler","InRole__aspect","InControlRole","InRole","AfterEvent__symbol","read","InRole$Active","roles","active","iterator","keys","has","role","result","Map","add","_defaultSupply","isDefault","named","get","supply","Supply","set","whenOff","delete","defaultSupply","activateBy","off","reason","activator","prevActivator","_activate","_control","super","trackValue","create","_active","on","activate","needs","do","mapAfter_","it","modify","_add","remove","size","activators","_activators","cuts","activatedSupply","values","isAspectKey","value","noopInConversion","_aspect","noopInConverter","intoConvertedBy","valueOrAspectConverter","converters","converter","inConverter","length","aspectConverters","map","from","conversion","conversions","overElementsOf","filterArray","acf","isPresent","itsReduction","prev","cv","isInAspectConversion","bind","intoConvertedAspects","aspects","arrayOfElements","InBuilder$Impl__symbol","InBuilder$Impl","_aspectsByKey","_commonAspects","setup","_setup","factory","_aspects","byKey","intoConvertedByKey","InBuilder","addAspect","addAspects","aspectKeyOrSetup","aspectSetup","InControl$Aspects__symbol","InControl$Aspects","applied","_byKey","application","_applyAspect","InControl","ValueTracker","aspectList","InControl$SameValued","by","and","InControl$Converted","_supply","src","EventEmitter","backward","lastRev","convertAspect","asis","fallback","_it","newValue","oldValue","_on","send","rev","prevValue","prevRev","InContainer__aspect","InContainer","InContainerControls","OnEvent__symbol","InParents__aspect","InControlParents","InParents","allParents","_map","mapAfter","entry","existingSupply","parent","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","own","OwnModeTracker","element","_tracker","getAttribute","initialInMode","DerivedInModes","Set","sources","afterSent","mapOn","_all","valuesProvider","digAfter_","afterEach","mergeInModes","source","derive","InParentsAspect","digAfter","parentsInMode","last","afterAll","derived","_derived","translateAfter","next","substring","lastUpdate","translateOn","old","setAttribute","removeAttribute","applyInMode","afterSupplied","isEventKeeper","supplyAfter","parents","parentList","itsElements","afterThe","parentModes","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","InGroupControls","key","inControlReplacedReason","InGroupSnapshot","mapIt","overIterator","_entriesIt","PushIterator__symbol","accept","iteratorOf","InGroupMap","_controls","added","removed","replaced","newEntry","sendUpdate","push","neverSupply","_shot","itsEach","entries","k","e","InGroupControlControls","_group","_updates","controlEntryToGroupEntry","takeSnapshot","snapshot","model","onceAfter","withValues","overEntries","keyOrControls","newControl","group","newModel","forEach","keyAndEntry","as","applyControlsToModel","clear","InGroupControl","opts","_model","controls","cs","readInGroupData","csData","controlsData","data","keyAndControlData","controlData","inGroup","RequireNothing$","requireNothing","dontRemove","InValidationMessages","emitter","validators","validatorMessages","validate","_messages","afterEventBy","receiver","resultSupply","validator","validatorSupply","messages","flatMapIt","shareAfter","inValidator","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","ok","hasBut","overNone","_accept","InValidationErrors","overArray","message","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","container","results","flatMapArray","nestedInValidationMessages","numValidators","requireAll","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","Error","errors","submit","InSubmitRejectedError","rejected","submitted","busy","flags","_flags","ready","itsEvery","_errors","submitter","isOff","async","d","Promise","reject","submitData","error","toInSubmitMessages","inModeByForm","form","notReady","invalid","inModeByValidity","ignore","validity","AbstractInElement","self","_get","_set","_value","doUpdate","_update","update","input","correction","_input","events","DomEventDispatcher","listenForInput","onInput","event","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","ownerDocument","activeElement","ctx","onRecurrent","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","c","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","options","inSubmitButton","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","done","_sources","classes","mergeInCssClassesMap","track","DeltaSet","EventNotifier","classesSent","filterIt","flag","name","delta","redelta","undelta","schedule","_schedule","controlSchedule","specs","names","isQualifiedName","css__naming","inSupply","classesSupply","resolve","context","receive","classList","updateClasses","node","inCssError","mark","when","hasError","Array","isArray","defaultInCssHasError","defaultInCssErrorMarks","marks","inCssErrorMarks","inCssInfo","ns","cls","md","vl","st","valid"],"mappings":"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"}