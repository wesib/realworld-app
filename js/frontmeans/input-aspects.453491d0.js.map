{"version":3,"file":"input-aspects.453491d0.js","sources":["../../../../../frontmeans/input-aspects/src/aspect.ts","../../../../../frontmeans/input-aspects/src/aspect.impl.ts","../../../../../frontmeans/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../../../frontmeans/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../../../frontmeans/input-aspects/src/converter.ts","../../../../../frontmeans/input-aspects/src/control.ts","../../../../../frontmeans/input-aspects/src/controls/value-of.control.ts","../../../../../frontmeans/input-aspects/src/controls/abstract.control.ts","../../../../../frontmeans/input-aspects/src/containers/container.control.ts","../../../../../frontmeans/input-aspects/src/containers/parents.aspect.ts","../../../../../frontmeans/input-aspects/src/element.control.ts","../../../../../frontmeans/input-aspects/src/data/mode.aspect.ts","../../../../../frontmeans/input-aspects/src/data/data.aspect.ts","../../../../../frontmeans/input-aspects/src/containers/group.control.ts","../../../../../frontmeans/input-aspects/src/validation/require-nothing.validator.ts","../../../../../frontmeans/input-aspects/src/validation/validator.impl.ts","../../../../../frontmeans/input-aspects/src/validation/validator.ts","../../../../../frontmeans/input-aspects/src/validation/validation.aspect.ts","../../../../../frontmeans/input-aspects/src/validation/require-all.validator.ts","../../../../../frontmeans/input-aspects/src/validation/require-present.validator.ts","../../../../../frontmeans/input-aspects/src/submit.aspect.ts","../../../../../frontmeans/input-aspects/src/data/modes/mode-by-form.ts","../../../../../frontmeans/input-aspects/src/data/modes/mode-by-validity.ts","../../../../../frontmeans/input-aspects/src/elements/abstract-element.control.ts","../../../../../frontmeans/input-aspects/src/elements/text.control.ts","../../../../../frontmeans/input-aspects/src/elements/focus/focus.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/focus/status.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/forms/form-element.control.ts","../../../../../frontmeans/input-aspects/src/elements/forms/submit-button.control.ts","../../../../../frontmeans/input-aspects/src/elements/style/styled-element.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/style/css-classes.aspect.ts","../../../../../frontmeans/input-aspects/src/elements/style/css-error.ts","../../../../../frontmeans/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["import { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n */\nexport interface InAspect<TInstance, TKind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeParam TValue - Input value type.\n   * @param control - Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, TInstance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\n/**\n * @category Aspect\n */\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   */\n  export interface Key<TInstance, TKind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<TInstance, TKind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TConvertedInstance - A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<TValue, TInstance, TConvertedInstance extends TInstance = TInstance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: TInstance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by {@link InControl.convert} method.\n     *\n     * @typeParam TTargetValue - Converted input value type.\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<TTargetValue>(target: InControl<TTargetValue>): Applied<TTargetValue, TConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of {@link convertTo} when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<TValue>): Applied<TValue, TInstance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Result<TInstance, TValue, TKind extends Kind> =\n        Applied<TValue, Instance<TInstance, TValue, TKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Instance<TInstance, TValue, TKind extends Kind> =\n        ReturnType<Map<TInstance, TValue>[TKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     */\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): TInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from '@proc7ts/primitives';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance, TKind>,\n    build: <TValue>(this: void, control: InControl<TValue>, origin?: InControl<any>) => TInstance,\n    instance?: TInstance,\n    origin?: InControl<any>,\n): InAspect.Applied<TValue, TInstance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<TTo>(target: InControl<TTo>): InAspect.Applied<TTo, TInstance> {\n      return inAspectSameOrBuild<TTo, TInstance, TKind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<TValue>): InAspect.Applied<TValue, TInstance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as TInstance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance | null, TKind>,\n    instance: TInstance | null = null,\n): InAspect.Applied<TValue, TInstance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<TInstance>(instance: TInstance): InAspect.Applied<any, TInstance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","import { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * {@link InNamespaceAliaser.to} converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param nsAlias - Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by {@link InRenderScheduler.to} converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param scheduler - Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(scheduler: InRenderScheduler): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { isPresent, noop, valueProvider } from '@proc7ts/primitives';\nimport { filterArray, itsReduction, overElementsOf } from '@proc7ts/push-iterator';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n */\nexport type InConverter<TFrom, TTo> =\n    | InConverter.Conversion<TFrom, TTo>\n    | InConverter.Factory<TFrom, TTo>;\n\n/**\n * @category Converter\n */\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Conversion<TFrom, TTo> =\n      | InConverter.Value.Conversion<TFrom, TTo>\n      | InConverter.Aspect.Conversion<TTo>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Value<TFrom, TTo> =\n      | InConverter.Value.Factory<TFrom, TTo>\n      | InConverter.Value.Conversion<TFrom, TTo>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Aspect<TFrom, TTo = TFrom> =\n      | InConverter.Aspect.Conversion<TTo>\n      | InConverter.Aspect.Factory<TFrom, TTo>;\n\n}\n\n/**\n * @category Converter\n */\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> =\n  /**\n   * @param from - Original input control.\n   * @param to - Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<TFrom>,\n          to: InControl<TTo>,\n      ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export interface Conversion<TFrom, TTo> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value - Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: TFrom): TTo;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value - A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: TTo): TFrom;\n\n  }\n\n}\n\n/**\n * @category Converter\n */\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo = TFrom> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TTo>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Conversion<TValue> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeParam TValue - Input value type.\n * @param converters - Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<TValue>(\n    ...converters: InConverter.Aspect<TValue, TValue>[]\n): InConverter.Aspect.Factory<TValue, TValue>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter?: InConverter<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo>;\n\nexport function intoConvertedBy<TFrom, TTo>(\n    valueOrAspectConverter?: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo> {\n\n  type AspectApplicator = <TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = converters.map<InConverter.Aspect.Factory<TFrom, TTo>>(inConverter);\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<TFrom, TTo> => {\n\n    const conversion = converter(from, to);\n    const conversions = overElementsOf<InConverter.Conversion<TFrom, TTo>>(\n        [conversion],\n        filterArray<InConverter.Aspect.Conversion<TTo> | undefined, InConverter.Aspect.Conversion<TTo>>(\n            aspectConverters.map(acf => acf(from, to)),\n            isPresent,\n        ),\n    );\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<TFrom, TTo>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeParam TValue - Input value type.\n * @param aspects - Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<TValue>(\n    aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[],\n): InConverter.Aspect.Factory<TValue> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<TValue>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion - Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<TFrom, TTo>(\n    conversion: InConverter.Conversion<TFrom, TTo>,\n): conversion is InConverter.Aspect.Conversion<TTo> {\n  return !(conversion as Partial<InConverter.Value.Conversion<TFrom, TTo>>).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Aspect<TFrom, TTo>,\n): InConverter.Aspect.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo>;\n\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo> | InConverter.Aspect.Factory<TFrom, TTo> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","import { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { asis, noop, Supply } from '@proc7ts/primitives';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InControl<TValue> extends ValueTracker<TValue> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: TValue;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get supply(): Supply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n  ): InAspect.Application.Instance<TInstance, TValue, TKind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup - A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to set up.\n   * @param setup - A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<TInstance, TValue, TKind>, control: this) => void,\n  ): this;\n\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<TInstance, TKind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<TInstance, TValue, TKind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<TValue, TValue>[]\n  ): InControl<TValue>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control converter.\n   * @param and - Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<TTo>(\n      by: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TTo>;\n\n  convert<TTo>(\n      by?: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TValue> | InControl<TTo> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<TInstance, TValue, TKind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<TInstance, TValue, TKind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param _aspect - An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      _aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<TInstance, TKind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<TInstance, TKind> {\n  return InAspect__symbol in value;\n}\n\n/**\n * @category Control\n */\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeParam TControl - Input control type.\n   */\n  export type ValueType<TControl extends InControl<any>> = TControl extends InControl<infer TValue> ? TValue : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<TFrom, TTo> extends InControl<TTo> {\n\n  readonly supply: Supply;\n  private readonly _on = new EventEmitter<[TTo, TTo]>();\n  private readonly _it: ValueTracker<[TTo, number]>;\n  protected readonly _applyAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  constructor(src: InControl<TFrom>, by: InConverter.Factory<TFrom, TTo>) {\n    super();\n    this.supply = new Supply().needs(src);\n\n    let lastRev = 0;\n    let backward: TFrom | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: TFrom) => TTo;\n    let get: (value: TTo) => TFrom;\n    let convertAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      set = asis as (value: TFrom) => TTo;\n      get = asis as (value: TTo) => TFrom;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    this._it.supply.needs(this.supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get it(): TTo {\n    return this._it.it[0];\n  }\n\n  set it(value: TTo) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  get on(): OnEvent<[TTo, TTo]> {\n    return this._on.on;\n  }\n\n}\n","import { OnEvent } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nclass InSameValueControl<TValue> extends InControl<TValue> {\n\n  private _supply?: Supply;\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._supply || (this._supply = new Supply().needs(this._control));\n  }\n\n  get it(): TValue {\n    return this._control.it;\n  }\n\n  set it(value: TValue) {\n    this._control.it = value;\n  }\n\n  get on(): OnEvent<[TValue, TValue]> {\n    return this._control.on;\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @param control - Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<TValue>(control: InControl<TValue>): InControl<TValue> {\n  return new InSameValueControl(control);\n}\n","import { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class AbstractInControl<TValue> extends InControl<TValue> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<TValue>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InContainer<TValue> extends AbstractInControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<TValue> | null;\n\n    }\n\n  }\n\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry - Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): Supply;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  readonly read: AfterEvent<[InParents.All]>;\n  private readonly _map = new Map<InParents.Entry, Supply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this._on.supply.needs(this._control);\n\n    const allParents = (): IterableIterator<InParents.Entry> => this._map.keys();\n\n    this.read = this.on.do(mapAfter(allParents, allParents));\n  }\n\n  add(entry: InParents.Entry): Supply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = new Supply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  get on(): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this._on.on;\n  }\n\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport abstract class InElement<TValue, TElt = HTMLElement> extends AbstractInControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: TElt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<TValue>]>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<TValue, any>,\n        ) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Input<TValue> {\n\n    /**\n     * The value user entered.\n     */\n    value: TValue;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<TValue> | null;\n\n    }\n\n  }\n\n}\n","import {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  afterThe,\n  digAfter,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  mapAfter,\n  mapOn,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { Supply, valuesProvider } from '@proc7ts/primitives';\nimport { itsElements, overElementsOf } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode - Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source - A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): Supply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason - Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get supply(): Supply {\n    return this._tracker.supply;\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n    case 'off':\n    case 'ro':\n    case '-on':\n    case '-ro':\n      break;\n    default:\n      value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  get on(): OnEvent<[InMode.Value, InMode.Value]> {\n    return this._tracker.on;\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on.do(mapOn(() => this._all)),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.do(\n        digAfter_((set: Set<AfterEvent<[InMode.Value]>>) => afterEach(...set)),\n        mapAfter(mergeInModes),\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): Supply {\n\n    const supply = new Supply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    this.own.supply.needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read.do(digAfter(parentsInMode)));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterAll({\n      derived: this._derived.read,\n      own: this.own,\n    }).do(translateAfter(\n        (\n            send,\n            {\n              derived: [derived],\n              own: [own],\n            },\n        ) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          if (last !== next) {\n            send(last = next);\n          }\n        },\n        valuesProvider<[InMode.Value]>(last),\n    ));\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.do(translateOn((send, value) => {\n\n      const old = lastUpdate;\n\n      if (old !== value) {\n        send(lastUpdate = value, old);\n      }\n    }));\n\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  derive(source: InMode.Source): Supply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control)).do(supplyAfter(this._control)),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off'\n      : (element.getAttribute('readonly') != null ? 'ro' : 'on');\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n  case 'off':\n    element.setAttribute('disabled', '');\n    break;\n  case 'ro':\n  case '-ro':\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    element.setAttribute('readonly', '');\n    break;\n  default:\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('readonly', '');\n    element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): AfterEvent<[InMode.Value]> {\n\n  const parentList = itsElements(parents);\n\n  if (!parentList.length) {\n    return afterThe('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return afterEach(...parentModes).do(mapAfter(mergeInModes));\n}\n\n/**\n * @internal\n * @param modes\n */\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...overElementsOf<InMode.Value>(...modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes - Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n    case 'off':\n      return 'off';\n    case 'ro':\n      ro = true;\n      break;\n    case '-on':\n      off = true;\n      break;\n    case '-ro':\n      off = true;\n      ro = true;\n      break;\n    case 'on':\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","import { afterAll, AfterEvent, mapAfter } from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport type InData<TValue> = AfterEvent<[InData.DataType<TValue>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <TValue>(ctrl: InControl<TValue>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).do(mapAfter(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? value as any\n            : undefined,\n    )));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<TValue> extends InAspect.Applied<TValue, InData<TValue>, InData<any>> {\n\n  convertTo<TTo>(target: InControl<TTo>): Applied<TTo> | undefined;\n\n}\n\n/**\n * @category Aspect\n */\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export type DataType<TValue> =\n      | (TValue extends object ? { [K in keyof TValue]?: DataType<TValue[K]> } : TValue)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<TValue>;\n\n    }\n\n  }\n\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onceAfter,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { neverSupply, noop, Supply } from '@proc7ts/primitives';\nimport {\n  iteratorOf,\n  itsEach,\n  mapIt,\n  overEntries,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroup<TModel extends object> extends InContainer<TModel> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<TModel>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<TInstance, TModel, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export type Controls<TModel> = {\n    readonly [K in keyof TModel]?: InControl<TModel[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   * @typeParam TKey - Model keys type.\n   */\n  export type Entry<TModel, TKey extends keyof TModel = any> = readonly [TKey, InControl<TModel[TKey]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export interface Snapshot<TModel> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<TModel>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key - Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<TModel>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>,\n        EventKeeper<[InGroup.Snapshot<TModel>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @typeParam TKey - Model key type.\n   * @param key - A key of input control to set. I.e. corresponding model property key.\n   * @param control - Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<TKey extends keyof TModel>(key: TKey, control: InControl<TModel[TKey]> | undefined): Supply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls - A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<TModel>): Supply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key - A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof TModel): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<TModel> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, Supply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<TModel> implements InGroup.Snapshot<TModel>, PushIterable<InControl<any>> {\n\n  private readonly _it: PushIterable<InControl<any>>;\n  private readonly _entriesIt: PushIterable<InGroup.Entry<TModel>>;\n\n  constructor(private readonly _map: Map<keyof TModel, InGroupEntry>) {\n    this._it = mapIt(\n        overIterator(() => this._map.values()),\n        ([control]: InGroupEntry) => control,\n    );\n    this._entriesIt = mapIt(this._map, ([key, [control]]) => [key, control]);\n  }\n\n  get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<TModel>[TKey];\n  }\n\n  [Symbol.iterator](): PushIterator<InControl<any>> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InControl<any>>): PushIterator<InControl<any>> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n  entries(): PushIterator<InGroup.Entry<TModel>> {\n    return iteratorOf(this._entriesIt);\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<TModel extends object> {\n\n  readonly _supply = new Supply();\n  private _map = new Map<keyof TModel, InGroupEntry>();\n  private _shot?: InGroupSnapshot<TModel>;\n\n  constructor(private readonly _controls: InGroupControlControls<TModel>) {\n  }\n\n  set<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]> | undefined,\n      added: [keyof TModel, InGroupEntry][],\n      removed: [keyof TModel, InGroupEntry][],\n  ): Supply {\n\n    const replaced = this._map.get(key);\n    let supply: Supply;\n\n    if (control) {\n      supply = new Supply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = neverSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]>,\n      supply: Supply,\n  ): InGroupEntry {\n    return [\n      control,\n      new Supply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof TModel, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof TModel, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<TModel> {\n    return this._shot || (this._shot = new InGroupSnapshot<TModel>(this._map));\n  }\n\n  clear(): [keyof TModel, InGroupEntry][] {\n\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<TModel extends object> extends InGroupControls<TModel> {\n\n  readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n  private readonly _map: InGroupMap<TModel>;\n  private readonly _updates = new EventEmitter<[[keyof TModel, InGroupEntry][], [keyof TModel, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<TModel>) {\n    super();\n\n    const applyModelToControls = (model: TModel): void => {\n      this.read.do(onceAfter)(snapshot => {\n\n        const withValues = new Set<keyof TModel>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<TModel>(this);\n\n    this.on = this._updates.on.do(translateOn(\n        (send, added, removed) => send(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ));\n\n    const takeSnapshot = this._map.snapshot.bind(this._map);\n\n    this.read = this._updates.on.do(mapAfter(\n        takeSnapshot,\n        takeSnapshot,\n    ));\n\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  set<TKey extends keyof TModel>(\n      keyOrControls: TKey | InGroup.Controls<TModel>,\n      newControl?: InControl<TModel[TKey]> | undefined,\n  ): Supply {\n\n    const group = this._group;\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n    let supply: Supply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = new Supply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: TModel | undefined;\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.aspect(InParents).add({ parent: group }).as(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.read.do(supplyAfter(supply))(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<TModel extends object>(\n    [key, [control]]: [keyof TModel, InGroupEntry],\n): InGroup.Entry<TModel> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<TModel extends object> extends InGroup<TModel> {\n\n  private readonly _model: ValueTracker<TModel>;\n  readonly controls: InGroupControlControls<TModel>;\n\n  constructor(\n      model: TModel,\n      opts: {\n        readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    this.supply.whenOff(() => this.controls.clear());\n  }\n\n  get supply(): Supply {\n    return this._model.supply;\n  }\n\n  get it(): TModel {\n    return this._model.it;\n  }\n\n  set it(value: TModel) {\n    this._model.it = value;\n  }\n\n  get on(): OnEvent<[TModel, TModel]> {\n    return this._model.on;\n  }\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<TModel extends object>(group: InGroup<TModel>): InData<TModel> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).do(\n      digAfter_(readInGroupData),\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<TModel extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<TModel>];\n      model: [TModel];\n      mode: [InMode.Value];\n    },\n): AfterEvent<[InData.DataType<TModel>?]> {\n  if (!InMode.hasData(mode)) {\n    return afterThe();\n  }\n\n  const csData = {} as { [key in keyof TModel]: InData<any> };\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof TModel] = control.aspect(InData);\n  });\n\n  return afterAll(csData).do(mapAfter(controlsData => {\n\n    const data: Partial<TModel> = { ...model };\n\n    itsEach(\n        overEntries(controlsData),\n        <TKey extends keyof TModel>(keyAndControlData: readonly [keyof TModel, [InData.DataType<any>?]]) => {\n\n          const [key, [controlData]] = keyAndControlData as readonly [TKey, [TModel[TKey]?]];\n\n          data[key] = controlData;\n        },\n    );\n\n    return data as InData.DataType<TModel>;\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n * @param model - Initial model of the group.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<TModel extends object>(\n    model: TModel,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n    } = {},\n): InGroup<TModel> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<TValue extends object ? TValue : never> | null;\n\n    }\n\n  }\n\n}\n","import { AfterEvent, afterThe } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst RequireNothing$ = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return RequireNothing$;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  shareAfter,\n  supplyAfter,\n} from '@proc7ts/fun-events';\nimport { noop, Supply, valuesProvider } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach } from '@proc7ts/push-iterator';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<TValue> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<TValue>) => Supply;\n\n  constructor(control: InControl<TValue>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, Supply>();\n    const validatorMessages = new Map<InValidator<TValue>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => void = noop;\n\n    this._messages = afterEventBy<InValidation.Message[]>(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).do(\n        shareAfter,\n        supplyAfter(control),\n    );\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = new Supply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values());\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","import { AfterEvent, afterSupplied, EventKeeper, isEventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements, valueProvider } from '@proc7ts/primitives';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n */\nexport type InValidator<TValue> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<TValue>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<TValue>;\n\n/**\n * @category Validation\n */\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Simple<TValue> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control - Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<TValue>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validator - Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<TValue>(\n    validator: InValidator<TValue>,\n): (this: void, control: InControl<TValue>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n\n  return control => control.read.do(\n      translateAfter(send => send(...arrayOfElements(validator.validate(control)))),\n  );\n}\n","import {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport {\n  flatMapArray,\n  itsEach,\n  mapIt,\n  overArray,\n  overEntries,\n  overNone,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return inAspectSameOrBuild<TValue, InValidation<TValue>, 'validation'>(\n        control,\n        InValidation,\n        <TValue>(ctrl: InControl<TValue>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<TValue>(ctrl);\n\n          if (origin) {\n            validation.by(\n                origin.aspect(InValidation).read.do(\n                    translateAfter((send, result) => send(...result.messages())),\n                ),\n            );\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InValidation<TValue> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators - Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<TValue>[]): Supply;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code - Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code - Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes - Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result & PushIterable<InValidation.Message> = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n  [PushIterator__symbol](_accept): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result, PushIterable<InValidation.Message> {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _it: PushIterable<InValidation.Message>;\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    this._it = overArray(this._all);\n    messages.forEach(message => {\n\n      let nonEmpty = false;\n\n      itsEach(overEntries(message), ([code, codePresent]) => {\n        if (codePresent) {\n          nonEmpty = true;\n\n          const prev = this._byCode.get(code);\n\n          if (prev) {\n            prev.push(message);\n          } else {\n            this._byCode.set(code, [message]);\n          }\n        }\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (nonEmpty) {\n        this._all.push(message);\n      }\n    });\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InValidation.Message>): PushIterator<InValidation.Message> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages - Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<TValue> extends InValidation<TValue> {\n\n  readonly _messages: InValidationMessages<TValue>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<TValue>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    this.read = afterSupplied(this._messages).do<AfterEvent<[InValidation.Result]>>(\n        mapAfter(inValidationResult),\n    );\n\n    const container = control.aspect(InContainer);\n\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n  }\n\n  by(...validators: InValidator<TValue>[]): Supply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.do(\n      digAfter_(controls => afterEach(...mapIt(controls, control => control.aspect(InValidation)))),\n      translateAfter((send, ...results) => send(...flatMapArray(results, ([result]) => result))),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<TValue>;\n\n    }\n\n  }\n\n}\n","import { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validators - Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<TValue>(...validators: InValidator<TValue>[]): InValidator<TValue> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<TValue>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","import { EventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read.do(\n          translateAfter((send, value) => value ? send() : send({ missing: 'missing' })),\n      )\n      : requirePresent;\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  mapAfter,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { itsEvery } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrBuild } from './aspect.impl';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return inAspectSameOrBuild(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors - Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...errors.map(message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason - A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InSubmit<TValue> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of submit status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @typeParam TResult - Submit result value type.\n   * @param submitter - A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<TResult>(submitter: InSubmit.Submitter<TValue, TResult>): Promise<TResult>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TResult - Submit result value type.\n   */\n  export type Submitter<TValue, TResult> =\n  /**\n   * @param data - Input data to submit.\n   * @param control - Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          this: void,\n          data: TValue extends undefined ? never : TValue,\n          control: InControl<TValue>,\n      ) => Promise<TResult>;\n\n}\n\nclass InControlSubmit<TValue> extends InSubmit<TValue> {\n\n  readonly read: AfterEvent<[InSubmit.Flags]>;\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n    this.read = afterAll({\n      flags: this._flags,\n      data: this._control.aspect(InData),\n      messages: this._control.aspect(InValidation),\n    }).do(\n        supplyAfter(this._control),\n        mapAfter(({\n          flags: [flags],\n          data: [data],\n          messages: [messages],\n        }): InSubmit.Flags => ({\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n          submitted: flags.submitted,\n          busy: flags.busy,\n        })),\n    );\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read.do(\n        translateAfter((send, messages) => send(...messages)),\n    ));\n  }\n\n  async submit<TResult>(submitter: InSubmit.Submitter<TValue, TResult>): Promise<TResult> {\n    if (this._control.supply.isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    async function submitData(): Promise<TValue extends undefined ? never : TValue> {\n\n      const { data: [d], flags: [{ ready }] } = await afterAll({\n        data: control.aspect(InData),\n        flags: submit,\n      });\n\n      return ready\n          ? d as any\n          : Promise.reject(new InSubmitRejectedError('notReady'));\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<TValue>;\n\n    }\n\n  }\n\n}\n","import { mapAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form - Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady - Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid - Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy - Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read.do(mapAfter(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  ));\n}\n","import { mapAfter } from '@proc7ts/fun-events';\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid - Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore - Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read.do(mapAfter(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  ));\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent, EventEmitter, mapAfter, OnEvent, translateOn } from '@proc7ts/fun-events';\nimport { asis, Supply } from '@proc7ts/primitives';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport class AbstractInElement<TValue, TElt extends HTMLElement> extends InElement<TValue, TElt> {\n\n  readonly events: DomEventDispatcher;\n  readonly input: AfterEvent<[InElement.Input<TValue>]>;\n  readonly on: OnEvent<[TValue, TValue]>;\n  private readonly _get: (this: AbstractInElement<TValue, TElt>) => TValue;\n  private readonly _set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n  private readonly _input: EventEmitter<[InElement.Input<TValue>, TValue]> = new EventEmitter();\n  private _value: TValue;\n  private _update: (value: TValue, oldValue: TValue) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element - HTML input element the constructed control is based on.\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get - Input value getter.\n   * @param set - Input value setter.\n   */\n  constructor(\n      readonly element: TElt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n        readonly get: (this: AbstractInElement<TValue, TElt>) => TValue;\n        readonly set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: TValue, oldValue: TValue): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    this.events.supply.needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    this.on = this._input.on.do(\n        translateOn((\n            send,\n            { value: newValue },\n            oldValue,\n        ) => newValue !== oldValue && send(newValue, oldValue)),\n    );\n    this.input = this._input.on.do(mapAfter(asis, () => ({ value: this.it })));\n\n    function update(input: InElement.Input<TValue>, oldValue: TValue): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<TValue>, TValue] | undefined;\n\n        // Record corrections\n        self._update = (newValue: TValue, old: TValue) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get supply(): Supply {\n    return this._input.supply;\n  }\n\n  get it(): TValue {\n    return this._get();\n  }\n\n  set it(value: TValue) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update - Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<TValue>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input')(onInput);\n    this.events.on('change')(onInput);\n  }\n\n}\n","import { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\n/**\n * @category Control\n */\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element - Target text input element.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","import { OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when {@link InElement} aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot = element.getRootNode\n        ? element.getRootNode() as unknown as DocumentOrShadowRoot\n        : element.ownerDocument;\n\n    this._it = trackValue(owner.activeElement === element);\n    this.supply.needs(inElement);\n\n    events.on('focus')(() => this._it.it = true);\n    events.on('blur')(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get supply(): Supply {\n    return this._it.supply;\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  get on(): OnEvent<[boolean, boolean]> {\n    return this._it.on;\n  }\n\n}\n","import {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  onceAfter,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { itsEach, mapIt } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched - Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited - Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.supply.needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  get read(): AfterEvent<[InStatus.Flags]> {\n    return this._flags.read;\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.do(mapAfter(({ event }) => !!event)) : afterThe(false),\n  }).do(mapAfter(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  ));\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n    this.read = containerInStatusFlags(this._container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markEdited(edited),\n    ));\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markTouched(touched),\n    ));\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.do(\n      supplyAfter(container),\n      digAfter_((snapshot: InContainer.Snapshot) => afterEach(...inControlStatuses(snapshot))),\n      mapAfter(combineInStatusFlags),\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by {@link inFormElement} function.\n *\n * @category Control\n * @typeParam TElt - A type of HTML form element.\n */\nexport type InFormElement<TElt extends HTMLElement = HTMLElement> = InElement<void, TElt>;\n\n/**\n * @category Control\n */\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by {@link inModeByForm}.\n     */\n    readonly modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element - HTML element to create control for.\n * @param options - Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<TElt extends HTMLElement>(\n    element: TElt,\n    options: InFormElement.Options,\n): InFormElement<TElt> {\n\n  const { form, aspects, modes } = options;\n  const control = new AbstractInElement<void, TElt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  control.supply.needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, modes));\n\n  return control;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form submit button control.\n *\n * It is connected to control to submit (form) and may change submit button state depending on form submit status.\n * E.g. by disabling it when submit is {@link InSubmit.Flags.ready not ready}, or while {@link InSubmit.Flags.busy\n * submitting} the form.\n *\n * Submit button control can be created by {@link inSubmitButton} function.\n *\n * @category Control\n * @typeParam TElt - A type of submit button element.\n */\nexport type InSubmitButton<TElt extends HTMLElement = HTMLElement> = InElement<void, TElt>;\n\n/**\n * @category Control\n */\nexport namespace InSubmitButton {\n\n  /**\n   * Submit button control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to submit button control by {@link inModeByForm}.\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `off` (disable) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `off` (disabled) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element - Submit button element to create control for.\n * @param options - Submit button control options.\n *\n * @returns New submit button control.\n */\nexport function inSubmitButton<TElt extends HTMLElement>(\n    element: TElt,\n    options: InSubmitButton.Options,\n): InSubmitButton<TElt> {\n\n  const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n  const control = new AbstractInElement<void, TElt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  control.supply.needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, { notReady, invalid, busy }));\n\n  return control;\n}\n","import { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull as InAspect.Applied<any, InStyledElement | null>;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param element - A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(element: InStyledElement | null = null): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { css__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport { DeltaSet } from '@proc7ts/delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  EventNotifier,\n  isEventKeeper,\n  mapAfter,\n  mapAfter_,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * An `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   */\n  abstract readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source - A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): Supply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element - Target element to apply CSS classes to.\n   * @param schedule - DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): Supply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason - An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by {@link InNamespaceAliaser} aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n  private readonly _sources = trackValue<[Map<AfterEvent<[InCssClasses.Map]>, Supply>]>([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    _control.supply.whenOff(reason => this.done(reason));\n\n    this.read = this._sources.read.do(\n        supplyAfter(this._control),\n        digAfter_(([sources]) => afterEach(...sources.keys())),\n        mapAfter_((...classes: [InCssClasses.Map][]) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        }),\n    );\n\n    this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    });\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).do(\n        mapAfter((...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        }),\n    );\n  }\n\n  add(source: InCssClasses.Source): Supply {\n\n    const inSupply = this._control.supply;\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = new Supply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source)({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).do(shareAfter);\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): Supply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","import { translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark - Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when - {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | readonly InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  return control => control.aspect(InValidation).read.do(translateAfter(\n      (send, errors) => hasError(errors) ? send(...inCssErrorMarks(mark)) : send(),\n  ));\n}\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: readonly InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction inCssErrorMarks(mark?: InCssClasses.Spec | readonly InCssClasses.Spec[]): readonly InCssClasses.Spec[] {\n  if (!mark) {\n    return defaultInCssErrorMarks;\n  }\n\n  const marks = arrayOfElements(mark);\n\n  return marks.length ? marks : defaultInCssErrorMarks;\n}\n","import { NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { afterAll, translateAfter } from '@proc7ts/fun-events';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InValidation } from '../../validation';\nimport { InStatus } from '../focus';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns - A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).do(translateAfter(\n        (send, { md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          send(...names);\n        },\n    ));\n  };\n}\n"],"names":["InAspect__symbol","Symbol","inAspectNull","instance","convertTo","noop","inAspectSameOrBuild","control","aspectKey","build","origin","undefined","target","attachTo","aspect","inAspectSameOrNull","valueProvider","inAspectValue","[object Object]","this","InputAspects__NS","NamespaceDef","InNamespaceAliaser__aspect","applyTo","newNamespaceAliaser","InNamespaceAliaser","to","nsAlias","applyAspect","InRenderScheduler__aspect","newRenderSchedule","InRenderScheduler","scheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","length","aspectConverters","map","from","conversion","conversions","overElementsOf","filterArray","acf","isPresent","itsReduction","prev","cv","set","isInAspectConversion","bind","get","intoConvertedAspects","aspects","value","Array","isArray","noopInConversion","InControl","ValueTracker","Map","_aspect","aspectKeyOrSetup","aspectSetup","by","and","InConverted","existing","_aspects","applied","_applyAspect","src","super","EventEmitter","supply","Supply","needs","backward","lastRev","convertAspect","asis","fallback","_it","trackValue","it","on","newValue","oldValue","_on","send","cuts","rev","prevValue","prevRev","InSameValueControl","_control","_supply","AbstractInControl","_aspectConversion","InContainer__aspect","InContainer","InContainerControls","OnEvent__symbol","AfterEvent__symbol","read","InParents__aspect","InControlParents","InParents","allParents","_map","keys","do","mapAfter","entry","existingSupply","delete","parent","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","reason","own","off","OwnModeTracker","element","_tracker","getAttribute","initialInMode","DerivedInModes","Set","sources","afterSent","mapOn","_all","valuesProvider","digAfter_","afterEach","mergeInModes","source","add","derive","InParentsAspect","digAfter","parentsInMode","last","afterAll","derived","_derived","translateAfter","next","substring","lastUpdate","translateOn","old","setAttribute","removeAttribute","applyInMode","afterSupplied","isEventKeeper","supplyAfter","parents","parentList","itsElements","afterThe","parentModes","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","InGroupControls","key","inControlReplacedReason","InGroupSnapshot","mapIt","overIterator","values","_entriesIt","iterator","PushIterator__symbol","accept","iteratorOf","InGroupMap","_controls","added","removed","replaced","newEntry","sendUpdate","push","modify","neverSupply","remove","whenOff","_shot","itsEach","entries","k","e","InGroupControlControls","_group","_updates","controlEntryToGroupEntry","takeSnapshot","snapshot","model","onceAfter","withValues","overEntries","has","keyOrControls","newControl","group","newModel","forEach","keyAndEntry","as","applyControlsToModel","clear","InGroupControl","opts","_model","controls","cs","readInGroupData","csData","controlsData","data","keyAndControlData","controlData","inGroup","RequireNothing$","requireNothing","dontRemove","InValidationMessages","emitter","validators","validatorMessages","validate","_messages","afterEventBy","receiver","resultSupply","validator","validatorSupply","messages","flatMapIt","size","shareAfter","arrayOfElements","inValidator","InValidation__aspect","InValidation","validation","InControlValidation","result","noInValidationErrors","ok","hasBut","overNone","_accept","InValidationErrors","overArray","message","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","container","results","flatMapArray","nestedInValidationMessages","numValidators","requireAll","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","Error","errors","submit","InSubmitRejectedError","rejected","submitted","busy","flags","_flags","ready","itsEvery","_errors","submitter","isOff","async","d","Promise","reject","submitData","error","toInSubmitMessages","inModeByForm","form","notReady","invalid","inModeByValidity","ignore","validity","AbstractInElement","self","_get","_set","_value","doUpdate","_update","update","input","correction","_input","events","DomEventDispatcher","listenForInput","onInput","event","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","ownerDocument","activeElement","ctx","onRecurrent","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","c","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","options","inSubmitButton","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","done","_sources","mapAfter_","classes","mergeInCssClassesMap","track","DeltaSet","EventNotifier","classesSent","filterIt","flag","name","delta","redelta","undelta","schedule","_schedule","controlSchedule","specs","names","isQualifiedName","css__naming","inSupply","classesSupply","resolve","context","receive","classList","updateClasses","node","inCssError","mark","when","hasError","defaultInCssHasError","defaultInCssErrorMarks","marks","inCssErrorMarks","inCssInfo","ns","cls","md","vl","st","valid"],"mappings":"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"}