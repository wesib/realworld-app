{"version":3,"file":"generic.5b4ac940.js","sources":["../../../../../hatsy/http-header-value/src/impl/hthv-item.ts","../../../../../hatsy/http-header-value/src/parser/add-param.ts","../../../../../hatsy/http-header-value/src/parser/parse-none.ts","../../../../../hatsy/http-header-value/src/parser/date-time-parser.ts","../../../../../hatsy/http-header-value/src/parser/next-in-item.ts","../../../../../hatsy/http-header-value/src/parser/item-parser.ts","../../../../../hatsy/http-header-value/src/parser/angle-brackets-parser.ts","../../../../../hatsy/http-header-value/src/parser/quoted-string-parser.ts","../../../../../hatsy/http-header-value/src/parser/next-in-comment.ts","../../../../../hatsy/http-header-value/src/parser/spaces-parser.ts","../../../../../hatsy/http-header-value/src/parser/param-parser.ts","../../../../../hatsy/http-header-value/src/parser/parser-config.ts","../../../../../hatsy/http-header-value/src/hthv-parser.ts","../../../../../hatsy/http-header-value/src/parser/item-delimit-parser.ts","../../../../../hatsy/http-header-value/src/parser/comment-parser.ts","../../../../../hatsy/http-header-value/src/hthv-parse.ts","../../../../../hatsy/http-header-value/src/hthv-quote.ts","../../../../generic/src/fetch/fetch-agent-key.impl.ts","../../../../generic/src/fetch/http-fetch-agent.ts","../../../../generic/src/fetch/http-fetch.impl.ts","../../../../generic/src/fetch/http-fetch.ts","../../../../generic/src/hierarchy/hierarchy-updates.impl.ts","../../../../generic/src/hierarchy/hierarchy-context.ts","../../../../generic/src/hierarchy/hierarchy-registry.impl.ts","../../../../generic/src/tree/element-node-list.ts","../../../../generic/src/tree/element-node-list.impl.ts","../../../../generic/src/tree/node-attributes.impl.ts","../../../../generic/src/tree/node-properties.impl.ts","../../../../generic/src/tree/element-node.impl.ts","../../../../generic/src/tree/element-node.ts","../../../../generic/src/navigation/hash-url/hash-url.ts","../../../../generic/src/navigation/page-param.ts","../../../../generic/src/navigation/hash-url/page-hash-url-param.impl.ts","../../../../generic/src/navigation/hash-url/page-hash-url-param.ts","../../../../generic/src/navigation/navigation-agent.ts","../../../../generic/src/navigation/hash-url/page-hash-url-support.feature.ts","../../../../generic/src/navigation/page-param-context.ts","../../../../generic/src/navigation/nav-history.impl.ts","../../../../generic/src/navigation/navigation.event.ts","../../../../generic/src/navigation/navigation.ts","../../../../generic/src/navigation/activate-nav-link.decorator.ts","../../../../generic/src/navigation/handle-nav-links.decorator.ts","../../../../generic/src/util/import-node.ts","../../../../generic/src/navigation/page-load/caching-page-loader.impl.ts","../../../../generic/src/navigation/page-load/page-load-requests.impl.ts","../../../../generic/src/navigation/page-load/page-load-agent.ts","../../../../generic/src/navigation/page-load/page-load-url-modifier.ts","../../../../generic/src/navigation/page-load/page-loader.impl.ts","../../../../generic/src/navigation/page-load/page-load-param.ts","../../../../generic/src/navigation/page-load/page-cache-buster.impl.ts","../../../../generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../../../generic/src/navigation/page-load/page-style-agent.impl.ts","../../../../generic/src/navigation/page-load/page-title-agent.impl.ts","../../../../generic/src/navigation/page-load/page-load-support.feature.ts","../../../../generic/src/navigation/page-load/include-page.decorator.ts","../../../../generic/src/input/default-in-aspects.ts","../../../../generic/src/input/input-from-control.ts","../../../../generic/src/input/convert-input.decorator.ts","../../../../generic/src/input/input-to-form.ts","../../../../generic/src/input/fill-input-form.decorator.ts","../../../../generic/src/input/on-submit.decorator.ts","../../../../generic/src/input/set-input-name.decorator.ts","../../../../generic/src/input/use-input-element.decorator.ts"],"sourcesContent":["import type { HthvItem } from '../hthv-item';\nimport type { HthvPartial } from './hthv-partial';\n\n/**\n * @internal\n */\nexport function hthvItem<TItem extends HthvItem<any, any, any>>(\n    {\n      $ = 'raw',\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<TItem>,\n): TItem {\n  if (n) {\n    (p as Record<string, HthvPartial>)[n as string] = { $, n, v, x: [], p: {}, pl: [] };\n  }\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as TItem;\n}\n","import type { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam(\n    {\n      p,\n      pl,\n    }: HthvItem,\n    param: HthvParamItem,\n): void {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","/**\n * @internal\n */\nexport const parseNone = (): false => false;\n","import { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function dateTimeParser(\n    { dateTime }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return dateTime ? parseDateTime : parseNone;\n}\n\nfunction parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (datePattern.test(input.s)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","import type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = delimiterOf(c);\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { dateTimeParser } from './date-time-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { quotedStringParser } from './quoted-string-parser';\n\n/**\n * @internal\n */\nexport interface ItemParserConfig {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseDateTime = dateTimeParser(config);\n  const parseQuotedString = quotedStringParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem))); // eslint-disable-line curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser({ delimiterOf }: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport type { HthvParserConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  readonly dateTime?: boolean;\n  delimiterOf(this: void, char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n      dateTime,\n    }: HthvParserConfig = {},\n): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    dateTime,\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = (/*#__PURE__*/ buildParserConfig());\n\n/**\n * @internal\n */\nexport const commentParserConfig = (/*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n}));\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport type { HthvDelimiterChar } from './hthv-delimiter';\nimport type { HthvItem } from './hthv-item';\nimport { hthvItem } from './impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeParam TNameMode - Whether parsed items have {@link HthvItem.n names}.\n * @typeParam TTagMode - Whether parsed items have {@link HthvItem.t tags}.\n * @typeParam TParamsMode - Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    TNameMode extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    TTagMode extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    TParamsMode extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value - HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<TNameMode, TTagMode, TParamsMode>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse date/time values.\n   *\n   * @default `false`\n   */\n  readonly dateTime?: boolean;\n\n  /**\n   * Whether to parse comments.\n   *\n   * @default `false`.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config - New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // eslint-disable-line curly\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const commentParserConfig: ItemParserConfig = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserConfig);\n  const parseParam = paramParser(config, commentParserConfig);\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while ( // eslint-disable-line curly\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        );\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments or date/time values.\n *\n * Treats illegal characters as ASCII letters.\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser = (/*#__PURE__*/ newHthvParser());\n\n/**\n * Parses HTTP header value that may contain date/time.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default config except {@link HthvParserConfig.dateTime date/time parsing enabled}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParseDT: HthvParser = (/*#__PURE__*/ newHthvParser({ dateTime: true }));\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string - A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  const { delimiterOf } = defaultParserConfig;\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper, EventSender, OnEvent, onSupplied } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<TResponse>,\n    request: Request,\n) => EventSender<TResponse>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n) => OnEvent<TResponse>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<TResponse extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>\n    implements ContextUpRef<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...agents) => {\n              if (agents.length) {\n                return afterThe(combineFetchAgents(agents));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(defaultFetchAgent);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          CombinedFetchAgent<TResponse>,\n          EventKeeper<FetchAgent<TResponse>[]> | FetchAgent<TResponse>,\n          AfterEvent<FetchAgent<TResponse>[]>>,\n  ): void {\n\n    let delegated: CombinedFetchAgent<TResponse>;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, request) => delegated(next, request));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<TResponse extends any[]>(\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n): OnEvent<TResponse> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<TResponse extends any[]>(\n    agents: FetchAgent<TResponse>[],\n): CombinedFetchAgent<TResponse> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<TResponse> = (\n        agentIdx,\n        agentRequest,\n    ) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter {@link HttpFetch} processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by {@link HttpFetch}.\n */\nexport type HttpFetchAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * {@link HttpFetch} call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under {@link HttpFetchAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of response object(s) receivers. It is returned as a result of {@link HttpFetch} call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an {@link HttpFetchAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { EventEmitter, onceOn, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: Supply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new window.AbortController();\n        const { signal } = abortController;\n\n        supply = new Supply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal)\n              .on('abort')\n              .do(onceOn)(\n                  () => abortController.abort(),\n              );\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of {@link HttpFetch} is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input - The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init - Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an {@link HttpFetch} instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport {\n  BootstrapContext,\n  BootstrapRoot,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentContextHolder,\n  ComponentEvent,\n} from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport type HierarchyRoot = ValueTracker<ComponentContext | undefined>;\n\n/**\n * @internal\n */\nexport const HierarchyRoot = (/*#__PURE__*/ new SingleContextKey<HierarchyRoot>(\n    'hierarchy-root',\n    {\n      byDefault: bsContext => {\n\n        const root = bsContext.get(BootstrapRoot);\n\n        new DomEventDispatcher(root).on<ComponentEvent>('wesib:component')(\n            ({ context }: ComponentEvent) => context.get(HierarchyUpdates).issue(),\n        );\n\n        return trackValue();\n      },\n    },\n));\n\nconst HierarchyUpdates__key = (/*#__PURE__*/ new SingleContextKey<HierarchyUpdates>(\n    'hierarchy-updates',\n    {\n      byDefault: context => new HierarchyUpdates(context.get(ComponentContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class HierarchyUpdates {\n\n  static get [ContextKey__symbol](): ContextKey<HierarchyUpdates> {\n    return HierarchyUpdates__key;\n  }\n\n  readonly on: OnEvent<[ComponentContext]>;\n  readonly send: (this: void) => void;\n  readonly issue: () => void;\n\n  constructor(context: ComponentContext) {\n\n    const updates = new EventEmitter<[ComponentContext]>();\n    const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n\n    this.on = updates.on;\n    this.send = () => updates.send(context);\n    this.issue = () => {\n\n      const parent = findParentContext(context);\n\n      if (parent) {\n        parent[0].get(HierarchyUpdates).send();\n      } else {\n        hierarchyRoot.it = context;\n      }\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport function findParentContext(of: ComponentContext): [ComponentContext, boolean] | undefined {\n\n  const root = of.get(BootstrapContext).get(BootstrapRoot);\n  let { element } = of as { element: Node };\n  let immediate = true;\n\n  if (element === root) {\n    return;\n  }\n  for (;;) {\n\n    const parent = element.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    const ctx = (parent as ComponentContextHolder)[ComponentContext__symbol];\n\n    if (ctx) {\n      return [ctx, immediate];\n    }\n    if (parent === root) {\n      return;\n    }\n\n    immediate = false;\n    element = parent;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  ContextValueSpec,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  afterEventBy,\n  consumeEvents,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { BootstrapContext, ComponentContext } from '@wesib/wesib';\nimport { newHierarchyRegistry } from './hierarchy-registry.impl';\nimport { findParentContext, HierarchyRoot, HierarchyUpdates } from './hierarchy-updates.impl';\n\n/**\n * @internal\n */\nconst HierarchyContext__key = (/*#__PURE__*/ new SingleContextKey<HierarchyContext>(\n    'hierarchy-context',\n    {\n      byDefault: context => new HierarchyContext$(context.get(ComponentContext)),\n    },\n));\n\n/**\n * Component's hierarchy context.\n *\n * Passes provided values to hierarchy contexts of nested components.\n *\n * Available as component context value.\n *\n * @typeParam T - A type of component.\n */\nexport abstract class HierarchyContext<T extends object = any> extends ContextValues implements SupplyPeer {\n\n  /**\n   * A key of component context value containing its hierarchy context instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<HierarchyContext> {\n    return HierarchyContext__key;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * An `AfterEvent` keeper of enclosing component's hierarchy context.\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   */\n  abstract readonly up: AfterEvent<[HierarchyContext?]>;\n\n  get supply(): Supply {\n    return this.context.supply;\n  }\n\n  /**\n   * Assigns enclosing component to use by default.\n   *\n   * The provided component will be treated as enclosing one until component element connected. After that the real\n   * enclosing component will be used instead.\n   *\n   * @param enclosing - Enclosing component's context to assign, or nothing to remove one.\n   *\n   * @returns `this` instance.\n   */\n  abstract inside(enclosing?: ComponentContext): this;\n\n  /**\n   * Provides hierarchy context value.\n   *\n   * If provided value is updatable (i.e. its key implements `ContextUpKey`), then it will be available in this context,\n   * as well as in all nested hierarchy contexts. Otherwise the value will be available in this context only.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   * @param spec - Context value specifier.\n   *\n   * @returns A value supply that that removes the given context value specifier once cut off.\n   */\n  abstract provide<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, TDeps, TSrc, TSeed>,\n  ): Supply;\n\n}\n\nclass HierarchyContext$<T extends object> extends HierarchyContext<T> {\n\n  private readonly _parent: ValueTracker<HierarchyContext | undefined>;\n  private readonly _registry: ContextRegistry<HierarchyContext<T>>;\n  readonly get: HierarchyContext<T>['get'];\n  readonly up: AfterEvent<[HierarchyContext?]>;\n\n  constructor(readonly context: ComponentContext<T>) {\n    super();\n\n    this.up = afterEventBy<[HierarchyContext?]>(\n        receiver => {\n\n          const { supply } = receiver;\n\n          supply.needs(this);\n\n          const parentHierarchy = trackValue<HierarchyContext>();\n\n          parentHierarchy.by(this._parent);\n          supply.cuts(parentHierarchy);\n\n          const rootSupply = new Supply().needs(supply);\n          const parentSupply = new Supply().needs(supply);\n          const updateParent = (): void => {\n\n            const parent = findParentContext(this.context);\n\n            if (parent) {\n\n              const [parentCtx, immediate] = parent;\n\n              parentHierarchy.it = parentCtx.get(HierarchyContext);\n              rootSupply.off();\n              if (immediate) {\n                parentSupply.off();\n              }\n            } else {\n              parentHierarchy.it = undefined;\n            }\n          };\n\n          this.context.get(BootstrapContext).get(HierarchyRoot).read({\n            supply: rootSupply,\n            receive: () => this.context.connected && updateParent(),\n          });\n          parentHierarchy.read.do(\n              supplyAfter(parentSupply),\n              consumeEvents(newParent => newParent && newParent.context.get(HierarchyUpdates).on(updateParent)),\n          );\n          parentHierarchy.read(receiver);\n          this.context.whenConnected({\n            supply: new Supply().needs(supply),\n            receive: updateParent,\n          });\n        },\n    ).do(shareAfter);\n\n    const parent = this._parent = trackValue<HierarchyContext>();\n\n    context.whenConnected(noop).cuts(parent);\n\n    const registry = this._registry = newHierarchyRegistry<T>(this.up);\n\n    this.get = registry.newValues().get;\n  }\n\n  provide<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, TDeps, TSrc, TSeed>,\n  ): Supply {\n    return this._registry.provide(spec).needs(this);\n  }\n\n  inside(enclosing?: ComponentContext): this {\n    this._parent.it = enclosing && enclosing.get(HierarchyContext);\n    return this;\n  }\n\n}\n","import { ContextRegistry, ContextSeedKey } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { HierarchyContext } from './hierarchy-context';\n\n/**\n * @internal\n */\nexport function newHierarchyRegistry<T extends object>(\n    up: AfterEvent<[HierarchyContext?]>,\n): ContextRegistry<HierarchyContext<T>> {\n  return new ContextRegistry(\n      <TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>) => isContextSeedUpKey(key)\n          ? up.do(digAfter(\n              upper => upper ? upper.get(key) : afterThe(),\n          )) as unknown as TSeed\n          : undefined,\n  );\n}\n\n/**\n * @internal\n */\nfunction isContextSeedUpKey<TSrc>(\n    key: ContextSeedKey<TSrc | EventKeeper<TSrc[]>, any>,\n): key is ContextUpKey.SeedKey<TSrc> {\n  return 'upKey' in key;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n *\n * @typeParam TNode - A type of element nodes.\n */\nexport abstract class ElementNodeList<TNode extends ElementNode = ElementNode>\n    implements Iterable<TNode>, EventSender<[TNode[], TNode[]]>, EventKeeper<[ElementNodeList<TNode>]> {\n\n  /**\n   * An `OnEvent` sender of this list changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[TNode[], TNode[]]>;\n\n  /**\n   * An `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[ElementNodeList<TNode>]>;\n\n  /**\n   * An `AfterEvent` keeper of tracked list changes.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   */\n  abstract readonly track: AfterEvent<[readonly TNode[], readonly TNode[]]>;\n\n  /**\n   * An `AfterEvent` keeper of either the first node in this list, or `undefined` when the list is empty.\n   */\n  abstract readonly first: AfterEvent<[TNode?]>;\n\n  abstract [Symbol.iterator](): Iterator<TNode>;\n\n  [OnEvent__symbol](): OnEvent<[TNode[], TNode[]]> {\n    return this.onUpdate;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[ElementNodeList<TNode>]> {\n    return this.read;\n  }\n\n}\n","import { html__naming } from '@frontmeans/namespace-aliaser';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  mapAfter,\n  OnEvent,\n  onEventBy,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { isPresent, valueProvider } from '@proc7ts/primitives';\nimport {\n  filterArray,\n  filterIt,\n  flatMapArray,\n  iteratorOf,\n  itsEach,\n  itsElements,\n  itsFirst,\n  mapIt,\n  overArray,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<TNode extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => TNode | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList<TNode> {\n\n  const updates = new EventEmitter<[TNode[], TNode[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let selector: string | undefined;\n  const overNodes: (nodes: NodeList) => Iterable<Node> = deep ? overNodeSubtree : overArray;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n          // Refresh selection after component name resolution.\n          // This is needed  when new document loaded.\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = itsElements(\n                filterIt<TNode | undefined, TNode>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            /* istanbul ignore if. Can not test native custom element */\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    }).catch(console.error);\n  }\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as TNode;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  const iterable: PushIterable<TNode> = filterIt<TNode | undefined, TNode>(\n      mapIt(\n          overIterator(elements),\n          element => nodeOf(element),\n      ),\n      isPresent,\n  );\n\n  class ElementNodeList$ extends ElementNodeList<TNode> implements PushIterable<TNode> {\n\n    readonly onUpdate: OnEvent<[TNode[], TNode[]]>;\n    readonly read: AfterEvent<[ElementNodeList<TNode>]>;\n    readonly track: AfterEvent<[readonly TNode[], readonly TNode[]]>;\n    readonly first: AfterEvent<[TNode?]>;\n\n    constructor() {\n      super();\n\n      const observer = bsContext.get(ElementObserver)(update);\n\n      this.onUpdate = onEventBy<[TNode[], TNode[]]>(receiver => {\n\n        const firstReceiver = !updates.size;\n        const supply = updates.on(receiver);\n\n        if (firstReceiver) {\n          refresh();\n          observer.observe(root, init);\n        }\n\n        supply.whenOff(() => {\n          if (!updates.size) {\n            observer.disconnect();\n            clearCache(); // clear cache as there is no more receivers\n          }\n        }).needs(receiver.supply);\n      });\n\n      const returnSelf = valueProvider(this);\n\n      this.read = this.onUpdate.do(mapAfter(returnSelf, returnSelf));\n\n      this.track = afterEventBy<[readonly TNode[], readonly TNode[]]>(receiver => {\n\n        const initialEmitter = new EventEmitter<[readonly TNode[], readonly TNode[]]>();\n\n        initialEmitter.on(receiver);\n        initialEmitter.send(itsElements(this), []);\n\n        this.onUpdate(receiver);\n      });\n\n      this.first = afterSupplied(this.read).do(translateAfter(\n          (send, list) => send(itsFirst(list)),\n      ));\n    }\n\n    [Symbol.iterator](): PushIterator<TNode> {\n      return this[PushIterator__symbol]();\n    }\n\n    [PushIterator__symbol](accept?: PushIterator.Acceptor<TNode>): PushIterator<TNode> {\n      return iterable[PushIterator__symbol](accept);\n    }\n\n  }\n\n  return new ElementNodeList$();\n\n  function elements(): Iterator<Element> {\n    return iteratorOf(updates.size ? cache : refresh());\n  }\n\n  function clearCache(): void {\n    cache.clear();\n  }\n\n  function refresh(): Set<Element> {\n\n    const list = select();\n\n    if (updates.size) {\n      cache = list; // cache is for receivers only\n    }\n\n    return list;\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n\n    return new Set(filterArray(root.children, item => item.matches(sel)));\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: TNode[] = [];\n    const removed: TNode[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<TNode | undefined, TNode>(\n              mapIt(overNodes(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<TNode | undefined, TNode>(\n              mapIt(overNodes(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): TNode | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): TNode | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n\nfunction overNodeSubtree(nodes: NodeList): Iterable<Node> {\n  return flatMapArray(\n      nodes,\n      node => overArray([node, ...overNodeSubtree(node.childNodes)]),\n  );\n}\n","import { EventEmitter, eventReceiver, EventReceiver, OnEvent, onEventBy, ValueTracker } from '@proc7ts/fun-events';\nimport { neverSupply, Supply } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string | null, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer = this._bs.get(BootstrapWindow).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string | null, string | null]>): Supply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: new Supply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: [...self._emitters.keys()],\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string | null, string | null]> {\n\n    const emitter = new EventEmitter<[string | null, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly on: OnEvent<[string | null, string | null]>;\n  private readonly _updates = new EventEmitter<[string | null, string | null]>();\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n\n    let observeSupply = neverSupply();\n\n    this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            this._name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    });\n  }\n\n  get supply(): Supply {\n    return this._updates.supply;\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (value != null) {\n      this._observer.element.setAttribute(this._name, value);\n    } else {\n      this._observer.element.removeAttribute(this._name);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { EventEmitter, OnEvent, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\n\n/**\n * @internal\n */\ntype ElementWithProperty<T> = {\n  [key in PropertyKey]: T;\n};\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n  private readonly _key: string;\n  constructor(\n      private readonly _element: ElementWithProperty<T>,\n      key: PropertyKey,\n  ) {\n    super();\n    this._key = key as string;\n  }\n\n  get supply(): Supply {\n    return this._updates.supply;\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._updates.on;\n  }\n\n  bind(context: ComponentContext): void {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    propertyState.onUpdate({\n      supply: this.supply,\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import { ValueTracker } from '@proc7ts/fun-events';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentContextHolder,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ComponentNode, ComponentTreeNode, ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\ntype TreeElement = Element & ComponentContextHolder & {\n  [ElementNode__symbol]?: ComponentTreeNode;\n};\n\n/**\n * @internal\n */\nclass ElementNode$ implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: TreeElement) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    element[ElementNode__symbol] = this;\n\n    const context = element[ComponentContext__symbol];\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return this.element[ComponentContext__symbol];\n  }\n\n  get parent(): ElementNode | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null> {\n    return this._attrs.get(name);\n  }\n\n  property<TValue>(key: PropertyKey): ValueTracker<TValue> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional: true,\n): ElementNode | undefined;\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: false,\n): ElementNode;\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: boolean,\n): ElementNode | undefined;\n\n\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: boolean,\n): ElementNode | undefined {\n\n  const existing = element[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode$(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { BootstrapContext, ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector - Simple CSS selector of nested components.\n   * @param mode - Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType - Nested component type with custom element name.\n   * @param mode - Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector - Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode - A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * `null` attribute value corresponds to its absence. Setting it to `null` removes attribute.\n   *\n   * @param name - Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @typeParam TValue - Property value type.\n   * @param key - Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<TValue>(key: PropertyKey): ValueTracker<TValue>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>(\n        'component-node',\n        {\n          byDefault(context) {\n            return elementNodeOf(\n                context.get(BootstrapContext),\n                context.get(ComponentContext).element,\n            ) as ComponentNode;\n          },\n        },\n    )\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\n/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url - An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url - Base URL.\n * @param hashURL - Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL(`#${hashURL}`, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to {@link LeavePageEvent}). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeParam T - Parameter value type.\n * @typeParam TInput - Parameter input type.\n */\nexport abstract class PageParam<T, TInput> implements PageParam.Ref<T, TInput> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page - A page to assign navigation parameter to.\n   * @param input - Parameter input used to construct its initial value.\n   * @param context - Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: TInput, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page - A page to assign navigation parameter to.\n   * @param _context - Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, TInput> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Ref<T, TInput> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, TInput>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface WithDefaults<T, TInput> extends PageParam<T, TInput> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     */\n    export interface Ref<T, TInput> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, TInput>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Handle<T, TInput> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input - Parameter input to use when updating its value.\n     */\n    put(input: TInput): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before {@link LeavePageEvent} is fired for each parameter handle of current page.\n     *\n     * @param to - A page to transfer parameter to.\n     * @param when - When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(\n        to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return',\n    ): Handle<T, TInput> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page - Entered page.\n     * @param when - When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at - The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","import { Page } from '../page';\nimport { PageParam } from '../page-param';\n\nclass PageHashURLValueParam$ extends PageParam<URL | undefined | null, URL | string | null | undefined> {\n\n  create(\n      page: Page,\n      input: URL | null | undefined,\n  ): PageParam.Handle<URL | null | undefined, URL | string | null | undefined> {\n\n    let hashURL: URL | null | undefined;\n    const handle: PageParam.Handle<URL | null | undefined, URL | string | null | undefined> = {\n      get() {\n        return hashURL;\n      },\n      put(value) {\n        hashURL = typeof value === 'string' ? new URL(value, page.url.origin) : value;\n      },\n    };\n\n    handle.put(input);\n\n    return handle;\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageHashURLValueParam: PageParam<URL | null | undefined, URL | string | null | undefined> = (\n    /*#__PURE__*/ new PageHashURLValueParam$()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { getHashURL } from './hash-url';\nimport { PageHashURLValueParam } from './page-hash-url-param.impl';\n\n/**\n * @internal\n */\nclass PageHashURLParam$ extends PageParam<URL, URL | string | null | undefined> {\n\n  create(page: Page, input: URL | string | null | undefined): PageParam.Handle<URL, URL | string | null | undefined> {\n\n    const handle: PageParam.Handle<URL, URL | string | null | undefined> = {\n      get() {\n        return page.get(PageHashURLValueParam) || getHashURL(page.url);\n      },\n      put(value) {\n        page.put(PageHashURLValueParam, value);\n      },\n    };\n\n    handle.put(input);\n\n    return handle;\n  }\n\n  byDefault(page: Page): PageParam.Handle<URL, URL> {\n    return this.create(page, null);\n  }\n\n}\n\n/**\n * Page parameter representing its {@link getHashURL hash URL}.\n *\n * When {@link Navigation.with set} to another value while navigating, the hash of target URL is updated, unless set to\n * `null` or `undefined`.\n *\n * Requires {@link PageHashURLSupport} for above to function properly.\n */\nexport const PageHashURLParam: PageParam.WithDefaults<URL, URL | string | null | undefined> = (\n    /*#__PURE__*/ new PageHashURLParam$()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from - The page to leave.\n * @param to - Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => {\n\n          const { document } = slot.context.get(BootstrapWindow);\n\n          slot.insert(slot.seed.do(\n              digAfter((...agents) => {\n                if (agents.length) {\n                  return afterThe(combinedAgent);\n                }\n                if (slot.hasFallback && slot.or) {\n                  return slot.or;\n                }\n\n                return afterThe(defaultNavigationAgent);\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              }),\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): void {\n\n    let delegated: NavigationAgent.Combined;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, when, from, to) => delegated(next, when, from, to));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under {@link NavigationAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the\n   * last one. Not calling this function effectively prevents navigation.\n   * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n   * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from - The page to leave.\n   * @param to - Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an {@link NavigationAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { NavigationAgent } from '../navigation-agent';\nimport { Page } from '../page';\nimport { setHashURL } from './hash-url';\nimport { PageHashURLValueParam } from './page-hash-url-param.impl';\n\nconst PageHashURLSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: NavigationAgent, is: pageHashURLAgent });\n  },\n};\n\n/**\n * {@link PageHashURLParam Page hash URL parameter} support feature.\n */\nexport class PageHashURLSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageHashURLSupport__feature;\n  }\n\n}\n\nfunction pageHashURLAgent(\n    next: (this: void, target?: Navigation.Target) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n\n  const hashURL = to.get(PageHashURLValueParam);\n\n  if (hashURL) {\n    next({ url: setHashURL(to.url, hashURL) });\n  } else {\n    next();\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValues } from '@proc7ts/context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * @internal\n */\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\n/**\n * @internal\n */\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      ? { data: state }\n      : (state as NavDataEnvelope)[NAV_DATA_KEY] as PartialNavData;\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      get data(): any {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, TInput> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, TInput>(param: PageParam<T, TInput>, handle: PageParam.Handle<T, TInput>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onAny,\n  OnEvent,\n  OnEvent__symbol,\n  onSupplied,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>(\n    'navigation',\n    {\n      byDefault: bootstrapDefault(createNavigation),\n    },\n));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` {@link StayOnPageEvent stay on page events}.\n   *\n   * The registered listener is informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   *\n   * @returns `OnDomEvent` sender of {@link StayOnPageEvent stay on page events}.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` sender of {@link NavigationEvent navigation events}.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of {@link page current page}.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta - Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target - Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target - Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url - An URL to replace the the current one with.\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   * @param ref - A reference to page navigation parameter to apply.\n   * @param input - Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     * @param ref - A reference to page navigation parameter to apply.\n     * @param input - Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target - Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target - Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to.\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to {@link Navigation.open} and {@link Navigation.replace} methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n\nfunction createNavigation(context: BootstrapContext): Navigation {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation.URLTarget]: Navigation.URLTarget[K] };\n\n  class Navigation$ extends Navigation {\n\n    readonly onEnter: OnDomEvent<EnterPageEvent>;\n    readonly onLeave: OnDomEvent<LeavePageEvent>;\n    readonly onStay: OnDomEvent<StayOnPageEvent>;\n    readonly on: OnEvent<[NavigationEvent]>;\n    readonly read: AfterEvent<[Page]>;\n\n    constructor() {\n      super();\n      this.onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n      this.onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n      this.onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n      this.on = onAny<[NavigationEvent]>(\n          onSupplied(this.onEnter),\n          onSupplied(this.onLeave),\n          onSupplied(this.onStay),\n      );\n      this.read = nav.read.do(\n          mapAfter(({ page }) => page),\n      );\n    }\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation$();\n\n  function withParam(applyParams: (page: Page) => void): Navigation.Parameterized {\n    return {\n      with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { css__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  consumeEvents,\n  digAfter_,\n  EventKeeper,\n  supplyAfter,\n  translateAfter_,\n} from '@proc7ts/fun-events';\nimport { Class, noop, Supply } from '@proc7ts/primitives';\nimport { mapIt } from '@proc7ts/push-iterator';\nimport {\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  ElementRenderScheduler,\n  RenderDef,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { ComponentNode, ElementNode, ElementPickMode } from '../tree';\nimport { getHashURL } from './hash-url';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  supply(): Supply;\n}\n\n/**\n * Creates component decorator that marks navigation link(s) inside decorated component active.\n *\n * Marks navigation links with highest weight.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenConnected(() => {\n\n          let active = new Map<ElementNode, ActiveNavLink>();\n\n          navigation.read.do(\n              supplyAfter(context),\n              consumeEvents(\n                  page => componentNode.select(select, pick).read.do(\n                      digAfter_(nodes => afterEach(\n                          ...mapIt(nodes, node => weigh({ node, context, page })),\n                      )),\n                      consumeEvents((...weights: NavLinkWeight[]) => {\n\n                        const selected = selectActiveNavLinks(weights);\n                        const newActive = new Map<ElementNode, ActiveNavLink>();\n                        const result = new Supply();\n\n                        selected.forEach(node => {\n\n                          let activeLink: ActiveNavLink;\n                          const existing = active.get(node);\n\n                          if (existing) {\n                            newActive.set(node, existing);\n                            activeLink = existing;\n                          } else {\n                            activeLink = activate({ node, context, page });\n                            newActive.set(node, activeLink);\n                          }\n\n                          activeLink.supply().needs(result);\n                        });\n\n                        active = newActive;\n\n                        return result;\n                      }),\n                  ),\n              ),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked {@link active}.\n *\n * @typeParam T - A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Rendering definition options to pass to nav links render scheduler.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path length as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters plus the\n   *    link path length is used as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as {@link getHashURL URLs}. The weight is calculated by applying steps 1, 2, and 3\n   *    to hash URLs increased by the link path length and the number of search parameters.\n   *\n   * Ignores search parameters with names starting and ending with double underscores. Like `__wesib_app_rev__`.\n   *\n   * @param node - Navigation link node to weigh.\n   * @param page - Current navigation page.\n   * @param context - Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active - Whether to make target link active (`true`), or inactive (`false`).\n   * @param node - Navigation link node to update activity state of.\n   * @param page - Current navigation page.\n   * @param context - Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLinks(weights: NavLinkWeight[]): ElementNode[] {\n\n  let maxWeight = 0;\n  let active: ElementNode[] = [];\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = [node];\n    } else if (weight === maxWeight) {\n      active.push(node);\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = afterSupplied(weight).do(translateAfter_(\n        (send, weight) => send(opts.node, weight),\n    ));\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier({\n        supply: new Supply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier(receiver);\n            }),\n        receive: receiver.receive.bind(receiver),\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const { element } = node as { element: Element };\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n    if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n\n    return linkURL.pathname.length\n        + searchParamWeight\n        + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return linkURL.pathname.length + searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((value, key) => {\n    if (!isIgnoredSearchParam(key)) {\n      if (weight >= 0) {\n        if (pageParams.getAll(key).includes(value)) {\n          weight += 1;\n        } else {\n          weight = -1;\n        }\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nfunction isIgnoredSearchParam(key: string): boolean {\n  return key.startsWith('__') && key.endsWith('__');\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\ninterface RenderedElement extends Element {\n\n  [NavLinkRenderSchedule__symbol]?: RenderSchedule;\n\n}\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(ElementRenderScheduler);\n  const { render, active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const { element } = node as { element: Element };\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node as { element: RenderedElement };\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler(render));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: Supply | undefined;\n\n    return {\n      supply(): Supply {\n\n        const supply = lastSupply = new Supply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { onceAfter } from '@proc7ts/fun-events';\nimport { Class, setOfElements } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link Navigation navigation actions} instead of default ones.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks(def);\n  const events = setOfElements(def.event || 'click');\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenConnected(() => {\n\n          const navigation = context.get(Navigation);\n\n          for (const eventType of events) {\n            context.on(eventType)(event => {\n              navigation.read.do(onceAfter)(\n                  page => handle({\n                    event,\n                    page,\n                    context,\n                    navigation,\n                  }),\n              );\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeParam T - A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action. It also prevents navigation\n   * if URL didn't change.\n   *\n   * @param event - A click event to handle.\n   * @param page - Current navigation page.\n   * @param navigation - Navigation service to use.\n   * @param context - Component context.\n   */\n  handle?(\n      {\n        event,\n        page,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        page: Page;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n  /**\n   * Extracts hyper-reference of clicked element.\n   *\n   * Extracts hyper-reference from `href` attribute of event target.\n   *\n   * @param event - A click event to handle.\n   *\n   * @returns Extracted hyper-reference, or nothing if it can not be extracted. Event will be ignored in this case.\n   */\n  href?(event: Event): string | undefined | null;\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkHref(event: Event): string | null {\n\n  const target = event.target as Element;\n\n  return target.getAttribute('href');\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    def: HandleNavLinksDef,\n): (\n    opts: {\n      event: Event;\n      page: Page;\n      navigation: Navigation;\n    },\n) => void {\n\n  const getHref = def.href ? def.href.bind(def) : defaultNavLinkHref;\n\n  return ({\n    event,\n    page,\n    navigation,\n  }) => {\n\n    const href = getHref(event);\n\n    if (href == null) {\n      return;\n    }\n\n    const target = event.target as Element;\n    const pageURL = page.url;\n    const url = new URL(href, target.ownerDocument.baseURI);\n\n    if (url.origin !== pageURL.origin) {\n      return; // External link\n    }\n\n    event.preventDefault();\n    if (pageURL.href !== url.href) {\n      navigation.open(href).catch(console.error);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { itsEach, overArray } from '@proc7ts/push-iterator';\nimport { isElement } from '@wesib/wesib';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param before - The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: TNode, to: TNode) => void),\n    importContent: (this: void, from: TNode, to: TNode) => void = importNodeContent,\n): TNode {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & TNode);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from - The node which contents to import.\n * @param to - The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { OnEvent, onEventBy, supplyOn, trackValue, valueOn_ } from '@proc7ts/fun-events';\nimport { asis, Supply } from '@proc7ts/primitives';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: Supply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = new Supply(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.cuts(trackSupply).cuts(tracker);\n\n        tracked = {\n          on: tracker.read.do(valueOn_(asis)),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on.do(supplyOn(supply))(receiver).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          }).catch(console.error);\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  mapOn_,\n  OnEvent,\n  onEventBy,\n  shareOn,\n  supplyOn,\n} from '@proc7ts/fun-events';\nimport { neverSupply, noop, Supply } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach, itsEvery, overIterator, PushIterable } from '@proc7ts/push-iterator';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests {\n\n  private readonly _map = new Map<Supply, PageLoadReq[]>();\n  private readonly _requests: PushIterable<PageLoadReq>;\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {\n    this._requests = flatMapIt(overIterator(() => this._map.values()));\n  }\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    if (!itsEvery(\n        this._requests,\n        request => {\n          if (!request.fragment) {\n            return false;\n          }\n          result.push(request.fragment);\n          return true;\n        },\n    )) {\n      return [];\n    }\n\n    return result;\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = new Supply();\n    let loadSupply = neverSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = new Supply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page).do(supplyOn(loadSupply))(\n              response => emitter.send(response),\n          ).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error,\n              });\n            }\n          });\n\n          return supply;\n        }).do(shareOn);\n\n        itsEach(\n            self._requests,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: new Supply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, list.slice());\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.do(\n          mapOn_(\n              response => response.ok\n                  ? {\n                    ...response,\n                    fragment: (\n                        fragment.tag != null\n                            ? response.document.getElementsByTagName(fragment.tag)[0]\n                            : response.document.getElementById(fragment.id)\n                    ) || undefined,\n                  }\n                  : response,\n          ),\n      )\n      : onLoad;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under {@link PageLoadAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of page load response.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an {@link PageLoadAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { noop, valueProvider } from '@proc7ts/primitives';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url - An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { hthvParse, hthvQuote } from '@hatsy/http-header-value';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { afterThe, digOn_, EventNotifier, mapOn_, OnEvent, onEventBy, resolveOnOrdered } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser = new window.DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        httpFetch(fetchRequest).do(\n            mapOn_(response => Promise.all([response, response.text()])),\n            resolveOnOrdered,\n            digOn_((...batch: [Response, string][]) => afterThe<[Response, string][]>(...batch)),\n            mapOn_(([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                  error,\n                };\n              }\n            }),\n        )(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        fragments.reduce(\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as DOMParserSupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { AfterEvent, afterThe, mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request)).do(\n              mapOn_(response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  }),\n          ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { filterArray, filterIt, itsEach, mapIt, PushIterable } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, doc.scripts),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, response.document.querySelectorAll('script')),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      }),\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: ArrayLike<HTMLScriptElement>,\n): PushIterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterArray(scripts, ({ src }) => !!src),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { itsEach, itsFirst, overArray } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      }),\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(mapOn_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { onceAfter } from '@proc7ts/fun-events';\nimport { Class, noop, Supply, valueProvider } from '@proc7ts/primitives';\nimport {\n  BootstrapWindow,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  ElementRenderScheduler,\n  RenderDef,\n} from '@wesib/wesib';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes {@link PageLoadParam} navigation parameter.\n *\n * Enables {@link PageLoadSupport} feature.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n  const contentKey: (page: Page) => string | undefined = def.contentKey\n      ? def.contentKey.bind(def)\n      : defaultPageContentKey;\n\n  return Component({\n    feature: {\n      needs: [PageLoadSupport],\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const { fragment, render } = def;\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(ElementRenderScheduler)(render);\n        const navigation = context.get(Navigation);\n        let lastPageURL = contentKey(navigation.page);\n        let detectFragment: () => PageFragmentRequest;\n\n        if (fragment) {\n          detectFragment = valueProvider(fragment);\n        } else {\n          detectFragment = () => {\n\n            const { element: { id, tagName: tag } } = context as { element: Element };\n\n            return id ? { id } : { tag };\n          };\n        }\n\n        context.whenConnected(() => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot);\n\n          navigation.read.do(onceAfter)(page => {\n            page.put(\n                PageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply: new Supply().needs(context),\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n\n            const newPageURL = contentKey(response.page);\n\n            if (newPageURL === lastPageURL) {\n              return; // Only hash changed. Do not refresh the page.\n            }\n\n            if (!response.ok) {\n              schedule(() => onResponse({ context, range, response }));\n              return;\n            }\n\n            lastPageURL = newPageURL;\n            schedule(() => {\n              range.deleteContents();\n\n              const target = document.createDocumentFragment();\n              const { fragment } = response;\n\n              if (fragment) {\n                importNodeContent(fragment, target);\n                range.insertNode(target);\n              }\n\n              onResponse({ context, range, response });\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction defaultPageContentKey({ url }: Page): string {\n  return new URL('', url).href;\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeParam T - A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  readonly fragment?: PageFragmentRequest;\n\n  /**\n   * Rendering options.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Builds content key for the given page.\n   *\n   * The loaded content will replace already included one only when their content key differ.\n   *\n   * By default uses page URL without hash part as a key. This prevents content refresh when only URL hash changes.\n   *\n   * @param page - Target page. Either loaded or not.\n   *\n   * @returns Content key.\n   */\n  contentKey?(page: Page): any;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context - Decorated component context.\n   * @param response - Page load response.\n   * @param range - Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InConverter, InNamespaceAliaser, InRenderScheduler, intoConvertedBy } from '@frontmeans/input-aspects';\nimport { ContextSupply, ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, EventKeeper, mapAfter, supplyAfter } from '@proc7ts/fun-events';\nimport { DefaultNamespaceAliaser, ElementRenderScheduler } from '@wesib/wesib';\n\n/**\n * Default input aspects.\n *\n * This is an `AfterEvent` keeper of aspect converter meant to be applied to controls.\n *\n * As a bare minimum it assigns the following aspects to converted controls:\n * - `InRenderScheduler` set to `ElementRenderScheduler`,\n * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n *\n * More input aspect converters may be registered in context. They may override the default ones.\n */\nexport type DefaultInAspects = AfterEvent<[InConverter.Aspect<any, any>]>;\n\n/**\n * @internal\n */\nclass DefaultInAspectsKey\n    extends ContextUpKey<AfterEvent<[InConverter.Aspect<any, any>]>, InConverter.Aspect<any, any>> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor() {\n    super('default-in-aspects');\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[InConverter.Aspect<any, any>]>,\n          EventKeeper<InConverter.Aspect<any, any>[]> | InConverter.Aspect<any, any>,\n          AfterEvent<InConverter.Aspect<any, any>[]>>,\n  ): void {\n\n    const nsAlias = slot.context.get(DefaultNamespaceAliaser);\n    const scheduler = slot.context.get(ElementRenderScheduler);\n\n    slot.insert(\n        slot.seed.do(\n            mapAfter((...fns) => intoConvertedBy(\n                ...fns,\n                InRenderScheduler.to(scheduler),\n                InNamespaceAliaser.to(nsAlias),\n            )),\n            supplyAfter(slot.context.get(ContextSupply)),\n        ),\n    );\n  }\n\n}\n\n/**\n * A key of component context containing default input aspects.\n */\nexport const DefaultInAspects: ContextUpRef<DefaultInAspects, InConverter.Aspect<any, any>> = (\n    /*#__PURE__*/ new DefaultInAspectsKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl } from '@frontmeans/input-aspects';\nimport { SingleContextUpKey, SingleContextUpRef } from '@proc7ts/context-values/updatable';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\n\n/**\n * A user input originated from control.\n *\n * It is meant to be present in root {@link HierarchyContext hierarchy context}. Nested components may access it from\n * their hierarchy contexts to participate in user input.\n *\n * An {@link inputFromControl} function can be used to initiate user input.\n *\n * @typeParam TValue - Input value type.\n */\nexport interface InputFromControl<TValue = any> {\n\n  /**\n   * Root component context the input is initiated for.\n   */\n  readonly root: ComponentContext;\n\n  /**\n   * User input control.\n   */\n  readonly control: InControl<TValue>;\n\n}\n\n/**\n * No user input originated from control.\n */\nexport interface NoInputFromControl {\n  control?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a user input originated from control. Potentially\n * {@link NoInputFromControl absent}.\n */\nexport const InputFromControl: SingleContextUpRef<InputFromControl | NoInputFromControl> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputFromControl | NoInputFromControl>(\n        'input-from-control',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates user input from the given control for the given root component.\n *\n * Constructs an {@link InputFromControl} instance and makes it available in `root` component's hierarchy.\n *\n * @typeParam TValue - Input value type.\n * @param root - Root component context to initiate user input for.\n * @param control - User input control.\n *\n * @returns User input supply. The user input would be stopped once this supply is cut off.\n */\nexport function inputFromControl<TValue>(\n    root: ComponentContext,\n    control: InControl<TValue>,\n): Supply {\n  return root.get(HierarchyContext)\n      .provide({\n        a: InputFromControl,\n        by: () => ({\n          root,\n          control,\n        }),\n      })\n      .needs(root)\n      .needs(control);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl, InConverter } from '@frontmeans/input-aspects';\nimport { afterAll, AfterEvent, afterThe, consumeEvents, digAfter_, EventKeeper } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl, InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that converts input control from {@link HierarchyContext.up enclosing component}\n * and uses it as an {@link InputFromControl origin of user input} in decorated component.\n *\n * @param convert - Input control converter definition.\n *\n * @returns New component decorator.\n */\nexport function ConvertInput<T extends ComponentClass = Class>(\n    convert: ConvertInputDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const { up } = context.get(HierarchyContext);\n\n        afterAll({\n          parent: up.do(\n              digAfter_((upper): AfterEvent<[InputFromControl | NoInputFromControl]> => upper\n                  ? upper.get(InputFromControl)\n                  : afterThe<[NoInputFromControl]>({})),\n          ),\n          aspects: context.get(DefaultInAspects),\n        }).do(\n            digAfter_(({\n              parent: [control],\n              aspects: [aspects],\n            }): EventKeeper<[InControl<any>?, Supply?]> => {\n              if (control.control) {\n\n                const converted = convert({ control, context, aspects });\n\n                if (converted) {\n                  return converted instanceof InControl ? afterThe(converted) : converted;\n                }\n              }\n\n              return afterThe();\n            }),\n            consumeEvents((control?: InControl<any> | null, supply?: Supply) => {\n              if (!control) {\n                return;\n              }\n\n              const usageSupply = inputFromControl(context, control);\n\n              (supply || control.supply).needs(usageSupply);\n\n              return usageSupply;\n            }),\n        );\n      });\n    },\n  });\n}\n\n/**\n * Converter definition of enclosing component's user input control.\n *\n * The returned converted control keeper may send an event supply as a second parameter. This supply will be cut off\n * once the input from converted control is no longer needed. Otherwise the control's input supply will be cut off\n * instead, and control would become unusable after that.\n *\n * Configures {@link ConvertInput @ConvertInput} component decorator.\n */\nexport type ConvertInputDef<T extends object = any> =\n/**\n * @param control - Enclosing component's user input to convert.\n * @param context - Decorated component context.\n * @param aspects - Default input aspect converter. This is a value of {@link DefaultInAspects}.\n *\n * @returns Either input control, its keeper, or nothing.\n */\n    (\n        this: void,\n        {\n          control,\n          context,\n          aspects,\n        }: {\n          control: InputFromControl;\n          context: ComponentContext<T>;\n          aspects: InConverter.Aspect<any, any>;\n        },\n    ) => InControl<any> | EventKeeper<[InControl<any>?, Supply?]> | null | undefined;\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl, InFormElement } from '@frontmeans/input-aspects';\nimport { SingleContextUpKey, SingleContextUpRef } from '@proc7ts/context-values/updatable';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputFromControl } from './input-from-control';\n\n/**\n * A form control to fill by user input.\n *\n * An {@link inputToForm} function can be used to initiate filling the form.\n *\n * @typeParam TModel - Form model type.\n * @typeParam TElt - A type of HTML form element.\n */\nexport interface InputToForm<TModel = any, TElt extends HTMLElement = HTMLElement> extends InputFromControl<TModel> {\n\n  /**\n   * Input form element control.\n   *\n   * Unlike input form control this one is not supposed to be submitted. But it contains a `<form>` element issuing a\n   * `submit` event.\n   */\n  readonly form: InFormElement<TElt>;\n\n}\n\n/**\n * No user input filling the form.\n */\nexport interface NoInputToForm {\n  control?: undefined;\n  form?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a form element to fill by user input. Potentially\n * {@link NoInputToForm absent}.\n */\nexport const InputToForm: SingleContextUpRef<InputToForm<any, any> | NoInputToForm> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputToForm<any, any> | NoInputToForm>(\n        'input-to-form',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates filling the form by user input from.\n *\n * Constructs {@link InputToForm} and {@link InputFromControl} instances and makes them available in `root` component's\n * hierarchy.\n *\n * @typeParam TModel - Form model type.\n * @typeParam TElt - A type of HTML form element.\n * @param root - Root component context to initiate user input for.\n * @param control - Input form control.\n * @param form - Form element control.\n *\n * @returns Form fill supply. The form filling would be stopped once this supply is cut off.\n */\nexport function inputToForm<TModel, TElt extends HTMLElement>(\n    root: ComponentContext,\n    control: InControl<TModel>,\n    form: InFormElement<TElt>,\n): Supply {\n\n  const hierarchy = root.get(HierarchyContext);\n  const supply = hierarchy.provide({\n    a: InputToForm,\n    by: () => ({\n      root,\n      control,\n      form,\n    }),\n  });\n\n  hierarchy.provide({\n    a: InputFromControl,\n    via: InputToForm,\n  }).needs(supply);\n\n  return supply\n      .needs(root)\n      .needs(control)\n      .needs(form);\n}\n\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl, InConverter, InFormElement } from '@frontmeans/input-aspects';\nimport { afterAll, afterThe, consumeEvents, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { ComponentNode, ElementNode, ElementPickMode } from '../tree';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputToForm } from './input-to-form';\n\n/**\n * Constructs component decorator that finds form element to {@link InputToForm fill by user input}.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Form element fill definition.\n *\n * @returns New component decorator.\n */\nexport function FillInputForm<T extends ComponentClass = Class>(\n    def: FillInputFormDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n\n  const { select = 'form', pick = { deep: true, all: true } } = def;\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n\n        context.whenConnected(() => {\n          afterAll({\n            node: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).do(\n              digAfter(({\n                node: [node],\n                aspects: [aspects],\n              }): EventKeeper<[InControl<any>, InFormElement, Supply?] | []> => {\n                if (!node) {\n                  return afterThe();\n                }\n\n                const tuple = def.makeForm({ node, context, aspects });\n\n                if (!tuple) {\n                  return afterThe();\n                }\n\n                return Array.isArray(tuple) ? afterThe(...tuple) : tuple;\n              }),\n              consumeEvents((control?, form?, supply?) => {\n                if (!control) {\n                  return;\n                }\n\n                const fillSupply = inputToForm(context, control, form!);\n\n                if (supply) {\n                  supply.needs(fillSupply);\n                } else {\n                  fillSupply.cuts(form!).cuts(control);\n                }\n\n                return fillSupply;\n              }),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * A definition of form element to {@link InputToForm fill by user input}.\n *\n * Configures {@link FillInputForm @FillInputForm} component decorator.\n *\n * @typeParam T - A type of component.\n */\nexport interface FillInputFormDef<T extends object = any> {\n\n  /**\n   * CSS selector of form element to fill.\n   *\n   * `form` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Constructs form control and form element control for element node found by {@link FillInputForm @FillInputForm}\n   * decorator.\n   *\n   * The returned control keeper may send an event supply as a third parameter. This supply will be cut off once\n   * the form filling is no longer needed. Otherwise the form's control supply will be cut off instead,\n   * and it would become unusable after that.\n   *\n   * @param node - Element node to construct form element control for.\n   * @param context - Component context the {@link FillInputForm @FillInputForm} decorator is applied to.\n   * @param aspects - Default input aspect converter. This is a value of {@link DefaultInAspects}.\n   *\n   * @returns Either form control and form element control tuple, their keeper, or nothing.\n   */\n  makeForm(\n      {\n        node,\n        context,\n        aspects,\n      }: {\n        node: ElementNode;\n        context: ComponentContext<T>;\n        aspects: InConverter.Aspect<any, any>;\n      },\n  ):\n      | [InControl<any>, InFormElement]\n      | EventKeeper<[InControl<any>, InFormElement, Supply?] | []>\n      | null\n      | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { DomEventDispatcher, handleDomEvents } from '@frontmeans/dom-events';\nimport { consumeEvents } from '@proc7ts/fun-events';\nimport { ComponentClass, ComponentProperty, ComponentPropertyDecorator } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputToForm, NoInputToForm } from './input-to-form';\n\n/**\n * Creates a decorator for component method to call on input form submit.\n *\n * The decorated method accepts a {@link InputToForm filled input form} and submit event as parameters.\n *\n * @typeParam T - A type of decorated component class.\n * @typeParam TModel - Submitted model type.\n * @typeParam TElt - A type of HTML form element.\n * @param def - Submit handler definition.\n *\n * @returns New component property decorator.\n */\nexport function OnSubmit<T extends ComponentClass, TModel = any, TElt extends HTMLElement = HTMLElement>(\n    def: OnSubmitDef = {},\n): ComponentPropertyDecorator<(form: InputToForm<TModel, TElt>, event: Event) => void, T> {\n\n  const { cancel = true } = def;\n\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenConnected(() => {\n\n            const hierarchy = context.get(HierarchyContext);\n            const { component } = context;\n\n            hierarchy.get(InputToForm).do(consumeEvents((inputToForm: InputToForm<TModel, TElt> | NoInputToForm) => {\n              if (!inputToForm.control) {\n                return;\n              }\n\n              const submitDispatcher = new DomEventDispatcher(inputToForm.form.element);\n\n              submitDispatcher.supply.needs(context);\n\n              const onSubmit = submitDispatcher.on('submit');\n\n              return (cancel ? onSubmit.do(handleDomEvents(false)) : onSubmit)(\n                  event => get(component).call(component, inputToForm, event),\n              );\n            }));\n          });\n        });\n      },\n    },\n  }));\n}\n\n/**\n * Form submit handler definition.\n *\n * Configures {@link OnSubmit @OnSubmit} component property decorator.\n */\nexport interface OnSubmitDef {\n\n  /**\n   * Whether to cancel default submit handler.\n   *\n   * `true` by default.\n   */\n  cancel?: boolean;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InGroup } from '@frontmeans/input-aspects';\nimport { afterAll, afterThe, consumeEvents, digAfter_, EventKeeper, mapAfter_ } from '@proc7ts/fun-events';\nimport { Class, valueProvider } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Creates component decorator that adds {@link InputFromControl input control} of decorated component to input control\n * group of enclosing one under the given name.\n *\n * @typeParam T - A type of decorated component class.\n * @param name - A name to assign to component. This could be either a string, or a function returning name as a string\n * or as its keeper.\n *\n * @returns New component decorator.\n */\nexport function SetInputName<T extends ComponentClass = Class>(\n    name: string | ((this: void, context: ComponentContext<InstanceType<T>>) => string | EventKeeper<[string?]>),\n): ComponentDecorator<T> {\n\n  const getName: (context: ComponentContext<InstanceType<T>>) => EventKeeper<[string?]> = typeof name === 'string'\n      ? valueProvider(afterThe(name))\n      : context => {\n        const result = name(context);\n        return typeof result === 'string' ? afterThe(result) : result;\n      };\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const hierarchy = context.get(HierarchyContext);\n\n        afterAll({\n          group: hierarchy.up.do(\n              digAfter_(upper => upper ? upper.get(InputFromControl) : afterThe<[NoInputFromControl]>({})),\n              mapAfter_(({ control }) => control && control.aspect(InGroup)),\n          ),\n          control: hierarchy.get(InputFromControl),\n          name: getName(context),\n        }).do(\n            consumeEvents(({\n              group: [group],\n              control: [{ control }],\n              name: [name],\n            }) => {\n              if (name == null\n                  || !group\n                  || !control\n                  || group === control) {\n                return;\n              }\n              return group.controls.set(name, control);\n            }),\n        );\n      });\n    },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl, InConverter } from '@frontmeans/input-aspects';\nimport { afterAll, afterThe, consumeEvents, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { ComponentNode, ElementNode, ElementPickMode } from '../tree';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that finds input element and uses it as an {@link InputFromControl origin of user\n * input}.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Input element usage definition.\n *\n * @returns New component decorator.\n */\nexport function UseInputElement<T extends ComponentClass = Class>(\n    def: UseInputElementDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n\n  const { select = 'input', pick = { deep: true, all: true } } = def;\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n\n        context.whenConnected(() => {\n          afterAll({\n            node: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).do(\n              digAfter(({\n                node: [node],\n                aspects: [aspects],\n              }): EventKeeper<[InControl<any>?, Supply?]> => {\n                if (!node) {\n                  return afterThe();\n                }\n\n                const control = def.makeControl({ node, context, aspects });\n\n                if (!control) {\n                  return afterThe();\n                }\n\n                return control instanceof InControl ? afterThe(control) : control;\n              }),\n              consumeEvents((control?: InControl<any>, supply?: Supply) => {\n                if (!control) {\n                  return;\n                }\n\n                const usageSupply = inputFromControl(context, control);\n\n                (supply || control.supply).needs(usageSupply);\n\n                return usageSupply;\n              }),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * A definition of element to use as an {@link InputFromControl origin of user input}.\n *\n * Configures {@link UseInputElement @UseInputElement} component decorator.\n *\n * @typeParam T - A type of component.\n */\nexport interface UseInputElementDef<T extends object = any> {\n\n  /**\n   * CSS selector of input element to use.\n   *\n   * `input` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Constructs input control for element node found by {@link UseInputElement @UseInputElement} decorator.\n   *\n   * The returned control keeper may send an event supply as a second parameter. This supply will be cut off once\n   * the input from control is no longer needed. Otherwise the control's input supply will be cut off instead,\n   * and control would become unusable after that.\n   *\n   * @param node - Element node to construct input control for.\n   * @param context - Component context the {@link UseInputElement @UseInputElement} decorator is applied to.\n   * @param aspects - Default input aspect converter. This is a value of {@link DefaultInAspects}.\n   *\n   * @returns Either input control, its keeper, or nothing.\n   */\n  makeControl(\n      {\n        node,\n        context,\n        aspects,\n      }: {\n        node: ElementNode;\n        context: ComponentContext<T>;\n        aspects: InConverter.Aspect<any, any>;\n      },\n  ):\n      | InControl<any>\n      | EventKeeper<[InControl<any>?, Supply?]>\n      | null\n      | undefined;\n\n}\n"],"names":["hthvItem","$","n","t","v","x","p","pl","addParam","param","key","prev","push","parseNone","datePattern","dateTimeParser","dateTime","parseDateTime","input","out","s","substring","i","test","nextInItem","delimiterOf","c","d","itemParser","config","named","tagged","extra","next","parseAngleBrackets","result","length","angleBracketsParser","parseQuotedString","unquoted","quotedStringParser","parseExtra","tag","value","item","name","type","undefined","extraItem","nextInComment","spacesParser","start","paramParser","opts","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","FetchAgentKey","ContextUpKey","[object Object]","super","this","upKey","createUpKey","slot","insert","seed","do","digAfter","agents","afterThe","request","fetch","agentIdx","agentRequest","agent","onSupplied","nextRequest","combineFetchAgents","hasFallback","or","defaultFetchAgent","delegated","context","get","whenOff","reason","contextDestroyed","HttpFetchAgent","HttpFetchAborted","HttpFetch","FnContextKey","byDefault","bootstrapDefault","window","BootstrapWindow","init","Request","onEventBy","receiver","responseEmitter","EventEmitter","supply","abortController","AbortController","signal","Supply","abort","off","needs","on","ctx","response","receive","customSignal","DomEventDispatcher","onceOn","aborted","then","send","catch","HierarchyRoot","SingleContextKey","bsContext","root","BootstrapRoot","HierarchyUpdates","issue","trackValue","HierarchyUpdates__key","ComponentContext","updates","hierarchyRoot","BootstrapContext","parent","findParentContext","it","ContextKey__symbol","of","element","immediate","parentNode","ComponentContext__symbol","HierarchyContext__key","HierarchyContext$","HierarchyContext","ContextValues","up","afterEventBy","parentHierarchy","by","_parent","cuts","rootSupply","parentSupply","updateParent","parentCtx","read","connected","supplyAfter","consumeEvents","newParent","whenConnected","shareAfter","noop","registry","_registry","ContextRegistry","isContextSeedUpKey","upper","newValues","spec","provide","enclosing","ElementNodeList","OnEvent__symbol","onUpdate","AfterEvent__symbol","WATCH_DEEP","subtree","elementNodeList","selectorOrType","nodeOf","deep","all","selector","cache","Set","overNodes","overNodeSubtree","overArray","whenDefined","elementDef","html__naming","DefaultNamespaceAliaser","size","selected","refresh","added","itsElements","filterIt","mapIt","node","isPresent","console","error","addEventListener","event","target","has","iterable","overIterator","iteratorOf","ElementNodeList$","observer","ElementObserver","update","firstReceiver","observe","disconnect","clear","returnSelf","valueProvider","mapAfter","track","initialEmitter","first","afterSupplied","translateAfter","list","itsFirst","Symbol","iterator","PushIterator__symbol","accept","sel","querySelectorAll","filterArray","children","matches","select","mutations","removed","forEach","mutation","itsEach","removedNodes","removeNode","addedNodes","addNode","isElement","add","delete","nodes","flatMapArray","childNodes","AttributesObserver","_bs","Map","_observer","Observer","MutationObserver","_update","self","emitter","_emitter","rcv","eventReceiver","_emitters","reconnect","newValue","oldValue","takeRecords","attributes","attributeOldValue","attributeFilter","keys","attributeName","getAttribute","set","AttributeTracker","ValueTracker","_name","observeSupply","neverSupply","_updates","setAttribute","removeAttribute","NodeAttributes","bs","existing","_attrs","created","PropertyTracker","_element","_key","ComponentState","domPropertyPathTo","_ctx","_path","NodeProperties","_context","_props","prop","bind","ElementNode__symbol","ElementNode$","_bind","elementNodeOf","mode","optional","adapter","ElementAdapter","selectNodes","ComponentNode","getHashURL","url","URL","hash","origin","setHashURL","hashURL","username","pathname","search","PageParam__symbol","PageParam","_page","PageHashURLValueParam$","page","handle","put","PageHashURLValueParam","PageHashURLParam$","create","PageHashURLParam","NavigationAgentKey","document","when","from","to","navigate","agentTo","nextURL","title","nextTitle","data","nextData","String","baseURI","visited","current","ref","defaultNavigationAgent","_when","_from","NavigationAgent","PageHashURLSupport__feature","setup","a","is","pageHashURLAgent","PageHashURLSupport","FeatureDef__symbol","PageParamContext","NavHistory__key","NavHistory","extractNavData","state","_document","_location","location","_history","history","_uid","btoa","Math","random","entry","newEntry","href","_entries","id","schedule","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","tracker","pushState","_enter","fromEntry","e","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_bsContext","proto","_params","_status","newHandle","_newContext","_init","entries","transferred","at","values","stay","EnterPageEvent","Event","cancelable","LeavePageEvent","StayOnPageEvent","Navigation__key","dispatcher","navHistory","nav","nextEntry","apply","Promise","resolve","dispatch","hashChange","Navigation","onEnter","onLeave","onStay","onAny","delta","go","toURL","withParam","applyParams","with","mergeFunctions","open","replace","targetOrCallback","callback","navTarget","navTargetOf","applyAgent","whenLeave","promise","doNavigate","prepared","leavePage","prepare","navigated","ActivateNavLink","def","pick","Component","defContext","whenComponent","activate","scheduler","ElementRenderScheduler","render","active","defaultActiveNavLinkClass","activeClass","css__naming","assignClass","classList","remove","NavLinkRenderSchedule__symbol","makeActive","lastSupply","activateNavLink","weigh","defaultNavLinkWeight","weight","supplier","translateAfter_","navLinkWeight","navigation","componentNode","digAfter_","afterEach","weights","maxWeight","selectActiveNavLinks","newActive","activeLink","linkURL","ownerDocument","calcNavLinkWeight","pageURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight","navLinkSearchParamsWeight","startsWith","path","endsWith","searchParams","linkParams","pageParams","isIgnoredSearchParam","getAll","includes","Wesib__NS","HandleNavLinks","getHref","defaultNavLinkHref","preventDefault","defaultHandleNavLinks","events","setOfElements","eventType","onceAfter","importNode","beforeOrImport","importContent","importNodeContent","before","doc","elementClone","createElement","tagName","toLowerCase","getAttributeNames","attr","insertBefore","nodeClone","cachingPageLoader","loader","pageUrl","sup","tracked","onLoad","trackSupply","resp","valueOn_","asis","num","requested","supplyOn","PageLoadAbortError","Error","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","_loader","_requests","flatMapIt","_map","fragments","itsEvery","fragment","pageSupply","loadSupply","_add","_transfer","responseReceiver","ok","shareOn","mapOn_","getElementsByTagName","getElementById","onFragment","req","slice","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","reduce","header","requestPageFragments","EventNotifier","text","resolveOnOrdered","digOn_","batch","status","parsePageDocument","parseFromString","head","base","querySelector","newBase","appendChild","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","rev","appRev","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","src","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","style","removeChild","pageTitleAgent","textContent","PageLoadSupport__feature","buster","PageLoadSupport","IncludePage","onResponse","contentKey","defaultPageContentKey","feature","detectFragment","lastPageURL","range","createRange","selectNodeContents","contentRoot","newPageURL","deleteContents","createDocumentFragment","insertNode","handleResponse","DefaultInAspectsKey","nsAlias","fns","intoConvertedBy","InRenderScheduler","InNamespaceAliaser","ContextSupply","DefaultInAspects","InputFromControl","SingleContextUpKey","inputFromControl","control","ConvertInput","convert","afterAll","aspects","converted","InControl","usageSupply","InputToForm","FillInputForm","tuple","makeForm","Array","isArray","form","fillSupply","hierarchy","via","inputToForm","OnSubmit","cancel","ComponentProperty","componentDef","component","submitDispatcher","onSubmit","handleDomEvents","call","SetInputName","getName","group","mapAfter_","aspect","InGroup","controls","UseInputElement","makeControl"],"mappings":"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"}