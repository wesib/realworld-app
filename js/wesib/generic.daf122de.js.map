{"version":3,"file":"generic.daf122de.js","sources":["../../../../generic/src/fetch/fetch-agent-key.impl.ts","../../../../generic/src/fetch/http-fetch-agent.ts","../../../../generic/src/fetch/http-fetch.impl.ts","../../../../generic/src/fetch/http-fetch.ts","../../../../generic/src/tree/element-node-list.ts","../../../../generic/src/tree/element-node-list.impl.ts","../../../../generic/src/tree/node-attributes.impl.ts","../../../../generic/src/tree/node-properties.impl.ts","../../../../generic/src/tree/element-node.impl.ts","../../../../generic/src/tree/element-node.ts","../../../../generic/src/navigation/hash-url/hash-url.ts","../../../../generic/src/navigation/page-param.ts","../../../../generic/src/navigation/hash-url/page-hash-url-param.impl.ts","../../../../generic/src/navigation/hash-url/page-hash-url-param.ts","../../../../generic/src/navigation/navigation-agent.ts","../../../../generic/src/navigation/hash-url/page-hash-url-support.feature.ts","../../../../generic/src/navigation/page-param-context.ts","../../../../generic/src/navigation/nav-history.impl.ts","../../../../generic/src/navigation/navigation.event.ts","../../../../generic/src/navigation/navigation.ts","../../../../generic/src/navigation/activate-nav-link.decorator.ts","../../../../generic/src/navigation/handle-nav-links.decorator.ts","../../../../generic/src/util/import-node.ts","../../../../generic/src/navigation/page-load/caching-page-loader.impl.ts","../../../../generic/src/navigation/page-load/page-load-requests.impl.ts","../../../../generic/src/navigation/page-load/page-load-agent.ts","../../../../generic/src/navigation/page-load/page-load-url-modifier.ts","../../../../generic/src/navigation/page-load/page-loader.impl.ts","../../../../generic/src/navigation/page-load/page-load-param.ts","../../../../generic/src/navigation/page-load/page-cache-buster.impl.ts","../../../../generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../../../generic/src/navigation/page-load/page-style-agent.impl.ts","../../../../generic/src/navigation/page-load/page-title-agent.impl.ts","../../../../generic/src/navigation/page-load/page-load-support.feature.ts","../../../../generic/src/navigation/page-load/include-page.decorator.ts","../../../../generic/src/shares/share-ref.ts","../../../../generic/src/shares/share-registry.impl.ts","../../../../generic/src/shares/share-key.impl.ts","../../../../generic/src/shares/share.impl.ts","../../../../generic/src/shares/shared-value.ts","../../../../generic/src/shares/shared-value.impl.ts","../../../../generic/src/shares/share.ts","../../../../generic/src/shares/share-locator.ts","../../../../generic/src/shares/shareable.ts","../../../../generic/src/shares/share-accessor.impl.ts","../../../../generic/src/shares/shared.decorator.ts","../../../../generic/src/shares/target-share.ts","../../../../generic/src/forms/default.preset.impl.ts","../../../../generic/src/forms/form-preset.ts","../../../../generic/src/forms/form-unit.ts","../../../../generic/src/forms/field.ts","../../../../generic/src/forms/field.share.ts","../../../../generic/src/forms/form.share.ts","../../../../generic/src/forms/adjacent-field.ts","../../../../generic/src/forms/field.impl.ts","../../../../generic/src/forms/field-name.definer.ts","../../../../generic/src/forms/form.ts","../../../../generic/src/forms/form-scope.ts","../../../../generic/src/forms/presets/abstract-form-preset.ts","../../../../generic/src/forms/scoped-form-config.ts","../../../../generic/src/forms/presets/form-css.preset.ts","../../../../generic/src/forms/presets/form-mode.preset.ts","../../../../generic/src/forms/on-submit.decorator.ts","../../../../generic/src/forms/shared-form-unit.decorator.ts","../../../../generic/src/forms/shared-field.decorator.ts","../../../../generic/src/forms/shared-form.decorator.ts"],"sourcesContent":["import { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventSender, OnEvent, onSupplied } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<TResponse>,\n    request: Request,\n) => EventSender<TResponse>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n) => OnEvent<TResponse>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<TResponse extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>\n    implements ContextUpRef<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...agents) => {\n              if (agents.length) {\n                return afterThe(combineFetchAgents(agents));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(defaultFetchAgent);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          CombinedFetchAgent<TResponse>,\n          ContextUpKey.Source<FetchAgent<TResponse>>,\n          AfterEvent<FetchAgent<TResponse>[]>>,\n  ): void {\n\n    let delegated: CombinedFetchAgent<TResponse>;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, request) => delegated(next, request));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<TResponse extends any[]>(\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n): OnEvent<TResponse> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<TResponse extends any[]>(\n    agents: FetchAgent<TResponse>[],\n): CombinedFetchAgent<TResponse> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<TResponse> = (\n        agentIdx,\n        agentRequest,\n    ) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","import { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter {@link HttpFetch} processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by {@link HttpFetch}.\n */\nexport type HttpFetchAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * {@link HttpFetch} call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under {@link HttpFetchAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of response object(s) receivers. It is returned as a result of {@link HttpFetch} call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an {@link HttpFetchAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { EventEmitter, onceOn, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: Supply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new window.AbortController();\n        const { signal } = abortController;\n\n        supply = new Supply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal)\n              .on('abort')\n              .do(onceOn)(\n                  () => abortController.abort(),\n              );\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","import { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of {@link HttpFetch} is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input - The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init - Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an {@link HttpFetch} instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n *\n * @typeParam TNode - A type of element nodes.\n */\nexport abstract class ElementNodeList<TNode extends ElementNode = ElementNode>\n    implements Iterable<TNode>, EventSender<[TNode[], TNode[]]>, EventKeeper<[ElementNodeList<TNode>]> {\n\n  /**\n   * An `OnEvent` sender of this list changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[TNode[], TNode[]]>;\n\n  /**\n   * An `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[ElementNodeList<TNode>]>;\n\n  /**\n   * An `AfterEvent` keeper of tracked list changes.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   */\n  abstract readonly track: AfterEvent<[readonly TNode[], readonly TNode[]]>;\n\n  /**\n   * An `AfterEvent` keeper of either the first node in this list, or `undefined` when the list is empty.\n   */\n  abstract readonly first: AfterEvent<[TNode?]>;\n\n  abstract [Symbol.iterator](): Iterator<TNode>;\n\n  [OnEvent__symbol](): OnEvent<[TNode[], TNode[]]> {\n    return this.onUpdate;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[ElementNodeList<TNode>]> {\n    return this.read;\n  }\n\n}\n","import { html__naming } from '@frontmeans/namespace-aliaser';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  mapAfter,\n  OnEvent,\n  onEventBy,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { isPresent, valueProvider } from '@proc7ts/primitives';\nimport {\n  filterArray,\n  filterIt,\n  flatMapArray,\n  iteratorOf,\n  itsEach,\n  itsElements,\n  itsFirst,\n  mapIt,\n  overArray,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<TNode extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => TNode | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList<TNode> {\n\n  const updates = new EventEmitter<[TNode[], TNode[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let selector: string | undefined;\n  const overNodes: (nodes: NodeList) => Iterable<Node> = deep ? overNodeSubtree : overArray;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n          // Refresh selection after component name resolution.\n          // This is needed  when new document loaded.\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = itsElements(\n                filterIt<TNode | undefined, TNode>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            /* istanbul ignore if. Can not test native custom element */\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    }).catch(console.error);\n  }\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as TNode;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  const iterable: PushIterable<TNode> = filterIt<TNode | undefined, TNode>(\n      mapIt(\n          overIterator(elements),\n          element => nodeOf(element),\n      ),\n      isPresent,\n  );\n\n  class ElementNodeList$ extends ElementNodeList<TNode> implements PushIterable<TNode> {\n\n    readonly onUpdate: OnEvent<[TNode[], TNode[]]>;\n    readonly read: AfterEvent<[ElementNodeList<TNode>]>;\n    readonly track: AfterEvent<[readonly TNode[], readonly TNode[]]>;\n    readonly first: AfterEvent<[TNode?]>;\n\n    constructor() {\n      super();\n\n      const observer = bsContext.get(ElementObserver)(update);\n\n      this.onUpdate = onEventBy<[TNode[], TNode[]]>(receiver => {\n\n        const firstReceiver = !updates.size;\n        const supply = updates.on(receiver);\n\n        if (firstReceiver) {\n          refresh();\n          observer.observe(root, init);\n        }\n\n        supply.whenOff(() => {\n          if (!updates.size) {\n            observer.disconnect();\n            clearCache(); // clear cache as there is no more receivers\n          }\n        }).needs(receiver.supply);\n      });\n\n      const returnSelf = valueProvider(this);\n\n      this.read = this.onUpdate.do(mapAfter(returnSelf, returnSelf));\n\n      this.track = afterEventBy<[readonly TNode[], readonly TNode[]]>(receiver => {\n\n        const initialEmitter = new EventEmitter<[readonly TNode[], readonly TNode[]]>();\n\n        initialEmitter.on(receiver);\n        initialEmitter.send(itsElements(this), []);\n\n        this.onUpdate(receiver);\n      });\n\n      this.first = afterSupplied(this.read).do(translateAfter(\n          (send, list) => send(itsFirst(list)),\n      ));\n    }\n\n    [Symbol.iterator](): PushIterator<TNode> {\n      return this[PushIterator__symbol]();\n    }\n\n    [PushIterator__symbol](accept?: PushIterator.Acceptor<TNode>): PushIterator<TNode> {\n      return iterable[PushIterator__symbol](accept);\n    }\n\n  }\n\n  return new ElementNodeList$();\n\n  function elements(): Iterator<Element> {\n    return iteratorOf(updates.size ? cache : refresh());\n  }\n\n  function clearCache(): void {\n    cache.clear();\n  }\n\n  function refresh(): Set<Element> {\n\n    const list = select();\n\n    if (updates.size) {\n      cache = list; // cache is for receivers only\n    }\n\n    return list;\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n\n    return new Set(filterArray(root.children, item => item.matches(sel)));\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: TNode[] = [];\n    const removed: TNode[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<TNode | undefined, TNode>(\n              mapIt(overNodes(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<TNode | undefined, TNode>(\n              mapIt(overNodes(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): TNode | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): TNode | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n\nfunction overNodeSubtree(nodes: NodeList): Iterable<Node> {\n  return flatMapArray(\n      nodes,\n      node => overArray([node, ...overNodeSubtree(node.childNodes)]),\n  );\n}\n","import { EventEmitter, eventReceiver, EventReceiver, OnEvent, onEventBy, ValueTracker } from '@proc7ts/fun-events';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string | null, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer = this._bs.get(BootstrapWindow).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string | null, string | null]>): Supply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: new Supply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: [...self._emitters.keys()],\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string | null, string | null]> {\n\n    const emitter = new EventEmitter<[string | null, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly on: OnEvent<[string | null, string | null]>;\n  private readonly _updates = new EventEmitter<[string | null, string | null]>();\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n\n    let observeSupply = neverSupply();\n\n    this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            this._name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    });\n  }\n\n  get supply(): Supply {\n    return this._updates.supply;\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (value != null) {\n      this._observer.element.setAttribute(this._name, value);\n    } else {\n      this._observer.element.removeAttribute(this._name);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { EventEmitter, OnEvent, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\n\n/**\n * @internal\n */\ntype ElementWithProperty<T> = {\n  [key in PropertyKey]: T;\n};\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n  private readonly _key: string;\n  constructor(\n      private readonly _element: ElementWithProperty<T>,\n      key: PropertyKey,\n  ) {\n    super();\n    this._key = key as string;\n  }\n\n  get supply(): Supply {\n    return this._updates.supply;\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._updates.on;\n  }\n\n  bind(context: ComponentContext): void {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    propertyState.onUpdate({\n      supply: this.supply,\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import { ValueTracker } from '@proc7ts/fun-events';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentElement,\n  ComponentEvent,\n  ComponentSlot__symbol,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ComponentNode, ComponentTreeNode, ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\ntype TreeElement = Element & ComponentElement & {\n  [ElementNode__symbol]?: ComponentTreeNode;\n};\n\n/**\n * @internal\n */\nclass ElementNode$ implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: TreeElement) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    element[ElementNode__symbol] = this;\n\n    const context = this.context;\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext | undefined {\n    return this.element[ComponentSlot__symbol]?.context;\n  }\n\n  get parent(): ElementNode | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null> {\n    return this._attrs.get(name);\n  }\n\n  property<TValue>(key: PropertyKey): ValueTracker<TValue> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional: true,\n): ElementNode | undefined;\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: false,\n): ElementNode;\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: boolean,\n): ElementNode | undefined;\n\n\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: boolean,\n): ElementNode | undefined {\n\n  const existing = element[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode$(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { BootstrapContext, ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector - Simple CSS selector of nested components.\n   * @param mode - Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType - Nested component type with custom element name.\n   * @param mode - Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector - Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode - A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * `null` attribute value corresponds to its absence. Setting it to `null` removes attribute.\n   *\n   * @param name - Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @typeParam TValue - Property value type.\n   * @param key - Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<TValue>(key: PropertyKey): ValueTracker<TValue>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>(\n        'component-node',\n        {\n          byDefault(context) {\n            return elementNodeOf(\n                context.get(BootstrapContext),\n                context.get(ComponentContext).element,\n            ) as ComponentNode;\n          },\n        },\n    )\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url - An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url - Base URL.\n * @param hashURL - Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL(`#${hashURL}`, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","import { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to {@link LeavePageEvent}). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeParam T - Parameter value type.\n * @typeParam TInput - Parameter input type.\n */\nexport abstract class PageParam<T, TInput> implements PageParam.Ref<T, TInput> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page - A page to assign navigation parameter to.\n   * @param input - Parameter input used to construct its initial value.\n   * @param context - Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: TInput, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page - A page to assign navigation parameter to.\n   * @param _context - Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, TInput> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Ref<T, TInput> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, TInput>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface WithDefaults<T, TInput> extends PageParam<T, TInput> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     */\n    export interface Ref<T, TInput> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, TInput>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Handle<T, TInput> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input - Parameter input to use when updating its value.\n     */\n    put(input: TInput): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before {@link LeavePageEvent} is fired for each parameter handle of current page.\n     *\n     * @param to - A page to transfer parameter to.\n     * @param when - When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(\n        to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return',\n    ): Handle<T, TInput> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page - Entered page.\n     * @param when - When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at - The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","import { Page } from '../page';\nimport { PageParam } from '../page-param';\n\nclass PageHashURLValueParam$ extends PageParam<URL | undefined | null, URL | string | null | undefined> {\n\n  create(\n      page: Page,\n      input: URL | null | undefined,\n  ): PageParam.Handle<URL | null | undefined, URL | string | null | undefined> {\n\n    let hashURL: URL | null | undefined;\n    const handle: PageParam.Handle<URL | null | undefined, URL | string | null | undefined> = {\n      get() {\n        return hashURL;\n      },\n      put(value) {\n        hashURL = typeof value === 'string' ? new URL(value, page.url.origin) : value;\n      },\n    };\n\n    handle.put(input);\n\n    return handle;\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageHashURLValueParam: PageParam<URL | null | undefined, URL | string | null | undefined> = (\n    /*#__PURE__*/ new PageHashURLValueParam$()\n);\n","import { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { getHashURL } from './hash-url';\nimport { PageHashURLValueParam } from './page-hash-url-param.impl';\n\n/**\n * @internal\n */\nclass PageHashURLParam$ extends PageParam<URL, URL | string | null | undefined> {\n\n  create(page: Page, input: URL | string | null | undefined): PageParam.Handle<URL, URL | string | null | undefined> {\n\n    const handle: PageParam.Handle<URL, URL | string | null | undefined> = {\n      get() {\n        return page.get(PageHashURLValueParam) || getHashURL(page.url);\n      },\n      put(value) {\n        page.put(PageHashURLValueParam, value);\n      },\n    };\n\n    handle.put(input);\n\n    return handle;\n  }\n\n  byDefault(page: Page): PageParam.Handle<URL, URL> {\n    return this.create(page, null);\n  }\n\n}\n\n/**\n * Page parameter representing its {@link getHashURL hash URL}.\n *\n * When {@link Navigation.with set} to another value while navigating, the hash of target URL is updated, unless set to\n * `null` or `undefined`.\n *\n * Requires {@link PageHashURLSupport} for above to function properly.\n */\nexport const PageHashURLParam: PageParam.WithDefaults<URL, URL | string | null | undefined> = (\n    /*#__PURE__*/ new PageHashURLParam$()\n);\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from - The page to leave.\n * @param to - Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => {\n\n          const { document } = slot.context.get(BootstrapWindow);\n\n          slot.insert(slot.seed.do(\n              digAfter((...agents) => {\n                if (agents.length) {\n                  return afterThe(combinedAgent);\n                }\n                if (slot.hasFallback && slot.or) {\n                  return slot.or;\n                }\n\n                return afterThe(defaultNavigationAgent);\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              }),\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          NavigationAgent.Combined,\n          ContextUpKey.Source<NavigationAgent>,\n          AfterEvent<NavigationAgent[]>>,\n  ): void {\n\n    let delegated: NavigationAgent.Combined;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, when, from, to) => delegated(next, when, from, to));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under {@link NavigationAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the\n   * last one. Not calling this function effectively prevents navigation.\n   * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n   * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from - The page to leave.\n   * @param to - Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an {@link NavigationAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","import { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { NavigationAgent } from '../navigation-agent';\nimport { Page } from '../page';\nimport { setHashURL } from './hash-url';\nimport { PageHashURLValueParam } from './page-hash-url-param.impl';\n\nconst PageHashURLSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: NavigationAgent, is: pageHashURLAgent });\n  },\n};\n\n/**\n * {@link PageHashURLParam Page hash URL parameter} support feature.\n */\nexport class PageHashURLSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageHashURLSupport__feature;\n  }\n\n}\n\nfunction pageHashURLAgent(\n    next: (this: void, target?: Navigation.Target) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n\n  const hashURL = to.get(PageHashURLValueParam);\n\n  if (hashURL) {\n    next({ url: setHashURL(to.url, hashURL) });\n  } else {\n    next();\n  }\n}\n","import { ContextValues } from '@proc7ts/context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * @internal\n */\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\n/**\n * @internal\n */\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      ? { data: state }\n      : (state as NavDataEnvelope)[NAV_DATA_KEY] as PartialNavData;\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      get data(): any {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, TInput> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, TInput>(param: PageParam<T, TInput>, handle: PageParam.Handle<T, TInput>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","import { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","import { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onAny,\n  OnEvent,\n  OnEvent__symbol,\n  onSupplied,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>(\n    'navigation',\n    {\n      byDefault: bootstrapDefault(createNavigation),\n    },\n));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` {@link StayOnPageEvent stay on page events}.\n   *\n   * The registered listener is informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   *\n   * @returns `OnDomEvent` sender of {@link StayOnPageEvent stay on page events}.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` sender of {@link NavigationEvent navigation events}.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of {@link page current page}.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta - Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target - Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target - Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url - An URL to replace the the current one with.\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   * @param ref - A reference to page navigation parameter to apply.\n   * @param input - Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     * @param ref - A reference to page navigation parameter to apply.\n     * @param input - Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target - Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target - Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to.\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to {@link Navigation.open} and {@link Navigation.replace} methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n\nfunction createNavigation(context: BootstrapContext): Navigation {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation.URLTarget]: Navigation.URLTarget[K] };\n\n  class Navigation$ extends Navigation {\n\n    readonly onEnter: OnDomEvent<EnterPageEvent>;\n    readonly onLeave: OnDomEvent<LeavePageEvent>;\n    readonly onStay: OnDomEvent<StayOnPageEvent>;\n    readonly on: OnEvent<[NavigationEvent]>;\n    readonly read: AfterEvent<[Page]>;\n\n    constructor() {\n      super();\n      this.onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n      this.onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n      this.onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n      this.on = onAny<[NavigationEvent]>(\n          onSupplied(this.onEnter),\n          onSupplied(this.onLeave),\n          onSupplied(this.onStay),\n      );\n      this.read = nav.read.do(\n          mapAfter(({ page }) => page),\n      );\n    }\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation$();\n\n  function withParam(applyParams: (page: Page) => void): Navigation.Parameterized {\n    return {\n      with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","import { css__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterThe,\n  consumeEvents,\n  digAfter_,\n  EventKeeper,\n  supplyAfter,\n  translateAfter_,\n} from '@proc7ts/fun-events';\nimport { Class, noop } from '@proc7ts/primitives';\nimport { mapIt } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport {\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  ElementRenderScheduler,\n  RenderDef,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { ComponentNode, ElementNode, ElementPickMode } from '../tree';\nimport { getHashURL } from './hash-url';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  supply(): Supply;\n}\n\n/**\n * Creates component decorator that marks navigation link(s) inside decorated component active.\n *\n * Marks navigation links with highest weight.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenConnected(() => {\n\n          let active = new Map<ElementNode, ActiveNavLink>();\n\n          navigation.read.do(\n              supplyAfter(context),\n              consumeEvents(\n                  page => componentNode.select(select, pick).read.do(\n                      digAfter_(nodes => afterEach(\n                          ...mapIt(nodes, node => weigh({ node, context, page })),\n                      )),\n                      consumeEvents((...weights: NavLinkWeight[]) => {\n\n                        const selected = selectActiveNavLinks(weights);\n                        const newActive = new Map<ElementNode, ActiveNavLink>();\n                        const result = new Supply();\n\n                        selected.forEach(node => {\n\n                          let activeLink: ActiveNavLink;\n                          const existing = active.get(node);\n\n                          if (existing) {\n                            newActive.set(node, existing);\n                            activeLink = existing;\n                          } else {\n                            activeLink = activate({ node, context, page });\n                            newActive.set(node, activeLink);\n                          }\n\n                          activeLink.supply().needs(result);\n                        });\n\n                        active = newActive;\n\n                        return result;\n                      }),\n                  ),\n              ),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked {@link active}.\n *\n * @typeParam T - A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Rendering definition options to pass to nav links render scheduler.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path length as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters plus the\n   *    link path length is used as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as {@link getHashURL URLs}. The weight is calculated by applying steps 1, 2, and 3\n   *    to hash URLs increased by the link path length and the number of search parameters.\n   *\n   * Ignores search parameters with names starting and ending with double underscores. Like `__wesib_app_rev__`.\n   *\n   * @param node - Navigation link node to weigh.\n   * @param page - Current navigation page.\n   * @param context - Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active - Whether to make target link active (`true`), or inactive (`false`).\n   * @param node - Navigation link node to update activity state of.\n   * @param page - Current navigation page.\n   * @param context - Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLinks(weights: NavLinkWeight[]): ElementNode[] {\n\n  let maxWeight = 0;\n  let active: ElementNode[] = [];\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = [node];\n    } else if (weight === maxWeight) {\n      active.push(node);\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = weight[AfterEvent__symbol]().do(\n        translateAfter_((send, weight) => send(opts.node, weight)),\n    );\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier({\n        supply: new Supply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier(receiver);\n            }),\n        receive: receiver.receive,\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const { element } = node as { element: Element };\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n    if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n\n    return linkURL.pathname.length\n        + searchParamWeight\n        + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return linkURL.pathname.length + searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((value, key) => {\n    if (!isIgnoredSearchParam(key)) {\n      if (weight >= 0) {\n        if (pageParams.getAll(key).includes(value)) {\n          weight += 1;\n        } else {\n          weight = -1;\n        }\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nfunction isIgnoredSearchParam(key: string): boolean {\n  return key.startsWith('__') && key.endsWith('__');\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\ninterface RenderedElement extends Element {\n\n  [NavLinkRenderSchedule__symbol]?: RenderSchedule;\n\n}\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(ElementRenderScheduler);\n  const { render, active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const { element } = node as { element: Element };\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node as { element: RenderedElement };\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler(render));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: Supply | undefined;\n\n    return {\n      supply(): Supply {\n\n        const supply = lastSupply = new Supply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","import { onceAfter } from '@proc7ts/fun-events';\nimport { Class, setOfElements } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link Navigation navigation actions} instead of default ones.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks(def);\n  const events = setOfElements(def.event || 'click');\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenConnected(() => {\n\n          const navigation = context.get(Navigation);\n\n          for (const eventType of events) {\n            context.on(eventType)(event => {\n              navigation.read.do(onceAfter)(\n                  page => handle({\n                    event,\n                    page,\n                    context,\n                    navigation,\n                  }),\n              );\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeParam T - A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action. It also prevents navigation\n   * if URL didn't change.\n   *\n   * @param event - A click event to handle.\n   * @param page - Current navigation page.\n   * @param navigation - Navigation service to use.\n   * @param context - Component context.\n   */\n  handle?(\n      {\n        event,\n        page,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        page: Page;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n  /**\n   * Extracts hyper-reference of clicked element.\n   *\n   * Extracts hyper-reference from `href` attribute of event target.\n   *\n   * @param event - A click event to handle.\n   *\n   * @returns Extracted hyper-reference, or nothing if it can not be extracted. Event will be ignored in this case.\n   */\n  href?(event: Event): string | undefined | null;\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkHref(event: Event): string | null {\n\n  const target = event.target as Element;\n\n  return target.getAttribute('href');\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    def: HandleNavLinksDef,\n): (\n    opts: {\n      event: Event;\n      page: Page;\n      navigation: Navigation;\n    },\n) => void {\n\n  const getHref = def.href ? def.href.bind(def) : defaultNavLinkHref;\n\n  return ({\n    event,\n    page,\n    navigation,\n  }) => {\n\n    const href = getHref(event);\n\n    if (href == null) {\n      return;\n    }\n\n    const target = event.target as Element;\n    const pageURL = page.url;\n    const url = new URL(href, target.ownerDocument.baseURI);\n\n    if (url.origin !== pageURL.origin) {\n      return; // External link\n    }\n\n    event.preventDefault();\n    if (pageURL.href !== url.href) {\n      navigation.open(href).catch(console.error);\n    }\n  };\n}\n","import { itsEach, overArray } from '@proc7ts/push-iterator';\nimport { isElement } from '@wesib/wesib';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param before - The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: TNode, to: TNode) => void),\n    importContent: (this: void, from: TNode, to: TNode) => void = importNodeContent,\n): TNode {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & TNode);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from - The node which contents to import.\n * @param to - The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { OnEvent, onEventBy, supplyOn, trackValue, valueOn_ } from '@proc7ts/fun-events';\nimport { asis } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: Supply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = new Supply(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.cuts(trackSupply).cuts(tracker);\n\n        tracked = {\n          on: tracker.read.do(valueOn_(asis)),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on.do(supplyOn(supply))(receiver).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          }).catch(console.error);\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  mapOn_,\n  OnEvent,\n  onEventBy,\n  shareOn,\n  supplyOn,\n} from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach, itsEvery, overIterator, PushIterable } from '@proc7ts/push-iterator';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests {\n\n  private readonly _map = new Map<Supply, PageLoadReq[]>();\n  private readonly _requests: PushIterable<PageLoadReq>;\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {\n    this._requests = flatMapIt(overIterator(() => this._map.values()));\n  }\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    if (!itsEvery(\n        this._requests,\n        request => {\n          if (!request.fragment) {\n            return false;\n          }\n          result.push(request.fragment);\n          return true;\n        },\n    )) {\n      return [];\n    }\n\n    return result;\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = new Supply(noop);\n    let loadSupply = neverSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = new Supply(noop).needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page).do(supplyOn(loadSupply))(\n              response => emitter.send(response),\n          ).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error,\n              });\n            }\n          });\n\n          return supply;\n        }).do(shareOn);\n\n        itsEach(\n            self._requests,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: new Supply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, list.slice());\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.do(\n          mapOn_(\n              response => response.ok\n                  ? {\n                    ...response,\n                    fragment: (\n                        fragment.tag != null\n                            ? response.document.getElementsByTagName(fragment.tag)[0]\n                            : response.document.getElementById(fragment.id)\n                    ) || undefined,\n                  }\n                  : response,\n          ),\n      )\n      : onLoad;\n}\n","import { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under {@link PageLoadAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of page load response.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an {@link PageLoadAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","import { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { noop, valueProvider } from '@proc7ts/primitives';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url - An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { hthvParse, hthvQuote } from '@hatsy/http-header-value';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { afterThe, digOn_, EventNotifier, mapOn_, OnEvent, onEventBy, resolveOnOrdered } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser = new window.DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        httpFetch(fetchRequest).do(\n            mapOn_(response => Promise.all([response, response.text()])),\n            resolveOnOrdered,\n            digOn_((...batch: [Response, string][]) => afterThe<[Response, string][]>(...batch)),\n            mapOn_(([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                  error,\n                };\n              }\n            }),\n        )(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        fragments.reduce(\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as DOMParserSupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","import { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { AfterEvent, afterThe, mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request)).do(\n              mapOn_(response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  }),\n          ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { filterArray, filterIt, itsEach, mapIt, PushIterable } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, doc.scripts),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, response.document.querySelectorAll('script')),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      }),\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: ArrayLike<HTMLScriptElement>,\n): PushIterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterArray(scripts, ({ src }) => !!src),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { itsEach, itsFirst, overArray } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      }),\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(mapOn_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  }));\n}\n","import { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","import { onceAfter } from '@proc7ts/fun-events';\nimport { Class, noop, valueProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport {\n  BootstrapWindow,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  ElementRenderScheduler,\n  RenderDef,\n} from '@wesib/wesib';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes {@link PageLoadParam} navigation parameter.\n *\n * Enables {@link PageLoadSupport} feature.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n  const contentKey: (page: Page) => string | undefined = def.contentKey\n      ? def.contentKey.bind(def)\n      : defaultPageContentKey;\n\n  return Component({\n    feature: {\n      needs: [PageLoadSupport],\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const { fragment, render } = def;\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(ElementRenderScheduler)(render);\n        const navigation = context.get(Navigation);\n        let lastPageURL = contentKey(navigation.page);\n        let detectFragment: () => PageFragmentRequest;\n\n        if (fragment) {\n          detectFragment = valueProvider(fragment);\n        } else {\n          detectFragment = () => {\n\n            const { element: { id, tagName: tag } } = context as { element: Element };\n\n            return id ? { id } : { tag };\n          };\n        }\n\n        context.whenConnected(() => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot);\n\n          navigation.read.do(onceAfter)(page => {\n            page.put(\n                PageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply: new Supply().needs(context),\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n\n            const newPageURL = contentKey(response.page);\n\n            if (newPageURL === lastPageURL) {\n              return; // Only hash changed. Do not refresh the page.\n            }\n\n            if (!response.ok) {\n              schedule(() => onResponse({ context, range, response }));\n              return;\n            }\n\n            lastPageURL = newPageURL;\n            schedule(() => {\n              range.deleteContents();\n\n              const target = document.createDocumentFragment();\n              const { fragment } = response;\n\n              if (fragment) {\n                importNodeContent(fragment, target);\n                range.insertNode(target);\n              }\n\n              onResponse({ context, range, response });\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction defaultPageContentKey({ url }: Page): string {\n  return new URL('', url).href;\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeParam T - A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  readonly fragment?: PageFragmentRequest;\n\n  /**\n   * Rendering options.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Builds content key for the given page.\n   *\n   * The loaded content will replace already included one only when their content key differ.\n   *\n   * By default uses page URL without hash part as a key. This prevents content refresh when only URL hash changes.\n   *\n   * @param page - Target page. Either loaded or not.\n   *\n   * @returns Content key.\n   */\n  contentKey?(page: Page): any;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context - Decorated component context.\n   * @param response - Page load response.\n   * @param range - Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","import { Share } from './share';\n\n/**\n * A key of {@link ShareRef component share reference} property containing a {@link Share component\n * share} instance.\n */\nexport const Share__symbol = (/*#__PURE__*/ Symbol('Share'));\n\n/**\n * A reference to {@link Share component share}.\n *\n * @typeParam T - Shared value type.\n */\nexport interface ShareRef<T> {\n\n  /**\n   * Component share instance.\n   */\n  readonly [Share__symbol]: Share<T>;\n\n}\n\n/**\n * Checks whether the given value is a {@link ShareRef component share reference}.\n *\n * @typeParam T - Shared value type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the value has a {@link Share__symbol} property, or `false` otherwise.\n */\nexport function isShareRef<T, TOther>(value: ShareRef<T> | TOther): value is ShareRef<T> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && !!(value as Partial<ShareRef<T>>)[Share__symbol];\n}\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { bootstrapDefault, ComponentClass, DefaultNamespaceAliaser } from '@wesib/wesib';\nimport { Share } from './share';\n\nconst ShareRegistry__key = (/*#__PURE__*/ new SingleContextKey(\n    'share-registry',\n    {\n      byDefault: bootstrapDefault(bsContext => new ShareRegistry(bsContext.get(DefaultNamespaceAliaser))),\n    },\n));\n\n/**\n * @internal\n */\nexport class ShareRegistry {\n\n  static get [ContextKey__symbol](): ContextKey<ShareRegistry> {\n    return ShareRegistry__key;\n  }\n\n  private readonly _sharers = new Map<Share<unknown>, ValueTracker<Sharers>>();\n\n  constructor(readonly nsAlias: DefaultNamespaceAliaser) {\n  }\n\n  addSharer(\n      share: Share<unknown>,\n      componentType: ComponentClass,\n      elementName: string | undefined,\n      supply: Supply,\n  ): void {\n\n    let sharers = this._sharers.get(share);\n\n    if (!sharers) {\n      sharers = Sharers$new();\n      this._sharers.set(share, sharers);\n      Sharers$addSharer(sharers, componentType, supply);\n      Sharers$addName(sharers, elementName, supply);\n    } else {\n      Sharers$addSharer(sharers, componentType, supply);\n      Sharers$addName(sharers, elementName, supply);\n      sharers.it = { ...sharers.it };\n    }\n  }\n\n  sharers(share: Share<unknown>): ValueTracker<Sharers> {\n\n    let sharers = this._sharers.get(share);\n\n    if (!sharers) {\n      sharers = Sharers$new();\n      this._sharers.set(share, sharers);\n    }\n\n    return sharers;\n  }\n\n}\n\n/**\n * @internal\n */\nexport interface Sharers {\n\n  readonly names: Map<string, number>;\n  readonly sharers: Map<ComponentClass, number>;\n\n}\n\nfunction Sharers$new(): ValueTracker<Sharers> {\n  return trackValue({ names: new Map(), sharers: new Map() });\n}\n\nfunction Sharers$addName(\n    tracker: ValueTracker<Sharers>,\n    name: string | undefined,\n    supply: Supply,\n): void {\n  if (!name) {\n    return;\n  }\n\n  const sharers = tracker.it;\n  const counter = sharers.names.get(name) || 0;\n\n  sharers.names.set(name, counter + 1);\n  supply.whenOff(() => {\n\n    const counter = sharers.names.get(name)! - 1;\n\n    if (counter > 0) {\n      sharers.names.set(name, counter);\n    } else {\n      sharers.names.delete(name);\n    }\n\n    tracker.it = { ...sharers };\n  });\n}\n\nfunction Sharers$addSharer(\n    tracker: ValueTracker<Sharers>,\n    componentType: ComponentClass,\n    supply: Supply,\n): void {\n\n  const sharers = tracker.it;\n  const counter = sharers.sharers.get(componentType) || 0;\n\n  sharers.sharers.set(componentType, counter + 1);\n  supply.whenOff(() => {\n\n    const counter = sharers.sharers.get(componentType)! - 1;\n\n    if (counter > 0) {\n      sharers.sharers.set(componentType, counter);\n    } else {\n      sharers.sharers.delete(componentType);\n    }\n\n    tracker.it = { ...sharers };\n  });\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, digAfter } from '@proc7ts/fun-events';\nimport { Share } from './share';\nimport { SharedValue } from './shared-value';\n\n/**\n * @internal\n */\nexport class ShareKey<T> extends ContextUpKey<AfterEvent<[T?]>, SharedValue<T>> {\n\n  constructor(name: string, private readonly _share: Share<T>) {\n    super(`${name}:share`);\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[T?]>,\n          Share.Source<T>,\n          AfterEvent<SharedValue<T>[]>>,\n  ): void {\n    slot.insert(\n        slot.seed.do(\n            digAfter((...values) => this._share.selectValue(...values)),\n        ),\n    );\n  }\n\n}\n","import { html__naming } from '@frontmeans/namespace-aliaser';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { BootstrapContext, DefinitionContext } from '@wesib/wesib';\nimport { Share } from './share';\nimport { ShareKey } from './share-key.impl';\nimport { Share__symbol } from './share-ref';\nimport { ShareRegistry } from './share-registry.impl';\nimport { SharedValue } from './shared-value';\n\n/**\n * @internal\n */\nexport const Share$impl__symbol = (/*#__PURE__*/ Symbol('Share.impl'));\n\n/**\n * @internal\n */\nexport class Share$<T> {\n\n  readonly key: ContextUpKey<AfterEvent<[T?]>, SharedValue<T>>;\n  private readonly _aliases: readonly Share<T>[];\n\n  constructor(\n      private readonly _share: Share<T>,\n      readonly name: string,\n      options: Share.Options<T>,\n  ) {\n    this.key = new ShareKey(name, _share);\n    this._aliases = arrayOfElements(options.as).map(alias => alias[Share__symbol]);\n  }\n\n  addSharer(defContext: DefinitionContext, options: SharedValue.Options = {}): Supply {\n\n    const { local, name = defContext.elementDef.name } = options;\n    const registry = defContext.get(BootstrapContext).get(ShareRegistry);\n    const supply = new Supply();\n    const { componentType } = defContext;\n    const elementName = local\n        ? undefined\n        : name && html__naming.name(name, registry.nsAlias).toLowerCase();\n\n    registry.addSharer(this._share, componentType, elementName, supply);\n    for (const alias of this._aliases) {\n      registry.addSharer(alias, componentType, elementName, supply);\n    }\n\n    return supply;\n  }\n\n  shareValue(\n      registrar: SharedValue.Registrar<T>,\n  ): void {\n    registrar.shareAs(this._share);\n\n    const priorityOffset = registrar.priority + 1;\n\n    this._aliases.forEach((alias, index) => {\n      alias.shareValue(registrar.withPriority(priorityOffset + index));\n    });\n  }\n\n}\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { ComponentContext } from '@wesib/wesib';\nimport { ShareRef } from './share-ref';\n\n/**\n * A key of the {@link SharedValue.Detailed detailed shared value descriptor} containing the\n * {@link SharedValue.Details shared value details}.\n */\nexport const SharedValue__symbol = (/*#__PURE__*/ Symbol('SharedValue'));\n\n/**\n * A value shared by component.\n *\n * Either a pure value, or its {@link SharedValue.Detailed detailed descriptor}.\n *\n * @typeParam T - Shared value type.\n */\nexport type SharedValue<T> = T | SharedValue.Detailed<T>;\n\nexport namespace SharedValue {\n\n  /**\n   * Value sharing options.\n   *\n   * Declare availability of the shared value.\n   */\n  export interface Options {\n\n    /**\n     * The name of the element the sharer component is bound to. Defaults to component's element name.\n     *\n     * Ignored for {@link local} shares\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Whether the share is local.\n     *\n     * - `true` to make the value available only locally, i.e. only when requested by sharer context.\n     * - `false` (by default) to make the value available to nested components too.\n     */\n    readonly local?: boolean;\n\n  }\n\n  /**\n   * A detailed descriptor of the value shared by component.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Detailed<T> {\n\n    /**\n     * Shared value details.\n     */\n    readonly [SharedValue__symbol]: Details<T>;\n\n  }\n\n  /**\n   * Details of the shared value.\n   */\n  export interface Details<T> {\n\n    /**\n     * A priority of the shared value.\n     *\n     * Never negative. The lesser value means higher priority. The shared value with higher priority\n     * {@link Share.selectValue takes precedence}.\n     */\n    readonly priority: number;\n\n    /**\n     * Builds the shared value.\n     *\n     * @returns Either the shared value, or its `AfterEvent` keeper.\n     */\n    get(): T | AfterEvent<[T?]>;\n\n  }\n\n  /**\n   * Shared value registrar.\n   *\n   * Passed to {@link Share.shareValue} method in order to share the value.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Registrar<T> extends SupplyPeer {\n\n    /**\n     * The default priority of the shared value.\n     *\n     * Never negative.\n     */\n    readonly priority: number;\n\n    /**\n     * Shared value supply.\n     *\n     * Stops value sharing once cut off.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Shares the value under the given alias.\n     *\n     * @param alias - A reference to share alias.\n     * @param priority - Shared value priority. Equals to {@link priority default one} when omitted.\n     */\n    shareAs(this: void, alias: ShareRef<T>, priority?: number): void;\n\n    /**\n     * Builds a shared value registrar instance with another default priority.\n     *\n     * @param priority - New default shared value priority.\n     *\n     * @returns New registrar instance with {@link priority} set to the given value.\n     */\n    withPriority(this: void, priority: number): Registrar<T>;\n\n  }\n\n  /**\n   * Shared value provider.\n   *\n   * Can be used to {@link Share.createRegistrar create} a {@link SharedValue.Registrar} instance.\n   *\n   * @typeParam TSharer - Supported sharer component type.\n   * @typeParam T - Shared value type.\n   */\n  export interface Provider<T, TSharer extends object = any> {\n\n    /**\n     * The default priority of the shared value.\n     *\n     * Equals to `0` when absent or negative.\n     */\n    readonly priority?: number;\n\n    /**\n     * Shared value supply.\n     *\n     * Stops value sharing once cut off.\n     *\n     * New supply instance will be created when absent.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Provides shared value for the given component context.\n     *\n     * @typeParam TComponent - Actual sharer component type.\n     * @param context - Sharer component context to provide value for.\n     *\n     * @returns Either a shared value, or its `AfterEvent` keeper.\n     */\n    provide<TComponent extends TSharer>(context: ComponentContext<TComponent>): T | AfterEvent<[T?]>;\n\n  }\n\n}\n\nexport const SharedValue = {\n\n  /**\n   * Checks whether the given value shared by component is has details.\n   *\n   * @typeParam T - Shared value type.\n   * @param value - Shared value to check.\n   *\n   * @returns `true` if the given value is an object implementing a {@link SharedValue.Detailed} interface.\n   */\n  hasDetails<T>(\n      this: void,\n      value: SharedValue<T>,\n  ): value is SharedValue.Detailed<T> {\n    return !!value\n        && typeof value === 'object'\n        && typeof (value as SharedValue.Detailed<T>)[SharedValue__symbol] === 'object';\n  },\n\n};\n","import { applyContextTo, ContextBuilder, ContextBuilder__symbol, ContextRegistry } from '@proc7ts/context-values';\nimport { applyContextAfter } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, isAfterEvent, translateAfter } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Share } from './share';\nimport { Share__symbol } from './share-ref';\nimport { SharedValue, SharedValue__symbol } from './shared-value';\n\n/**\n * @internal\n */\nexport function SharedValue$ContextBuilder<T, TSharer extends object>(\n    share: Share<T>,\n    provider: SharedValue.Provider<T, TSharer>,\n): ContextBuilder<ComponentContext<TSharer>> {\n  return {\n    [ContextBuilder__symbol]: registry => {\n\n      const registrar = share.createRegistrar(registry, provider);\n\n      share.shareValue(registrar);\n\n      return registrar.supply;\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function SharedValue$Registrar<T, TSharer extends object>(\n    registry: ContextRegistry<ComponentContext<TSharer>>,\n    provider: SharedValue.Provider<T, TSharer>,\n): SharedValue.Registrar<T> {\n  return SharedValue$BoundRegistrar(registry, SharedValue$bindProvider(provider));\n}\n\nfunction SharedValue$BoundRegistrar<T, TSharer extends object>(\n    registry: ContextRegistry<ComponentContext<TSharer>>,\n    provider: SharedValue$BoundProvider<T, TSharer>,\n): SharedValue.Registrar<T> {\n\n  const { priority, supply, provide } = provider;\n\n  return {\n    priority,\n    supply,\n    shareAs: (alias, newPriority = priority) => {\n      newPriority = Math.max(0, newPriority);\n      registry.provide({\n        a: alias[Share__symbol],\n        by: newPriority\n            ? SharedValue$detailedProvider(provide, newPriority)\n            : SharedValue$bareProvider(provide),\n      }).as(supply);\n    },\n    withPriority: newPriority => SharedValue$BoundRegistrar(\n        registry,\n        { ...provider, priority: Math.max(0, newPriority) },\n    ),\n  };\n}\n\ninterface SharedValue$BoundProvider<T, TSharer extends object> {\n  readonly priority: number;\n  readonly supply: Supply;\n  provide(this: void, context: ComponentContext<TSharer>): T | AfterEvent<[T?]>;\n}\n\nfunction SharedValue$bindProvider<T, TSharer extends object>(\n    provider: SharedValue.Provider<T>,\n): SharedValue$BoundProvider<T, TSharer> {\n\n  const priority = provider.priority ? Math.max(0, provider.priority) : 0;\n  const { supply = new Supply() } = provider;\n\n  return {\n    priority,\n    supply,\n    provide: (context: ComponentContext): T | AfterEvent<[T?]> => {\n\n      const value = provider.provide(context);\n\n      if (isAfterEvent(value)) {\n        return value.do(\n            applyContextAfter(context),\n        );\n      }\n\n      return applyContextTo(value)(context);\n    },\n  };\n}\n\nfunction SharedValue$bareProvider<T, TComponent extends object>(\n    provider: (context: ComponentContext<TComponent>) => T | AfterEvent<[T?]>,\n): (\n    context: ComponentContext<TComponent>,\n) => T | AfterEvent<T[]> | null | undefined {\n  return context => {\n\n    const value = provider(context);\n\n    if (isAfterEvent(value)) {\n      return value.do(\n          translateAfter((send, value?) => value !== undefined ? send(value) : send()),\n      );\n    }\n\n    return value;\n  };\n}\n\nfunction SharedValue$detailedProvider<T, TComponent extends object>(\n    provider: (context: ComponentContext<TComponent>) => T | AfterEvent<[T?]>,\n    priority: number,\n): (\n    context: ComponentContext<TComponent>,\n) => SharedValue.Detailed<T> {\n  return context => ({\n    [SharedValue__symbol]: {\n      priority,\n      get: () => provider(context),\n    },\n  });\n}\n","import { ContextKey__symbol, ContextRegistry } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport {\n  afterAll,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  deduplicateAfter,\n  deduplicateAfter_,\n  digAfter_,\n  isAfterEvent,\n  sendEventsTo,\n  shareAfter,\n  translateAfter_,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport {\n  BootstrapContext,\n  ComponentContext,\n  ComponentElement,\n  ComponentSlot,\n  DefinitionContext,\n  parentElement,\n} from '@wesib/wesib';\nimport { ShareLocator } from './share-locator';\nimport { Share__symbol, ShareRef } from './share-ref';\nimport { ShareRegistry } from './share-registry.impl';\nimport { Share$, Share$impl__symbol } from './share.impl';\nimport { SharedValue, SharedValue__symbol } from './shared-value';\nimport { SharedValue$Registrar } from './shared-value.impl';\n\n/**\n * A kind of the value a component shares with the nested ones.\n *\n * The sharing implies the following:\n *\n * - The sharer component {@link addSharer registers} its element name as the one bound to sharer.\n * - The sharer component {@link shareValue provides} an (updatable) shared value within its context.\n * - The consumer component {@link valueFor obtains} the shared value by searching the parent element with a sharer\n *   bound to it.\n *\n * A share instance is used as an identifier in all these steps.\n *\n * A {@link Shared @Shared} component property decorator may be used to automate this.\n *\n * @typeParam T - Shared value type.\n */\nexport class Share<T> implements ShareRef<T>, ContextUpRef<AfterEvent<[T?]>, SharedValue<T>> {\n\n  /**\n   * @internal\n   */\n  readonly [Share$impl__symbol]: Share$<T>;\n\n  /**\n   * Constructs new component share.\n   *\n   * @param name - A human-readable name of the share.\n   * @param options - Constructed share options.\n   */\n  constructor(name: string, options: Share.Options<T> = {}) {\n    this[Share$impl__symbol] = new Share$(this, name, options);\n  }\n\n  /**\n   * Refers to itself.\n   */\n  get [Share__symbol](): this {\n    return this;\n  }\n\n  /**\n   * A human-readable name of the name.\n   */\n  get name(): string {\n    return this[Share$impl__symbol].name;\n  }\n\n  /**\n   * A key of the sharer component context value containing an `AfterEvent` keeper of the shared value.\n   */\n  get [ContextKey__symbol](): ContextUpKey<AfterEvent<[T?]>, SharedValue<T>> {\n    return this[Share$impl__symbol].key;\n  }\n\n  /**\n   * Registers a sharer component.\n   *\n   * The registration is necessary for consumers to be able to find the element bound to sharer by that element's name.\n   *\n   * @param defContext - The definition context of the sharer component.\n   * @param options - Value sharing options.\n   *\n   * @returns Sharer registration supply. Revokes the sharer registration once cut off.\n   */\n  addSharer(defContext: DefinitionContext, options?: SharedValue.Options): Supply {\n    return this[Share$impl__symbol].addSharer(defContext, options);\n  }\n\n  /**\n   * Shares a value by providing it for the sharer component context.\n   *\n   * @param registrar - Shared value registrar.\n   *\n   * @return A builder of shared value for component context.\n   */\n  shareValue(\n      registrar: SharedValue.Registrar<T>,\n  ): void {\n    this[Share$impl__symbol].shareValue(registrar);\n  }\n\n  /**\n   * Creates a shared value registrar that shares a value created by the given provider.\n   *\n   * @typeParam TSharer - Sharer component type.\n   * @param registry - Target component context registry.\n   * @param provider - Shared value provider.\n   *\n   * @returns New shared value registrar.\n   */\n  createRegistrar<TSharer extends object>(\n      registry: ContextRegistry<ComponentContext<TSharer>>,\n      provider: SharedValue.Provider<T, TSharer>,\n  ): SharedValue.Registrar<T> {\n    return SharedValue$Registrar(registry, provider);\n  }\n\n  /**\n   * Locates a shared value for the consuming component.\n   *\n   * Searches among parent elements for the one bound to the sharer component, then obtains the shared value from\n   * the sharer's context.\n   *\n   * @param consumer - Consumer component context.\n   * @param options - Location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n  valueFor(\n      consumer: ComponentContext,\n      options: ShareLocator.Options = {},\n  ): AfterEvent<[T, ComponentContext] | []> {\n\n    const { local } = options;\n    const sharers = consumer.get(BootstrapContext).get(ShareRegistry).sharers(this);\n    const status = consumer.readStatus.do(\n        deduplicateAfter_(\n            (a, b) => a === b,\n            Share$consumerStatus,\n        ),\n    );\n\n    return afterAll({\n      sharers,\n      status,\n    }).do(\n        digAfter_(({ sharers: [sharers] }): AfterEvent<[T, ComponentContext] | []> => {\n          if (local) {\n            if (sharers.sharers.has(consumer.componentType)) {\n              return Share$sharedValue(this, consumer);\n            }\n            if (local === true) {\n              return afterThe();\n            }\n          }\n\n          let element: ComponentElement | null = parentElement(consumer.element);\n\n          while (element) {\n            if (sharers.names.has(element.tagName.toLowerCase())) {\n              return ComponentSlot.of(element).read.do(\n                  digAfter_(sharer => sharer ? Share$sharedValue(this, sharer) : afterThe()),\n              );\n            }\n\n            element = parentElement(element);\n          }\n\n          return afterThe();\n        }),\n        deduplicateAfter(),\n    );\n  }\n\n  /**\n   * Selects a shared value among candidates.\n   *\n   * It is especially useful when the value shared by multiple sharers.\n   *\n   * By default:\n   *\n   * - Prefers bare value.\n   * - Prefers the value from {@link SharedValue.Detailed detailed specifier} with higher priority\n   *   (i.e. lesser {@link SharedValue.Details.priority priority value}).\n   * - Prefers the value declared last.\n   *\n   * @param values - The values shared by sharers. May contain a {@link SharedValue.Detailed detailed value\n   * specifiers} in addition to pure values.\n   *\n   * @returns An `AfterEvent` keeper of selected value, if present.\n   */\n  selectValue(...values: SharedValue<T>[]): AfterEvent<[T?]> {\n\n    let selected: SharedValue.Details<T> | undefined;\n\n    for (let i = values.length - 1; i >= 0; --i) {\n\n      const value = values[i];\n\n      if (!SharedValue.hasDetails(value)) {\n        return afterThe(value);\n      }\n\n      const details = value[SharedValue__symbol];\n\n      if (!selected || selected.priority > details.priority) {\n        selected = details;\n      }\n    }\n\n    if (!selected) {\n      return afterThe();\n    }\n\n    return afterEventBy<[T?]>(receiver => {\n\n      const value = selected!.get();\n\n      if (isAfterEvent(value)) {\n        value(receiver);\n      } else {\n        sendEventsTo(receiver)(value);\n      }\n    }).do(\n        shareAfter,\n    );\n  }\n\n}\n\nexport namespace Share {\n\n  /**\n   * {@link Share Component share} options.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Options<T> {\n\n    /**\n     * Component share reference(s) the share provides a value for in addition to the one it provides for itself.\n     *\n     * The order of aliases is important. It defines the {@link SharedValue.Details.priority priority} of the\n     * value shared for the corresponding share.\n     */\n    readonly as?: ShareRef<T> | readonly ShareRef<T>[];\n\n  }\n\n  /**\n   * A key of context value containing an `AfterEvent` keeper of shared value.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Key<T> = ContextUpKey<AfterEvent<[T?]>, SharedValue<T>>;\n\n  /**\n   * A source value accepted by {@link Share component share} context value.\n   *\n   * Either a single shared value, its {@link SharedValue.Detailed detailed descriptor}, or an `AfterEvent`\n   * keeper of the above.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Source<T> = ContextUpKey.Source<SharedValue<T>>;\n\n}\n\nfunction Share$consumerStatus([{ settled, connected }]: [ComponentContext]): 0 | 1 | 2 {\n  return connected ? 2 : settled ? 1 : 0;\n}\n\nfunction Share$sharedValue<T>(\n    share: Share<T>,\n    sharer: ComponentContext,\n): AfterEvent<[T, ComponentContext] | []> {\n  return sharer.get(share).do(\n      translateAfter_((send, value?) => value ? send(value, sharer) : send()),\n  );\n}\n","import { AfterEvent } from '@proc7ts/fun-events';\nimport { ComponentContext } from '@wesib/wesib';\nimport { isShareRef, Share__symbol, ShareRef } from './share-ref';\n\n/**\n * Shared value locator.\n *\n * Can be one of:\n *\n * - component share {@link ShareRef reference},\n * - shared value locator specified {@link ShareLocator.Spec},\n * - {@link ShareLocator.CustomWithFallback custom} shared value locator, or\n * - `null`/`undefined` to locate a fallback share.\n *\n * A {@link shareLocator} function can be used to convert arbitrary locator to a function.\n *\n * @typeParam T - Shared value type.\n */\nexport type ShareLocator<T> =\n    | ShareRef<T>\n    | ShareLocator.Spec<T>\n    | ShareLocator.CustomWithFallback<T>\n    | null\n    | undefined;\n\n/**\n * Converts mandatory shared value locator to locator function.\n *\n * @typeParam T - Shared value type.\n * @param locator - Shared value locator to convert.\n * @param defaultOptions - Default shared value locator options.\n *\n * @returns Shared value locator function.\n */\nexport function shareLocator<T>(\n    locator: ShareLocator.Mandatory<T>,\n    defaultOptions?: ShareLocator.Options,\n): ShareLocator.Fn<T>;\n\n/**\n * Converts arbitrary shared value locator to locator function.\n *\n * @typeParam T - Shared value type.\n * @param locator - Shared value locator to convert.\n * @param defaultSpec - Default shared value locator specifier including fallback share reference.\n *\n * @returns Shared value locator function.\n */\nexport function shareLocator<T>(\n    locator: ShareLocator<T>,\n    defaultSpec: ShareLocator.MandatorySpec<T>,\n): ShareLocator.Fn<T>;\n\nexport function shareLocator<T>(\n    locator:\n        | ShareRef<T>\n        | Partial<ShareLocator.MandatorySpec<T>>\n        | ShareLocator.CustomWithFallback<T>\n        | null\n        | undefined,\n    defaultSpec: ShareLocator.Spec<T> = {},\n): ShareLocator.Fn<T> {\n  if (isShareRef(locator)) {\n\n    const share = locator[Share__symbol];\n\n    return (consumer, options = {}) => {\n\n      const { local = defaultSpec.local } = options;\n\n      return share.valueFor(consumer, { local });\n    };\n  }\n\n  if (typeof locator === 'function') {\n\n    const { local: localByDefault = false, share: shareByDefault } = defaultSpec;\n\n    return (consumer, options = {}) => {\n\n      const { share = shareByDefault!, local = localByDefault } = options;\n\n      return locator(consumer, { share, local });\n    };\n  }\n\n  const { share: shareRef = defaultSpec.share!, local: localByDefault = defaultSpec.local } = locator || {};\n  const share = shareRef[Share__symbol];\n\n  return (consumer, options = {}) => {\n\n    const { local = localByDefault } = options;\n\n    return share.valueFor(consumer, { local });\n  };\n}\n\nexport namespace ShareLocator {\n\n  /**\n   * Mandatory shared value locator.\n   *\n   * Can be one of:\n   *\n   * - component share {@link ShareRef reference},\n   * - shared value locator specified {@link ShareLocator.Spec}, or\n   * - {@link ShareLocator.Custom custom} shared value locator.\n   *\n   * A {@link shareLocator} function can be used to convert arbitrary locator to a function.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Mandatory<T> =\n      | ShareRef<T>\n      | MandatorySpec<T>\n      | Custom<T>;\n\n  /**\n   * Shared value location options.\n   */\n  export interface Options {\n\n    /**\n     * Whether to search locally, in consumer component itself.\n     *\n     * - `false` (by default), to start the search from consumer's parent,\n     * - `true` to search locally, i.e. only in consumer component, or\n     * - `'too'` to start the search from consumer component.\n     */\n    readonly local?: boolean | 'too';\n\n  }\n\n  /**\n   * Shared value location options with all properties present.\n   */\n  export type FullOptions = Required<Options>;\n\n  /**\n   * Shared value locator specifier.\n   *\n   * @typeParam T - Share value type.\n   */\n  export interface Spec<T> extends Options {\n\n    /**\n     * Target share.\n     */\n    readonly share?: ShareRef<T>;\n\n  }\n\n  /**\n   * Mandatory shared value locator specifier.\n   *\n   * @typeParam T - Share value type.\n   */\n  export interface MandatorySpec<T> extends Spec<T> {\n\n    /**\n     * Target share.\n     */\n    readonly share: ShareRef<T>;\n\n  }\n\n  /**\n   * Shared value locator specifier with all properties set.\n   *\n   * @typeParam T - Share value type.\n   */\n  export type FullSpec<T> = Required<MandatorySpec<T>>;\n\n  /**\n   * Signature of custom shared value locator.\n   *\n   * @typeParam T - Shared value type.\n   * @typeParam consumer - Consumer component context.\n   * @typeParam options - Shared value location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n  export type Custom<T> =\n  /**\n   * @param consumer - Consumer component context.\n   * @param options - Full shared value location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n      (\n          this: void,\n          consumer: ComponentContext,\n          options: FullOptions,\n      ) => AfterEvent<[] | [T, ComponentContext]>;\n\n  /**\n   * Signature of custom shared value locator that expects a fallback share reference to be specified.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type CustomWithFallback<T> =\n  /**\n   * @param consumer - Consumer component context.\n   * @param options - Full shared value location specifier, including fallback share reference.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n      (\n          this: void,\n          consumer: ComponentContext,\n          spec: FullSpec<T>,\n      ) => AfterEvent<[] | [T, ComponentContext]>;\n\n  /**\n   * Signature of shared value locator function.\n   *\n   * Can be constructed by {@link shareLocator} function.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Fn<T> =\n  /**\n   * @param consumer - Consumer component context.\n   * @param options - Shared value location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n      (\n          this: void,\n          consumer: ComponentContext,\n          defaultSpec?: Spec<T>,\n      ) => AfterEvent<[] | [T, ComponentContext]>;\n\n}\n","import { Contextual, Contextual__symbol } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterValue,\n  EventKeeper,\n  trackValueBy,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop, valueProvider, valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\n\nconst Shareable$Internals__symbol = (/*#__PURE__*/ Symbol('Shareable.internals'));\n\n/**\n * Abstract implementation of value shareable by component.\n *\n * Shareable instance contains a {@link body} that become usable only when bound to sharer component.\n *\n * @typeParam TBody - Shareable body type.\n * @typeParam TSharer - Sharer component type.\n */\nexport class Shareable<TBody = unknown, TSharer extends object = any>\n    implements EventKeeper<[TBody]>, Contextual<Shareable<TBody, TSharer>> {\n\n  /**\n   * Converts shareable body or its provider to provider that always returns an `AfterEvent` keeper of shareable body.\n   *\n   * @typeParam TBody - Shareable body type.\n   * @typeParam TSharer - Sharer component type.\n   * @param body - Either shareable body, or its provider.\n   *\n   * @returns Shareable body provider.\n   */\n  static provider<TBody = unknown, TSharer extends object = any>(\n      body: TBody | Shareable.Provider<TBody, TSharer>,\n  ): (\n      this: void,\n      sharer: ComponentContext<TSharer>,\n  ) => AfterEvent<[TBody]> {\n\n    const provider = valueRecipe(body);\n\n    return context => afterValue(provider(context));\n  }\n\n  /**\n   * @internal\n   */\n  private [Shareable$Internals__symbol]: Shareable$Internals<TBody, TSharer>;\n\n  /**\n   * Constructs shareable instance.\n   *\n   * @param body - Either shareable body, or its provider.\n   */\n  constructor(body: TBody | Shareable.Provider<TBody, TSharer>) {\n    this[Shareable$Internals__symbol] = new Shareable$Internals(this, body);\n  }\n\n  /**\n   * Sharer component context.\n   *\n   * Accessing it throws an exception until bound to sharer.\n   */\n  get sharer(): ComponentContext<TSharer> {\n    return this[Shareable$Internals__symbol].sharer();\n  }\n\n  /**\n   * An `AfterEvent` keeper of shareable body.\n   *\n   * An `[AfterEvent__symbol]` method always returns this value.\n   */\n  get read(): AfterEvent<[TBody]> {\n    return this[Shareable$Internals__symbol].get().read;\n  }\n\n  /**\n   * Binds this shareable instance to sharer component.\n   *\n   * @param sharer - Sharer component context.\n   *\n   * @returns `this` instance.\n   */\n  [Contextual__symbol](sharer: ComponentContext): this {\n    this[Shareable$Internals__symbol].bind(sharer);\n    return this;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[TBody]> {\n    return this.read;\n  }\n\n  /**\n   * Shareable body.\n   *\n   * Accessing is throws an exception until bound to sharer.\n   */\n  get body(): TBody {\n    return this[Shareable$Internals__symbol].get().it;\n  }\n\n}\n\nexport namespace Shareable {\n\n  /**\n   * Shareable provider signature.\n   *\n   * Provides shareable body rather the shareable instance itself.\n   *\n   * @typeParam TBody - Shareable body type.\n   * @typeParam TSharer - Sharer component type.\n   */\n  export type Provider<TBody = unknown, TSharer extends object = any> =\n  /**\n   * @param sharer - Sharer component context.\n   *\n   * @returns Either shareable body instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          sharer: ComponentContext<TSharer>,\n      ) => TBody | AfterEvent<[TBody]>;\n\n}\n\nclass Shareable$Internals<TBody, TSharer extends object> {\n\n  private readonly _get: (\n      this: void,\n      sharer: ComponentContext<TSharer>,\n  ) => AfterEvent<[TBody]>;\n\n  constructor(\n      private readonly _source: Shareable<TBody, TSharer>,\n      body: TBody | Shareable.Provider<TBody, TSharer>,\n  ) {\n    this._get = Shareable.provider(body);\n  }\n\n  sharer(): ComponentContext<TSharer> {\n    this._notBound();\n  }\n\n  get(): ValueTracker<TBody> {\n    this._notBound();\n  }\n\n  bind(sharer: ComponentContext<TSharer>): void {\n    this.bind = noop;\n    this.sharer = valueProvider(sharer);\n    this.get = () => {\n\n      const tracker = trackValueBy(this._get(sharer));\n\n      this.get = valueProvider(tracker);\n\n      return tracker;\n    };\n  }\n\n  private _notBound(): never {\n    throw new TypeError(`${String(this._source)} is not properly shared yet`);\n  }\n\n}\n","import { Contextual__symbol, isContextual } from '@proc7ts/context-values';\nimport { AfterEvent, isAfterEvent, trackValue, trackValueBy, ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentClass, ComponentContext, ComponentInstance, ComponentProperty } from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport class ShareAccessor<T, TClass extends ComponentClass> {\n\n  private readonly _get: () => T | AfterEvent<[T?]>;\n  private readonly _set: (value: T | AfterEvent<[T?]>) => void;\n  private readonly _ctx: ComponentContext<InstanceType<TClass>>;\n  private _valSupply?: Supply;\n  readonly val: ValueTracker<T | undefined>;\n\n  constructor(\n      desc: ComponentProperty.Descriptor<T | AfterEvent<[T?]>, TClass>,\n      component: ComponentInstance<InstanceType<TClass>>,\n  ) {\n    this._get = desc.get.bind(undefined, component);\n    this._set = desc.writable ? desc.set.bind(undefined, component) : noop;\n    this._ctx = ComponentContext.of(component);\n\n    const value = this._get();\n    let dynSync = false;\n\n    if (isAfterEvent(value)) {\n      dynSync = true;\n      this.val = trackValueBy(value);\n    } else {\n      this.val = trackValue(value);\n    }\n\n    this.val.supply.needs(this._ctx);\n\n    // Bind to context as the very first operation\n    this.val.read(value => isContextual(value) && value[Contextual__symbol](this._ctx));\n\n    if (dynSync) {\n      this._syncDyn();\n    } else {\n      this._syncVal();\n    }\n  }\n\n  get(): T | AfterEvent<[T?]> {\n    return this._valSupply ? this.val.it! : this.val.read;\n  }\n\n  set(value: T | AfterEvent<[T?]>): void {\n    if (isAfterEvent(value)) {\n      this.val.by(value);\n      this._syncDyn();\n    } else {\n      this.val.it = value;\n      this._syncVal();\n    }\n  }\n\n  private _syncVal(): void {\n    if (!this._valSupply) {\n      this._valSupply = this.val.read(value => this._set(value!));\n    }\n  }\n\n  private _syncDyn(): void {\n    if (this._valSupply) {\n      this._valSupply.off();\n      this._valSupply = undefined;\n      this._set(this.val.read);\n    }\n  }\n\n}\n","import { AfterEvent, digAfter_ } from '@proc7ts/fun-events';\nimport { Class, valuesProvider } from '@proc7ts/primitives';\nimport {\n  ComponentClass,\n  ComponentInstance,\n  ComponentProperty,\n  ComponentPropertyDecorator,\n  DefinitionContext,\n  DefinitionSetup,\n} from '@wesib/wesib';\nimport { Share } from './share';\nimport { ShareAccessor } from './share-accessor.impl';\nimport { Share__symbol } from './share-ref';\nimport { SharedValue$ContextBuilder } from './shared-value.impl';\nimport { targetShare, TargetShare } from './target-share';\n\n/**\n * Builds a decorator of component property that {@link Share shares} its value.\n *\n * The decorated property should return either a static value, or its `AfterEvent` keeper if the case the value is\n * updatable.\n *\n * Applies current component context to `Contextual` shared values.\n *\n * @typeParam T - Shared value type.\n * @typeParam TClass - A type of decorated component class.\n * @param share - Target component share.\n * @param define - Sharing property definition builders.\n *\n * @returns Component property decorator.\n */\nexport function Shared<T, TClass extends ComponentClass = Class>(\n    share: TargetShare<T>,\n    ...define: Shared.Definer<T, TClass>[]\n): ShareDecorator<T, TClass> {\n\n  const { share: { [Share__symbol]: shr }, local } = targetShare(share);\n\n  return ComponentProperty(\n      descriptor => {\n\n        const accessorKey = Symbol(`${String(descriptor.key)}:shared`);\n\n        type Component = ComponentInstance<InstanceType<TClass>> & {\n          [accessorKey]?: ShareAccessor<T, TClass>;\n        };\n\n        const accessor = (component: Component): ShareAccessor<T, TClass> => component[accessorKey]\n            || (component[accessorKey] = new ShareAccessor(descriptor, component));\n\n        return {\n          get: component => accessor(component).get(),\n          set: descriptor.writable\n              ? (component, value) => accessor(component).set(value)\n              : undefined,\n          componentDef: {\n            setup(setup: DefinitionSetup<InstanceType<TClass>>): void {\n              setup.perComponent(SharedValue$ContextBuilder(\n                  shr,\n                  {\n                    provide: context => context.onceReady.do(\n                        digAfter_(\n                            ({ component }) => accessor(component).val,\n                            valuesProvider<[T?]>(),\n                        ),\n                    ),\n                  },\n              ));\n            },\n            define(defContext: DefinitionContext<InstanceType<TClass>>) {\n              shr.addSharer(defContext, { local });\n            },\n          },\n        };\n\n\n      },\n      ...define.map(define => (\n          descriptor: ComponentProperty.Descriptor<T | AfterEvent<[T?]>, TClass>,\n      ) => define({ ...descriptor, share: shr })),\n  );\n}\n\n/**\n * Decorator of component property that {@link Share shares} its value.\n *\n * Built by {@link Shared @Shared} decorator.\n *\n * @typeParam T - Shared value type.\n * @typeParam TClass - A type of decorated component class.\n */\nexport type ShareDecorator<T, TClass extends ComponentClass = Class> =\n    ComponentPropertyDecorator<T | AfterEvent<[T?]>, TClass>;\n\nexport namespace Shared {\n\n  /**\n   * A descriptor of the component property that {@link Share shares} its value.\n   *\n   * Passed to {@link Definer property definer} by {@link Shared @Shared} decorator to build a {@link Definition\n   * property definition}.\n   *\n   * @typeParam T - Shared value type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export interface Descriptor<T, TClass extends ComponentClass = Class>\n      extends ComponentProperty.Descriptor<T | AfterEvent<[T?]>, TClass> {\n\n    /**\n     * Target share instance.\n     */\n    readonly share: Share<T>;\n\n  }\n\n  /**\n   * A signature of definition builder of the component property that {@link Share shares} its value.\n   *\n   * This is a function called by {@link Shared @Shared} decorator to apply additional definitions.\n   *\n   * @typeParam T - Shared value type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export type Definer<T, TClass extends ComponentClass = Class> =\n  /**\n   * @param descriptor - Decorated component property descriptor.\n   *\n   * @returns Component property definition, or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<T, TClass>,\n      ) => Definition<T, TClass> | void;\n\n  /**\n   * A definition of component property that {@link Share shares} its value.\n   *\n   * @typeParam T - Shared value type.\n   * @typeParam TClass - A type of component class.\n   */\n  export type Definition<T, TClass extends ComponentClass = Class> =\n      ComponentProperty.Definition<T | AfterEvent<[T?]>, TClass>;\n\n}\n","import { isShareRef, ShareRef } from './share-ref';\n\n/**\n * A specifier of component share to share the value of.\n *\n * Can be one of:\n *\n * - component share {@link ShareRef reference}, or\n * - detailed target component share {@link TargetShare.Spec specifier}.\n *\n * @typeParam T - Shared value type.\n */\nexport type TargetShare<T> =\n    | ShareRef<T>\n    | TargetShare.Spec<T>;\n\nexport namespace TargetShare {\n\n  /**\n   * A detailed specifier of the component share to share the value of.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Spec<T> {\n\n    /**\n     * Target component share reference.\n     */\n    readonly share: ShareRef<T>;\n\n    /**\n     * Whether to share is local.\n     *\n     * - `true` to make the value available only locally, i.e. only when requested by sharer context.\n     * - `false` (by default) to make the value available to nested components too.\n     */\n    readonly local?: boolean;\n\n  }\n\n}\n\n/**\n * Converts arbitrary {@link TargetShare target component share} to its detailed {@link TargetShare.Spec specifier}.\n *\n * @typeParam T - Share value type.\n * @param target\n */\nexport function targetShare<T>(target: TargetShare<T>): TargetShare.Spec<T> {\n  return isShareRef(target) ? { share: target } : target;\n}\n","import {\n  InAspect,\n  InBuilder,\n  InControl,\n  InNamespaceAliaser,\n  InRenderScheduler,\n  knownInAspect,\n} from '@frontmeans/input-aspects';\nimport { ComponentContext, DefaultNamespaceAliaser, ElementRenderScheduler } from '@wesib/wesib';\nimport { Field } from './field';\nimport { Form } from './form';\nimport { FormPreset } from './form-preset';\n\n/**\n * @internal\n */\nexport const DefaultFormPreset: FormPreset.Spec = {\n\n  setupField<TValue, TSharer extends object>(\n      { sharer, control }: Field.Builder<TValue, TSharer>,\n  ): void {\n    DefaultFormPreset$setup(sharer, control);\n  },\n\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      { sharer, control, element }: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    DefaultFormPreset$setup(sharer, control);\n    DefaultFormPreset$setup(sharer, element);\n  },\n\n};\n\nfunction DefaultFormPreset$setup<TValue, TSharer extends object>(\n    sharer: ComponentContext<TSharer>,\n    builder: InBuilder<InControl<TValue>>,\n): void {\n\n  const nsAliaser = sharer.get(DefaultNamespaceAliaser);\n  const renderScheduler = sharer.get(ElementRenderScheduler);\n\n  builder\n      .addAspect(\n          InNamespaceAliaser,\n          {\n            applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n                _aspect: InAspect<TInstance, TKind>,\n            ): InAspect.Application.Result<TInstance, TValue, TKind> {\n              return knownInAspect(nsAliaser) as InAspect.Application.Result<TInstance, TValue, TKind>;\n            },\n          },\n      ).addAspect(\n      InRenderScheduler,\n      {\n        applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n            _aspect: InAspect<TInstance, TKind>,\n        ): InAspect.Application.Result<TInstance, TValue, TKind> {\n          return knownInAspect(renderScheduler) as InAspect.Application.Result<TInstance, TValue, TKind>;\n        },\n      },\n  );\n}\n","import { ContextKey__symbol, ContextSupply, ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, mapAfter, supplyAfter } from '@proc7ts/fun-events';\nimport { DefaultFormPreset } from './default.preset.impl';\nimport { Field } from './field';\nimport { Form } from './form';\n\nclass FormPresetKey extends ContextUpKey<FormPreset, FormPreset.Spec> {\n\n  constructor() {\n    super('form-preset');\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          FormPreset,\n          ContextUpKey.Source<FormPreset.Spec>,\n          AfterEvent<FormPreset.Spec[]>>,\n  ): void {\n    slot.insert(new FormPreset(slot.seed.do(\n        mapAfter((...specs) => FormPreset.combine(...specs, DefaultFormPreset)),\n        supplyAfter(slot.context.get(ContextSupply)),\n    )));\n  }\n\n}\n\nconst FormPreset__key = (/*#__PURE__*/ new FormPresetKey());\nconst FormPreset$rules__symbol = (/*#__PURE__*/ Symbol('FormPreset.rules'));\n\n/**\n * Form controls preset.\n *\n * Any number of presets can be {@link FormPreset.Spec specified} in component context to be applies to forms\n * and fields. They would be combined into single preset available in component context.\n */\nexport class FormPreset implements FormPreset.Rules, EventKeeper<[FormPreset.Rules]> {\n\n  /**\n   * A key of component context value containing default form preset combined from all provided {@link FormPreset.Spec\n   * specifiers}.\n   *\n   * As a bare minimum it attaches the following aspects to controls:\n   *\n   * - `InRenderScheduler` set to `ElementRenderScheduler`,\n   * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n   */\n  static get [ContextKey__symbol](): ContextUpKey<FormPreset, FormPreset.Spec> {\n    return FormPreset__key;\n  }\n\n  /**\n   * Combines form preset specifiers.\n   *\n   * @param specs - Form preset specifiers to combine.\n   *\n   * @returns Form preset rules instance combining the given specifiers.\n   */\n  static combine(...specs: FormPreset.Spec[]): FormPreset.Rules {\n    return {\n      setupField: FormPreset$setupField(specs),\n      setupForm: FormPreset$setupForm(specs),\n    };\n  }\n\n  /**\n   * @internal\n   */\n  private [FormPreset$rules__symbol]: FormPreset.Rules;\n\n  /**\n   * Constructs form preset.\n   *\n   * @param rules - An `AfterEvent` keeper of form preset {@link FormPreset.Rules rules}.\n   */\n  constructor(readonly rules: AfterEvent<[FormPreset.Rules]>) {\n    rules(rules => {\n      this[FormPreset$rules__symbol] = rules;\n    });\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of this form preset {@link FormPreset.Rules rules}.\n   */\n  [AfterEvent__symbol](): AfterEvent<[FormPreset.Rules]> {\n    return this.rules;\n  }\n\n  /**\n   * Sets up form field controls.\n   *\n   * @param builder - Target field builder.\n   */\n  setupField<TValue, TSharer extends object>(\n      builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    this[FormPreset$rules__symbol].setupField(builder);\n  }\n\n  /**\n   * Sets up form controls.\n   *\n   * @param builder - Target form builder.\n   */\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    this[FormPreset$rules__symbol].setupForm(builder);\n  }\n\n}\n\nexport namespace FormPreset {\n\n  /**\n   * A {@link FormPreset form preset} specifier.\n   *\n   * Contains a partial form preset implementation.\n   */\n  export interface Spec {\n\n    /**\n     * Sets up form field controls.\n     *\n     * @param builder - Target field builder.\n     */\n    setupField?<TValue, TSharer extends object>(\n        builder: Field.Builder<TValue, TSharer>,\n    ): void;\n\n    /**\n     * Sets up form controls.\n     *\n     * @param builder - Target form builder.\n     */\n    setupForm?<TModel, TElt extends HTMLElement, TSharer extends object>(\n        builder: Form.Builder<TModel, TElt, TSharer>,\n    ): void;\n\n  }\n\n  /**\n   * {@link FormPreset Form preset} rules.\n   *\n   * Multiple {@link Spec specifiers} could be combined into single rule instance by {@link FormPreset.combine} static\n   * method.\n   */\n  export interface Rules extends FormPreset.Spec {\n\n    setupField<TValue, TSharer extends object>(\n        this: void,\n        builder: Field.Builder<TValue, TSharer>,\n    ): void;\n\n    setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n        this: void,\n        builder: Form.Builder<TModel, TElt, TSharer>,\n    ): void;\n\n  }\n\n}\n\nfunction FormPreset$setupField(\n    specs: readonly FormPreset.Spec[],\n): <TValue, TSharer extends object>(\n    builder: Field.Builder<TValue, TSharer>,\n) => void {\n  return specs.reduce(\n      (prev, spec) => spec.setupField\n          ? <TValue, TSharer extends object>(\n              builder: Field.Builder<TValue, TSharer>,\n          ): void => {\n            prev(builder);\n            spec.setupField!(builder);\n          }\n          : prev,\n      FormPreset$noFieldSetup,\n  );\n}\n\nfunction FormPreset$noFieldSetup<TValue, TSharer extends object>(\n    _builder: Field.Builder<TValue, TSharer>,\n): void {\n  // No field setup\n}\n\nfunction FormPreset$setupForm(\n    specs: readonly FormPreset.Spec[],\n): <TModel, TElt extends HTMLElement, TSharer extends object>(\n    builder: Form.Builder<TModel, TElt, TSharer>,\n) => void {\n  return specs.reduce(\n      (prev, spec) => spec.setupForm\n          ? <TModel, TElt extends HTMLElement, TSharer extends object>(\n              builder: Form.Builder<TModel, TElt, TSharer>,\n          ): void => {\n            prev(builder);\n            spec.setupForm!(builder);\n          }\n          : prev,\n      FormPreset$noFormSetup,\n  );\n}\n\nfunction FormPreset$noFormSetup<TModel, TElt extends HTMLElement, TSharer extends object>(\n    _builder: Form.Builder<TModel, TElt, TSharer>,\n): void {\n  // No form setup\n}\n","import { InControl } from '@frontmeans/input-aspects';\nimport { Contextual__symbol } from '@proc7ts/context-values';\nimport { noop } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Shareable } from '../shares';\n\n/**\n * Abstract unit of input {@link Form form}.\n *\n * Represents a form or its field control and contains its value.\n *\n * @typeParam TValue - Input value type.\n * @typeParam TControls - A type of input controls this unit represents.\n * @typeParam TSharer - Unit sharer component type.\n */\nexport abstract class FormUnit<\n    TValue,\n    TControls extends FormUnit.Controls<TValue> = FormUnit.Controls<TValue>,\n    TSharer extends object = any>\n    extends Shareable<TControls | undefined, TSharer> {\n\n  /**\n   * Constructs form unit.\n   *\n   * @param controls - Either input controls, or their provider.\n   */\n  constructor(// eslint-disable-line @typescript-eslint/no-useless-constructor\n      controls: TControls | Shareable.Provider<TControls | undefined, TSharer>,\n  ) {\n    super(controls);\n  }\n\n  /**\n   * Input control of the field, if present.\n   */\n  get control(): InControl<TValue> | undefined {\n    return this.body?.control;\n  }\n\n  [Contextual__symbol](sharer: ComponentContext): this {\n    super[Contextual__symbol](sharer);\n    this.read(noop).needs(sharer); // Create controls eagerly.\n    return this;\n  }\n\n}\n\nexport namespace FormUnit {\n\n  /**\n   * A value type for the given form unit type.\n   *\n   * @typeParam TUnit - Target unit type.\n   */\n  export type ValueType<TUnit extends FormUnit<any, any, any>> =\n      TUnit extends FormUnit<infer TValue, any, any> ? TValue : never;\n\n  /**\n   * A type of controls type for the given form unit type.\n   *\n   * @typeParam TUnit - Target unit type.\n   */\n  export type ControlsType<TUnit extends FormUnit<any, any, any>> =\n      TUnit extends FormUnit<any, infer TControls, any> ? TControls : never;\n\n  /**\n   * A type of the sharer for the given form unit type.\n   *\n   * @typeParam TUnit - Target unit type.\n   */\n  export type SharerType<TUnit extends FormUnit<any, any, any>> =\n      TUnit extends FormUnit<any, any, infer TSharer> ? TSharer : never;\n\n  /**\n   * Form unit controls.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Controls<TValue> {\n\n    /**\n     * An input control of the unit.\n     */\n    readonly control: InControl<TValue>;\n\n  }\n\n}\n","import { InBuilder, InControl } from '@frontmeans/input-aspects';\nimport { AfterEvent, afterValue, deduplicateAfter_, digAfter_, mapAfter } from '@proc7ts/fun-events';\nimport { valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Shareable } from '../shares';\nimport { FormPreset } from './form-preset';\nimport { FormUnit } from './form-unit';\n\n/**\n * A field of the user input {@link Form form}.\n *\n * A component {@link FieldShare shares} field (e.g. using {@link SharedField @SharedField} decorator) to make it\n * accessible by component itself and nested ones. E.g. to add it to {@link Form form} or to manipulate its value.\n *\n * The field instance is not usable until it is bound to its sharer component. The latter is done automatically when\n * the field is shared by {@link FieldShare}.\n *\n * @typeParam TValue - Field value type.\n * @typeParam TSharer - Field sharer component type.\n */\nexport class Field<TValue, TSharer extends object = any> extends FormUnit<TValue, Field.Body<TValue>, TSharer> {\n\n  /**\n   * Creates a form field by the given field control factory.\n   *\n   * @param factory - Field control factory.\n   *\n   * @returns New field instance.\n   */\n  static by<TValue, TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TValue>>,\n  ): Field<TValue, TSharer> {\n    return new this(this.providerBy(factory));\n  }\n\n  /**\n   * Creates a form field controls provider by the given control factory.\n   *\n   * @param factory - Field control factory.\n   *\n   * @returns New form field controls provider.\n   */\n  static providerBy<TValue, TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TValue>>,\n  ): Field.Provider<TValue, TSharer> {\n    return builder => ({\n      control: builder.control.build(factory),\n    });\n  }\n\n  /**\n   * Constructs form field.\n   *\n   * @param controls - Either a field controls instance, or its provider.\n   */\n  constructor(controls: Field.Controls<TValue> | Field.Provider<TValue, TSharer>) {\n    super(Field$provider(() => this, valueRecipe(controls)));\n  }\n\n  toString(): string {\n    return 'Field';\n  }\n\n}\n\nexport namespace Field {\n\n  /**\n   * A value type of the given form field.\n   *\n   * @typeParam TField - Field type.\n   */\n  export type ValueType<TField extends Field<any>> = FormUnit.ValueType<TField>;\n\n  /**\n   * Form field controls.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Controls<TValue> extends FormUnit.Controls<TValue> {\n\n    /**\n     * Field input control.\n     */\n    readonly control: InControl<TValue>;\n\n  }\n\n  /**\n   * Form field body containing its input control.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Body<TValue, TSharer extends object = any> extends FormUnit.Controls<TValue> {\n\n    /**\n     * A field the input control belongs to.\n     */\n    readonly field: Field<TValue, TSharer>;\n\n    /**\n     * Field input control.\n     */\n    readonly control: InControl<TValue>;\n\n  }\n\n  /**\n   * Form field builder.\n   *\n   * @typeParam TValue - Field value type.\n   * @typeParam TSharer - Field sharer component type.\n   */\n  export interface Builder<TValue, TSharer extends object> {\n\n    /**\n     * Sharer component context.\n     */\n    readonly sharer: ComponentContext<TSharer>;\n\n    /**\n     * Target field.\n     */\n    readonly field: Field<TValue, TSharer>;\n\n    /**\n     * Field input control builder.\n     */\n    readonly control: InBuilder<InControl<TValue>, TValue>;\n\n  }\n\n  /**\n   * Form field controls provider signature.\n   *\n   * @typeParam TValue - Field value type.\n   * @typeParam TSharer - Field sharer component type.\n   */\n  export type Provider<TValue, TSharer extends object = any> =\n  /**\n   * @param builder - Field builder.\n   *\n   * @returns Either field controls instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          builder: Builder<TValue, TSharer>,\n      ) => Controls<TValue> | AfterEvent<[Controls<TValue>?]>;\n\n}\n\nfunction Field$provider<TValue, TSharer extends object>(\n    field: () => Field<TValue, TSharer>,\n    provider: Field.Provider<TValue>,\n): Shareable.Provider<Field.Body<TValue> | undefined, TSharer> {\n  return sharer => sharer.get(FormPreset).rules.do(\n      digAfter_(preset => {\n\n        const builder: Field.Builder<TValue, TSharer> = {\n          sharer,\n          field: field(),\n          control: new InBuilder<InControl<TValue>, TValue>(),\n        };\n\n        preset.setupField(builder);\n\n        return afterValue(provider(builder));\n      }),\n      deduplicateAfter_(Field$isDuplicateControls, ([controls]) => controls),\n      mapAfter(controls => controls && { field: field(), control: controls.control }),\n  );\n}\n\nfunction Field$isDuplicateControls<TValue>(\n    prior?: Field.Controls<TValue>,\n    next?: Field.Controls<TValue>,\n): boolean {\n  if (prior?.control !== next?.control) {\n    prior?.control.supply.off();\n    return false;\n  }\n  return true;\n}\n","import { ContextKey__symbol } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { Share, Share__symbol } from '../shares';\nimport { Field } from './field';\n\nconst FieldShare$map = (/*#__PURE__*/ new WeakMap<Class, FieldShare<any>>());\n\n/**\n * A kind of component share containing a {@link Field form field}.\n *\n * This class may be inherited to represent a specific type of forms. E.g. to distinguish multiple fields defined\n * within the same component.\n *\n * @typeParam TValue - Field value type.\n */\nexport class FieldShare<TValue = any> extends Share<Field<TValue>> {\n\n  /**\n   * Default field share instance.\n   */\n  static get [Share__symbol](): FieldShare {\n\n    let instance = FieldShare$map.get(this);\n\n    if (!instance) {\n      instance = new this('field');\n      FieldShare$map.set(this, instance);\n    }\n\n    return instance;\n  }\n\n  /**\n   * A key of component context value containing default field instance.\n   */\n  static get [ContextKey__symbol](): Share.Key<Field<any>> {\n    return this[Share__symbol][ContextKey__symbol];\n  }\n\n}\n","import { ContextKey__symbol } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { Share, Share__symbol } from '../shares';\nimport { Form } from './form';\n\nconst FormShare$map = (/*#__PURE__*/ new WeakMap<Class, FormShare<any, any>>());\n\n/**\n * A kind of component share containing a user input form.\n *\n * This class may be inherited to represent a specific type of forms. E.g. to support multiple forms within the same\n * component tree.\n *\n * @typeParam TModel - A model type of the form.\n * @typeParam TElt - A type of HTML form element.\n */\nexport class FormShare<TModel = any, TElt extends HTMLElement = HTMLElement> extends Share<Form<TModel, TElt>> {\n\n  /**\n   * Default form share instance.\n   */\n  static get [Share__symbol](): FormShare<any, any> {\n\n    let instance = FormShare$map.get(this);\n\n    if (!instance) {\n      instance = new this('form');\n      FormShare$map.set(this, instance);\n    }\n\n    return instance;\n  }\n\n  /**\n   * A key of component context value containing default form instance.\n   */\n  static get [ContextKey__symbol](): Share.Key<Form> {\n    return this[Share__symbol][ContextKey__symbol];\n  }\n\n}\n","import { InBuilder, InControl } from '@frontmeans/input-aspects';\nimport { AfterEvent, afterThe, afterValue, digAfter } from '@proc7ts/fun-events';\nimport { valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { shareLocator, ShareLocator } from '../shares';\nimport { Field } from './field';\nimport { FieldShare } from './field.share';\nimport { Form } from './form';\nimport { FormUnit } from './form-unit';\nimport { FormShare } from './form.share';\n\n/**\n * Creates a field adjacent to some form unit.\n *\n * Suitable e.g. for buttons or error indicators.\n *\n * The controls of adjacent field are based on the ones of the unit it is adjacent to.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n * @typeParam TSharer - Adjacent field sharer component type.\n */\nexport function adjacentField<\n    TValue,\n    TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n    TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n    TSharer extends object = FormUnit.SharerType<TAdjacentTo>,\n    >(\n    controls: Field.Controls<TValue> | AdjacentField.Provider<TValue, TAdjacentTo, TAdjusted, TSharer>,\n    adjacentTo: ShareLocator.Mandatory<TAdjacentTo>,\n): Field<TValue, TSharer> {\n  return new Field(AdjacentField$provider(\n      valueRecipe(controls),\n      shareLocator(adjacentTo, { local: 'too' }),\n  ));\n}\n\n/**\n * Creates a field adjacent to another one.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TSharer - Adjacent field sharer component type.\n * @param controls - Either a field controls instance, or its provider.\n * @param adjacentTo - A locator of the field share the created field is adjacent to. Includes local shares by\n * default. Defaults to {@link FieldShare}.\n */\nexport function adjacentToField<TValue, TSharer extends object = any>(\n    controls:\n        | Field.Controls<TValue>\n        | AdjacentField.Provider<TValue, Field<unknown>, Field.Controls<unknown>, TSharer>,\n    adjacentTo: ShareLocator.Mandatory<Field<unknown>> = FieldShare,\n): Field<TValue, TSharer> {\n  return adjacentField(controls, adjacentTo);\n}\n\n/**\n * Creates a field adjacent to form.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TSharer - Adjacent field sharer component type.\n * @param controls - Either a field controls instance, or its provider.\n * @param adjacentTo - A locator of the form share the created field is adjacent to. Includes local shares by default.\n * Defaults to {@link FormShare}.\n */\nexport function adjacentToForm<TValue, TSharer extends object = any>(\n    controls:\n        | Field.Controls<TValue>\n        | AdjacentField.Provider<TValue, Form<unknown>, Form.Body<unknown>, TSharer>,\n    adjacentTo: ShareLocator.Mandatory<Form<unknown>> = FormShare,\n): Field<TValue, TSharer> {\n  return adjacentField(controls, adjacentTo);\n}\n\nexport namespace AdjacentField {\n\n  /**\n   * Adjacent field builder.\n   *\n   * @typeParam TValue - Adjacent field value type.\n   * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n   * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n   * @typeParam TSharer - Adjacent field sharer component type.\n   */\n  export interface Builder<\n      TValue,\n      TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n      TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n      TSharer extends object = any,\n      > extends Field.Builder<TValue, TSharer> {\n\n    /**\n     * Sharer component context.\n     */\n    readonly sharer: ComponentContext<TSharer>;\n\n    /**\n     * Target field.\n     */\n    readonly field: Field<TValue, TSharer>;\n\n    /**\n     * Field input control builder.\n     */\n    readonly control: InBuilder<InControl<TValue>, TValue>;\n\n    /**\n     * Form unit the field is adjacent to.\n     */\n    readonly adjacentTo: TAdjacentTo;\n\n    /**\n     * Adjusted form unit control.\n     */\n    readonly adjusted: TAdjusted;\n\n  }\n\n  /**\n   * Adjacent field controls provider signature.\n   *\n   * @typeParam TValue - Adjacent field value type.\n   * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n   * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n   * @typeParam TSharer - Adjacent field sharer component type.\n   */\n  export type Provider<\n      TValue,\n      TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n      TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n      TSharer extends object = any,\n      > =\n  /**\n   * @param builder - Adjacent field builder.\n   *\n   * @returns Either field controls instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          builder: Builder<TValue, TAdjacentTo, TAdjusted, TSharer>,\n      ) => Field.Controls<TValue> | AfterEvent<[Field.Controls<TValue>?]>;\n\n}\n\nfunction AdjacentField$provider<\n    TValue,\n    TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n    TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n    TSharer extends object = any>(\n    provider: AdjacentField.Provider<TValue, TAdjacentTo, TAdjusted, TSharer>,\n    adjacentLocator: ShareLocator.Fn<TAdjacentTo>,\n): Field.Provider<TValue, TSharer> {\n  return builder => adjacentLocator(builder.sharer).do(\n      digAfter((adjacentTo?: TAdjacentTo, _sharer?): AfterEvent<[Field.Controls<TValue>?]> => adjacentTo\n          ? adjacentTo.read.do(\n              digAfter((adjusted?: TAdjusted): AfterEvent<[Field.Controls<TValue>?]> => adjusted\n                  ? afterValue(provider({\n                    ...builder,\n                    adjacentTo,\n                    adjusted,\n                  }))\n                  : afterThe()),\n          )\n          : afterThe()),\n  );\n}\n","/**\n * @internal\n */\nexport function Field$name(key: string | symbol, name: string | undefined): string | null {\n  if (name === '') {\n    return null;\n  }\n  if (name) {\n    return name;\n  }\n  return Field$nameByKey(key);\n}\n\n/**\n * @internal\n */\nexport function Field$nameByKey(key: string | symbol): string | null {\n  return typeof key === 'string' ? key : null;\n}\n","import { InGroup } from '@frontmeans/input-aspects';\nimport { afterAll, consumeEvents, digAfter_ } from '@proc7ts/fun-events';\nimport { asis, Class, valuesProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentClass } from '@wesib/wesib';\nimport { shareLocator, ShareLocator } from '../shares';\nimport { Field } from './field';\nimport { Field$nameByKey } from './field.impl';\nimport { Form } from './form';\nimport { FormUnit } from './form-unit';\nimport { FormShare } from './form.share';\nimport { SharedField } from './shared-field.decorator';\nimport { SharedFormUnit } from './shared-form-unit.decorator';\nimport { SharedForm } from './shared-form.decorator';\n\n/**\n * Builds a {@link SharedForm shared form} definition builder that adds nested form to enclosing one.\n *\n * @typeParam TForm - Nested form type.\n * @typeParam TModel - Nested form model type.\n * @typeParam TElt - A type of nested HTML form element.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Nested form naming definition.\n *\n * @returns Shared form definition builder.\n */\nexport function FormName<\n    TForm extends Form<TModel, TElt>,\n    TModel = Form.ModelType<TForm>,\n    TElt extends HTMLElement = Form.ElementType<TForm>,\n    TClass extends ComponentClass = Class>(\n    def?: FieldNameDef,\n): SharedForm.Definer<TForm, TModel, TElt, TClass> {\n  return FormUnitName<TForm, TModel, Form.Body<TModel, TElt>, TClass>(def);\n}\n\n/**\n * Builds a {@link SharedField shared form field} definition builder that adds the field to enclosing form.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Field naming definition.\n *\n * @returns Shared field definition builder.\n */\nexport function FieldName<\n    TField extends Field<TValue>,\n    TValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class>(\n    def: FieldNameDef = {},\n): SharedField.Definer<TField, TValue, TClass> {\n  return FormUnitName<TField, TValue, Field.Controls<TValue>, TClass>(def);\n}\n\nfunction FormUnitName<\n    TUnit extends FormUnit<TValue, TControls, any>,\n    TValue,\n    TControls extends FormUnit.Controls<TValue>,\n    TClass extends ComponentClass = Class>(\n    def: FieldNameDef = {},\n): SharedFormUnit.Definer<TUnit, TValue, TControls, TClass> {\n  return ({\n    key,\n    share,\n    locateForm: defaultForm,\n    name: defaultName,\n  }) => {\n\n    const { name = defaultName } = def;\n    let fieldName: string;\n\n    if (name) {\n      fieldName = name;\n    } else if (name != null) {\n      return; // Empty field name. Do not ad it to form.\n    } else {\n\n      const autoName = Field$nameByKey(key);\n\n      if (!autoName) {\n        return;\n      }\n\n      fieldName = autoName;\n    }\n\n    const locateForm = shareLocator(def.form || defaultForm, { share: FormShare });\n\n    return {\n      componentDef: {\n        setup(setup) {\n          setup.whenComponent(context => {\n            afterAll({\n              unit: context.get(share).do(\n                  digAfter_(asis, valuesProvider<[TControls?]>()),\n              ),\n              form: locateForm(context).do(\n                  digAfter_((form?, _sharer?) => form, valuesProvider<[FormUnit.Controls<any>?]>()),\n              ),\n            }).do(\n                consumeEvents(({ unit: [field], form: [form] }): Supply | undefined => {\n                  if (!form || !field) {\n                    return;\n                  }\n\n                  const group = form.control.aspect(InGroup);\n\n                  if (!group) {\n                    return;\n                  }\n\n                  return group.controls.set(fieldName, field.control);\n                }),\n            );\n          });\n        },\n      },\n    };\n  };\n}\n\n/**\n * Form field naming definition.\n */\nexport interface FieldNameDef {\n\n  /**\n   * A locator of form unit to add the field to.\n   *\n   * Either {@link SharedFieldDef.form predefined}, or {@link FormShare default} form share is used when omitted.\n   */\n  readonly form?: ShareLocator<FormUnit<any>>;\n\n  /**\n   * Field name.\n   *\n   * The shared field will be added to the input control group (`InGroup`) within the {@link form target form},\n   * unless the name is empty string.\n   *\n   * Either {@link SharedFieldDef.name predefined}, or property name is used when omitted.\n   */\n  readonly name?: string;\n\n}\n","import {\n  InAspect,\n  InAspect__symbol,\n  InBuilder,\n  InControl,\n  InConverter,\n  inconvertibleInAspect,\n  inFormElement,\n  InFormElement,\n  nullInAspect,\n} from '@frontmeans/input-aspects';\nimport { AfterEvent, afterValue, deduplicateAfter_, digAfter_, mapAfter } from '@proc7ts/fun-events';\nimport { lazyValue, valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Shareable } from '../shares';\nimport { FormPreset } from './form-preset';\nimport { FormUnit } from './form-unit';\n\nconst Form__aspect: Form$Aspect = {\n\n  applyTo<TValue>(_control: InControl<TValue>): Form$Applied<TValue> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return nullInAspect();\n  },\n\n};\n\n/**\n * User input form.\n *\n * A component {@link FormShare shares} form (e.g. using {@link SharedForm @SharedForm} decorator) to make its\n * accessible by component itself and nested ones. E.g. to add {@link Field fields} to it or submit it.\n *\n * A form may be nested within another one, as it implements a {@link Field} interface.\n *\n * The form instance is not usable until it is bound to its sharer component. The latter is done automatically when the\n * form is shared by {@link FormShare}.\n *\n * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TSharer - Form sharer component type.\n */\nexport class Form<TModel = any, TElt extends HTMLElement = HTMLElement, TSharer extends object = any>\n    extends FormUnit<TModel, Form.Body<TModel, TElt>, TSharer> {\n\n  /**\n   * Builds a user input form for the given form control and HTML element.\n   *\n   * @param control - Submitted control. Typically a container one.\n   * @param element - HTML element to create control for.\n   * @param options - Form element control options.\n   *\n   * @returns New form instance.\n   */\n  static forElement<TModel, TElt extends HTMLElement>(\n      control: InControl<TModel>,\n      element: TElt,\n      options?: Omit<InFormElement.Options, 'form'>,\n  ): Form.Controls<TModel, TElt> {\n    return {\n      control,\n      element: inFormElement(element, { ...options, form: control }),\n    };\n  }\n\n  /**\n   * Creates a form instance by the given control factories.\n   *\n   * @param factory - Submittable form control factory.\n   * @param elementFactory - Form element control factory or options.\n   *\n   * @returns New form instance.\n   */\n  static by<\n      TModel,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TModel>, TModel>,\n      elementFactory: (\n          this: void,\n          options: Parameters<InControl.Factory<InFormElement<TElt>, void>>[0] & { form: InControl<TModel>},\n      ) => InFormElement<TElt>,\n  ): Form<TModel, TElt, TSharer> {\n    return new this(this.providerBy(factory, elementFactory));\n  }\n\n  /**\n   * Creates a form controls provider by the given control factories.\n   *\n   * @param factory - Submittable form control factory.\n   * @param elementFactory - Form element control factory or options.\n   *\n   * @returns New form controls provider.\n   */\n  static providerBy<\n      TModel,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TModel>, TModel>,\n      elementFactory: (\n          this: void,\n          options: Parameters<InControl.Factory<InFormElement<TElt>, void>>[0] & { form: InControl<TModel>},\n      ) => InFormElement<TElt>,\n  ): Form.Provider<TModel, TElt, TSharer> {\n    return builder => {\n\n      let control = (): InControl<TModel> => builder.control.build(\n          // Allow recurrent access to `Form` aspect during control setup.\n          opts => (control = lazyValue(() => factory(opts)))(),\n      );\n      let element = (): InFormElement<TElt> => builder.element.build(\n          // Allow recurrent access to `Form` aspect during control setup.\n          opts => (element = lazyValue(() => elementFactory({\n            form: control(),\n            ...opts,\n          })))(),\n      );\n\n      return {\n        get control() {\n          return control();\n        },\n        get element() {\n          return element();\n        },\n      };\n    };\n  }\n\n  /**\n   * An input control aspect representing a form this control belongs to.\n   *\n   * This aspect is available in {@link Form.Body.control submittable form control} and {@link Form.Body.element form\n   * element control}.\n   */\n  static get [InAspect__symbol](): InAspect<Form.Whole | null> {\n    return Form__aspect;\n  }\n\n  /**\n   * Constructs form.\n   *\n   * @param controls - Either form controls instance, or its provider.\n   */\n  constructor(\n      controls: Form.Controls<TModel, TElt> | Form.Provider<TModel, TElt, TSharer>,\n  ) {\n    super(Form$provider(() => this, valueRecipe(controls)));\n  }\n\n  /**\n   * Form element control, if present.\n   *\n   * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n   * element issuing a `submit` event.\n   */\n  get element(): InFormElement<TElt> | undefined {\n    return this.body?.element;\n  }\n\n  toString(): string {\n    return 'Form';\n  }\n\n}\n\nfunction Form$provider<TModel, TElt extends HTMLElement, TSharer extends object>(\n    form: () => Form<TModel, TElt, TSharer>,\n    provider: Form.Provider<TModel, TElt, TSharer>,\n): Shareable.Provider<Form.Body<TModel, TElt> | undefined, TSharer> {\n\n  const formAspect: InConverter.Aspect.Factory<any> = control => ({\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        _aspect: InAspect<any, any>,\n    ): InAspect.Application.Result<TInstance, any, TKind> | undefined {\n      return inconvertibleInAspect(\n          control,\n          Form,\n          form() as Form.Whole,\n      ) as InAspect.Application.Result<TInstance, any, TKind>;\n    },\n  });\n\n  return sharer => sharer.get(FormPreset).rules.do(\n      digAfter_(preset => {\n\n        const builder: Form.Builder<TModel, TElt, TSharer> = {\n          sharer,\n          form: form(),\n          control: new InBuilder<InControl<TModel>, TModel>().addAspect(Form, formAspect),\n          element: new InBuilder<InFormElement<TElt>, void>().addAspect(Form, formAspect),\n        };\n\n        preset.setupForm(builder);\n\n        return afterValue(provider(builder));\n      }),\n      deduplicateAfter_(Form$isDuplicateControls, ([controls]) => controls),\n      mapAfter(controls => controls && {\n        get form() {\n          return form();\n        },\n        get control() {\n          return controls!.control;\n        },\n        get element() {\n          return controls!.element;\n        },\n      }),\n  );\n}\n\nfunction Form$isDuplicateControls<TModel, TElt extends HTMLElement>(\n    prior: Form.Controls<TModel, TElt> | undefined,\n    next: Form.Controls<TModel, TElt> | undefined,\n): boolean {\n\n  let duplicate = true;\n\n  if (prior?.control !== next?.control) {\n    prior?.control.supply.off();\n    duplicate = false;\n  }\n  if (prior?.element !== next?.element) {\n    prior?.element.supply.off();\n    duplicate = false;\n  }\n\n  return duplicate;\n}\n\nexport namespace Form {\n\n  /**\n   * A whole form instance containing controls.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TSharer - Form sharer component type.\n   */\n  export interface Whole<\n      TModel = any,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any>\n      extends Form<TModel, TElt, TSharer> {\n\n    /**\n     * Form body.\n     */\n    readonly body: Body<TModel, TElt, TSharer>;\n\n    /**\n     * Submittable form input control.\n     */\n    readonly control: InControl<TModel>;\n\n    /**\n     * Form element control.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InFormElement<any>;\n\n  }\n\n  /**\n   * A model type of the given form.\n   *\n   * @typeParam TForm - Form type.\n   */\n  export type ModelType<TForm extends Form<any, any>> = FormUnit.ValueType<TForm>;\n\n  /**\n   * HTML form element type of the form.\n   *\n   * @typeParam TForm - Form type.\n   */\n  export type ElementType<TForm extends Form<any, any>> = TForm extends Form<any, infer TElt> ? TElt : never;\n\n  /**\n   * Form controls.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   */\n  export interface Controls<TModel, TElt extends HTMLElement = HTMLElement> extends FormUnit.Controls<TModel> {\n\n    /**\n     * Submittable form input control.\n     */\n    readonly control: InControl<TModel>;\n\n    /**\n     * Form element control.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InFormElement<TElt>;\n\n  }\n\n  /**\n   * Form body containing input controls.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TSharer - Form sharer component type.\n   */\n  export interface Body<\n      TModel,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any,\n      > extends FormUnit.Controls<TModel> {\n\n    /**\n     * A form the controls belong to.\n     */\n    readonly form: Form<TModel, TElt, TSharer>;\n\n    /**\n     * Submittable form input control.\n     */\n    readonly control: InControl<TModel>;\n\n    /**\n     * Form element control.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InFormElement<TElt>;\n\n  }\n\n  /**\n   * Form builder.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   */\n  export interface Builder<TModel, TElt extends HTMLElement, TSharer extends object> {\n\n    /**\n     * Sharer component context.\n     */\n    readonly sharer: ComponentContext<TSharer>;\n\n    /**\n     * Target form.\n     */\n    readonly form: Form<TModel, TElt, TSharer>;\n\n    /**\n     * Submittable form control builder.\n     */\n    readonly control: InBuilder<InControl<TModel>, TModel>;\n\n    /**\n     * Form element control builder.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InBuilder<InFormElement<TElt>, void>;\n\n  }\n\n  /**\n   * Form controls provider signature.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TSharer - Form sharer component type.\n   */\n  export type Provider<TModel = any, TElt extends HTMLElement = HTMLElement, TSharer extends object = object> =\n  /**\n   * @param builder - Form builder.\n   *\n   * @returns Either form controls instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          builder: Builder<TModel, TElt, TSharer>,\n      ) => Controls<TModel, TElt> | AfterEvent<[Controls<TModel, TElt>?]>;\n\n}\n\n/**\n * Form aspect.\n */\ninterface Form$Aspect extends InAspect<Form | null, 'form'> {\n\n  applyTo<TValue>(control: InControl<TValue>): Form$Applied<TValue>;\n\n}\n\n/**\n * A form aspect applied to control.\n */\ntype Form$Applied<TValue> = InAspect.Applied<TValue, Form.Whole<TValue> | null, Form.Whole<any> | null>;\n\ndeclare module '@frontmeans/input-aspects' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Form aspect application type.\n       */\n      form(): Form.Whole<TValue> | null;\n\n    }\n\n  }\n\n}\n","import { InControl, InRole } from '@frontmeans/input-aspects';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/supply';\n\n/**\n * A scope of form setup applicability.\n *\n * Selects controls to set up:\n *\n * - `false` - to set up nothing,\n * - `true` - to set up every control,\n * - role name or array of role names - to set up only to controls with that roles,\n * - `null`, `undefined`, or empty array - to set up only controls with default role.\n */\nexport type FormScope =\n    | boolean\n    | string\n    | readonly string[]\n    | null\n    | undefined;\n\nexport const FormScope = {\n\n  /**\n   * Creates an input control setup procedure applied to the given scope.\n   *\n   * @typeParam TControl - Input control type.\n   * @typeParam TValue - Input value type.\n   * @param scope - Setup applicability scope.\n   * @param setup - A setup procedure to apply. Accepts target control instance as parameter and returns a setup supply\n   * peer. The setup should be reverted once this peer's supply cut off.\n   * @param defaultRole - A role name to apply by default. `'default'` when omitted.\n   *\n   * @returns A setup procedure accepting target control as parameter and returning a setup supply. The setup is\n   * reverted once this supply cut off.\n   */\n  createSetup<TControl extends InControl<TValue>, TValue = InControl.ValueType<TControl>>(\n      this: void,\n      scope: FormScope,\n      setup: (this: void, control: TControl) => SupplyPeer,\n      defaultRole = 'default',\n  ): (this: void, control: TControl) => Supply {\n    if (scope === false) {\n      return _control => neverSupply();\n    }\n    if (scope === true) {\n      return control => setup(control).supply;\n    }\n\n    let roles = arrayOfElements(scope);\n\n    if (!roles.length) {\n      roles = [defaultRole];\n    }\n\n    if (roles.length === 1) {\n      return control => control.aspect(InRole).when(roles[0], () => setup(control));\n    }\n\n    return control => roles.reduce(\n        (supply, role) => control.aspect(InRole).when(role, () => setup(control)).as(supply),\n        new Supply(),\n    );\n  },\n\n};\n","import { ContextBuilder, ContextBuilder__symbol, ContextRegistry } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Field } from '../field';\nimport { Form } from '../form';\nimport { FormPreset } from '../form-preset';\n\nconst AbstractFormPreset$map = (/*#__PURE__*/ new WeakMap<typeof AbstractFormPreset, FeatureDef>());\n\n/**\n * Abstract form preset implementation.\n *\n * A class extending it may be used as a feature. E.g. passed to `bootstrapComponents()` function or used as a\n * dependency of another feature.\n *\n * An instance of implementation class may be created to customize its behavior. Such instance implements a\n * `ContextBuilder` interface. Thus is can be passed to context value registration method.\n */\nexport abstract class AbstractFormPreset implements FormPreset.Spec, ContextBuilder {\n\n  /**\n   * Feature definition of the preset.\n   */\n  static get [FeatureDef__symbol](): FeatureDef {\n\n    const found = AbstractFormPreset$map.get(this);\n\n    if (found) {\n      return found;\n    }\n\n    const preset = new (this as unknown as Class<AbstractFormPreset>)();\n    const featureDef: FeatureDef = {\n      setup: setup => {\n        setup.provide(preset);\n      },\n    };\n\n    AbstractFormPreset$map.set(this, featureDef);\n\n    return featureDef;\n  }\n\n  /**\n   * Provides this form preset to the given context.\n   *\n   * @param registry - A context registry to provide a value to.\n   *\n   * @returns A supply instance that removes the added preset once cut off.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry): Supply {\n    return registry.provide({ a: FormPreset, is: this });\n  }\n\n  /**\n   * Sets up form field controls.\n   *\n   * Does nothing by default.\n   *\n   * @param _builder - Target field builder.\n   */\n  setupField<TValue, TSharer extends object>(\n      _builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    // No field setup\n  }\n\n  /**\n   * Sets up form controls.\n   *\n   * Does nothing by default.\n   *\n   * @param _builder - Target form builder.\n   */\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      _builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    // No form setup\n  }\n\n}\n","import { InControl } from '@frontmeans/input-aspects';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { FormScope } from './form-scope';\n\n/**\n * Scoped form setup configuration.\n *\n * Contains setup options along with the scope they applicable to.\n *\n * May be one of:\n *\n * - `false` - to not apply configuration,\n * - `true` - to apply default configuration to every control,\n * - role name or array of role names - to apply default configuration only to controls with that roles,\n * - `null`, `undefined`, or empty array - to apply default configuration only to controls with default role,\n * - an array containing options as the first element, and role names as the rest of them - to apply these options\n *   only to controls with that roles,\n * - a tuple consisting of options and {@link FormScope scope} specifier - to apply these options to specified scope.\n *\n * @typeParam TOptions - A type of setup options.\n */\nexport type ScopedFormConfig<TOptions> =\n    | TOptions\n    | FormScope\n    | readonly [TOptions, FormScope?]\n    | readonly [TOptions, ...string[]];\n\nexport const ScopedFormConfig = {\n\n  /**\n   * Creates an input control setup procedure that applies the given configuration to appropriate scope.\n   *\n   * @typeParam TOptions - A type of setup options.\n   * @typeParam TControl - Input control type.\n   * @typeParam TValue - Input value type.\n   * @param config - Scoped form setup configuration.\n   * @param createSetup - A function accepting setup options and returning a procedure that sets up the given control\n   * with these options. The setup procedure returns a setup supply peer. The setup should be reverted once this peer's\n   * supply cut off.\n   * @param defaultRole - A role name to apply by default. `'default'` when omitted.\n   *\n   * @returns A setup procedure accepting target control as parameter and returning a setup supply. The setup is\n   * reverted once this supply cut off.\n   */\n  createSetup<\n      TOptions,\n      TControl extends InControl<TValue>,\n      TValue = InControl.ValueType<TControl>,\n      >(\n      config: ScopedFormConfig<TOptions>,\n      createSetup: (this: void, options?: TOptions) => (this: void, control: TControl) => SupplyPeer,\n      defaultRole?: string,\n  ): (this: void, control: TControl) => Supply {\n\n    let scope: FormScope;\n    let options: TOptions | undefined;\n\n    if (Array.isArray(config)) {\n\n      const [first, ...rest] = config;\n\n      if (ScopedFormConfig$isOptions(first)) {\n        scope = rest.length > 1 ? rest : rest[0];\n        options = first;\n      } else {\n        scope = config;\n      }\n    } else if (ScopedFormConfig$isOptions(config)) {\n      options = config as TOptions;\n    } else {\n      scope = config;\n    }\n\n    return FormScope.createSetup<TControl, TValue>(\n        scope,\n        createSetup(options),\n        defaultRole,\n    );\n  },\n\n};\n\nfunction ScopedFormConfig$isOptions<TOptions>(\n    config: TOptions | string | boolean | undefined,\n): config is TOptions {\n  return config != null && typeof config !== 'string' && typeof config !== 'boolean';\n}\n","import { InControl, InCssClasses, inCssError, inCssInfo } from '@frontmeans/input-aspects';\nimport { Supply } from '@proc7ts/supply';\nimport { Field } from '../field';\nimport { Form } from '../form';\nimport { ScopedFormConfig } from '../scoped-form-config';\nimport { AbstractFormPreset } from './abstract-form-preset';\n\n/**\n * Form preset that enables CSS class indication of form and field states.\n *\n * - Enables CSS info classes (`inCssInfo()`) for forms and fields.\n * - Enables error indication (`inCssError()`) for fields.\n */\nexport class FormCssPreset extends AbstractFormPreset {\n\n  /**\n   * @internal\n   */\n  private readonly _info: (control: InControl<any>) => Supply;\n\n  /**\n   * @internal\n   */\n  private readonly _error: (control: InControl<any>) => Supply;\n\n  /**\n   * Constructs customized form CSS preset.\n   *\n   * @param options - Custom form CSS preset options.\n   */\n  constructor(options: FormCssPreset.Options = {}) {\n    super();\n    this._info = ScopedFormConfig.createSetup(\n        options.info,\n        opts => {\n\n          const src = inCssInfo(opts);\n\n          return control => control.aspect(InCssClasses).add(src);\n        },\n    );\n    this._error = ScopedFormConfig.createSetup(\n        options.error,\n        opts => {\n\n          const src = inCssError(opts);\n\n          return control => control.aspect(InCssClasses).add(src);\n        },\n    );\n  }\n\n  setupField<TValue, TSharer extends object>(\n      builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    builder.control.setup(this._info).setup(this._error);\n  }\n\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    builder.control.setup(this._info);\n    builder.element.setup(\n        InCssClasses,\n        (css, element) => css.add(\n            element.aspect(Form)!.control.aspect(InCssClasses),\n        ),\n    );\n  }\n\n}\n\nexport namespace FormCssPreset {\n\n  /**\n   * Form CSS preset options.\n   */\n  export interface Options {\n\n    /**\n     * CSS info options.\n     *\n     * `false` to disable.\n     */\n    readonly info?: ScopedFormConfig<Parameters<typeof inCssInfo>[0]>;\n\n    /**\n     * CSS error indication options.\n     *\n     * `false` to disable.\n     */\n    readonly error?: ScopedFormConfig<Parameters<typeof inCssError>[0]>;\n\n  }\n\n}\n","import { InControl, InMode, inModeByValidity, InParents } from '@frontmeans/input-aspects';\nimport { consumeEvents } from '@proc7ts/fun-events';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { Field } from '../field';\nimport { Form } from '../form';\nimport { FormScope } from '../form-scope';\nimport { ScopedFormConfig } from '../scoped-form-config';\nimport { AbstractFormPreset } from './abstract-form-preset';\n\n/**\n * Form preset that enables default form and field mode management.\n *\n * - Makes form mode depend on its validity (`inModeByValidity()`).\n * - Derives form field's mode from form element's one.\n */\nexport class FormModePreset extends AbstractFormPreset {\n\n  /**\n   * @internal\n   */\n  private readonly _byValidity: (control: InControl<any>) => Supply;\n\n  /**\n   * @internal\n   */\n  private readonly _byForm: (control: InControl<any>) => Supply;\n\n  /**\n   * Constructs customized form mode preset.\n   *\n   * @param options - Custom form mode preset options.\n   */\n  constructor(options: FormModePreset.Options = {}) {\n    super();\n    this._byValidity = ScopedFormConfig.createSetup(\n        options.byValidity,\n        opts => {\n\n          const src = inModeByValidity(opts);\n\n          return control => control.aspect(InMode).derive(src);\n        },\n    );\n    this._byForm = FormScope.createSetup(\n        options.byForm,\n        control => control.aspect(InParents).read.do(\n            consumeEvents(parents => {\n\n              const supply = new Supply();\n\n              itsEach(\n                  parents,\n                  ({ parent }) => {\n\n                    const form = parent.aspect(Form);\n\n                    if (form) {\n                      control.aspect(InMode).derive(form.element.aspect(InMode)).as(supply);\n                    }\n                  },\n              );\n\n              return supply;\n            }),\n        ),\n    );\n  }\n\n  setupField<TValue, TSharer extends object>(\n      builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    builder.control.setup(this._byForm);\n  }\n\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    builder.control.setup(this._byValidity);\n  }\n\n}\n\nexport namespace FormModePreset {\n\n  /**\n   * Form mode preset options.\n   */\n  export interface Options {\n\n    /**\n     * Whether to build a form mode by its validity options.\n     *\n     * `false` to disable.\n     */\n    readonly byValidity?: ScopedFormConfig<Parameters<typeof inModeByValidity>[0]>;\n\n    /**\n     * Whether form field mode should be derived from form element's one.\n     *\n     * `true` by default. `false` to disable.\n     */\n    readonly byForm?: FormScope;\n\n  }\n\n}\n","import { handleDomEvents } from '@frontmeans/dom-events';\nimport { consumeEvents } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentClass, ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '@wesib/wesib';\nimport { shareLocator, ShareLocator } from '../shares';\nimport { Form } from './form';\nimport { FormShare } from './form.share';\n\n/**\n * Creates a decorator for component method to call on input form submit.\n *\n * The decorated method accepts a {@link Form.Body body of the form} about to be submitted, and a submit event as\n * parameters.\n *\n * @typeParam TModel - Submitted model type.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Submit handler definition.\n *\n * @returns New component property decorator.\n */\nexport function OnSubmit<TModel = any, TElt extends HTMLElement = HTMLElement, T extends ComponentClass = Class>(\n    def: OnSubmitDef<TModel, TElt> = {},\n): ComponentPropertyDecorator<(form: Form.Body<TModel, TElt, InstanceType<T>>, event: Event) => void, T> {\n\n  const { form: formRef = FormShare, cancel = true } = def;\n  const locateForm = shareLocator(formRef, { share: FormShare, local: 'too' });\n\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenConnected(() => {\n\n            const { component } = context;\n\n            locateForm(context).do(\n                consumeEvents((form?: Form<TModel, TElt>, _sharer?: ComponentContext) => {\n\n                  const controls = form?.body;\n\n                  if (!controls) {\n                    return;\n                  }\n\n                  let onSubmit = controls.element.events.on('submit');\n\n                  if (cancel) {\n                    onSubmit = onSubmit.do(\n                        handleDomEvents(false),\n                    );\n                  }\n\n                  return onSubmit(\n                      event => get(component).call(component, controls, event),\n                  );\n                }),\n            ).needs(context);\n          });\n        });\n      },\n    },\n  }));\n}\n\n/**\n * Form submit handler definition.\n *\n * Configures {@link OnSubmit @OnSubmit} component property decorator.\n */\nexport interface OnSubmitDef<TModel = any, TElt extends HTMLElement = HTMLElement> {\n\n  /**\n   * A form to submit.\n   *\n   * This is a shared form locator. Includes the decorated component into the search (`{ local: 'too' }`) by default.\n   *\n   * A {@link FieldShare default} form share is used when omitted.\n   */\n  readonly form?: ShareLocator<Form<TModel, TElt>>;\n\n  /**\n   * Whether to cancel default submit handler.\n   *\n   * `true` by default.\n   */\n  readonly cancel?: boolean;\n\n}\n","import { Class } from '@proc7ts/primitives';\nimport { ComponentClass } from '@wesib/wesib';\nimport { Shared, ShareDecorator, ShareLocator, TargetShare } from '../shares';\nimport { FormUnit } from './form-unit';\n\n/**\n * Builds a decorator of component property that shares a form unit.\n *\n * @typeParam TUnit - Unit type.\n * @typeParam TValue - Unit value type.\n * @typeParam TControls - Unit controls type.\n * @typeParam TClass - A type of decorated component class.\n * @param share - Target unit share.\n * @param define - Unit property definition builders.\n *\n * @return Component property decorator.\n */\nexport function SharedFormUnit<\n    TUnit extends FormUnit<TValue, TControls>,\n    TValue = FormUnit.ValueType<TUnit>,\n    TControls extends FormUnit.Controls<TValue> = FormUnit.ControlsType<TUnit>,\n    TClass extends ComponentClass = Class>(\n    share: TargetShare<TUnit>,\n    ...define: SharedFormUnit.Definer<TUnit, TValue, TControls, TClass>[]\n): ShareDecorator<TUnit, TClass> {\n  return Shared(share, ...define);\n}\n\nexport namespace SharedFormUnit {\n\n  /**\n   * A descriptor of the component property that shares a form unit.\n   *\n   * Passed to {@link Definer property definer} by {@link SharedFormUnit @SharedFormUnit} decorator to build a\n   * {@link Definition property definition}.\n   *\n   * @typeParam TValue - Unit value type.\n   * @typeParam TControls - Unit controls type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export interface Descriptor<\n      TUnit extends FormUnit<TValue, TControls>,\n      TValue = FormUnit.ValueType<TUnit>,\n      TControls extends FormUnit.Controls<TValue> = FormUnit.ControlsType<TUnit>,\n      TClass extends ComponentClass = Class>\n      extends Shared.Descriptor<TUnit, TClass> {\n\n    /**\n     * Predefined locator function of the form unit to add the share unit to, or `undefined` when unknown.\n     */\n    readonly locateForm?: ShareLocator.Fn<FormUnit<any>>;\n\n    /**\n     * Predefined unit name, or `null`/`undefined` when the unit is not to be added to the {@link locateForm form}.\n     */\n    readonly name?: string | null;\n\n  }\n\n  /**\n   * A signature of definition builder of the component property that shares a form unit.\n   *\n   * This is a function called by {@link SharedFormUnit @SharedFormUnit} decorator to apply additional definitions.\n   *\n   * @typeParam TUnit - Unit type.\n   * @typeParam TValue - Unit value type.\n   * @typeParam TControls - Unit controls type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export type Definer<\n      TUnit extends FormUnit<TValue, TControls>,\n      TValue = FormUnit.ValueType<TUnit>,\n      TControls extends FormUnit.Controls<TValue> = FormUnit.ControlsType<TUnit>,\n      TClass extends ComponentClass = Class> =\n  /**\n   * @param descriptor - Decorated component property descriptor.\n   *\n   * @returns Component property definition, or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<TUnit, TValue, TControls, TClass>,\n      ) => Definition<TUnit, TValue, TControls, TClass> | void;\n\n  /**\n   * A definition of component property that shares a form unit.\n   *\n   * @typeParam TUnit - Unit type.\n   * @typeParam TValue - Unit value type.\n   * @typeParam TControls - Unit controls type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export type Definition<\n      TUnit extends FormUnit<TValue, TControls>,\n      TValue = FormUnit.ValueType<TUnit>,\n      TControls extends FormUnit.Controls<TValue> = FormUnit.ControlsType<TUnit>,\n      TClass extends ComponentClass = Class> =\n      Shared.Definition<TUnit, TClass>;\n\n}\n","import { Class } from '@proc7ts/primitives';\nimport { ComponentClass } from '@wesib/wesib';\nimport { Share, Shared, ShareDecorator, ShareLocator, shareLocator, ShareRef, TargetShare } from '../shares';\nimport { Field } from './field';\nimport { FieldName } from './field-name.definer';\nimport { Field$name } from './field.impl';\nimport { FieldShare } from './field.share';\nimport { FormUnit } from './form-unit';\nimport { FormShare } from './form.share';\nimport { SharedFormUnit } from './shared-form-unit.decorator';\n\n/**\n * Builds a decorator of component property that {@link FieldShare shares} a form field.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Field definition.\n * @param define - Field property definition builders.\n *\n * @return Component property decorator.\n */\nexport function SharedField<\n    TField extends Field<TValue>,\n    TValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class>(\n    def?: SharedFieldDef<TField, TValue>,\n    ...define: SharedField.Definer<TField, TValue, TClass>[]\n): ShareDecorator<TField, TClass>;\n\n/**\n * Builds a decorator of component property that {@link FieldShare shares} a form field and adds it to the\n * {@link FormShare default form} under decorated property name.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n * @typeParam TClass - A type of decorated component class.\n * @param define - Field property definition builders.\n *\n * @return Component property decorator.\n */\nexport function SharedField<\n    TField extends Field<TValue>,\n    TValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class>(\n    ...define: SharedField.Definer<TField, TValue, TClass>[]\n): ShareDecorator<TField, TClass>;\n\nexport function SharedField<\n    TField extends Field<TValue>,\n    TValue,\n    TClass extends ComponentClass>(\n    defOrDefiner:\n        | SharedFieldDef<TField, TValue>\n        | SharedField.Definer<TField, TValue, TClass> = {},\n    ...define: SharedField.Definer<TField, TValue, TClass>[]\n): ShareDecorator<TField, TClass> {\n\n  let def: SharedFieldDef<TField, TValue>;\n  let fieldName: string | undefined;\n  let definers: SharedField.Definer<TField, TValue, TClass>[];\n\n  if (typeof defOrDefiner === 'function') {\n    def = {};\n    definers = [FieldName(), defOrDefiner, ...define];\n  } else {\n    def = defOrDefiner;\n    fieldName = defOrDefiner.name;\n    definers = [FieldName({ name: fieldName }), ...define];\n  }\n\n  const {\n    share = FieldShare as ShareRef<any> as ShareRef<TField>,\n    form: formLocator,\n  } = def;\n  const locateForm = shareLocator(formLocator, { share: FormShare });\n\n  return SharedFormUnit<TField, TValue, Field.Controls<TValue>, TClass>(\n      share,\n      ...definers.map(definer => (\n          descriptor: Shared.Descriptor<TField, TClass>,\n      ) => definer({\n        ...descriptor,\n        locateForm,\n        name: Field$name(descriptor.key, fieldName),\n      })),\n  );\n}\n\n/**\n * Shared form field definition.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n */\nexport interface SharedFieldDef<TField extends Field<TValue>, TValue = Field.ValueType<TField>> {\n\n  /**\n   * Target field share.\n   */\n  readonly share?: TargetShare<TField>;\n\n  /**\n   * A locator of form unit to add the shared field to.\n   *\n   * The {@link FormShare default form share} is used when omitted.\n   */\n  readonly form?: ShareLocator<FormUnit<unknown>>;\n\n  /**\n   * Field name.\n   *\n   * The shared field will be added to the input control group (`InGroup`) within the {@link form target form},\n   * unless the name is empty string.\n   *\n   * Equals to decorated property name when omitted.\n   */\n  readonly name?: string;\n\n}\n\nexport namespace SharedField {\n\n  /**\n   * A descriptor of the component property that {@link FieldShare shares} a form field.\n   *\n   * Passed to {@link Definer property definer} by {@link SharedField @SharedField} decorator to build a\n   * {@link Definition property definition}.\n   *\n   * @typeParam TField - Field type.\n   * @typeParam TValue - Field value type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export interface Descriptor<\n      TField extends Field<TValue>,\n      TValue = Field.ValueType<TField>,\n      TClass extends ComponentClass = Class>\n      extends SharedFormUnit.Descriptor<TField, TValue, Field.Controls<TValue>, TClass> {\n\n    /**\n     * Target field share instance.\n     */\n    readonly share: Share<TField>;\n\n    /**\n     * Predefined locator function of the form unit to add the shared field to.\n     */\n    readonly locateForm: ShareLocator.Fn<FormUnit<any>>;\n\n    /**\n     * Predefined field name, or `null`/`undefined` when the field is not to be added to the {@link locateForm form}.\n     */\n    readonly name: string | null;\n\n  }\n\n  /**\n   * A signature of definition builder of the component property that {@link FieldShare shares} a form field.\n   *\n   * This is a function called by {@link SharedField @SharedField} decorator to apply additional definitions.\n   *\n   * @typeParam TField - Field type.\n   * @typeParam TValue - Field value type.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export type Definer<\n      TField extends Field<TValue>,\n      TValue = Field.ValueType<TField>,\n      TClass extends ComponentClass = Class> =\n  /**\n   * @param descriptor - Decorated component property descriptor.\n   *\n   * @returns Component property definition, or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<TField, TValue, TClass>,\n      ) => Definition<TField, TValue, TClass> | void;\n\n  /**\n   * A definition of component property that {@link FieldShare shares} a form field.\n   *\n   * @typeParam TField - Field type.\n   * @typeParam TValue - Field value type.\n   * @typeParam TClass - A type of component class.\n   */\n  export type Definition<\n      TField extends Field<TValue>,\n      TValue = Field.ValueType<TField>,\n      TClass extends ComponentClass = Class> =\n      SharedFormUnit.Definition<TField, TValue, Field.Controls<TValue>, TClass>;\n\n}\n","import { Class } from '@proc7ts/primitives';\nimport { ComponentClass } from '@wesib/wesib';\nimport { Share, ShareDecorator, ShareRef, TargetShare } from '../shares';\nimport { Form } from './form';\nimport { FormShare } from './form.share';\nimport { SharedFormUnit } from './shared-form-unit.decorator';\n\n/**\n * Builds a decorator of component property that {@link FormShare shares} a form.\n *\n * @typeParam TForm - Form type.\n * @typeParam TModel - Form model type.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Form definition.\n * @param define - Form property definition builders.\n *\n * @returns Component property decorator.\n */\nexport function SharedForm<\n    TForm extends Form<TModel, TElt>,\n    TModel = Form.ModelType<TForm>,\n    TElt extends HTMLElement = Form.ElementType<TForm>,\n    TClass extends ComponentClass = Class>(\n    def?: SharedFormDef<TForm, TModel, TElt>,\n    ...define: SharedForm.Definer<TForm, TModel, TElt, TClass>[]\n): ShareDecorator<TForm, TClass>;\n\n/**\n * Builds a decorator of component property that {@link FormShare shares} a form as default share.\n *\n * @typeParam TForm - Form type.\n * @typeParam TModel - Form model type.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TClass - A type of decorated component class.\n * @param define - Form property definition builders.\n *\n * @returns Component property decorator.\n */\nexport function SharedForm<\n    TForm extends Form<TModel, TElt>,\n    TModel = Form.ModelType<TForm>,\n    TElt extends HTMLElement = Form.ElementType<TForm>,\n    TClass extends ComponentClass = Class>(\n    ...define: SharedForm.Definer<TForm, TModel, TElt, TClass>[]\n): ShareDecorator<TForm, TClass>;\n\nexport function SharedForm<\n    TForm extends Form<TModel, TElt>,\n    TModel = Form.ModelType<TForm>,\n    TElt extends HTMLElement = Form.ElementType<TForm>,\n    TClass extends ComponentClass = Class>(\n    defOrDefiner:\n        | SharedFormDef<TForm, TModel, TElt>\n        | SharedForm.Definer<TForm, TModel, TElt, TClass> = {},\n    ...define: SharedForm.Definer<TForm, TModel, TElt, TClass>[]\n): ShareDecorator<TForm, TClass> {\n  if (typeof defOrDefiner === 'function') {\n    return SharedFormUnit<TForm, TModel, Form.Body<TModel, TElt>, TClass>(\n        FormShare as ShareRef<any> as ShareRef<TForm>,\n        defOrDefiner,\n        ...define,\n    );\n  }\n\n  const { share = FormShare as ShareRef<any> as ShareRef<TForm> } = defOrDefiner;\n\n  return SharedFormUnit<TForm, TModel, Form.Body<TModel, TElt>, TClass>(share, ...define);\n}\n\n/**\n * Shared form definition.\n *\n * @typeParam TForm - Form type.\n * @typeParam TModel - A model type of the form.\n * @typeParam TElt - A type of HTML form element.\n */\nexport interface SharedFormDef<\n    TForm extends Form<TModel, TElt>,\n    TModel = Form.ModelType<TForm>,\n    TElt extends HTMLElement = Form.ElementType<TForm>> {\n\n  /**\n   * Target form share.\n   */\n  readonly share?: TargetShare<TForm>;\n\n}\n\nexport namespace SharedForm {\n\n  /**\n   * A descriptor of the component property that {@link FormShare shares} a form.\n   *\n   * Passed to {@link Definer property definer} by {@link SharedForm @SharedForm} decorator to build a\n   * {@link Definition property definition}.\n   *\n   * @typeParam TForm - Form type.\n   * @typeParam TModel - A model type of the form.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export interface Descriptor<\n      TForm extends Form<TModel, TElt>,\n      TModel = Form.ModelType<TForm>,\n      TElt extends HTMLElement = Form.ElementType<TForm>,\n      TClass extends ComponentClass = Class>\n      extends SharedFormUnit.Descriptor<TForm, TModel, Form.Body<TModel, TElt>, TClass> {\n\n    /**\n     * Target form share instance.\n     */\n    readonly share: Share<TForm>;\n\n  }\n\n  /**\n   * A signature of definition builder of the component property that {@link FormShare shares} a form.\n   *\n   * This is a function called by {@link SharedForm @SharedForm} decorator to apply additional definitions.\n   *\n   * @typeParam TForm - Form type.\n   * @typeParam TModel - A model type of the form.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export type Definer<\n      TForm extends Form<TModel, TElt>,\n      TModel = Form.ModelType<TForm>,\n      TElt extends HTMLElement = Form.ElementType<TForm>,\n      TClass extends ComponentClass = Class> =\n  /**\n   * @param descriptor - Decorated component property descriptor.\n   *\n   * @returns Component property definition, or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<TForm, TModel, TElt, TClass>,\n      ) => Definition<TForm, TModel, TElt, TClass> | void;\n\n  /**\n   * A definition of component property that {@link FormShare shares} a form.\n   *\n   * @typeParam TForm - Form type.\n   * @typeParam TModel - A model type of the form.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TClass - A type of decorated component class.\n   */\n  export type Definition<\n      TForm extends Form<TModel, TElt>,\n      TModel = Form.ModelType<TForm>,\n      TElt extends HTMLElement = Form.ElementType<TForm>,\n      TClass extends ComponentClass = Class> =\n      SharedFormUnit.Definition<TForm, TModel, Form.Body<TModel, TElt>, TClass>;\n\n}\n"],"names":["FetchAgentKey","ContextUpKey","[object Object]","name","super","this","upKey","createUpKey","slot","insert","seed","do","digAfter","agents","length","afterThe","next","request","fetch","agentIdx","agentRequest","agent","onSupplied","nextRequest","combineFetchAgents","hasFallback","or","defaultFetchAgent","delegated","context","get","undefined","whenOff","reason","contextDestroyed","HttpFetchAgent","HttpFetchAborted","HttpFetch","FnContextKey","byDefault","bootstrapDefault","window","BootstrapWindow","input","init","Request","onEventBy","receiver","responseEmitter","EventEmitter","supply","abortController","AbortController","signal","Supply","abort","off","needs","on","ctx","response","receive","customSignal","DomEventDispatcher","onceOn","aborted","then","send","catch","ElementNodeList","OnEvent__symbol","onUpdate","AfterEvent__symbol","read","WATCH_DEEP","subtree","elementNodeList","bsContext","root","selectorOrType","nodeOf","deep","all","updates","selector","cache","Set","overNodes","overNodeSubtree","overArray","whenDefined","elementDef","html__naming","DefaultNamespaceAliaser","size","selected","refresh","added","itsElements","filterIt","mapIt","node","isPresent","console","error","addEventListener","event","element","target","has","iterable","overIterator","iteratorOf","ElementNodeList$","observer","ElementObserver","update","firstReceiver","observe","disconnect","clear","returnSelf","valueProvider","mapAfter","track","afterEventBy","initialEmitter","first","afterSupplied","translateAfter","list","itsFirst","Symbol","iterator","PushIterator__symbol","accept","sel","querySelectorAll","filterArray","children","item","matches","select","mutations","removed","forEach","mutation","itsEach","removedNodes","removeNode","push","addedNodes","addNode","isElement","add","delete","nodes","flatMapArray","childNodes","AttributesObserver","_bs","Map","_observer","Observer","MutationObserver","_update","self","emitter","_emitter","rcv","eventReceiver","_emitters","reconnect","newValue","oldValue","takeRecords","attributes","attributeOldValue","attributeFilter","keys","attributeName","getAttribute","set","AttributeTracker","ValueTracker","_name","observeSupply","neverSupply","_updates","it","value","setAttribute","removeAttribute","NodeAttributes","bs","existing","_attrs","created","PropertyTracker","_element","key","_key","ComponentState","domPropertyPathTo","_ctx","_path","NodeProperties","_context","_props","prop","bind","ElementNode__symbol","ElementNode$","_bind","ComponentSlot__symbol","parent","parentNode","elementNodeOf","mode","optional","adapter","ElementAdapter","selectNodes","ComponentNode","SingleContextKey","BootstrapContext","ComponentContext","getHashURL","url","URL","hash","substring","origin","setHashURL","hashURL","username","pathname","search","result","PageParam__symbol","PageParam","_page","PageHashURLValueParam$","page","handle","put","PageHashURLValueParam","PageHashURLParam$","create","PageHashURLParam","NavigationAgentKey","document","when","from","to","navigate","agentTo","nextURL","title","nextTitle","data","nextData","String","baseURI","visited","current","ref","defaultNavigationAgent","_when","_from","NavigationAgent","PageHashURLSupport__feature","setup","provide","a","is","pageHashURLAgent","PageHashURLSupport","FeatureDef__symbol","PageParamContext","ContextValues","NavHistory__key","NavHistory","extractNavData","state","_document","_location","location","_history","history","_uid","btoa","Math","random","ContextKey__symbol","entry","newEntry","href","_entries","id","schedule","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","tracker","pushState","_enter","fromEntry","e","_forget","prev","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_bsContext","proto","noop","_params","_status","param","newHandle","_newContext","_init","registry","ContextRegistry","newValues","entries","transferred","at","values","stay","EnterPageEvent","Event","type","cancelable","LeavePageEvent","StayOnPageEvent","Navigation__key","dispatcher","navHistory","nav","trackValue","nextEntry","apply","Promise","resolve","dispatch","hashChange","Navigation","onEnter","onLeave","onStay","onAny","delta","go","toURL","withParam","applyParams","with","mergeFunctions","open","replace","targetOrCallback","callback","navTarget","navTargetOf","applyAgent","whenLeave","promise","doNavigate","prepared","leavePage","prepare","navigated","ActivateNavLink","def","pick","Component","defContext","whenComponent","activate","scheduler","ElementRenderScheduler","render","active","defaultActiveNavLinkClass","activeClass","css__naming","assignClass","classList","remove","opts","NavLinkRenderSchedule__symbol","makeActive","lastSupply","activateNavLink","weigh","defaultNavLinkWeight","weight","supplier","translateAfter_","navLinkWeight","navigation","componentNode","whenConnected","supplyAfter","consumeEvents","digAfter_","afterEach","weights","maxWeight","selectActiveNavLinks","newActive","activeLink","linkURL","ownerDocument","calcNavLinkWeight","pageURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight","navLinkSearchParamsWeight","startsWith","path","endsWith","searchParams","linkParams","pageParams","isIgnoredSearchParam","getAll","includes","Wesib__NS","HandleNavLinks","getHref","defaultNavLinkHref","preventDefault","defaultHandleNavLinks","events","setOfElements","eventType","onceAfter","importNode","beforeOrImport","importContent","importNodeContent","before","doc","elementClone","createElement","tagName","toLowerCase","getAttributeNames","attr","insertBefore","nodeClone","cachingPageLoader","loader","pageUrl","sup","tracked","onLoad","trackSupply","resp","cuts","valueOn_","asis","num","requested","supplyOn","PageLoadAbortError","Error","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","_loader","_requests","flatMapIt","_map","fragments","itsEvery","fragment","pageSupply","loadSupply","_add","_transfer","responseReceiver","ok","shareOn","mapOn_","tag","getElementsByTagName","getElementById","onFragment","req","slice","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","reduce","header","hthvQuote","requestPageFragments","EventNotifier","text","resolveOnOrdered","digOn_","batch","status","parsePageDocument","parseFromString","hthvParse","v","head","base","querySelector","newBase","appendChild","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","rev","appRev","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","src","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","style","removeChild","pageTitleAgent","textContent","PageLoadSupport__feature","by","buster","PageLoadSupport","IncludePage","onResponse","contentKey","defaultPageContentKey","feature","detectFragment","lastPageURL","range","createRange","selectNodeContents","contentRoot","newPageURL","deleteContents","createDocumentFragment","insertNode","handleResponse","Share__symbol","isShareRef","ShareRegistry__key","ShareRegistry","nsAlias","share","componentType","elementName","sharers","_sharers","Sharers$addSharer","Sharers$addName","Sharers$new","names","counter","ShareKey","_share","selectValue","Share$impl__symbol","Share$","options","_aliases","arrayOfElements","as","map","alias","local","addSharer","registrar","shareAs","priorityOffset","priority","index","shareValue","withPriority","SharedValue__symbol","SharedValue","hasDetails","SharedValue$Registrar","provider","SharedValue$BoundRegistrar","max","isAfterEvent","applyContextAfter","applyContextTo","SharedValue$bindProvider","newPriority","SharedValue$detailedProvider","SharedValue$bareProvider","Share","consumer","readStatus","deduplicateAfter_","b","Share$consumerStatus","afterAll","Share$sharedValue","parentElement","ComponentSlot","of","sharer","deduplicateAfter","i","details","sendEventsTo","shareAfter","settled","connected","shareLocator","locator","defaultSpec","valueFor","localByDefault","shareByDefault","shareRef","Shareable$Internals__symbol","Shareable","body","Shareable$Internals","valueRecipe","afterValue","Contextual__symbol","_source","_get","_notBound","trackValueBy","TypeError","ShareAccessor","desc","component","_set","writable","dynSync","val","isContextual","_syncDyn","_syncVal","_valSupply","Shared","define","shr","ComponentProperty","descriptor","accessorKey","accessor","componentDef","perComponent","ContextBuilder__symbol","createRegistrar","SharedValue$ContextBuilder","onceReady","valuesProvider","DefaultFormPreset","control","DefaultFormPreset$setup","builder","nsAliaser","renderScheduler","addAspect","InNamespaceAliaser","applyAspect","_aspect","knownInAspect","InRenderScheduler","FormPresetKey","FormPreset","specs","combine","ContextSupply","FormPreset__key","FormPreset$rules__symbol","rules","setupField","FormPreset$setupField","setupForm","FormPreset$setupForm","spec","FormPreset$noFieldSetup","_builder","FormPreset$noFormSetup","FormUnit","controls","Field","factory","providerBy","build","field","preset","InBuilder","Field$isDuplicateControls","prior","FieldShare$map","WeakMap","FieldShare","instance","FormShare$map","FormShare","adjacentField","adjacentTo","adjacentLocator","_sharer","adjusted","adjacentToField","adjacentToForm","Field$nameByKey","FieldName","locateForm","defaultForm","defaultName","fieldName","autoName","form","unit","group","aspect","InGroup","FormUnitName","Form__aspect","applyTo","_control","nullInAspect","Form","inFormElement","elementFactory","lazyValue","InAspect__symbol","formAspect","inconvertibleInAspect","Form$isDuplicateControls","Form$provider","duplicate","FormScope","scope","defaultRole","roles","InRole","role","AbstractFormPreset$map","AbstractFormPreset","found","featureDef","ScopedFormConfig","config","createSetup","Array","isArray","rest","ScopedFormConfig$isOptions","FormCssPreset","_info","info","inCssInfo","InCssClasses","_error","inCssError","css","FormModePreset","_byValidity","byValidity","inModeByValidity","InMode","derive","_byForm","byForm","InParents","parents","OnSubmit","formRef","cancel","onSubmit","handleDomEvents","call","SharedFormUnit","SharedField","defOrDefiner","definers","formLocator","definer","SharedForm"],"mappings":"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"}