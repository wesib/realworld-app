{"version":3,"file":"wesib.5a50f1b5.js","sources":["../../../../wesib/src/boot/bootstrap-context.key.impl.ts","../../../../wesib/src/boot/bootstrap-context.ts","../../../../wesib/src/boot/bootstrap-default.ts","../../../../wesib/src/common/types.impl.ts","../../../../wesib/src/common/array-set.ts","../../../../wesib/src/common/classes.ts","../../../../wesib/src/common/decorators.ts","../../../../wesib/src/common/reflect.ts","../../../../wesib/src/common/functions.ts","../../../../wesib/src/common/is-element.ts","../../../../wesib/src/common/meta-accessor.ts","../../../../wesib/src/common/promises.ts","../../../../wesib/src/feature/feature-def.ts","../../../../wesib/src/feature/feature.decorator.ts","../../../../wesib/src/feature/feature-context.ts","../../../../wesib/src/feature/feature-needs-error.ts","../../../../wesib/src/feature/feature-ref.ts","../../../../wesib/src/component/component-def.ts","../../../../wesib/src/component/component.decorator.ts","../../../../wesib/src/component/component-context.key.impl.ts","../../../../wesib/src/component/component-event.key.impl.ts","../../../../wesib/src/component/content-root.ts","../../../../wesib/src/component/state-updater.ts","../../../../wesib/src/component/component-context.ts","../../../../wesib/src/component/component-event.ts","../../../../wesib/src/component/component-property.decorator.ts","../../../../wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../../../wesib/src/boot/impl/component-context-registry.impl.ts","../../../../wesib/src/boot/impl/definition-context-registry.impl.ts","../../../../wesib/src/boot/impl/post-def-setup.impl.ts","../../../../wesib/src/boot/globals/bootstrap-window.ts","../../../../wesib/src/boot/globals/bootstrap-root.ts","../../../../wesib/src/boot/globals/default-namespace-aliaser.ts","../../../../wesib/src/boot/globals/default-render-scheduler.ts","../../../../wesib/src/boot/globals/element-adapter.ts","../../../../wesib/src/boot/globals/element-observer.ts","../../../../wesib/src/boot/impl/definition-context.symbol.impl.ts","../../../../wesib/src/component/definition/custom-elements.ts","../../../../wesib/src/component/definition/definition.context.key.impl.ts","../../../../wesib/src/component/definition/element-def.ts","../../../../wesib/src/component/definition/definition-context.ts","../../../../wesib/src/boot/impl/component-context.impl.ts","../../../../wesib/src/boot/impl/component-mount.impl.ts","../../../../wesib/src/component/component-mount.ts","../../../../wesib/src/boot/impl/custom-element.impl.ts","../../../../wesib/src/boot/impl/when-component.impl.ts","../../../../wesib/src/boot/impl/definition-context.impl.ts","../../../../wesib/src/boot/impl/element-builder.impl.ts","../../../../wesib/src/boot/impl/unloader.impl.ts","../../../../wesib/src/feature/loader/component-registry.impl.ts","../../../../wesib/src/feature/loader/feature-context.impl.ts","../../../../wesib/src/feature/loader/feature-loader.impl.ts","../../../../wesib/src/feature/loader/feature-request.impl.ts","../../../../wesib/src/feature/loader/feature-requester.impl.ts","../../../../wesib/src/boot/impl/when-defined.impl.ts","../../../../wesib/src/boot/bootstrap/bootstrap-components.ts","../../../../wesib/src/feature/attributes/attribute-path.ts","../../../../wesib/src/feature/attributes/attribute-state-update.impl.ts","../../../../wesib/src/feature/attributes/property2attribute-name.ts","../../../../wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../../../wesib/src/feature/attributes/attribute-registry.ts","../../../../wesib/src/feature/attributes/attribute.decorator.ts","../../../../wesib/src/feature/attributes/attribute-changed.decorator.ts","../../../../wesib/src/feature/attributes/attributes.decorator.ts","../../../../wesib/src/feature/state/component-state.ts","../../../../wesib/src/feature/state/state-property-path.ts","../../../../wesib/src/feature/state/state-property-update.impl.ts","../../../../wesib/src/feature/state/state-property.decorator.ts","../../../../wesib/src/feature/attributes/track-attribute.ts","../../../../wesib/src/feature/dom-properties/dom-property-registry.ts","../../../../wesib/src/feature/dom-properties/dom-property-path.ts","../../../../wesib/src/feature/dom-properties/dom-property-update.impl.ts","../../../../wesib/src/feature/dom-properties/dom-property.decorator.ts","../../../../wesib/src/feature/dom-properties/dom-property-descriptor.impl.ts","../../../../wesib/src/feature/render/render-def.ts","../../../../wesib/src/feature/render/element-render-ctl.impl.ts","../../../../wesib/src/feature/render/element-render-ctl.ts","../../../../wesib/src/feature/render/element-render-scheduler.ts","../../../../wesib/src/feature/render/render.decorator.ts","../../../../wesib/src/feature/shadow-dom/shadow-content-root.ts","../../../../wesib/src/feature/shadow-dom/shadow-dom-event.ts","../../../../wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../../../wesib/src/feature/shadow-dom/attach-shadow.decorator.ts","../../../../wesib/src/wesib.ns.ts"],"sourcesContent":["import { SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '../common';\nimport { ComponentClass, DefinitionContext } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to [[FeatureDef.Options.init]] method so that the feature can configure itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of ready bootstrap context.\n   */\n  abstract whenReady(): OnEvent<[BootstrapContext]>;\n\n  /**\n   * Registers a `receiver` of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of reay bootstrap context.\n   *\n   * @returns Bootstrap readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[BootstrapContext]>): EventSupply;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentType  Component class constructor.\n   *\n   * @return An `OnEvent` sender of definition context sent when the given `componentType` is registered.\n   */\n  abstract whenDefined<C extends object>(componentType: ComponentClass<C>): OnEvent<[DefinitionContext<C>]>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature  The feature to load.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class): FeatureRef;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @param provide  A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<Value, Key extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: Key) => Value | null | undefined,\n): ContextKeyDefault<Value, Key> {\n  return (context, key) => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext ? provide(bootstrapContext, key) : bootstrapContext.get(key);\n  };\n}\n","/**\n * @internal\n */\nexport function isArray<T>(value: T | T[] | null | undefined): value is T[];\n\n/**\n * @internal\n */\nexport function isArray<T>(value: T | readonly T[] | null | undefined): value is readonly T[];\n\nexport function isArray<T>(value: T | readonly T[]): value is T[] {\n  return Array.isArray(value);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsEach, itsFirst } from '@proc7ts/a-iterable';\nimport { isArray } from './types.impl';\n\n/**\n * @category Utility\n */\nexport class ArraySet<T> implements Iterable<T> {\n\n  readonly items: Set<T>;\n\n  constructor(value?: T | readonly T[]) {\n    this.items = value == null ? new Set() : isArray(value) ? new Set(value) : new Set([value]);\n  }\n\n  get value(): T | T[] | undefined {\n    return this.items.size < 2 ? itsFirst(this.items) : Array.from(this.items);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.items[Symbol.iterator]();\n  }\n\n  add(...items: readonly T[]): this {\n    return this.addAll(items);\n  }\n\n  addAll(items: Iterable<T>): this {\n    itsEach(items, item => this.items.add(item));\n    return this;\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  merge(items: readonly T[] | T | undefined): this {\n    if (isArray(items)) {\n      this.addAll(items);\n    } else if (items != null) {\n      this.items.add(items);\n    }\n    return this;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Arbitrary class constructor.\n *\n * @category Utility\n * @typeparam T  A type of object.\n */\nexport interface Class<T extends object = any> extends Function {\n  new(...args: any[]): T;\n  prototype: T;\n}\n\n/**\n * Detects super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @category Utility\n * @param type  The class constructor to find super class of.\n * @param satisfying  The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  const prototype = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from './classes';\nimport { fieldAccessorDescriptor, PropertyAccessorDescriptor, toPropertyAccessorDescriptor } from './reflect';\n\n/**\n * Typed class decorator.\n *\n * @category Utility\n * @typeparam T  A type of class to decorate.\n */\nexport type TypedClassDecorator<T extends Class> = (type: T) => T | void;\n\n/**\n * Typed property decorator.\n *\n * @category Utility\n * @typeparam T  A type of class the decorated property belongs to.\n */\nexport type TypedPropertyDecorator<T extends Class> =\n    <V>(target: InstanceType<T>, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<V>) => any | void;\n\n/**\n * Property decorator helper converting a field or property to the one with accessor (`get` and optionally `set`).\n *\n * @category Utility\n * @typeparam T  A type of target object.\n * @typeparam V  A property value type.\n * @param target  Target object containing the property.\n * @param propertyKey  Target property key.\n * @param desc  Target property descriptor, or `undefined` for object fields.\n * @param updateDescriptor  Descriptor updater. Accepts the accessor descriptor as the only argument. If returns\n * a descriptor, then it is applied to the property. Otherwise the target property descriptor is never updated.\n *\n * @returns Updated property descriptor to return from decorator to apply to the property, or `undefined` if there is\n * nothing to update.\n */\nexport function decoratePropertyAccessor<T, V>(\n    target: T,\n    propertyKey: string | symbol,\n    desc: TypedPropertyDescriptor<V> | undefined,\n    updateDescriptor: (desc: PropertyAccessorDescriptor<V>) => PropertyAccessorDescriptor<V>,\n): PropertyAccessorDescriptor<V> | undefined {\n\n  const isField = !desc;\n  const accessorDesc: PropertyAccessorDescriptor<V> = desc\n      ? toPropertyAccessorDescriptor(desc)\n      : fieldAccessorDescriptor(target, propertyKey as keyof T) as any;\n  const updatedDesc = updateDescriptor(accessorDesc);\n\n  if (isField && updatedDesc) {\n    Object.defineProperty(target, propertyKey, updatedDesc);\n    return;\n  }\n\n  return updatedDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts an object field to property accessor.\n *\n * Defines a new property with the given name in the target object and returns its descriptor.\n *\n * The converted descriptor is always configurable, enumerable, and writable.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n *\n * @return New property accessor descriptor.\n */\nexport function field2accessor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const desc = fieldAccessorDescriptor(target, fieldKey);\n\n  Object.defineProperty(target, fieldKey, desc);\n\n  return desc;\n}\n\n/**\n * Creates an property accessor descriptor for the given field.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n */\nexport function fieldAccessorDescriptor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const value__symbol = Symbol(`${String(fieldKey)}:value`);\n  const initial: T[K] = target[fieldKey];\n\n  return {\n    configurable: true,\n    enumerable: true,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n    set(this: any, newValue) {\n      this[value__symbol] = newValue;\n    },\n  };\n}\n\n/**\n * Property accessor descriptor. I.e. the one with `get` and `set` functions.\n *\n * @category Utility\n * @typeparam V  Property value type.\n */\nexport interface PropertyAccessorDescriptor<V> extends TypedPropertyDescriptor<V> {\n  enumerable?: boolean;\n  configurable?: boolean;\n  writable?: undefined;\n  value?: undefined;\n  get?: () => V;\n  set?: (value: V) => void;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nexport function isPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): desc is PropertyAccessorDescriptor<V> {\n  return desc.value === undefined && desc.writable === undefined;\n}\n\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nexport function toPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): PropertyAccessorDescriptor<V> {\n  if (isPropertyAccessorDescriptor(desc)) {\n    return desc;\n  }\n\n  const value__symbol = Symbol('value');\n  const initial = desc.value as V;\n\n  const accessorDesc: PropertyAccessorDescriptor<V> = {\n    ...desc,\n    writable: undefined,\n    value: undefined,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n  };\n\n  if (desc.writable) {\n    accessorDesc.set = function (this: any, newValue: V) {\n      this[value__symbol] = newValue;\n    };\n  }\n\n  delete accessorDesc.writable;\n  delete accessorDesc.value;\n\n  return accessorDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @category Utility\n * @typeparam P  Function parameter types as tuple.\n * @typeparam R  A type of function result.\n * @typeparam T  A type if `this` object expected by function.\n * @param first  The first function to call.\n * @param second  The second function to call.\n * @param merge  Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<P extends any[], R, T>(\n    first: (this: T, ...args: P) => R,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: (this: T, ...args: P) => R,\n    merge?: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge?: (first: R, second: R) => R,\n): ((this: T, ...args: P) => R) | undefined;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R = (_f, s) => s,\n): ((this: T, ...args: P) => R) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: T, ...args: P): R {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node  A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { flatMapIt, mapIt } from '@proc7ts/a-iterable';\nimport { Class, superClassOf } from './classes';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<M, S = M> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): M | undefined {\n    // eslint-disable-next-line no-prototype-builtins\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] : undefined;\n  }\n\n  of(type: Class): M | undefined {\n\n    const ownDef: M | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<C extends Class>(type: C, sources: Iterable<S>): C {\n\n    const prevMeta = this.own(type);\n    const updates = mapIt(sources, source => this.meta(source, type));\n    const newMeta: M = this.merge(prevMeta ? flatMapIt([[prevMeta], updates]) : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: Iterable<M>): M;\n\n  protected abstract meta(source: S, type: Class): M;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * @category Utility\n */\nexport class PromiseResolver<T = void> {\n\n  readonly promise: Promise<T>;\n  private _resolve!: (value: T) => void;\n  private _reject!: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  resolve(value: T): void {\n    this._resolve(value);\n  }\n\n  reject(error: any): void {\n    this._reject(error);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from '@proc7ts/a-iterable';\nimport { BootstrapSetup } from '../boot';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup  Bootstrap setup.\n     */\n    setup?(setup: BootstrapSetup): void;\n\n    /**\n     * Bootstraps this feature by calling the given bootstrap context constructed.\n     *\n     * @param context  Feature initialization context.\n     */\n    init?(context: FeatureContext): void;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType  A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: Iterable<FeatureDef.Options>): FeatureDef.Options {\n    return itsReduction<FeatureDef.Options, FeatureDef.Options>(\n        defs,\n        (prev, def) => ({\n          needs: new ArraySet(prev.needs).merge(def.needs).value,\n          has: new ArraySet(prev.has).merge(def.has).value,\n          setup: mergeFunctions<[BootstrapSetup], void, Class>(prev.setup, def.setup),\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType  Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType  Target feature class constructor.\n   * @param def  A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs  Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs  Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return itsReduction<FeatureDef, FeatureDef.Factory>(\n        defs,\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeparam T  Feature type.\n   * @param featureType  Feature class constructor.\n   * @param defs  Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(this: void, featureType: T, ...defs: readonly FeatureDef[]): T {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to [[bootstrapComponents]] function or referenced by other features.\n *\n * This is an alternative to direct call to [[FeatureDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated feature class.\n * @param defs  Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, ...defs);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext extends BootstrapContext implements BootstrapSetup {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  /**\n   * Builds an `OnEvent` sender of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of ready feature context.\n   */\n  abstract whenReady(): OnEvent<[FeatureContext]>;\n\n  /**\n   * Registers a receiver of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of ready feature context.\n   *\n   * @returns Feature readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[FeatureContext]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component definition events.\n   *\n   * The registered receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   *\n   * @returns `OnEvent` sender of component definition contexts.\n   */\n  abstract onDefinition(): OnEvent<[DefinitionContext]>;\n\n  /**\n   * Starts sending component definition events to the given `receiver`.\n   *\n   * The receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   *\n   * @param receiver  Target receiver of component definition contexts.\n   *\n   * @returns Component definition events supply.\n   */\n  abstract onDefinition(receiver: EventReceiver<[DefinitionContext]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component construction events.\n   *\n   * The registered receiver will be notified right before component is constructed.\n   *\n   * @returns `OnEvent` sender of constructed component contexts.\n   */\n  abstract onComponent(): OnEvent<[ComponentContext]>;\n\n  /**\n   * Starts sending component construction events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of constructed component contexts.\n   *\n   * @returns Component construction events supply.\n   */\n  abstract onComponent(receiver: EventReceiver<[ComponentContext]>): EventSupply;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a [[BootstrapSetup.provide]] method can be used.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<C extends object>(componentType: ComponentClass<C>): OnEvent<[DefinitionContext<C>]> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class): FeatureRef {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.Options.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.Options.has provides} another one.\n *\n * @category Core\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n *\n * @category Core\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs  Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: ' + needs.reduce(\n        (\n            prev,\n            [feature, reason, need],\n        ) => (prev ? prev : feature.name) + ` ${reason} ${need.name}`,\n        '',\n        ),\n    );\n    this.needs = needs;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventReceiver, EventSupply } from '@proc7ts/fun-events';\nimport { FeatureStatus } from './feature-status';\n\n/**\n * Dynamically loaded feature reference.\n *\n * It is returned from [[BootstrapContext.load]] and can be used to read feature load status and unload it.\n *\n * Implements an `EventKeeper` interface by sending a feature load status updates.\n *\n * @category Core\n */\nexport abstract class FeatureRef implements EventKeeper<[FeatureStatus]> {\n\n  /**\n   * A promise resolved when feature is unloaded.\n   *\n   * This happens after all feature references dismissed.\n   */\n  abstract readonly down: Promise<void>;\n\n  /**\n   * Builds an `AfterEvent` keeper of feature load status.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` sender of feature load status.\n   */\n  abstract read(): AfterEvent<[FeatureStatus]>;\n\n  /**\n   * Starts sending feature load status and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of feature load status.\n   *\n   * @returns Feature load status supply.\n   */\n  abstract read(receiver: EventReceiver<[FeatureStatus]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[FeatureStatus]> {\n    return this.read();\n  }\n\n  /**\n   * Dismisses feature reference.\n   *\n   * When all feature references dismissed, then unloads the feature. This removes everything set up by the\n   * feature via [[BootstrapSetup]] and [[DefinitionSetup]].\n   *\n   * @param reason  Arbitrary reason of feature reference dismiss. This will be reported by load status supplies\n   * as their cut off reason.\n   *\n   * @returns A promise resolved when feature is unloaded. This happens only after all feature references dismissed.\n   */\n  abstract dismiss(reason?: any): Promise<void>;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from '@proc7ts/a-iterable';\nimport { isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup  Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param defContext  Component definition context.\n     */\n    define?(defContext: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType  A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: Iterable<ComponentDef.Options<T>>): ComponentDef.Options<T> {\n    return itsReduction<ComponentDef.Options<T>, ComponentDef.Options<T>>(\n        defs,\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as any)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as any)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType  Target component class constructor.\n   * @param source  A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return itsReduction<ComponentDef<T>, ComponentDef.Factory<T>>(\n        defs,\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under [[ComponentDef__symbol]] key.\n   *\n   * Each component can be passed directly to [[bootstrapComponents]] function or added as a requirement\n   * of another feature.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   * @param defs  Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      this: void,\n      componentType: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by [[Component]] function.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n */\nexport type ComponentDecorator<T extends ComponentClass = Class> =\n    & ((this: void, type: T) => T | void)\n    & ComponentDef<InstanceType<T>>;\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with [[FeatureContext.define]] method or used as a feature, e.g. passed to\n * [[bootstrapComponents]] function, or added to [[FeatureDef.Options.needs]] property of another feature.\n *\n * This is an alternative to direct call to [[ComponentDef.Options.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n * @param defs  Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<T>>[]\n): ComponentDecorator<T> {\n\n  const decorator = ((type: T) => ComponentDef.define(type, ...defs)) as ComponentDecorator<T>;\n  const def = decorator as ComponentDef.Factory<InstanceType<T>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { eventSupplyOf } from '@proc7ts/fun-events';\nimport { DomEventDispatcher, OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        eventSupplyOf(dispatcher).needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<E extends Event>(type: string): OnDomEvent<E> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * @category Core\n */\nexport type ContentRoot = any;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent, statePath, StatePath } from '@proc7ts/fun-events';\nimport { mergeFunctions } from '../common';\n\n/**\n * Component state updater signature.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeparam V  Updated value type\n * @param path  Updated state node path.\n * @param newValue  New value.\n * @param oldValue  Replaced value.\n */\n    <V>(this: void, path: StatePath, newValue: V, oldValue: V) => void;\n\nexport namespace StateUpdater {\n\n  /**\n   * Normalized component state updater signature.\n   *\n   * Accepts normalized state path.\n   */\n  export type Normalized =\n  /**\n   * @typeparam V  Updated value type\n   * @param path  Normalized path of updated state node.\n   * @param newValue  New value.\n   * @param oldValue  Replaced value.\n   */\n      <V>(this: void, path: StatePath.Normalized, newValue: V, oldValue: V) => void;\n\n}\n\n/**\n * @internal\n */\nclass StateUpdaterKey extends ContextUpKey<StateUpdater, StateUpdater.Normalized> {\n\n  readonly upKey: ContextUpKey.UpKey<StateUpdater, StateUpdater.Normalized>;\n\n  constructor() {\n    super('state-updater');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n\n                const combined: StateUpdater.Normalized = fns.reduce(\n                    (prev, fn) => mergeFunctions(fn, prev),\n                    noop,\n                );\n\n                return (path, newValue, oldValue) => combined(statePath(path), newValue, oldValue);\n              }\n              if (slot.hasFallback && slot.or) {\n                return nextAfterEvent(slot.or);\n              }\n              return noop;\n            },\n        )),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          StateUpdater,\n          EventKeeper<StateUpdater.Normalized[]> | StateUpdater.Normalized,\n          AfterEvent<StateUpdater.Normalized[]>>,\n  ): void {\n\n    let delegated: StateUpdater;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        () => delegated = noop,\n    );\n\n    slot.insert((path, newValue, oldValue) => delegated(path, newValue, oldValue));\n  }\n\n}\n\n/**\n * A key of component context value containing a component {@link StateUpdater state updater} function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Does nothing by default and after component destruction.\n *\n * When multiple state updaters provided, they all will be called on each state update, in reverse order.\n *\n * @category Core\n */\nexport const StateUpdater: ContextUpRef<StateUpdater, StateUpdater.Normalized> = (/*#__PURE__*/ new StateUpdaterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport {\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  EventSupplyPeer,\n  OnEvent,\n  StatePath,\n} from '@proc7ts/fun-events';\nimport { OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perComponent]] and [[DefinitionSetup.perComponent]] methods.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements EventSupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A [[whenReady]] callback could\n   * be utilized to work this around.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is defined when component is mounted to arbitrary element by [[DefinitionContext.mountTo]]. Ot is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the component is settled.\n   *\n   * Component settlement happens:\n   * - when [[settle]] method is called,\n   * - when component is {@link DefinitionContext.mountTo mounted} to element, or\n   * - when component's element is [[connected]].\n   *\n   * It is guaranteed that component settlement won't happen inside custom element's constructor. So the settlement\n   * event may be used e.g. to start DOM manipulations, as the latter is prohibited inside custom element constructor.\n   *\n   * This becomes `true` right before [[whenSettled]] event is sent.\n   */\n  abstract readonly settled: boolean;\n\n  /**\n   * Whether the component's element is connected.\n   *\n   * This becomes `true` right before [[whenConnected]] event is sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An event supply that {@link destroy destroys} component when cut off.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  readonly updateState: StateUpdater;\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element  Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under [[ComponentContext__symbol]] key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = element[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${element}`);\n    }\n\n    return context;\n  }\n\n  constructor() {\n    super();\n    this.updateState = <V>(key: StatePath, newValue: V, oldValue: V): void => {\n      this.get(StateUpdater)(key, newValue, oldValue);\n    };\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): any {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   *\n   * @returns An `OnEvent` sender of this context upon component readiness.\n   */\n  abstract whenReady(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * @param receiver  Target receiver of this component upon component readiness.\n   *\n   * @returns Component readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Settles component.\n   *\n   * Calling this method has no effect if component is [[settled]] already, when component is not\n   * {@link whenReady ready} yet, or custom element's constructor is not exited.\n   *\n   * Calling this method may trigger DOM manipulations (the latter is prohibited inside custom element's constructor).\n   * This may be desired for rendering optimizations. E.g. to render element's content _before_ adding it to document.\n   *\n   * This method is called automatically when {@link DefinitionContext.mountTo mounting} component to element.\n   */\n  abstract settle(): void;\n\n  /**\n   * Builds an `OnEvent` sender of component settlement event.\n   *\n   * The registered receiver is called when component is [[settled]]. If settled already the receiver is called\n   * immediately.\n   *\n   * @returns An `OnEvent` sender of this component context when settled.\n   */\n  abstract whenSettled(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component settlement event.\n   *\n   * The registered receiver is called when component is [[settled]]. If settled already the receiver is called\n   * immediately.\n   *\n   * @param receiver  Target receiver of this component context when connected.\n   *\n   * @returns Component settlement event supply.\n   */\n  abstract whenSettled(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   *\n   * @returns An `OnEvent` sender of this component context when connected.\n   */\n  abstract whenConnected(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   *\n   * @param receiver  Target receiver of this component context when connected.\n   *\n   * @returns Component's element connection event supply.\n   */\n  abstract whenConnected(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event  An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   * However the component is destroyed automatically once disconnected, i.e. when custom element's\n   * `disconnectedCallback()` method is called.\n   *\n   * @param reason  Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextRef } from '@proc7ts/context-values';\nimport { OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using [[ComponentEventDispatcher]] available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E>;\n\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { valueProvider } from '@proc7ts/call-thru';\nimport { Class, decoratePropertyAccessor, PropertyAccessorDescriptor } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { Component, ComponentDecorator } from './component.decorator';\nimport { ComponentClass } from './definition';\n\n/**\n * Component property decorator interface.\n *\n * Allows to construct a {@link ComponentDecorator component decorator} by declaring a virtual property to use instead\n * of decorated one.\n *\n * Constructed by [[ComponentProperty]] function.\n *\n * @category Core\n * @typeparam V  Property value type.\n * @typeparam T  A type of decorated component class.\n */\nexport interface ComponentPropertyDecorator<V, T extends ComponentClass = Class> {\n\n  /**\n   * Decorates component method.\n   *\n   * @typeparam P  Property value type.\n   * @param proto  Decorated class prototype.\n   * @param propertyKey  Decorated property key.\n   * @param descriptor  Decorated property descriptor.\n   *\n   * @returns  Either updated property descriptor, or nothing.\n   */\n  // eslint-disable-next-line\n  <P extends V>(\n      this: void,\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<P>,\n  ): any | void;\n\n  /**\n   * Builds component decorator assuming the virtual property has the given value.\n   *\n   * @param value  Virtual property value.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  As(\n      this: void,\n      value: V,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the virtual property value is provided by the given `provider`.\n   *\n   * @param provider  Virtual property read-only value provider.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  By(\n      this: void,\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is available via the given `accessor`.\n   *\n   * @param accessor  Virtual property accessor.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  With(\n      this: void,\n      accessor: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is bound to component with by the given `binder`.\n   *\n   * @param binder  A binder of virtual property accessor\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]]..\n   *\n   * @returns New component decorator.\n   */\n  Bind(\n      this: void,\n      binder: ComponentProperty.Binder<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n}\n\nexport namespace ComponentProperty {\n\n  /**\n   * Component property value provider signature.\n   *\n   * This function will be called each time the property value is requested.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Provider<V, T extends object = any> =\n  /**\n   * @param component  Component instance.\n   * @param key  Target property key.\n   *\n   * @returns Property value.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => V;\n\n  /**\n   * Component property accessor.\n   *\n   * Allows to read and write property value.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export interface Accessor<V, T extends object = any> {\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: T, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set(this: void, component: T, value: V, key: string | symbol): void;\n\n  }\n\n  /**\n   * Property accessor binder signature.\n   *\n   * This is a function that binds a {@link BoundAccessor property accessor} to target component.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Binder<V, T extends object = any> =\n  /**\n   * @param component  Target component to bind property accessor to.\n   * @param key  Property key.\n   *\n   * @returns Property accessor bound to `component`.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => BoundAccessor<V>;\n\n  export interface BoundAccessor<V> {\n\n    /**\n     * Reads bound component's property value.\n     *\n     * An attempt to read the value would throw when omitted.\n     *\n     * @returns Property value.\n     */\n    get?(): V;\n\n    /**\n     * Assigns bound component's new property value.\n     *\n     * An attempt to assign the value would throw when omitted.\n     *\n     * @param value  New property value.\n     */\n    set?(value: V): void;\n\n  }\n\n  /**\n   * Component property descriptor.\n   *\n   * Passed to {@link Definer property definer} by [[ComponentProperty]] function to construct a {@link Definition\n   * property definition}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Descriptor<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component class constructor.\n     */\n    readonly type: T;\n\n    /**\n     * Component property key.\n     */\n    readonly key: string | symbol;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.get property read definition}.\n     */\n    readonly readable: boolean;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.set property assignment definition}.\n     */\n    readonly writable: boolean;\n\n    /**\n     * Whether the property is initially enumerable.\n     *\n     * This can be changed by {@link Definition.enumerable property definition}.\n     */\n    readonly enumerable: boolean;\n\n    /**\n     * Whether the property is initially configurable.\n     *\n     * This can be changed by {@link Definition.configurable property definition}.\n     */\n    readonly configurable: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: InstanceType<T>): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     */\n    set(this: void, component: InstanceType<T>, value: V): void;\n\n  }\n\n  /**\n   * Component property definition builder signature.\n   *\n   * This is a function called by [[ComponentProperty]] to define the property.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export type Definer<V, T extends ComponentClass = Class> =\n  /**\n   * @param descriptor  Component property descriptor.\n   *\n   * @returns Component property definition. Or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<V, T>,\n      ) => Definition<V, T> | void;\n\n  /**\n   * Property definition to apply to existing property.\n   *\n   * When applying to decorated property, this definition updates its definition.\n   *\n   * When applying to virtual property assumed by one of [[ComponentPropertyDecorator]] methods, most of returned\n   * values ignored. Except for {@link Definition.componentDef component definition}, {@link Definition.get value\n   * reader}, and {@link Definition.set value setter}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Definition<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component definition to apply to component.\n     *\n     * When specified, it is used to enable certain functionality for decorated (or virtual) property.\n     */\n    readonly componentDef?: ComponentDef<InstanceType<T>>;\n\n    /**\n     * Whether to make the property enumerable.\n     *\n     * When specified, it is used as `enumerable` attribute value of decorated property descriptor.\n     */\n    readonly enumerable?: boolean;\n\n    /**\n     * Whether to make the property configurable.\n     *\n     * When specified, it is used as `configurable` attribute value of decorated property descriptor.\n     */\n    readonly configurable?: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * When specified it changes how the property value is read.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get?(this: void, component: InstanceType<T>, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * When specified it changes how the property value is assigned.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set?(this: void, component: InstanceType<T>, value: V, key: string | symbol): void;\n\n  }\n\n}\n\n/**\n * Anonymous component property key.\n *\n * Used as a default virtual property key.\n *\n * @category Core\n */\nexport const AnonymousComponentProperty__symbol = (/*#__PURE__*/ Symbol('anonymous-component-property'));\n\n/**\n * Decorator of component property.\n *\n * Updates decorated property and component definition. Can be converted to {@link ComponentDecorator component\n * decorator} by calling appropriate method of returned decorator instance.\n *\n * @category Core\n * @typeparam V  Decorated property value type.\n * @typeparam T  A type of decorated component class.\n * @param define  Component property definition builder.\n *\n * @returns Component property decorator.\n */\nexport function ComponentProperty<V, T extends ComponentClass = Class>(\n    define: ComponentProperty.Definer<V, T>,\n): ComponentPropertyDecorator<V, T> {\n\n  const decorator = (\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<V>,\n  ): any | void => decoratePropertyAccessor(\n      proto,\n      propertyKey,\n      descriptor,\n      desc => {\n\n        const { get: getValue, set: setValue } = desc;\n        const type = proto.constructor;\n        const { get, set, configurable, enumerable, componentDef = {} } = define({\n          type,\n          key: propertyKey,\n          readable: !!desc.get,\n          writable: !!desc.set,\n          enumerable: !!desc.enumerable,\n          configurable: !!desc.configurable,\n          get: getValue\n              ? ((component: InstanceType<T>) => getValue.call(component))\n              : notReadableAccessor(propertyKey),\n          set: setValue\n              ? ((component, value) => setValue.call(component, value))\n              : notWritableAccessor(propertyKey),\n        }) || {};\n\n        ComponentDef.define(type, componentDef);\n\n        const updated: PropertyAccessorDescriptor<V> = {\n          ...desc,\n          configurable: configurable ?? desc.configurable,\n          enumerable: enumerable ?? desc.enumerable,\n        };\n\n        if (get || set) {\n          updated.get = get && function (this: InstanceType<T>) {\n            return get(this, propertyKey);\n          };\n          updated.set = set && function (this: InstanceType<T>, value: V) {\n            set(this, value, propertyKey);\n          };\n        }\n\n        return updated;\n      },\n  );\n  const decorateWith = (\n      { get, set }: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key: string | symbol = AnonymousComponentProperty__symbol,\n      writable: boolean,\n  ): ComponentDecorator<T> => Component({\n    [ComponentDef__symbol](type: InstanceType<T>) {\n\n      const def = define({\n        type,\n        key,\n        readable: true,\n        writable,\n        enumerable: false,\n        configurable: false,\n        get: component => get(component, key),\n        set: (component, value) => set(component, value, key),\n      });\n\n      return (def && def.componentDef) || {};\n    },\n  });\n  const By = (\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T> => decorateWith(\n      {\n        get(component, key) {\n          return provider(component, key);\n        },\n      } as ComponentProperty.Accessor<V>,\n      key,\n      false,\n  );\n\n  const result = decorator as ComponentPropertyDecorator<V, T>;\n\n  result.With = (access, key) => decorateWith(access, key, true);\n  result.By = By;\n  result.As = (value, key?) => By(valueProvider(value), key);\n  result.Bind = (binder, key = AnonymousComponentProperty__symbol) => {\n\n    const accessor__symbol = Symbol(`${String(key)}:accessor`);\n    const accessor = (component: any): {\n      get(): V;\n      set(value: V): void;\n    } => {\n\n      const existing = component[accessor__symbol];\n\n      if (existing) {\n        return existing;\n      }\n\n      const accessor = binder(component, key);\n\n      return component[accessor__symbol] = {\n        get: accessor.get ? accessor.get.bind(accessor) : notReadableAccessor(key),\n        set: accessor.set ? accessor.set.bind(accessor) : notWritableAccessor(key),\n      };\n    };\n\n    return decorateWith(\n        {\n          get(component) {\n            return accessor(component).get();\n          },\n          set(component, value) {\n            return accessor(component).set(value);\n          },\n        },\n        key,\n        true,\n    );\n  };\n\n  return result;\n}\n\n/**\n * @internal\n */\nfunction notReadableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not readable`); };\n}\n\n/**\n * @internal\n */\nfunction notWritableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not writable`); };\n}\n","import {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst ComponentContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'component-context-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentContextRegistry> {\n    return ComponentContextRegistry__key;\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst DefinitionContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'definition-context-registry',\n    {\n      byDefault: bootstrapDefault(context => new DefinitionContextRegistry(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n\n  static get [ContextKey__symbol](): ContextKey<DefinitionContextRegistry> {\n    return DefinitionContextRegistry__key;\n  }\n\n}\n","import { nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport { EventEmitter, onAny, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { superClassOf } from '../../common';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\nimport { Unloader } from './unloader.impl';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    unloader: Unloader,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on.to({\n      supply: receiver.supply.needs(unloader.supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady().tillOff(unloader.supply).F;\n        const whenComponent = setup.whenComponent().tillOff(unloader.supply).F;\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return unloader.add(() => setup.perDefinition(spec));\n          },\n          perComponent(spec) {\n            return unloader.add(() => setup.perComponent(spec));\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: ComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return (componentType as any)[PostDefSetup__symbol];\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read().thru(setup => setup ? nextArgs(setup) : nextSkip());\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on.to(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = any;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of [[BootstrapWindow]].\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { NamespaceAliaser } from '@proc7ts/namespace-aliaser';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValues, ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { newRenderSchedule, RenderScheduler } from '@proc7ts/render-scheduler';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nclass DefaultRenderSchedulerKey extends ContextUpKey<DefaultRenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<DefaultRenderScheduler, RenderScheduler>;\n\n  constructor() {\n    super('default-render-scheduler');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n                return toDefaultRenderScheduler(slot.context, fns[fns.length - 1]);\n              }\n              if (slot.hasFallback && slot.or) {\n                return nextAfterEvent(slot.or);\n              }\n              return toDefaultRenderScheduler(slot.context, newRenderSchedule);\n            },\n        )),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          DefaultRenderScheduler,\n          EventKeeper<RenderScheduler[]> | RenderScheduler,\n          AfterEvent<RenderScheduler[]>>,\n  ): void {\n\n    let delegated: DefaultRenderScheduler;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!.to(\n        scheduler => delegated = toDefaultRenderScheduler(slot.context, scheduler),\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toDefaultRenderScheduler(\n    context: ContextValues,\n    scheduler: RenderScheduler,\n): DefaultRenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n\n/**\n * A key of bootstrap, definition, or component context value containing [[DefaultRenderScheduler]] instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new DefaultRenderSchedulerKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element  Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ElementAdapter>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.keepThru((...adapters) => {\n\n          const combined: ElementAdapter = adapters.reduce(\n              (prev, adapter) => element => prev(element) || adapter(element),\n              defaultElementAdapter,\n          );\n\n          if (combined !== defaultElementAdapter) {\n            return combined;\n          }\n          if (slot.hasFallback && slot.or) {\n            return nextAfterEvent(slot.or);\n          }\n\n          return defaultElementAdapter;\n        })),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter,\n          AfterEvent<ElementAdapter[]>>,\n  ): void {\n\n    let delegated: ElementAdapter;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!.to(\n        adapter => delegated = adapter,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert(element => delegated(element));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: any): ComponentContext {\n  return element[ComponentContext__symbol];\n}\n\n/**\n * A key of bootstrap context value containing combined [[ElementAdapter]] instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = (/*#__PURE__*/ new ElementAdapterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { filterIt, itsEach, overArray } from '@proc7ts/a-iterable';\nimport { FnContextKey } from '@proc7ts/context-values/updatable';\nimport { isElement } from '../../common';\nimport { ComponentContext__symbol, ComponentMount } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * [[disconnect]].\n   *\n   * @param target  A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options  An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new [[ElementObserver]] instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node)?.checkConnected(),\n                );\n                itsEach(\n                    filterIt(\n                        overArray(mutation.addedNodes),\n                        isElement,\n                    ),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: any): ComponentMount | undefined {\n  return node[ComponentContext__symbol]?.mount;\n}\n","import { ComponentClass, DefinitionContext } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const DefinitionContext__symbol = (/*#__PURE__*/ Symbol('definition-context'));\n\n/**\n * @internal\n */\nexport function definitionContextOf<T extends object>(componentType: ComponentClass<T>): DefinitionContext<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (!componentType.hasOwnProperty(DefinitionContext__symbol)) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n  return (componentType as any)[DefinitionContext__symbol];\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { html__naming, isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { definitionContextOf } from '../../boot/impl/definition-context.symbol.impl';\nimport { Class, PromiseResolver } from '../../common';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: bootstrapDefault(createCustomElements),\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName  A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType  A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName  Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(bsContext: BootstrapContext): CustomElements {\n\n  const customElements: CustomElementRegistry = bsContext.get(BootstrapWindow).customElements;\n  const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n\n  class CustomElements$ extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name, extend } = defContext.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name } = defContext.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise;\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new CustomElements$();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: any): PromiseResolver {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(ComponentResolver__symbol)) {\n    return componentType[ComponentResolver__symbol];\n  }\n  return componentType[ComponentResolver__symbol] = new PromiseResolver();\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class } from '../../common';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../component-context';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perDefinition]] and [[DefinitionSetup.perDefinition]] methods. All [[BootstrapContext]] values\n * are available too.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of this component definition context upon its readiness.\n   */\n  abstract whenReady(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component definition readiness event.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of this component definition context upon its readiness.\n   *\n   * @returns Component definition readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connect();\n\n    return mount;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   *\n   * @returns `OnEvent` sender of instantiated component context.\n   */\n  abstract whenComponent(): OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Starts sending component instantiation events to the given `receiver`.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   *\n   * @param receiver  Target receiver of instantiate component contexts.\n   *\n   * @returns Component instantiation events supply.\n   */\n  abstract whenComponent(receiver: EventReceiver<[ComponentContext<T>]>): EventSupply;\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeparam Deps  A type of dependencies.\n   * @typeparam Src  The type of context value sources.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Component context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void;\n\n}\n","import { nextArg, nextArgs, nextSkip, valueProvider } from '@proc7ts/call-thru';\nimport {\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentContext__symbol, ComponentEvent } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Built,\n  Settled,\n  Connected,\n}\n\n/**\n * @internal\n */\nexport abstract class ComponentContext$<T extends object> extends ComponentContext<T> {\n\n  readonly get: ComponentContext<T>['get'];\n  private _status = trackValue<ComponentStatus>(ComponentStatus.Building);\n\n  constructor(\n      readonly _definitionContext: DefinitionContext$<T>,\n      readonly element: any,\n  ) {\n    super();\n\n    const registry = _definitionContext._newComponentRegistry();\n\n    registry.provide({ a: ComponentContext, is: this });\n    this.get = registry.newValues().get;\n  }\n\n  get componentType(): ComponentClass<T> {\n    return this._definitionContext.componentType;\n  }\n\n  get component(): T {\n    return this._component();\n  }\n\n  get settled(): boolean {\n    return this._status.it >= ComponentStatus.Settled && !eventSupplyOf(this).isOff;\n  }\n\n  get connected(): boolean {\n    return this._status.it >= ComponentStatus.Connected && !eventSupplyOf(this).isOff;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._status);\n  }\n\n  _component(): T {\n    throw new TypeError('Component is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  whenReady(): OnEvent<[this]>;\n  whenReady(receiver: EventReceiver<[this]>): EventSupply;\n  whenReady(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n    return (this.whenReady = this._status.read().thru_(\n        status => status ? nextArgs(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  settle(): void {\n    if (this._status.it === ComponentStatus.Built) {\n      // Prevent settling until exiting custom element constructor\n      this._status.it = ComponentStatus.Settled;\n    }\n  }\n\n  whenSettled(): OnEvent<[this]>;\n  whenSettled(receiver: EventReceiver<[this]>): EventSupply;\n  whenSettled(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n    return (this.whenSettled = this._status.read().thru_(\n        status => status >= ComponentStatus.Settled ? nextArg(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  whenConnected(): OnEvent<[this]>;\n  whenConnected(receiver: EventReceiver<[this]>): EventSupply;\n  whenConnected(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n    return (this.whenConnected = this._status.read().thru_(\n        status => status >= ComponentStatus.Connected ? nextArg(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  destroy(reason?: any): void {\n    try {\n      this._status.done(reason);\n    } finally {\n      delete (this.component as any)[ComponentContext__symbol];\n      delete this.element[ComponentContext__symbol];\n      this._component = componentDestroyed;\n      removeElement(this.element);\n    }\n  }\n\n  _createComponent(): this {\n\n    const whenComponent = this._definitionContext._whenComponent;\n\n    let lastRev = 0;\n\n    this.element[ComponentContext__symbol] = this;\n    whenComponent.readNotifier.once(notifier => lastRev = notifier(this, lastRev));\n    this.whenConnected(() => {\n      whenComponent.readNotifier.to({\n        supply: eventSupply().needs(this),\n        receive: (_, notifier) => {\n          lastRev = notifier(this, lastRev);\n        },\n      });\n    });\n    this._definitionContext._elementBuilder.components.send(this);\n\n    const component = newComponent(this);\n\n    this._component = valueProvider(component);\n    this._status.it = ComponentStatus.Ready; // Issue `whenReady` event\n\n    return this;\n  }\n\n  _connect(): void {\n    this._status.it = ComponentStatus.Connected;\n  }\n\n  _created(): void {\n    if (this._status.it < ComponentStatus.Built) { // Mounted component can be connected already\n      this._status.it = ComponentStatus.Built; // Can settle now\n    }\n    this.whenConnected(\n        () => this.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n    );\n  }\n\n}\n\nfunction newComponent<T extends object>(context: ComponentContext<T>): T {\n\n  const type = context.componentType;\n  const proto = type.prototype as any;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    (component as any)[ComponentContext__symbol] = context;\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nfunction removeElement(element: Element): void {\n\n  const { parentNode } = element;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n\nfunction componentDestroyed(): never {\n  throw new TypeError('Component destroyed already');\n}\n","import { ComponentMount } from '../../component';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass ComponentMount$<T extends object> extends ComponentMount<T> {\n\n  constructor(readonly context: ComponentContext$<T>) {\n    super();\n  }\n\n  get connected(): boolean {\n    return this.context.connected;\n  }\n\n  connect(): void {\n    this.context._connect();\n  }\n\n  checkConnected(): boolean {\n\n    const el: Element = this.context.element;\n    const doc = el.ownerDocument;\n    const connected = doc != null && doc.contains(el);\n\n    if (connected !== this.connected) {\n      if (connected) {\n        this.connect();\n      } else {\n        this.context.destroy();\n      }\n    }\n\n    return connected;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class MountComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  readonly mount: ComponentMount<T>;\n\n  constructor(definitionContext: DefinitionContext$<T>, element: any) {\n    super(definitionContext, element);\n    this.mount = this.mount = new ComponentMount$<T>(this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by [[DefinitionContext.mountTo]] method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating [[ComponentMount.connected]] property. E.g. by calling a\n * [[ComponentMount.checkConnected]] method. An [[ElementObserver]] and [[AutoConnectSupport]] feature could be used to\n * do it automatically.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * The initial state is set by [[checkConnected]] method.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element;\n  }\n\n  /**\n   * Forcibly connects mounted component element to the document.\n   */\n  abstract connect(): void;\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * When component is disconnected after it has been connected, the component is {@link ComponentContext.destroy\n   * destroyed}.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { Class } from '../../common';\nimport { ComponentContext__symbol } from '../../component';\nimport { ElementDef } from '../../component/definition';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass CustomComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  get mount(): undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nexport function customElementType<T extends object>(\n    definitionContext: DefinitionContext$<T>,\n): Class {\n\n  const elementDef = definitionContext.get(ElementDef);\n\n  class CustomElement$ extends elementDef.extend.type {\n\n    // Component context reference\n    [ComponentContext__symbol]: CustomComponentContext$<T>;\n\n    constructor() {\n      super();\n\n      const context = new CustomComponentContext$(definitionContext, this);\n\n      context._createComponent();\n      context._created();\n    }\n\n    connectedCallback(): void {\n      super.connectedCallback?.();\n      this[ComponentContext__symbol]._connect();\n    }\n\n    disconnectedCallback(): void {\n      this[ComponentContext__symbol].destroy();\n      super.disconnectedCallback?.();\n    }\n\n  }\n\n  return CustomElement$;\n}\n","import { AfterEvent, EventEmitter, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read().keepThru_(\n        rev => (context, notifiedRev) => {\n          created.send(context, notifiedRev);\n          return rev;\n        },\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { nextArgs, nextSkip, valueProvider } from '@proc7ts/call-thru';\nimport { ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext, ComponentContext__symbol, ComponentDef, ComponentMount } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { ComponentContextRegistry } from './component-context-registry.impl';\nimport { MountComponentContext$ } from './component-mount.impl';\nimport { customElementType } from './custom-element.impl';\nimport { DefinitionContextRegistry } from './definition-context-registry.impl';\nimport { DefinitionContext__symbol } from './definition-context.symbol.impl';\nimport { ElementBuilder } from './element-builder.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport class DefinitionContext$<T extends object> extends DefinitionContext<T> {\n\n  readonly get: ContextValues['get'];\n  private readonly _def: ComponentDef.Options<T>;\n  readonly _whenComponent = new WhenComponent<T>();\n  private readonly _ready: ValueTracker<boolean>;\n  private readonly _whenReady: OnEvent<[]>;\n  private readonly _perTypeRegistry: ComponentContextRegistry;\n\n  constructor(\n      readonly _bsContext: BootstrapContext,\n      readonly _elementBuilder: ElementBuilder,\n      readonly componentType: ComponentClass<T>,\n  ) {\n    super();\n    this._ready = trackValue(false);\n    this._whenReady = this._ready.read().thru(ready => ready ? nextArgs() : nextSkip());\n    this._def = ComponentDef.of(componentType);\n\n    const definitionContextRegistry = new DefinitionContextRegistry(\n        _bsContext.get(DefinitionContextRegistry).seedIn(this),\n    );\n\n    definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n    this.get = definitionContextRegistry.newValues().get;\n    this._perTypeRegistry = new ComponentContextRegistry(definitionContextRegistry.seedIn(this));\n\n    const whenReady$ = this.whenReady().F;\n    const whenComponent$ = this.whenComponent().F;\n\n    const definitionSetup: DefinitionSetup<T> = {\n      get componentType() {\n        return componentType;\n      },\n      get whenReady() {\n        return whenReady$;\n      },\n      get whenComponent() {\n        return whenComponent$;\n      },\n      perDefinition: spec => definitionContextRegistry.provide(spec),\n      perComponent: spec => this._perTypeRegistry.provide(spec),\n    };\n\n    this._def.setup?.(definitionSetup);\n    postDefSetup(componentType).setup(definitionSetup);\n  }\n\n  get elementType(): Class {\n    return this._elementType();\n  }\n\n  whenReady(): OnEvent<[this]>;\n  whenReady(receiver: EventReceiver<[this]>): EventSupply;\n  whenReady(receiver?: EventReceiver<[this]>): EventSupply | OnEvent<[this]> {\n    return (this.whenReady = (this._whenReady.thru_(valueProvider(this)).once() as OnEvent<[this]>).F)(receiver);\n  }\n\n  mountTo(element: any): ComponentMount<T> {\n    if (element[ComponentContext__symbol]) {\n      throw new Error(`Element ${element} already bound to component`);\n    }\n\n    const context = new MountComponentContext$(this, element);\n\n    context._createComponent();\n\n    const { mount } = context;\n\n    mount.checkConnected();\n    context._created();\n    context.settle();\n\n    return mount;\n  }\n\n  whenComponent(): OnEvent<[ComponentContext<T>]>;\n  whenComponent(receiver: EventReceiver<[ComponentContext<T>]>): EventSupply;\n  whenComponent(receiver?: EventReceiver<[ComponentContext<T>]>): OnEvent<[ComponentContext<T>]> | EventSupply {\n    return (this.whenComponent = this._whenComponent.onCreated.F)(receiver);\n  }\n\n  perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._perTypeRegistry.provide(spec);\n  }\n\n  _newComponentRegistry(): ComponentContextRegistry {\n    return this._bsContext.get(ComponentContextRegistry).append(this._perTypeRegistry);\n  }\n\n  _elementType(): Class {\n    throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  _define(): void {\n    this._def.define?.(this);\n    this._elementBuilder.definitions.send(this);\n    this._elementType = valueProvider(customElementType(this));\n    (this.componentType as any)[DefinitionContext__symbol] = this;\n    this._ready.it = true;\n  }\n\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { EventEmitter } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext]>;\n  readonly components: EventEmitter<[ComponentContext]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n  return {\n    definitions: new EventEmitter<[DefinitionContext]>(),\n    components: new EventEmitter<[ComponentContext]>(),\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const definitionContext = new DefinitionContext$(bsContext, this, componentType);\n\n      definitionContext._define();\n\n      return definitionContext;\n    },\n  };\n\n}\n","import { itsEach, overArray } from '@proc7ts/a-iterable';\nimport { noop, valueProvider } from '@proc7ts/call-thru';\nimport { EventSupply, eventSupply } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nexport interface Unloader {\n  readonly supply: EventSupply;\n  add(adder: () => () => void): () => void;\n}\n\nconst doNotAdd = valueProvider(noop);\n\n/**\n * @internal\n */\nexport function newUnloader(): Unloader {\n\n  const unloads: (() => void)[] = [];\n  let add = (adder: () => () => void): () => void => {\n\n    const unload = adder();\n\n    unloads.push(unload);\n\n    return unload;\n  };\n  const supply = eventSupply(() => {\n    add = doNotAdd;\n    itsEach(\n        overArray(unloads).reverse(),\n        unload => unload(),\n    );\n    unloads.length = 0;\n  });\n\n  return {\n    supply,\n    add(adder) {\n      return add(adder);\n    },\n  };\n}\n","import { ElementBuilder } from '../../boot/impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._definitionQueue.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const defContext = elementBuilder.buildElement(componentType);\n\n      this.customElements.define(componentType, defContext.elementType);\n    });\n  }\n\n}\n","import { nextArg, nextSkip } from '@proc7ts/call-thru';\nimport { ContextRegistry, ContextValueSpec } from '@proc7ts/context-values';\nimport { afterAll, EventReceiver, EventSupply, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ComponentContextRegistry,\n  DefinitionContextRegistry,\n  ElementBuilder,\n  newUnloader,\n  onPostDefSetup,\n} from '../../boot/impl';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureLoader } from './feature-loader.impl';\n\n/**\n * @internal\n */\nexport class FeatureContext$ extends FeatureContext {\n\n  readonly _unloader = newUnloader();\n  readonly get: FeatureContext['get'];\n  private readonly _componentRegistry: ComponentRegistry;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      private readonly _loader: FeatureLoader,\n  ) {\n    super();\n\n    const registry = new ContextRegistry<FeatureContext>(_bsContext);\n\n    registry.provide({ a: FeatureContext, is: this });\n    this.get = registry.newValues().get;\n    this._componentRegistry = new ComponentRegistry(this);\n  }\n\n  get feature(): Class {\n    return this._loader.request.feature;\n  }\n\n  whenReady(): OnEvent<[FeatureContext]>;\n  whenReady(receiver: EventReceiver<[FeatureContext]>): EventSupply;\n  whenReady(receiver?: EventReceiver<[FeatureContext]>): OnEvent<[FeatureContext]> | EventSupply {\n    return (this.whenReady = afterAll({\n      st: this._loader.state,\n      bs: trackValue<BootstrapContext>().by(this._bsContext.whenReady()),\n    }).thru(\n        ({\n          st: [ready],\n          bs: [bs],\n        }) => bs && ready ? nextArg(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  onDefinition(): OnEvent<[DefinitionContext]>;\n  onDefinition(receiver: EventReceiver<[DefinitionContext]>): EventSupply;\n  onDefinition(receiver?: EventReceiver<[DefinitionContext]>): OnEvent<[DefinitionContext]> | EventSupply {\n    return (this.onDefinition = this._bsContext.get(ElementBuilder).definitions.on()\n        .tillOff(this._unloader.supply).F)(receiver);\n  }\n\n  onComponent(): OnEvent<[ComponentContext]>;\n  onComponent(receiver: EventReceiver<[ComponentContext]>): EventSupply;\n  onComponent(receiver?: EventReceiver<[ComponentContext]>): EventSupply | OnEvent<[ComponentContext]> {\n    return (this.onComponent = this._bsContext.get(ElementBuilder).components.on()\n        .tillOff(this._unloader.supply).F)(receiver);\n  }\n\n  provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._unloader.add(() => this._bsContext.get(BootstrapContextRegistry).provide(spec));\n  }\n\n  perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._unloader.add(() => this._bsContext.get(DefinitionContextRegistry).provide(spec));\n  }\n\n  perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._unloader.add(() => this._bsContext.get(ComponentContextRegistry).provide(spec));\n  }\n\n  setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n    return onPostDefSetup(componentType, this._unloader);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._componentRegistry.define(componentType);\n  }\n\n}\n","import { filterIt, mapIt } from '@proc7ts/a-iterable';\nimport { isPresent, nextArgs, NextCall, NextSkip, nextSkip } from '@proc7ts/call-thru';\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  EventKeeper,\n  nextAfterEvent,\n  OnEventCallChain,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { BootstrapContext } from '../../boot';\nimport { ArraySet, Class } from '../../common';\nimport { FeatureContext } from '../feature-context';\nimport { FeatureContext$ } from './feature-context.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = (/*#__PURE__*/ Symbol('feature-key'));\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n    // eslint-disable-next-line no-prototype-builtins\n    return feature.hasOwnProperty(FeatureKey__symbol)\n        ? (feature as any)[FeatureKey__symbol]\n        : ((feature as any)[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): void {\n    slot.insert(loadFeature(\n        slot.context.get(BootstrapContext),\n        slot.seed.keepThru(preferredFeatureClause),\n    ));\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n    case 'is':\n      required = true;\n      if (!preferred) {\n        preferred = clause;\n      }\n      break;\n    case 'has':\n      preferred = clause;\n      break;\n    case 'needs':\n      required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: AfterEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).keepThru_(({ clause: [clause], deps }): NextCall<OnEventCallChain, [FeatureLoader?]> => {\n      if (!clause) {\n        return nextArgs();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return nextAfterEvent(source); // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return nextAfterEvent(source = bsContext.get(FeatureKey.of(origin)).keepThru_(\n            loader => {\n              loader!.to(stageId);\n              stageId = loader!.stage;\n              return loader;\n            },\n        ));\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return nextAfterEvent(source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource.to(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).share()); // Can be accessed again when reused\n    }).to(receiver);\n  }).keepThru(\n      preventDuplicateLoader(),\n  );\n}\n\nfunction preventDuplicateLoader():\n    (\n        loader?: FeatureLoader,\n    ) => NextCall<OnEventCallChain, [FeatureLoader?]> | NextSkip {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return (loader?: FeatureLoader) => {\n    if (lastLoader === loader) {\n      return nextSkip();\n    }\n    lastLoader = loader;\n\n    if (!loader) {\n      return nextArgs<[FeatureLoader?]>();\n    }\n\n    return nextArgs<[FeatureLoader?]>(loader);\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.keepThru_(clause => {\n    if (!clause) {\n      return nextArgs();\n    }\n\n    const [{ def }] = clause;\n    const needs = new ArraySet(def.needs);\n\n    if (!needs.size) {\n      return nextArgs();\n    }\n\n    return nextAfterEvent(\n        afterEach(\n            ...mapIt(\n                needs,\n                dep => bsContext.get(FeatureKey.of(dep)),\n            ),\n        ).keepThru_(presentFeatureDeps),\n    );\n  });\n}\n\nfunction presentFeatureDeps(...deps: [FeatureLoader?][]): NextCall<OnEventCallChain, FeatureLoader[]> {\n  return nextArgs<FeatureLoader[]>(\n      ...filterIt<FeatureLoader | undefined, FeatureLoader>(\n          mapIt(deps, dep => dep[0]),\n          isPresent,\n      ),\n  );\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    delete this._stage; // Unloaded feature should never be accessed again.\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  idle(): Promise<this> {\n    return Promise.resolve(this);\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after(): 'idle' {\n    return 'idle';\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def } } = this.loader;\n    const context = new FeatureContext$(bsContext, this.loader);\n    const supply = context._unloader.supply;\n\n    def.setup?.(context);\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        () => Promise.resolve(supply.off()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after(): 'setup' {\n    return 'setup';\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { def } } = this.loader;\n\n    def.init?.(this._context);\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after(): 'init' {\n    return 'init';\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  init(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n}\n","import { ArraySet, Class, mergeFunctions } from '../../common';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest {\n\n  readonly def: FeatureDef.Options;\n  private _uses = 0;\n\n  constructor(\n      private readonly _requester: FeatureRequester,\n      readonly feature: Class,\n      private _revoke: () => void,\n  ) {\n    this.def = featureDef(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    this._revokeBy(registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }));\n\n    for (const feature of new ArraySet(this.def.has)) {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n    }\n\n    for (const feature of new ArraySet(this.def.needs)) {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n    }\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(([{ feature }, reason, need]) => [feature, reason, need]));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse(): void {\n    if (!--this._uses) {\n      this._revoke();\n    }\n  }\n\n  private _revokeBy(revoke: () => void): void {\n    this._revoke = mergeFunctions(revoke, this._revoke);\n  }\n\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapContextRegistry } from '../../boot/impl';\nimport { Class } from '../../common';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = (/*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapContextRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapContextRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature, () => this._map.delete(feature));\n\n    this._map.set(feature, request);\n\n    return request.request(clauses);\n  }\n\n}\n","import { OnEvent, onPromise } from '@proc7ts/fun-events';\nimport { ComponentClass, CustomElements, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { definitionContextOf } from './definition-context.symbol.impl';\n\n/**\n * @internal\n */\nexport const WhenDefined__symbol = (/*#__PURE__*/ Symbol('when-defined'));\n\n/**\n * @internal\n */\nexport function whenDefined<T extends object>(\n    bsContext: BootstrapContext,\n    componentType: ComponentClass<T>,\n): OnEvent<[DefinitionContext<T>]> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(WhenDefined__symbol)) {\n    return (componentType as any)[WhenDefined__symbol];\n  }\n\n  const result: OnEvent<[DefinitionContext<T>]> = onPromise(\n      Promise.resolve(bsContext.whenReady())\n          .then(() => bsContext.get(CustomElements).whenDefined(componentType))\n          .then(() => definitionContextOf(componentType)),\n  );\n\n  return (componentType as any)[WhenDefined__symbol] = result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, EventReceiver, EventSupply, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { newNamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { Class } from '../../common';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { whenDefined } from '../impl/when-defined.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features  Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature)).to(loader => {\n    loader!.init().then(complete).catch(console.error);\n  });\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class BootstrapContext$ extends BootstrapContext {\n\n    readonly get = values.get;\n\n    constructor() {\n      super();\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    whenDefined<C extends object>(componentType: ComponentClass<C>): OnEvent<[DefinitionContext<C>]> {\n      return whenDefined(this, componentType);\n    }\n\n    whenReady(): OnEvent<[BootstrapContext]>;\n    whenReady(receiver: EventReceiver<[BootstrapContext]>): EventSupply;\n    whenReady(receiver?: EventReceiver<[BootstrapContext]>): OnEvent<[BootstrapContext]> | EventSupply {\n      return (this.whenReady = stage.read().thru(\n          s => s ? nextArgs(this) : nextSkip(),\n      ).once().F)(receiver);\n    }\n\n    load(feature: Class<any>): FeatureRef {\n\n      interface FeatureInfo {\n        status: FeatureStatus;\n        down?: Promise<void>;\n      }\n\n      const status = afterEventBy<[FeatureInfo]>(receiver => {\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<FeatureInfo>({\n          status: {\n            feature,\n            ready: false,\n          },\n        });\n\n        this.get(FeatureKey.of(feature)).to({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              status: {\n                feature: loader.request.feature,\n                ready: loader.ready,\n              },\n              down: loader.down,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  status: {\n                    feature: loader.request.feature,\n                    ready: true,\n                  },\n                  down: loader.down,\n                };\n              }).catch(console.error);\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).share();\n\n      let whenDown: Promise<void>;\n      const supply = status.to(({ down }) => {\n        whenDown = down!;\n      });\n\n      class Ref extends FeatureRef {\n\n        get down(): Promise<void> {\n          return whenDown;\n        }\n\n        read(): AfterEvent<[FeatureStatus]>;\n        read(receiver: EventReceiver<[FeatureStatus]>): EventSupply;\n        read(receiver?: EventReceiver<[FeatureStatus]>): AfterEvent<[FeatureStatus]> | EventSupply {\n          return (this.read = status.tillOff(supply).keepThru(\n              info => info.status,\n          ).F)(receiver);\n        }\n\n        dismiss(reason?: any): Promise<void> {\n          supply.off(reason);\n          return whenDown;\n        }\n\n      }\n\n      return new Ref();\n    }\n\n  }\n\n  const bootstrapContext = new BootstrapContext$();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath__rootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name  Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface AttributePath__rootKeys {\n  [AttributePath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(component, updateState, newValue, oldValue);\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string | null,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts property name to _dash-style_ attribute name.\n *\n * - Any ASCII uppercase letter A to Z is transformed into a dash followed by its lowercase counterpart;\n * - other characters are left unchanged.\n *\n * @category Feature\n * @param name  Property name to convert.\n *\n * @returns  _dash-style_ attribute name.\n */\nexport function property2attributeName(name: string): string {\n\n  let result: string | undefined;\n\n  for (let i = 0; i < name.length; ++i) {\n\n    const c = name[i];\n\n    if (c <= 'Z' && c >= 'A') {\n      if (!result) {\n        // Allocate result on first conversion\n        result = name.substring(0, i);\n      }\n      result += '-' + c.toLowerCase();\n    } else if (result) {\n      result += c;\n    }\n  }\n\n  return result || name;\n}\n","import { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { property2attributeName } from './property2attribute-name';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends ComponentClass>(\n    target: InstanceType<T>,\n    propertyKey: string | symbol,\n    opts?: AttributeDef<InstanceType<T>> | string,\n): AttributeDescriptor<InstanceType<T>> {\n\n  let name: string;\n  let change: AttributeChangedCallback<InstanceType<T>>;\n\n  if (typeof opts === 'string') {\n    name = property2attributeName(opts);\n    change = attributeStateUpdate(name);\n  } else {\n    if (opts && opts.name) {\n      name = property2attributeName(opts.name);\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = property2attributeName(propertyKey);\n    }\n\n    change = attributeStateUpdate(name, opts && opts.updateState);\n  }\n\n  return { name, change };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { ArraySet, Class, mergeFunctions } from '../../common';\nimport { isArray } from '../../common/types.impl';\nimport { ComponentContext, ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\n/**\n * A registry of component's element attributes.\n *\n * @category Feature\n */\nexport interface AttributeRegistry {\n\n  /**\n   * Declares component element's attribute.\n   *\n   * @param descriptor  Attribute descriptor.\n   */\n  declareAttribute(descriptor: AttributeDescriptor): void;\n\n}\n\n/**\n * A key of component definition context value containing {@link AttributeRegistry attribute registry}.\n *\n * @category Feature\n */\nexport const AttributeRegistry: ContextRef<AttributeRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<AttributeRegistry>(\n        'attribute-registry',\n        {\n          byDefault(context) {\n            return new AttributeRegistry$(context.get(DefinitionContext));\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nclass AttributeRegistry$ implements AttributeRegistry {\n\n  private readonly attrs = new Map<string, AttributeChangedCallback<any>>();\n\n  constructor(private readonly _context: DefinitionContext) {\n    _context.whenReady(({ elementType }) => this.define(elementType));\n    _context.whenComponent(({ mount }) => {\n      if (mount) {\n        // Mount element attributes\n        this.mount(mount);\n      }\n    });\n  }\n\n  declareAttribute({ name, change }: AttributeDescriptor): void {\n    this.attrs.set(name, mergeFunctions(this.attrs.get(name), change));\n  }\n\n  private define(elementType: Class): void {\n\n    const { attrs } = this;\n\n    if (!attrs.size) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes(elementType, attrs.keys()),\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: attributeChangedCallback(elementType, attrs),\n    });\n  }\n\n  private mount(mount: ComponentMount): void {\n\n    const element = mount.element;\n    const { attrs } = this;\n    const attributeFilter = Array.from(attrs.keys());\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  ComponentContext.of(element).component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n\n/**\n * @internal\n */\ntype ElementAttributeChanged = (\n    this: any,\n    name: string,\n    oldValue: string | null,\n    newValue: string | null,\n) => void;\n\n/**\n * @internal\n */\nfunction observedAttributes(\n    elementType: Class,\n    attrs: Iterable<string>,\n): readonly string[] {\n\n  const alreadyObserved: readonly string[] | undefined = (elementType as any).observedAttributes;\n\n  return Array.from(\n      isArray<string>(alreadyObserved)\n          ? new ArraySet(alreadyObserved).addAll(attrs).items\n          : attrs,\n  );\n}\n\n/**\n * @internal\n */\nfunction attributeChangedCallback<T extends object>(\n    elementType: Class,\n    attrs: Map<string, AttributeChangedCallback<T>>,\n): ElementAttributeChanged {\n\n  const prevCallback: ElementAttributeChanged | undefined = elementType.prototype.attributeChangedCallback;\n\n  if (!prevCallback) {\n    return function (this: any, name, oldValue, newValue) {\n      attrs.get(name)!(ComponentContext.of<T>(this).component, newValue, oldValue);\n    };\n  }\n\n  return function (this: any, name, oldValue, newValue) {\n\n    const attrChanged = attrs.get(name);\n\n    if (attrChanged) {\n      attrChanged(ComponentContext.of<T>(this).component, newValue, oldValue);\n    } else {\n      prevCallback.call(this, name, oldValue, newValue);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributeRegistry } from './attribute-registry';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` removes corresponding attribute.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Attribute definition or just an attribute name (either _camelCase_ or _dash-style_).\n *\n * @return Component property decorator.\n */\nexport function Attribute<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): ComponentPropertyDecorator<string | null, T> {\n  return ComponentProperty(({ type, key }) => {\n\n    const descriptor = parseAttributeDescriptor(type.prototype, key, def);\n    const { name } = descriptor;\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(AttributeRegistry).declareAttribute(descriptor);\n        },\n      },\n      get(component: InstanceType<T>): string | null {\n        return ComponentContext.of(component).element.getAttribute(name);\n      },\n      set(component: InstanceType<T>, newValue: string | null) {\n\n        const { element }: { element: Element } = ComponentContext.of(component);\n\n        if (newValue != null) {\n          element.setAttribute(name, newValue);\n        } else {\n          element.removeAttribute(name);\n        }\n      },\n    };\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributeRegistry } from './attribute-registry';\n\n/**\n * Creates a component method decorator for custom element attribute change callback.\n *\n * The decorated method should have up to two parameters:\n *\n * - the first one accepts new attribute value.\n * - the second one accepts old attribute value (or `null`),\n *\n * Example:\n * ```TypeScript\n * @Component('my-component')\n * class MyComponent {\n *\n *   @AttributeChanged('my-attribute')\n *   myAttributeChanged(newValue: string, oldValue: string | null) {\n *     console.log(`my-attribute value changed from ${oldValue} to ${newValue}`);\n *   }\n *\n * }\n * ```\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Attribute definition or just an attribute name.\n *\n * @return Component method decorator.\n */\nexport function AttributeChanged<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): ComponentPropertyDecorator<(newValue: string | null, oldValue: string | null) => void, T> {\n  return ComponentProperty(({ type, get, key }) => {\n\n    const { name, change } = parseAttributeDescriptor(type.prototype, key, def);\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(AttributeRegistry).declareAttribute({\n            name,\n            change(\n                component: InstanceType<T>,\n                newValue: string | null,\n                oldValue: string | null,\n            ) {\n\n              const callback = get(component);\n\n              callback.call(component, newValue, oldValue);\n              change(component, newValue, oldValue);\n            },\n          });\n        },\n      },\n    };\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { Component, ComponentDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeRegistry } from './attribute-registry';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { property2attributeName } from './property2attribute-name';\n\n/**\n * Creates a component decorator declaring supported custom element's attributes.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param items  Attributes definition options.\n *\n * @return New component decorator.\n */\nexport function Attributes<T extends ComponentClass = Class>(\n    ...items: readonly Attributes.Item<InstanceType<T>>[]\n): ComponentDecorator<T> {\n  return Component({\n    define(defContext) {\n\n      const registry = defContext.get(AttributeRegistry);\n\n      for (const item of items) {\n        if (typeof item === 'string') {\n\n          const name = property2attributeName(item);\n\n          registry.declareAttribute({\n            name,\n            change: attributeStateUpdate(name),\n          });\n        } else {\n          for (const [key, updateState] of Object.entries(item)) {\n\n            const name = property2attributeName(key);\n\n            registry.declareAttribute({\n              name,\n              change: attributeStateUpdate(name, updateState),\n            });\n          }\n        }\n      }\n    },\n  });\n}\n\nexport namespace Attributes {\n\n  /**\n   * Attribute definition item.\n   *\n   * This is either an attribute name (_camelCase_ or _dash-style_), or a per-attribute options map.\n   *\n   * @typeparam T  A type of component.\n   */\n  export type Item<T extends object> = Map<T> | string;\n\n  /**\n   * Per-attribute definition options.\n   *\n   * This is a map with attribute names as keys (either _camelCase_ or _dash-style_), and their state update\n   * instructions as values.\n   *\n   * The state update instruction can be one of:\n   * - `false` to not update the component state,\n   * - `true` to update the component state with changed attribute key,\n   * - a state value key to update, or\n   * - an attribute update receiver function with custom state update logic.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Map<T extends object> {\n    readonly [name: string]: boolean | StatePath | AttributeUpdateReceiver<T>;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSlot, SimpleContextKey } from '@proc7ts/context-values';\nimport { eventSupplyOf, StateTracker } from '@proc7ts/fun-events';\nimport { ComponentContext, StateUpdater } from '../../component';\n\nclass ComponentStateKey extends SimpleContextKey<ComponentState> {\n\n  constructor() {\n    super('component-state');\n  }\n\n  grow(\n      slot: ContextValueSlot<ComponentState, ComponentState, SimpleContextKey.Seed<ComponentState>>,\n  ): void {\n\n    const provided = slot.seed();\n    let state: ComponentState;\n\n    if (provided != null) {\n      state = provided;\n      slot.insert(state);\n    } else if (slot.hasFallback) {\n      return;\n    } else {\n      state = new ComponentState();\n      eventSupplyOf(slot.context.get(ComponentContext)).whenOff(reason => state.done(reason));\n      slot.insert(state);\n    }\n\n    slot.setup(({ registry }) => {\n      registry.provide({ a: StateUpdater, is: state.update });\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new ComponentStateKey());\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing component state properties.\n *\n * Thus a property state path is always something like `[StatePropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const StatePropertyPath__root = (/*#__PURE__*/ Symbol('state-property'));\n\n/**\n * A path to the named component property state.\n *\n * @category Feature\n */\nexport type StatePropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof StatePropertyPath__rootKeys, K];\n\n/**\n * Constructs a named component property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function statePropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): StatePropertyPath<K> {\n  return [StatePropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface StatePropertyPath__rootKeys {\n  [StatePropertyPath__root]: true;\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { StatePropertyPath, statePropertyPathTo } from './state-property-path';\nimport { StatePropertyUpdateReceiver } from './state-property.decorator';\n\n/**\n * @internal\n */\nexport type StatePropertyUpdateCallback<T extends object> = <K extends keyof T>(\n    this: void,\n    component: T,\n    newValue: T[K],\n    oldValue: T[K],\n) => void;\n\n/**\n * @internal\n */\nexport function statePropertyUpdate<T extends object>(\n    propertyKey: PropertyKey,\n    updateState: true | StatePropertyUpdateReceiver<T> | StatePath = true,\n): StatePropertyUpdateCallback<T> {\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = statePropertyPathTo(propertyKey as keyof T);\n    const update = updateState === true ? updateStatePropertyState : updateState;\n\n    return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n    }\n  };\n}\n\nfunction updateStatePropertyState<T extends object, K extends keyof T>(\n    component: T,\n    path: StatePropertyPath<K>,\n    newValue: T[K],\n    oldValue: T[K],\n): void {\n  if (newValue !== oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StatePropertyPath } from './state-property-path';\nimport { statePropertyUpdate } from './state-property-update.impl';\n\n/**\n * Creates a decorator of component property containing part of component state.\n *\n * Once such property updated, the component state is {@link ComponentContext.updateState also updated}.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Custom element property definition.\n *\n * @returns Component property decorator.\n */\nexport function StateProperty<V = any, T extends ComponentClass = Class>(\n    { updateState }: StatePropertyDef = {},\n): ComponentPropertyDecorator<V, T> {\n  return ComponentProperty(({ get, set, key }) => {\n    if (updateState !== false) {\n\n      const setValue = set;\n      const update = statePropertyUpdate<InstanceType<T>>(key, updateState);\n\n      set = (component, newValue) => {\n\n        const oldValue = get(component);\n\n        setValue(component, newValue);\n        update(component, newValue, oldValue);\n      };\n    }\n\n    return {\n      get,\n      set,\n    };\n  });\n}\n\n/**\n * Component state property definition.\n *\n * This is a parameter to {@link StateProperty @StateProperty} decorator applied to component property.\n *\n * @category Feature\n */\nexport interface StatePropertyDef<T extends object = any> {\n\n  /**\n   * Whether to update the component state after this property changed.\n   *\n   * Can be one of:\n   * - `false` to not update the component state,\n   * - `true` (the default value) to update the component state with changed property key,\n   * - a state value key to update, or\n   * - an state property update receiver function with custom state update logic.\n   *\n   * By default does not update component state if property value didn't change.\n   */\n  readonly updateState?: boolean | StatePath | StatePropertyUpdateReceiver<T>;\n\n}\n\n/**\n * Component state property updates receiver invoked when its value changed.\n *\n * @category Feature\n * @typeparam T  A type of component.\n */\nexport type StatePropertyUpdateReceiver<T extends object> =\n/**\n * @typeparam K  A type of component property keys.\n * @param component  Component instance.\n * @param path  The changed property state path in the form of `[StatePropertyPath__root, propertyKey]`.\n * @param newValue  New property value.\n * @param oldValue  Previous property value.\n */\n    <K extends keyof T>(\n        this: void,\n        component: T,\n        path: StatePropertyPath<K>,\n        newValue: T[K],\n        oldValue: T[K],\n    ) => void;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  eventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  StatePath,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly [EventSupply__symbol] = eventSupply();\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _name: string,\n      private readonly _path: StatePath,\n  ) {\n    super();\n  }\n\n  get it(): string | null {\n    return this._context.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (!eventSupplyOf(this).isOff) {\n      if (value == null) {\n        this._context.element.removeAttribute(this._name);\n      } else {\n        this._context.element.setAttribute(this._name, value);\n      }\n    }\n  }\n\n  on(): OnEvent<[string | null, string | null]>;\n  on(receiver: EventReceiver<[string | null, string | null]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[string | null, string | null]>,\n  ): OnEvent<[string | null, string | null]> | EventSupply {\n    return (this.on = this._context.get(ComponentState).track(this._path).onUpdate().thru(\n        (_path, newValue, oldValue) => nextArgs(newValue, oldValue),\n    ).tillOff(this).F)(receiver);\n  }\n\n}\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires [[AttributesSupport]] feature to be enabled and attribute to be defined. E.g. with {@link Attribute\n * @Attribute}, {@link AttributeChanged @AttributeChanged}, or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context  Target component context.\n * @param name  Attribute name.\n * @param path  Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n  return new AttributeTracker(context, name, path);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Class } from '../../common';\nimport { ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\n\n/**\n * A registry of component's element properties.\n *\n * @category Feature\n */\nexport interface DomPropertyRegistry {\n\n  /**\n   * Declares component element's property.\n   *\n   * @param descriptor  Property descriptor.\n   */\n  declareDomProperty(descriptor: DomPropertyDescriptor): void;\n\n}\n\n/**\n * A key of component definition context value containing {@link DomPropertyRegistry DOM property registry}.\n *\n * @category Feature\n */\nexport const DomPropertyRegistry: ContextRef<DomPropertyRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<DomPropertyRegistry>(\n        'dom-property-registry',\n        {\n          byDefault(context) {\n            return new DomPropertyRegistry$(context.get(DefinitionContext));\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nclass DomPropertyRegistry$ implements DomPropertyRegistry {\n\n  private readonly props = new Map<PropertyKey, PropertyDescriptor>();\n\n  constructor(defContext: DefinitionContext) {\n    defContext.whenReady(\n        ({ elementType }) => this.define(elementType),\n    );\n    defContext.whenComponent(({ mount }) => {\n      if (mount) {\n        // Mount element properties\n        this.mount(mount);\n      }\n    });\n  }\n\n  declareDomProperty({ key, descriptor }: DomPropertyDescriptor): void {\n    this.props.set(key, descriptor);\n  }\n\n  private define<T extends object>(elementType: Class<T>): void {\n\n    const prototype = elementType.prototype;\n\n    this.props.forEach((desc, key) => {\n      Object.defineProperty(prototype, key, desc);\n    });\n  }\n\n  private mount<T extends object>({ element }: ComponentMount<T>): void {\n    this.props.forEach((desc, key) => {\n      Object.defineProperty(element, key, desc);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n */\nexport type DomPropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath__rootKeys, K];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): DomPropertyPath<K> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface DomPropertyPath__rootKeys {\n  [DomPropertyPath__root]: true;\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { DomPropertyUpdateReceiver } from './dom-property-def';\nimport { DomPropertyPath, domPropertyPathTo } from './dom-property-path';\n\n/**\n * @internal\n */\nexport type DomPropertyUpdateCallback<T extends object> = <K extends keyof T>(\n    this: void,\n    component: T,\n    newValue: T[K],\n    oldValue: T[K],\n) => void;\n\n/**\n * @internal\n */\nexport function domPropertyUpdate<T extends object>(\n    propertyKey: PropertyKey,\n    updateState: true | DomPropertyUpdateReceiver<T> | StatePath = true,\n): DomPropertyUpdateCallback<T> {\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = domPropertyPathTo(propertyKey as keyof T);\n    const update = updateState === true ? updateDomPropertyState : updateState;\n\n    return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n  return (component, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n    }\n  };\n}\n\nfunction updateDomPropertyState<T extends object, K extends keyof T>(\n    component: T,\n    path: DomPropertyPath<K>,\n    newValue: T[K],\n    oldValue: T[K],\n): void {\n  if (newValue !== oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../../common';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { DomPropertyDef } from './dom-property-def';\nimport { domPropertyDescriptor } from './dom-property-descriptor.impl';\nimport { DomPropertyRegistry } from './dom-property-registry';\nimport { domPropertyUpdate } from './dom-property-update.impl';\n\n/**\n * Creates component property decorator that declares a property to add to custom element created for this component.\n *\n * The value of declared element's property will be read from and written to decorated one.\n *\n * By default does not update component state if property value didn't change.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Custom element property definition.\n *\n * @returns Component property decorator.\n */\nexport function DomProperty<V = any, T extends ComponentClass = Class>(\n    def: DomPropertyDef<T> = {},\n): ComponentPropertyDecorator<V, T> {\n  return ComponentProperty(descriptor => {\n\n    const { key, get } = descriptor;\n    let { set } = descriptor;\n    const domDescriptor = domPropertyDescriptor(descriptor, def);\n\n    if (def.updateState !== false) {\n\n      const updateState = domPropertyUpdate<InstanceType<T>>(key, def.updateState);\n      const setValue = set;\n\n      set = (component, newValue) => {\n\n        const oldValue = get(component);\n\n        setValue(component, newValue);\n        updateState(component, newValue, oldValue);\n      };\n    }\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(DomPropertyRegistry).declareDomProperty(domDescriptor);\n        },\n      },\n      get,\n      set,\n    };\n  });\n}\n\n/**\n * Component method decorator that declares a method to add to custom element created for this component.\n *\n * This is just an alias of {@link DomProperty @DomProperty} decorator.\n *\n * @category Feature\n */\nexport { DomProperty as DomMethod };\n","import { PropertyAccessorDescriptor } from '../../common';\nimport { ComponentContext, ComponentProperty } from '../../component';\nimport { DomPropertyDef } from './dom-property-def';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\n\n/**\n * @internal\n */\nexport function domPropertyDescriptor<V>(\n    propertyDesc: ComponentProperty.Descriptor<V>,\n    {\n      propertyKey: key = propertyDesc.key,\n      configurable = propertyDesc.configurable,\n      enumerable = propertyDesc.enumerable,\n      writable = propertyDesc.writable,\n    }: DomPropertyDef,\n): DomPropertyDescriptor {\n\n  const componentPropertyKey = propertyDesc.key;\n  const descriptor: PropertyAccessorDescriptor<V> = {\n    configurable,\n    enumerable,\n    get: function (this: any) {\n      return (ComponentContext.of(this).component as any)[componentPropertyKey];\n    },\n    set: writable\n        ? function (this: any, value: any) {\n          (ComponentContext.of(this).component as any)[componentPropertyKey] = value;\n        }\n        : undefined,\n  };\n\n  return { key, descriptor };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip, valueByRecipe } from '@proc7ts/call-thru';\nimport { EventSender, isEventSender, OnEvent, onSupplied, StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\n\n/**\n * Element rendering definition.\n *\n * This is either a {@link RenderDef.Spec rendering specifier}, or its {@link RenderDef.Provider provider function}.\n *\n * @category Feature\n */\nexport type RenderDef =\n    | RenderDef.Spec\n    | RenderDef.Provider;\n\nexport namespace RenderDef {\n\n  /**\n   * Rendering options.\n   */\n  export interface Options {\n\n    /**\n     * When to start the rendering.\n     *\n     * One of:\n     * - `settled` (the default) - start rendering when component is {@link ComponentContext.settled settled}.\n     * - `connected` - start rendering when component's element is {@link ComponentContext.connected connected}\n     *   to document.\n     */\n    readonly when?: 'settled' | 'connected';\n\n    /**\n     * Reports rendering error. E.g. a render shot execution failure.\n     *\n     * @param messages  Error messages to report.\n     */\n    error?(...messages: any[]): void;\n\n  }\n\n  /**\n   * Rendering specifier.\n   */\n  export interface Spec extends Options {\n\n    /**\n     * A trigger that issues rendering.\n     *\n     * This can be useful e.g. when component has multiple independent sub-views.\n     *\n     * This can be one of the following:\n     * - A path to component state part the renderer should track. The rendering would trigger only when the target\n     *   state part is updated.\n     * - Arbitrary event sender. The rendering would be triggered on any event from this sender.\n     *\n     * A root state path is tracked when omitted.\n     *\n     * When trigger is a root path (the default value), then the rendering will be triggered by any state update.\n     * Except for updates of sub-states inside {@link RenderPath__root}.\n     */\n    readonly on?: StatePath | EventSender<[]>;\n\n  }\n\n  /**\n   * Rendering specifier provider signature.\n   */\n  export type Provider =\n  /**\n   * @param context  A context of component to render.\n   *\n   * @returns Rendering specifier.\n   */\n      (\n          this: void,\n          context: ComponentContext,\n      ) => RenderDef.Spec;\n\n}\n\n/**\n * A root path to sub-states updates to which will be ignored by default.\n *\n * This can be used to create sub-states that won't trigger rendering occasionally, but only when requested explicitly.\n *\n * @category Feature\n */\nexport const RenderPath__root = (/*#__PURE__*/ Symbol('render'));\n\n/**\n * @category Feature\n */\nexport const RenderDef = {\n\n  /**\n   * Builds a rendering specifier for component by its definition.\n   *\n   * @param context  A context of component to render.\n   * @param def  Arbitrary rendering definition.\n   *\n   * @returns Rendering specifier.\n   */\n  spec(\n      this: void,\n      context: ComponentContext,\n      def: RenderDef,\n  ): RenderDef.Spec {\n    return valueByRecipe(def, context);\n  },\n\n  /**\n   * Fulfills rendering specifier with the given defaults.\n   *\n   * @param base  Base rendering specifier to fulfill.\n   * @param defaults  Defaults that will be applied unless defined in `base` specifier.\n   *\n   * @return `base` rendering specifier fulfilled by `defaults`.\n   */\n  fulfill(this: void, base: RenderDef.Spec, defaults: RenderDef.Spec = {}): RenderDef.Spec {\n\n    const { on = defaults.on, error } = base;\n\n    return {\n      on,\n      error: error ? error.bind(base) : defaults.error && defaults.error.bind(defaults),\n    };\n  },\n\n  /**\n   * Builds a trigger issuing rendering updates.\n   *\n   * @param context  Rendered component context.\n   * @param spec  Rendering specifier.\n   *\n   * @returns `OnEvent` sender that sends an event each time the rendering required.\n   */\n  trigger(\n      this: void,\n      context: ComponentContext,\n      spec: RenderDef.Spec = {},\n  ): OnEvent<[]> {\n\n    const { on = [] } = spec;\n\n    if (typeof on === 'object' && isEventSender(on)) {\n      return onSupplied(on).tillOff(context);\n    }\n\n    const trigger = context\n        .get(ComponentState)\n        .track(on)\n        .onUpdate()\n        .tillOff(context);\n\n    if (Array.isArray(on) && !on.length) {\n      return trigger.thru_(\n          (path: StatePath.Normalized) => path[0] === RenderPath__root ? nextSkip : nextArgs(),\n      );\n    }\n\n    return trigger;\n  },\n\n};\n","import { noop } from '@proc7ts/call-thru';\nimport { EventSupply } from '@proc7ts/fun-events';\nimport { immediateRenderScheduler, RenderExecution } from '@proc7ts/render-scheduler';\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * @internal\n */\nconst enum RenderStatus {\n  Cancelled = -1,\n  Complete = 0,\n  Pending = 1,\n  Scheduled = 2,\n}\n\n/**\n * @internal\n */\nexport class ElementRenderCtl$ implements ElementRenderCtl {\n\n  private readonly _renders = new Set<() => void>();\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  renderBy(\n      renderer: ElementRenderer,\n      def: RenderDef = {},\n  ): EventSupply {\n\n    const spec = RenderDef.spec(this._context, def);\n    const trigger = RenderDef.trigger(this._context, spec);\n    const schedule = this._context.get(DefaultRenderScheduler)({\n      ...RenderDef.fulfill(spec),\n      node: this._context.element,\n    });\n    const whenConnected = spec.when === 'connected';\n    let status = RenderStatus.Pending;\n    const startRendering = (): 0 | void => status /* there is an update to render */ && scheduleRenderer();\n    const onUpdate = whenConnected\n        ? () => this._context.connected && scheduleRenderer()\n        : () => this._context.settled && scheduleRenderer();\n    const supply = trigger\n        .to(onUpdate)\n        .needs(this._context)\n        .whenOff(cancelRenderer);\n\n    (whenConnected ? this._context.whenConnected() : this._context.whenSettled()).to(startRendering);\n\n    const immediateSchedule = immediateRenderScheduler();\n\n    this._renders.add(renderNow);\n\n    return supply.whenOff(() => this._renders.delete(renderNow));\n\n    function scheduleRenderer(): void {\n      status = RenderStatus.Scheduled;\n      schedule(renderElement);\n    }\n\n    function renderNow(): void {\n      immediateSchedule(renderElement);\n    }\n\n    function cancelRenderer(): void {\n      if (status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet\n        schedule(noop);\n      }\n      status = RenderStatus.Cancelled;\n    }\n\n    function renderElement(execution: RenderExecution): void {\n      if (status > RenderStatus.Complete) { // Prevent excessive rendering\n        status = RenderStatus.Complete;\n        for (; ;) {\n\n          const newRenderer = renderer(execution);\n\n          if (newRenderer === renderer || typeof newRenderer !== 'function') {\n            break;\n          }\n\n          renderer = newRenderer;\n        }\n      }\n    }\n  }\n\n  renderNow(): void {\n    this._renders.forEach(render => render());\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { EventSupply } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl$ } from './element-render-ctl.impl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A render control of component's element.\n *\n * Controls rendering by {@link ElementRenderer element renderers}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport interface ElementRenderCtl {\n\n  /**\n   * Enables component element rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n   *\n   * @param renderer  Element renderer function.\n   * @param def  Optional element rendering definition.\n   *\n   * @returns Render shots supply. Element `renderer` will stop rendering once this supply is cut off.\n   */\n  renderBy(\n      renderer: ElementRenderer,\n      def?: RenderDef,\n  ): EventSupply;\n\n  /**\n   * Executes scheduled element render shots immediately.\n   *\n   * Uses `immediateRenderScheduler` for that.\n   *\n   * Does not execute element renderers that are not scheduled. I.e. if no corresponding state updates happened.\n   */\n  renderNow(): void;\n\n}\n\n/**\n * A key of component context value containing {@link ElementRenderCtl element render control}.\n *\n * @category Feature\n */\nexport const ElementRenderCtl: ContextRef<ElementRenderCtl> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderCtl>(\n        'element-render-ctl',\n        {\n          byDefault(values) {\n            return new ElementRenderCtl$(values.get(ComponentContext));\n          },\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextRef, ContextValues, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue } from '@proc7ts/fun-events';\nimport { RenderSchedule, RenderScheduleOptions, RenderShot } from '@proc7ts/render-scheduler';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A signature of element render scheduler.\n *\n * Schedules render shots to be executed by {@link ElementRenderCtl element render control}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport type ElementRenderScheduler =\n/**\n * @param options  Options of constructed element render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: ElementRenderScheduleOptions) => RenderSchedule;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link ElementRenderScheduler element render scheduler} when constructing new render schedule.\n *\n * Generic `RenderSchedule` options are ignored.\n *\n * @category Feature\n */\nexport interface ElementRenderScheduleOptions extends RenderScheduleOptions, RenderDef.Options {\n\n  /**\n   * When to start the rendering.\n   *\n   * One of:\n   * - `settled` - start rendering when component is {@link ComponentContext.settled settled}.\n   * - `connected` (the default) - start rendering when component's element is {@link ComponentContext.connected\n   *   connected} to document.\n   */\n  readonly when?: 'settled' | 'connected';\n\n  /**\n   * Reports rendering error. E.g. a render shot execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * @internal\n */\nfunction newElementRenderScheduler(context: ContextValues): ElementRenderScheduler {\n\n  const renderCtl = context.get(ElementRenderCtl);\n\n  return (opts = {}): RenderSchedule => {\n\n    const recentShot = trackValue<RenderShot>(noop);\n    const renderer: ElementRenderer = execution => {\n      recentShot.it(execution);\n    };\n\n    renderCtl.renderBy(renderer, RenderDef.fulfill({ on: recentShot.on() }, opts));\n\n    return (shot: RenderShot): void => {\n      recentShot.it = execution => shot(execution); // Ensure render shot always updated\n    };\n  };\n}\n\n/**\n * A key of component context value containing {@link ElementRenderScheduler element render scheduler}.\n *\n * @category Feature\n */\nexport const ElementRenderScheduler: ContextRef<ElementRenderScheduler> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderScheduler>(\n        'element-render-scheduler',\n        {\n          byDefault: newElementRenderScheduler,\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { RenderExecution } from '@proc7ts/render-scheduler';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * Enables rendering with {@link ElementRenderCtl.renderBy element render control}.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(\n    def?: RenderDef,\n): ComponentPropertyDecorator<(execution: RenderExecution) => ElementRenderer | void, T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n            const renderer = get(component).bind(component);\n\n            context.get(ElementRenderCtl).renderBy(renderer, def);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> = (\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * An event related to element's shadow DOM.\n *\n * The following event types supported:\n * - `wesib:shadowAttached` is dispatched when a shadow root is attached to element.\n *   In particular, it is dispatched for components decorated with {@link AttachShadow @AttachShadow}.\n *   The event is dispatched when component is connected for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Feature\n */\nexport class ShadowDomEvent extends Event {\n\n  /**\n   * Shadow root this event relates to.\n   */\n  get shadowRoot(): ShadowRoot {\n    return (this.target as Element).shadowRoot as ShadowRoot;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\nimport { ShadowContentDef } from './attach-shadow.decorator';\nimport { ShadowDomEvent } from './shadow-dom-event';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses one.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context  Target component context.\n * @param init  Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>(\n        'shadow-root-builder',\n        {\n          byDefault() {\n            return attachShadow;\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const element = context.element;\n  const shadowRoot = shadowRootOf(element, init);\n\n  if (shadowRoot) {\n    (shadowRoot as any)[ComponentContext__symbol] = context;\n    context.whenConnected(() => context.dispatchEvent(new ShadowDomEvent(\n        'wesib:shadowAttached',\n        { bubbles: true },\n    )));\n  }\n\n  return shadowRoot;\n}\n\n/**\n * @internal\n */\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../../common';\nimport { Component, ComponentContext, ComponentDecorator, ContentRoot } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\n/**\n * Creates a component decorator that attaches shadow root to decorated component instance.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component decorator.\n */\nexport function AttachShadow<T extends ComponentClass = Class>(\n    def: ShadowContentDef = defaultShadowContentDef,\n): ComponentDecorator<T> {\n  return Component({\n    setup(setup) {\n      setup.perComponent(\n          {\n            a: ShadowContentRoot,\n            by(ctx: ComponentContext<InstanceType<T>>) {\n              return ctx.get(ShadowRootBuilder)(ctx, def);\n            },\n          },\n      );\n      setup.perComponent({ // Content root is an alias of shadow root when present.\n        a: ContentRoot,\n        by(context: ComponentContext<InstanceType<T>>) {\n          return context.get(ShadowContentRoot, { or: null });\n        },\n      });\n    },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { NamespaceDef } from '@proc7ts/namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n"],"names":["BootstrapContext__key","SingleContextKey","BootstrapContext","ContextValues","ContextKey__symbol","bootstrapDefault","provide","context","key","bootstrapContext","get","isArray","value","Array","ArraySet","[object Object]","this","items","Set","size","itsFirst","from","Symbol","iterator","addAll","itsEach","item","add","superClassOf","type","satisfying","prototype","Object","getPrototypeOf","superType","constructor","decoratePropertyAccessor","target","propertyKey","desc","updateDescriptor","isField","updatedDesc","undefined","writable","isPropertyAccessorDescriptor","value__symbol","initial","accessorDesc","set","newValue","toPropertyAccessorDescriptor","fieldKey","String","configurable","enumerable","fieldAccessorDescriptor","defineProperty","mergeFunctions","first","second","merge","_f","s","args","apply","isElement","node","nodeType","Node","ELEMENT_NODE","MetaAccessor","symbol","hasOwnProperty","ownDef","own","superDef","of","sources","prevMeta","updates","mapIt","source","meta","newMeta","flatMapIt","PromiseResolver","promise","Promise","resolve","reject","_resolve","_reject","error","FeatureDef__symbol","FeatureMeta","super","defs","itsReduction","prev","def","needs","has","setup","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","FeatureNeedsError","Error","reduce","reason","need","name","FeatureRef","AfterEvent__symbol","read","ComponentDef__symbol","ComponentMeta","isQualifiedName","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","values","dispatcher","DomEventDispatcher","element","eventSupplyOf","dispatch","event","on","ContentRoot","byDefault","ctx","StateUpdaterKey","ContextUpKey","upKey","createUpKey","slot","insert","seed","keepThru","fns","length","combined","fn","noop","path","oldValue","statePath","hasFallback","or","nextAfterEvent","delegated","afterThe","to","whenOff","StateUpdater","ComponentContext__symbol","ComponentContext","updateState","TypeError","contentRoot","ComponentEvent","Event","AnonymousComponentProperty__symbol","ComponentProperty","decorateWith","readable","component","componentDef","By","provider","result","proto","descriptor","getValue","setValue","call","notReadableAccessor","notWritableAccessor","updated","With","access","As","valueProvider","Bind","binder","accessor__symbol","accessor","existing","bind","BootstrapContextRegistry__key","BootstrapContextRegistry","ContextRegistry","a","is","newValues","ComponentContextRegistry__key","ComponentContextRegistry","DefinitionContextRegistry__key","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","tracker","trackValue","emitter","EventEmitter","onSetup","thru","nextArgs","nextSkip","onAny","superPostDefSetup","send","it","BootstrapWindow","window","BootstrapRoot","document","body","DefaultNamespaceAliaser","DefaultRenderSchedulerKey","toDefaultRenderScheduler","newRenderSchedule","scheduler","contextDestroyed","options","DefaultRenderScheduler","ElementAdapterKey","adapters","adapter","defaultElementAdapter","ElementAdapter","ElementObserver","FnContextKey","bsContext","DefaultElementObserver","MutationObserver","callback","mutations","forEach","mutation","overArray","removedNodes","mount","mountOf","checkConnected","filterIt","addedNodes","observe","childList","DefinitionContext__symbol","definitionContextOf","CustomElements__key","customElements","nsAlias","CustomElements","componentTypeOrName","elementType","html__naming","defContext","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","mountTo","connect","ComponentContext$","_definitionContext","registry","_newComponentRegistry","_component","settled","_status","isOff","connected","EventSupply__symbol","receiver","whenReady","thru_","status","once","F","whenSettled","nextArg","whenConnected","done","componentDestroyed","parentNode","removeChild","removeElement","whenComponent","_whenComponent","lastRev","readNotifier","notifier","supply","eventSupply","receive","_","_elementBuilder","components","prevContext","newComponent","dispatchEvent","bubbles","ComponentMount$","_connect","el","doc","ownerDocument","contains","destroy","MountComponentContext$","definitionContext","CustomComponentContext$","WhenComponent","currentRev","created","onCreated","onEventBy","receiverRev","eventContext","componentContext","notifiedRev","recurrentReceiver","onRecurrent","recurrentContext","keepThru_","rev","DefinitionContext$","_bsContext","_ready","_whenReady","ready","_def","definitionContextRegistry","seedIn","_perTypeRegistry","whenReady$","whenComponent$","definitionSetup","perDefinition","spec","perComponent","_elementType","_createComponent","_created","settle","append","definitions","CustomElement$","connectedCallback","disconnectedCallback","customElementType","ElementBuilder","_define","doNotAdd","ComponentRegistry","_context","_definitionQueue","definition","push","buildElement","FeatureContext$","_loader","unloads","adder","unload","reverse","newUnloader","_componentRegistry","request","afterAll","st","state","bs","by","onDefinition","tillOff","_unloader","onComponent","unloader","onPostDefSetup","FeatureKey__symbol","FeatureKey","preferredFeatureClause","afterEventBy","origin","stageId","clause","deps","loadFeatureDeps","loader","stage","ownLoader","FeatureLoader","ownSource","rcv","share","lastLoader","preventDuplicateLoader","clauses","preferred","required","afterEach","dep","presentFeatureDeps","isPresent","down","_down","_stage","SetupFeatureStage","then","after","lastStage","id","prevStage","stop","FeatureStage","_stop","action","map","perDep","InitFeatureStage","off","ActiveFeatureStage","FeatureRequest","_requester","_revoke","featureDef","requester","isClause","_revokeBy","unuse","_uses","revoke","FeatureRequester__key","FeatureRequester","Map","_map","reuse","delete","WhenDefined__symbol","bootstrapComponents","features","bootstrapContextRegistry","create","complete","newNamespaceAliaser","onPromise","info","_ctx","ldr","catch","console","whenDown","initBootstrap","AttributePath__root","attributePathTo","attributeStateUpdate","update","updateAttributeState","property2attributeName","i","c","substring","toLowerCase","parseAttributeDescriptor","opts","change","AttributeRegistry","AttributeRegistry$","attrs","observedAttributes","keys","attributeChangedCallback","attributeFilter","records","record","attributeName","getAttribute","attributes","attributeOldValue","alreadyObserved","prevCallback","attrChanged","Attribute","declareAttribute","setAttribute","removeAttribute","AttributeChanged","Attributes","entries","ComponentStateKey","SimpleContextKey","provided","ComponentState","ComponentState__key","StateTracker","StatePropertyPath__root","statePropertyPathTo","updateStatePropertyState","StateProperty","statePropertyUpdate","AttributeTracker","ValueTracker","_name","_path","track","onUpdate","trackAttribute","DomPropertyRegistry","DomPropertyRegistry$","props","DomPropertyPath__root","domPropertyPathTo","updateDomPropertyState","DomProperty","domDescriptor","propertyDesc","componentPropertyKey","domPropertyDescriptor","domPropertyUpdate","declareDomProperty","RenderPath__root","RenderDef","valueByRecipe","base","defaults","isEventSender","onSupplied","trigger","ElementRenderCtl$","renderer","schedule","fulfill","when","scheduleRenderer","immediateSchedule","immediateRenderScheduler","_renders","renderNow","renderElement","execution","newRenderer","render","ElementRenderCtl","ElementRenderScheduler","renderCtl","recentShot","renderBy","shot","Render","ShadowContentRoot","ShadowDomEvent","shadowRoot","ShadowRootBuilder","attachShadow","shadowRootOf","defaultShadowContentDef","mode","AttachShadow","Wesib__NS","NamespaceDef"],"mappings":"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"}