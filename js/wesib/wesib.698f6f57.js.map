{"version":3,"file":"wesib.698f6f57.js","sources":["../../../node_modules/@wesib/wesib/src/boot/bootstrap-context.key.impl.ts","../../../node_modules/@wesib/wesib/src/boot/bootstrap-context.ts","../../../node_modules/@wesib/wesib/src/boot/bootstrap-default.ts","../../../node_modules/@wesib/wesib/src/component/definition/component-factory.ts","../../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-window.ts","../../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-root.ts","../../../node_modules/@wesib/wesib/src/boot/globals/default-namespace-aliaser.ts","../../../node_modules/@wesib/wesib/src/boot/globals/default-render-scheduler.ts","../../../node_modules/@wesib/wesib/src/common/types.impl.ts","../../../node_modules/@wesib/wesib/src/common/array-set.ts","../../../node_modules/@wesib/wesib/src/common/classes.ts","../../../node_modules/@wesib/wesib/src/common/decorators.ts","../../../node_modules/@wesib/wesib/src/common/reflect.ts","../../../node_modules/@wesib/wesib/src/common/functions.ts","../../../node_modules/@wesib/wesib/src/common/is-element.ts","../../../node_modules/@wesib/wesib/src/common/meta-accessor.ts","../../../node_modules/@wesib/wesib/src/common/promises.ts","../../../node_modules/@wesib/wesib/src/feature/feature-def.ts","../../../node_modules/@wesib/wesib/src/feature/feature.decorator.ts","../../../node_modules/@wesib/wesib/src/feature/feature-context.ts","../../../node_modules/@wesib/wesib/src/feature/feature-needs-error.ts","../../../node_modules/@wesib/wesib/src/component/component-def.ts","../../../node_modules/@wesib/wesib/src/component/component.decorator.ts","../../../node_modules/@wesib/wesib/src/component/component-context.key.impl.ts","../../../node_modules/@wesib/wesib/src/component/component-event.key.impl.ts","../../../node_modules/@wesib/wesib/src/component/content-root.ts","../../../node_modules/@wesib/wesib/src/component/state-updater.ts","../../../node_modules/@wesib/wesib/src/component/component-context.ts","../../../node_modules/@wesib/wesib/src/component/component-event.ts","../../../node_modules/@wesib/wesib/src/component/component-property.decorator.ts","../../../node_modules/@wesib/wesib/src/boot/globals/element-adapter.ts","../../../node_modules/@wesib/wesib/src/boot/globals/element-observer.ts","../../../node_modules/@wesib/wesib/src/boot/impl/component-factory.symbol.impl.ts","../../../node_modules/@wesib/wesib/src/component/definition/custom-elements.ts","../../../node_modules/@wesib/wesib/src/component/definition/definition.context.key.impl.ts","../../../node_modules/@wesib/wesib/src/component/definition/element-def.ts","../../../node_modules/@wesib/wesib/src/component/definition/definition-context.ts","../../../node_modules/@wesib/wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../../node_modules/@wesib/wesib/src/boot/impl/component-context-registry.impl.ts","../../../node_modules/@wesib/wesib/src/boot/impl/definition-context-registry.impl.ts","../../../node_modules/@wesib/wesib/src/boot/impl/post-def-setup.impl.ts","../../../node_modules/@wesib/wesib/src/boot/impl/when-component.impl.ts","../../../node_modules/@wesib/wesib/src/boot/impl/element-builder.impl.ts","../../../node_modules/@wesib/wesib/src/component/component-mount.ts","../../../node_modules/@wesib/wesib/src/boot/impl/unloader.impl.ts","../../../node_modules/@wesib/wesib/src/feature/loader/component-registry.impl.ts","../../../node_modules/@wesib/wesib/src/feature/loader/feature-loader.impl.ts","../../../node_modules/@wesib/wesib/src/feature/loader/feature-request.impl.ts","../../../node_modules/@wesib/wesib/src/feature/loader/feature-requester.impl.ts","../../../node_modules/@wesib/wesib/src/boot/bootstrap/bootstrap-components.ts","../../../node_modules/@wesib/wesib/src/feature/feature-ref.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attribute-descriptor.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attribute-path.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attribute-state-update.impl.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attribute-registry.impl.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attributes-support.feature.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attribute.decorator.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/attributes.decorator.ts","../../../node_modules/@wesib/wesib/src/feature/state/component-state.ts","../../../node_modules/@wesib/wesib/src/feature/state/state-property-path.ts","../../../node_modules/@wesib/wesib/src/feature/state/state-property-update.impl.ts","../../../node_modules/@wesib/wesib/src/feature/state/state-support.feature.ts","../../../node_modules/@wesib/wesib/src/feature/state/state-property.decorator.ts","../../../node_modules/@wesib/wesib/src/feature/attributes/track-attribute.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-descriptor.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-registry.impl.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-properties-support.feature.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-path.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-update.impl.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property.decorator.ts","../../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-descriptor.impl.ts","../../../node_modules/@wesib/wesib/src/feature/render/element-renderer.ts","../../../node_modules/@wesib/wesib/src/feature/render/render.decorator.ts","../../../node_modules/@wesib/wesib/src/wesib.ns.ts"],"sourcesContent":["import { SingleContextKey } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { Class } from '../common';\nimport { ComponentClass, ComponentFactory } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to [[FeatureDef.Options.init]] method so that the feature can configure itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * An `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[BootstrapContext]>;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentType  Component class constructor.\n   *\n   * @return A promise that is resolved to component factory when the given `componentType` is registered.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature  The feature to load.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class): FeatureRef;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @param provide  A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<Value, Key extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: Key) => Value | null | undefined,\n): ContextKeyDefault<Value, Key> {\n  return (context, key) => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext ? provide(bootstrapContext, key) : bootstrapContext.get(key);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Class } from '../../common';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { ElementDef } from './element-def';\n\n/**\n * @internal\n */\nconst ComponentFactory__key = (/*#__PURE__*/ new SingleContextKey<ComponentFactory>('component-factory'));\n\n/**\n * A factory of components of particular type.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentFactory<T extends object = any> {\n\n  /**\n   * A key of definition context value containing a component factory.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentFactory> {\n    return ComponentFactory__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  abstract readonly elementDef: ElementDef;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connected = true;\n\n    return mount;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = any;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of [[BootstrapWindow]].\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { NamespaceAliaser } from 'namespace-aliaser';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\nclass DefaultRenderSchedulerKey extends ContextUpKey<DefaultRenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<DefaultRenderScheduler, RenderScheduler>;\n\n  constructor() {\n    super('default-render-scheduler');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.thru(\n            (...fns) => {\n              if (fns.length) {\n                return toDefaultRenderScheduler(opts.context, fns[fns.length - 1]);\n              }\n\n              const defaultProvider = (): AfterEvent<[DefaultRenderScheduler]> => afterThe(\n                  toDefaultRenderScheduler(opts.context, newRenderSchedule),\n              );\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          DefaultRenderScheduler,\n          EventKeeper<RenderScheduler[]> | RenderScheduler,\n          AfterEvent<RenderScheduler[]>>,\n      ): DefaultRenderScheduler {\n\n    let delegated!: DefaultRenderScheduler;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(scheduler => delegated = toDefaultRenderScheduler(opts.context, scheduler));\n\n    return (...args) => delegated(...args);\n  }\n\n}\n\nfunction toDefaultRenderScheduler(\n    context: ContextValues,\n    scheduler: RenderScheduler,\n): DefaultRenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n\n/**\n * A key of bootstrap, definition, or component context value containing [[DefaultRenderScheduler]] instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new DefaultRenderSchedulerKey()\n);\n","/**\n * @internal\n */\nexport function isArray<T>(value: T | T[]): value is T[];\n\n/**\n * @internal\n */\nexport function isArray<T>(value: T | readonly T[]): value is readonly T[];\n\nexport function isArray<T>(value: T | readonly T[]): value is T[] {\n  return Array.isArray(value);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AIterable } from 'a-iterable';\nimport { isArray } from './types.impl';\n\n/**\n * @category Utility\n */\nexport class ArraySet<T> extends AIterable<T> {\n\n  readonly items: Set<T>;\n\n  constructor(value?: T | readonly T[]) {\n    super();\n    this.items = value == null ? new Set() : isArray(value) ? new Set(value) : new Set([value]);\n  }\n\n  get value(): T | T[] | undefined {\n    switch (this.items.size) {\n    case 0: return;\n    case 1: return this.items[Symbol.iterator]().next().value;\n    default: return [...this.items];\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.items[Symbol.iterator]();\n  }\n\n  add(...items: T[]): this {\n    items.forEach(item => this.items.add(item));\n    return this;\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  merge(items: readonly T[] | T | undefined): this {\n    if (items == null) {\n      return this;\n    }\n    if (isArray(items)) {\n      return this.add(...items);\n    }\n    return this.add(items);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Arbitrary class constructor.\n *\n * @category Utility\n * @typeparam T  A type of object.\n */\nexport interface Class<T extends object = any> extends Function {\n  new(...args: any[]): T;\n  prototype: T;\n}\n\n/**\n * Detects super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @category Utility\n * @param type  The class constructor to find super class of.\n * @param satisfying  The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  const prototype = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from './classes';\nimport { fieldAccessorDescriptor, PropertyAccessorDescriptor, toPropertyAccessorDescriptor } from './reflect';\n\n/**\n * Typed class decorator.\n *\n * @category Utility\n * @typeparam T  A type of class to decorate.\n */\nexport type TypedClassDecorator<T extends Class> = (type: T) => T | void;\n\n/**\n * Typed property decorator.\n *\n * @category Utility\n * @typeparam T  A type of class the decorated property belongs to.\n */\nexport type TypedPropertyDecorator<T extends Class> =\n    <V>(target: InstanceType<T>, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<V>) => any | void;\n\n/**\n * Property decorator helper converting a field or property to the one with accessor (`get` and optionally `set`).\n *\n * @category Utility\n * @typeparam T  A type of target object.\n * @typeparam V  A property value type.\n * @param target  Target object containing the property.\n * @param propertyKey  Target property key.\n * @param desc  Target property descriptor, or `undefined` for object fields.\n * @param updateDescriptor  Descriptor updater. Accepts the accessor descriptor as the only argument. If returns\n * a descriptor, then it is applied to the property. Otherwise the target property descriptor is never updated.\n *\n * @returns Updated property descriptor to return from decorator to apply to the property, or `undefined` if there is\n * nothing to update.\n */\nexport function decoratePropertyAccessor<T, V>(\n    target: T,\n    propertyKey: string | symbol,\n    desc: TypedPropertyDescriptor<V> | undefined,\n    updateDescriptor: (desc: PropertyAccessorDescriptor<V>) => PropertyAccessorDescriptor<V>,\n): PropertyAccessorDescriptor<V> | undefined {\n\n  const isField = !desc;\n  const accessorDesc: PropertyAccessorDescriptor<V> = desc\n      ? toPropertyAccessorDescriptor(desc)\n      : fieldAccessorDescriptor(target, propertyKey as keyof T) as any;\n  const updatedDesc = updateDescriptor(accessorDesc);\n\n  if (isField && updatedDesc) {\n    Object.defineProperty(target, propertyKey, updatedDesc);\n    return;\n  }\n\n  return updatedDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts an object field to property accessor.\n *\n * Defines a new property with the given name in the target object and returns its descriptor.\n *\n * The converted descriptor is always configurable, enumerable, and writable.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n *\n * @return New property accessor descriptor.\n */\nexport function field2accessor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const desc = fieldAccessorDescriptor(target, fieldKey);\n\n  Object.defineProperty(target, fieldKey, desc);\n\n  return desc;\n}\n\n/**\n * Creates an property accessor descriptor for the given field.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n */\nexport function fieldAccessorDescriptor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const value__symbol = Symbol(`${String(fieldKey)}:value`);\n  const initial: T[K] = target[fieldKey];\n\n  return {\n    configurable: true,\n    enumerable: true,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n    set(this: any, newValue) {\n      this[value__symbol] = newValue;\n    },\n  };\n}\n\n/**\n * Property accessor descriptor. I.e. the one with `get` and `set` functions.\n *\n * @category Utility\n * @typeparam V  Property value type.\n */\nexport interface PropertyAccessorDescriptor<V> extends TypedPropertyDescriptor<V> {\n  enumerable?: boolean;\n  configurable?: boolean;\n  writable?: undefined;\n  value?: undefined;\n  get?: () => V;\n  set?: (value: V) => void;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nexport function isPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): desc is PropertyAccessorDescriptor<V> {\n  return desc.value === undefined && desc.writable === undefined;\n}\n\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nexport function toPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): PropertyAccessorDescriptor<V> {\n  if (isPropertyAccessorDescriptor(desc)) {\n    return desc;\n  }\n\n  const value__symbol = Symbol('value');\n  const initial = desc.value as V;\n\n  const accessorDesc: PropertyAccessorDescriptor<V> = {\n    ...desc,\n    writable: undefined,\n    value: undefined,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n  };\n\n  if (desc.writable) {\n    accessorDesc.set = function (this: any, newValue: V) {\n      this[value__symbol] = newValue;\n    };\n  }\n\n  delete accessorDesc.writable;\n  delete accessorDesc.value;\n\n  return accessorDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @category Utility\n * @typeparam P  Function parameter types as tuple.\n * @typeparam R  A type of function result.\n * @typeparam T  A type if `this` object expected by function.\n * @param first  The first function to call.\n * @param second  The second function to call.\n * @param merge  Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<P extends any[], R, T>(\n    first: (this: T, ...args: P) => R,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: (this: T, ...args: P) => R,\n    merge?: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge?: (first: R, second: R) => R,\n): ((this: T, ...args: P) => R) | undefined;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R = (_f, s) => s,\n): ((this: T, ...args: P) => R) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: T, ...args: P): R {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node  A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { flatMapIt, mapIt } from 'a-iterable';\nimport { Class, superClassOf } from './classes';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<M, S = M> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): M | undefined {\n    // eslint-disable-next-line no-prototype-builtins\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] : undefined;\n  }\n\n  of(type: Class): M | undefined {\n\n    const ownDef: M | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<C extends Class>(type: C, sources: Iterable<S>): C {\n\n    const prevMeta = this.own(type);\n    const updates = mapIt(sources, source => this.meta(source, type));\n    const newMeta: M = this.merge(prevMeta ? flatMapIt([[prevMeta], updates]) : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: Iterable<M>): M;\n\n  protected abstract meta(source: S, type: Class): M;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * @category Utility\n */\nexport class PromiseResolver<T = void> {\n\n  readonly promise: Promise<T>;\n  private _resolve!: (value: T) => void;\n  private _reject!: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  resolve(value: T): void {\n    this._resolve(value);\n  }\n\n  reject(error: any): void {\n    this._reject(error);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from 'a-iterable';\nimport { BootstrapSetup } from '../boot';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup  Bootstrap setup.\n     */\n    setup?(setup: BootstrapSetup): void;\n\n    /**\n     * Bootstraps this feature by calling the given bootstrap context constructed.\n     *\n     * @param context  Feature initialization context.\n     */\n    init?(context: FeatureContext): void;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType  A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: Iterable<FeatureDef.Options>): FeatureDef.Options {\n    return itsReduction<FeatureDef.Options, FeatureDef.Options>(\n        defs,\n        (prev, def) => ({\n          needs: new ArraySet(prev.needs).merge(def.needs).value,\n          has: new ArraySet(prev.has).merge(def.has).value,\n          setup: mergeFunctions<[BootstrapSetup], void, Class>(prev.setup, def.setup),\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType  Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType  Target feature class constructor.\n   * @param def  A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs  Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs  Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return itsReduction<FeatureDef, FeatureDef.Factory>(\n        defs,\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeparam T  Feature type.\n   * @param featureType  Feature class constructor.\n   * @param defs  Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(this: void, featureType: T, ...defs: readonly FeatureDef[]): T {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to [[bootstrapComponents]] function or referenced by other features.\n *\n * This is an alternative to direct call to [[FeatureDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated feature class.\n * @param defs  Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, ...defs);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, ComponentFactory, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext extends BootstrapContext implements BootstrapSetup {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  abstract readonly whenReady: OnEvent<[FeatureContext]>;\n\n  abstract readonly onDefinition: OnEvent<[DefinitionContext]>;\n\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a [[BootstrapSetup.provide]] method can be used.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class): FeatureRef {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.Options.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.Options.has provides} another one.\n *\n * @category Core\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n *\n * @category Core\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs  Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: ' + needs.reduce(\n        (\n            prev,\n            [feature, reason, need],\n        ) => (prev ? prev : feature.name) + ` ${reason} ${need.name}`,\n        '',\n        ),\n    );\n    this.needs = needs;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from 'a-iterable';\nimport { isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup  Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param context  Component definition context.\n     */\n    define?(context: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType  A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: Iterable<ComponentDef.Options<T>>): ComponentDef.Options<T> {\n    return itsReduction<ComponentDef.Options<T>, ComponentDef.Options<T>>(\n        defs,\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as any)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as any)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType  Target component class constructor.\n   * @param source  A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return itsReduction<ComponentDef<T>, ComponentDef.Factory<T>>(\n        defs,\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under [[ComponentDef__symbol]] key.\n   *\n   * Each component can be passed directly to [[bootstrapComponents]] function or added as a requirement\n   * of another feature.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   * @param defs  Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      this: void,\n      componentType: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by [[Component]] function.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n */\nexport type ComponentDecorator<T extends ComponentClass = Class> =\n    & ((this: void, type: T) => T | void)\n    & ComponentDef<InstanceType<T>>;\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with [[FeatureContext.define]] method or used as a feature, e.g. passed to\n * [[bootstrapComponents]] function, or added to [[FeatureDef.Options.needs]] property of another feature.\n *\n * This is an alternative to direct call to [[ComponentDef.Options.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n * @param defs  Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<T>>[]\n): ComponentDecorator<T> {\n\n  const decorator = ((type: T) => ComponentDef.define(type, ...defs)) as ComponentDecorator<T>;\n  const def = decorator as ComponentDef.Factory<InstanceType<T>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from 'context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { SingleContextKey } from 'context-values';\nimport { eventSupplyOf } from 'fun-events';\nimport { DomEventDispatcher, OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        eventSupplyOf(dispatcher).needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<E extends Event>(type: string): OnDomEvent<E> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * @category Core\n */\nexport type ContentRoot = any;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { StatePath } from 'fun-events';\n\n/**\n * Component state updater function.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeparam V  Updated value type\n * @param path  Updated state node path.\n * @param newValue  New value.\n * @param oldValue  Replaced value.\n */\n    <V>(this: void, path: StatePath, newValue: V, oldValue: V) => void;\n\n/**\n * A key of component context value containing a component state updates receiver function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Note that this value is not provided, unless the `StateSupport` feature is enabled.\n *\n * @category Core\n */\nexport const StateUpdater: FnContextRef<Parameters<StateUpdater>> = (/*#__PURE__*/ new FnContextKey(\n    'state-updater',\n    {\n      byDefault: valueProvider(noop),\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { EventSupply, EventSupply__symbol, EventSupplyPeer, OnEvent, StatePath } from 'fun-events';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perComponent]] and [[DefinitionSetup.perComponent]] methods.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements EventSupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A [[whenReady]] callback could\n   * be utilized to work this around.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is defined when component is mounted to arbitrary element by [[ComponentFactory.mountTo]]. Ot is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the custom element is connected.\n   *\n   * This becomes `true` right before [[whenOn]] event is sent, and becomes `false` right before [[whenOff]] event is\n   * sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An event supply that {@link destroy destroys} component when cut off.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * An `OnEvent` sender of custom element connection events.\n   *\n   * The registered receivers are called when custom element is connected, i.e. its `connectedCallback()` method is\n   * called. If component is connected already the receiver is called immediately.\n   *\n   * Sends a connection supply that is cut off once custom element is disconnected.\n   */\n  abstract readonly whenOn: OnEvent<[EventSupply]>;\n\n  /**\n   * An `OnEvent` sender of custom element disconnection events.\n   *\n   * The registered receivers are called when custom element is disconnected, i.e. its `disconnectedCallback()` method\n   * is called. If component is ready but disconnected, the receiver is called immediately.\n   */\n  abstract readonly whenOff: OnEvent<[]>;\n\n  /**\n   * An `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component destruction reason event.\n   *\n   * The registered receiver is notified when [[destroy]] method is called. If the component is destroyed already\n   * the receiver is notified immediately.\n   */\n  abstract readonly whenDestroyed: OnEvent<[any]>;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * Note that state update has no effect unless [[StateSupport]] feature is enabled or [[StateUpdater]] context value\n   * is provided by other means.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  readonly updateState: StateUpdater = updateComponentState.bind(this);\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element  Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under [[ComponentContext__symbol]] key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = element[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${element}`);\n    }\n\n    return context;\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): any {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Returns a `super` property value inherited from custom element parent.\n   *\n   * @param key  Target property key.\n   */\n  abstract elementSuper(key: PropertyKey): any;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event  An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   *\n   * @param reason  Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n\n/**\n * @internal\n */\nfunction updateComponentState<V>(this: ComponentContext<any>, key: StatePath, newValue: V, oldValue: V): void {\n  this.get(StateUpdater)(key, newValue, oldValue);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextRef } from 'context-values';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using [[ComponentEventDispatcher]] available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E>;\n\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { valueProvider } from 'call-thru';\nimport { Class, decoratePropertyAccessor, PropertyAccessorDescriptor } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { Component, ComponentDecorator } from './component.decorator';\nimport { ComponentClass } from './definition';\n\n/**\n * Component property decorator interface.\n *\n * Allows to construct a {@link ComponentDecorator component decorator} by declaring a virtual property to use instead\n * of decorated one.\n *\n * Constructed by [[ComponentProperty]] function.\n *\n * @category Core\n * @typeparam V  Property value type.\n * @typeparam T  A type of decorated component class.\n */\nexport interface ComponentPropertyDecorator<V, T extends ComponentClass = Class> {\n\n  /**\n   * Decorates component method.\n   *\n   * @typeparam P  Property value type.\n   * @param proto  Decorated class prototype.\n   * @param propertyKey  Decorated property key.\n   * @param descriptor  Decorated property descriptor.\n   *\n   * @returns  Either updated property descriptor, or nothing.\n   */\n  // eslint-disable-next-line\n  <P extends V>(\n      this: void,\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<P>,\n  ): any | void;\n\n  /**\n   * Builds component decorator assuming the virtual property has the given value.\n   *\n   * @param value  Virtual property value.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  As(\n      this: void,\n      value: V,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the virtual property value is provided by the given `provider`.\n   *\n   * @param provider  Virtual property read-only value provider.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  By(\n      this: void,\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is available via the given `accessor`.\n   *\n   * @param accessor  Virtual property accessor.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  With(\n      this: void,\n      accessor: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is bound to component with by the given `binder`.\n   *\n   * @param binder  A binder of virtual property accessor\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]]..\n   *\n   * @returns New component decorator.\n   */\n  Bind(\n      this: void,\n      binder: ComponentProperty.Binder<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n}\n\nexport namespace ComponentProperty {\n\n  /**\n   * Component property value provider signature.\n   *\n   * This function will be called each time the property value is requested.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Provider<V, T extends object = any> =\n  /**\n   * @param component  Component instance.\n   * @param key  Target property key.\n   *\n   * @returns Property value.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => V;\n\n  /**\n   * Component property accessor.\n   *\n   * Allows to read and write property value.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export interface Accessor<V, T extends object = any> {\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: T, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set(this: void, component: T, value: V, key: string | symbol): void;\n\n  }\n\n  /**\n   * Property accessor binder signature.\n   *\n   * This is a function that binds a {@link BoundAccessor property accessor} to target component.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Binder<V, T extends object = any> =\n  /**\n   * @param component  Target component to bind property accessor to.\n   * @param key  Property key.\n   *\n   * @returns Property accessor bound to `component`.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => BoundAccessor<V>;\n\n  export interface BoundAccessor<V> {\n\n    /**\n     * Reads bound component's property value.\n     *\n     * An attempt to read the value would throw when omitted.\n     *\n     * @returns Property value.\n     */\n    get?(): V;\n\n    /**\n     * Assigns bound component's new property value.\n     *\n     * An attempt to assign the value would throw when omitted.\n     *\n     * @param value  New property value.\n     */\n    set?(value: V): void;\n\n  }\n\n  /**\n   * Component property descriptor.\n   *\n   * Passed to {@link Definer property definer} by [[ComponentProperty]] function to construct a {@link Definition\n   * property definition}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Descriptor<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component class constructor.\n     */\n    readonly type: T;\n\n    /**\n     * Component property key.\n     */\n    readonly key: string | symbol;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.get property read definition}.\n     */\n    readonly readable: boolean;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.set property assignment definition}.\n     */\n    readonly writable: boolean;\n\n    /**\n     * Whether the property is initially enumerable.\n     *\n     * This can be changed by {@link Definition.enumerable property definition}.\n     */\n    readonly enumerable: boolean;\n\n    /**\n     * Whether the property is initially configurable.\n     *\n     * This can be changed by {@link Definition.configurable property definition}.\n     */\n    readonly configurable: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: InstanceType<T>): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     */\n    set(this: void, component: InstanceType<T>, value: V): void;\n\n  }\n\n  /**\n   * Component property definition builder signature.\n   *\n   * This is a function called by [[ComponentProperty]] to define the property.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export type Definer<V, T extends ComponentClass = Class> =\n  /**\n   * @param descriptor  Component property descriptor.\n   *\n   * @returns Component property definition. Or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<V, T>,\n      ) => Definition<V, T> | void;\n\n  /**\n   * Property definition to apply to existing property.\n   *\n   * When applying to decorated property, this definition updates its definition.\n   *\n   * When applying to virtual property assumed by one of [[ComponentPropertyDescriptor]] methods, most of returned\n   * values ignored. Except for {@link Definition.componentDef component definition}, {@link Definition.get value\n   * reader}, and {@link Definition.set value setter}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Definition<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component definition to apply to component.\n     *\n     * When specified, it is used to enable certain functionality for decorated (or virtual) property.\n     */\n    readonly componentDef?: ComponentDef<InstanceType<T>>;\n\n    /**\n     * Whether to make the property enumerable.\n     *\n     * When specified, it is used as `enumerable` attribute value of decorated property descriptor.\n     */\n    readonly enumerable?: boolean;\n\n    /**\n     * Whether to make the property configurable.\n     *\n     * When specified, it is used as `configurable` attribute value of decorated property descriptor.\n     */\n    readonly configurable?: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * When specified it changes how the property value is read.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get?(this: void, component: InstanceType<T>, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * When specified it changes how the property value is assigned.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set?(this: void, component: InstanceType<T>, value: V, key: string | symbol): void;\n\n  }\n\n}\n\n/**\n * Anonymous component property key.\n *\n * Used as a default virtual property key.\n *\n * @category Core\n */\nexport const AnonymousComponentProperty__symbol = (/*#__PURE__*/ Symbol('anonymous-component-property'));\n\n/**\n * Decorator of component property.\n *\n * Updates decorated property and component definition. Can be converted to {@link ComponentDecorator component\n * decorator} by calling appropriate method of returned decorator instance.\n *\n * @category Core\n * @typeparam V  Decorated property value type.\n * @typeparam T  A type of decorated component class.\n * @param define  Component property definition builder.\n *\n * @returns Component property decorator.\n */\nexport function ComponentProperty<V, T extends ComponentClass = Class>(\n    define: ComponentProperty.Definer<V, T>,\n): ComponentPropertyDecorator<V, T> {\n\n  const decorator = (\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<V>,\n  ): any | void => decoratePropertyAccessor(\n      proto,\n      propertyKey,\n      descriptor,\n      desc => {\n\n        const { get: getValue, set: setValue } = desc;\n        const type = proto.constructor;\n        const { get, set, configurable, enumerable, componentDef = {} } = define({\n          type,\n          key: propertyKey,\n          readable: !!desc.get,\n          writable: !!desc.set,\n          enumerable: !!desc.enumerable,\n          configurable: !!desc.configurable,\n          get: getValue\n              ? ((component: InstanceType<T>) => getValue.call(component))\n              : notReadableAccessor(propertyKey),\n          set: setValue\n              ? ((component, value) => setValue.call(component, value))\n              : notWritableAccessor(propertyKey),\n        }) || {};\n\n        ComponentDef.define(type, componentDef);\n\n        const updated: PropertyAccessorDescriptor<V> = {\n          ...desc,\n          configurable: configurable ?? desc.configurable,\n          enumerable: enumerable ?? desc.enumerable,\n        };\n\n        if (get || set) {\n          updated.get = get && function (this: InstanceType<T>) {\n            return get(this, propertyKey);\n          };\n          updated.set = set && function (this: InstanceType<T>, value: V) {\n            set(this, value, propertyKey);\n          };\n        }\n\n        return updated;\n      },\n  );\n  const decorateWith = (\n      { get, set }: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key: string | symbol = AnonymousComponentProperty__symbol,\n      writable: boolean,\n  ): ComponentDecorator<T> => Component({\n    [ComponentDef__symbol](type: InstanceType<T>) {\n\n      const def = define({\n        type,\n        key,\n        readable: true,\n        writable,\n        enumerable: false,\n        configurable: false,\n        get: component => get(component, key),\n        set: (component, value) => set(component, value, key),\n      });\n\n      return (def && def.componentDef) || {};\n    },\n  });\n  const By = (\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T> => decorateWith(\n      {\n        get(component, key) {\n          return provider(component, key);\n        },\n      } as ComponentProperty.Accessor<V>,\n      key,\n      false,\n  );\n\n  const result = decorator as ComponentPropertyDecorator<V, T>;\n\n  result.With = (access, key) => decorateWith(access, key, true);\n  result.By = By;\n  result.As = (value, key?) => By(valueProvider(value), key);\n  result.Bind = (binder, key = AnonymousComponentProperty__symbol) => {\n\n    const accessor__symbol = Symbol(`${String(key)}:accessor`);\n    const accessor = (component: any): {\n      get(): V;\n      set(value: V): void;\n    } => {\n\n      const existing = component[accessor__symbol];\n\n      if (existing) {\n        return existing;\n      }\n\n      const accessor = binder(component, key);\n\n      return component[accessor__symbol] = {\n        get: accessor.get ? accessor.get.bind(accessor) : notReadableAccessor(key),\n        set: accessor.set ? accessor.set.bind(accessor) : notWritableAccessor(key),\n      };\n    };\n\n    return decorateWith(\n        {\n          get(component) {\n            return accessor(component).get();\n          },\n          set(component, value) {\n            return accessor(component).set(value);\n          },\n        },\n        key,\n        true,\n    );\n  };\n\n  return result;\n}\n\n/**\n * @internal\n */\nfunction notReadableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not readable`); };\n}\n\n/**\n * @internal\n */\nfunction notWritableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not writable`); };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element  Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ElementAdapter>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.thru((...adapters) => {\n\n          const combined: ElementAdapter = adapters.reduce(\n              (prev, adapter) => element => prev(element) || adapter(element),\n              defaultElementAdapter,\n          );\n\n          const defaultProvider = (): AfterEvent<[ElementAdapter]> => afterThe(defaultElementAdapter);\n\n          return combined !== defaultElementAdapter\n              ? combined\n              : nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n        }),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter,\n          AfterEvent<ElementAdapter[]>>,\n  ): ElementAdapter {\n\n    let delegated: ElementAdapter;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(adapter => delegated = adapter);\n\n    return element => delegated(element);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: any): ComponentContext {\n  return element[ComponentContext__symbol];\n}\n\n/**\n * A key of bootstrap context value containing combined [[ElementAdapter]] instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = (/*#__PURE__*/ new ElementAdapterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { filterIt, itsEach, overArray } from 'a-iterable';\nimport { FnContextKey } from 'context-values/updatable';\nimport { isElement } from '../../common';\nimport { ComponentContext__symbol, ComponentMount } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * [[disconnect]].\n   *\n   * @param target  A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options  An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new [[ElementObserver]] instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node)?.checkConnected(),\n                );\n                itsEach(\n                    filterIt(\n                        overArray(mutation.addedNodes),\n                        isElement,\n                    ),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: any): ComponentMount | undefined {\n  return node[ComponentContext__symbol]?.mount;\n}\n","import { ComponentClass, ComponentFactory } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const ComponentFactory__symbol = (/*#__PURE__*/ Symbol('component-factory'));\n\n/**\n * @internal\n */\nexport function componentFactoryOf<T extends object>(componentType: ComponentClass<T>): ComponentFactory<T> {\n\n  const factory = (componentType as any)[ComponentFactory__symbol];\n\n  if (!factory) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n\n  return factory;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, SingleContextKey } from 'context-values';\nimport { html__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { componentFactoryOf } from '../../boot/impl/component-factory.symbol.impl';\nimport { Class, PromiseResolver } from '../../common';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: createCustomElements,\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName  A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType  A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName  Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(values: ContextValues): CustomElements {\n\n  const customElements: CustomElementRegistry = values.get(BootstrapWindow).customElements;\n  const nsAlias = values.get(DefaultNamespaceAliaser);\n\n  class WindowCustomElements extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name, extend } = factory.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name } = factory.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise;\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new WindowCustomElements();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: ComponentClass): PromiseResolver<void> {\n  return (componentType as any)[ComponentResolver__symbol]\n      || ((componentType as any)[ComponentResolver__symbol] = new PromiseResolver());\n}\n","import { SingleContextKey } from 'context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class } from '../../common';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../component-context';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perDefinition]] and [[DefinitionSetup.perDefinition]] methods. All [[BootstrapContext]] values\n * are available too.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * An `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenOn connected}. This is to prevent resource leaking\n   * on disconnected components that may be never used again.\n   */\n  abstract readonly whenComponent: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeparam Deps  A type of dependencies.\n   * @typeparam Src  The type of context value sources.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Component context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void;\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, ContextValues, SingleContextKey } from 'context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst ComponentContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'component-context-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentContextRegistry> {\n    return ComponentContextRegistry__key;\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst DefinitionContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'definition-context-registry',\n    {\n      byDefault: bootstrapDefault(context => new DefinitionContextRegistry(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n\n  static get [ContextKey__symbol](): ContextKey<DefinitionContextRegistry> {\n    return DefinitionContextRegistry__key;\n  }\n\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { EventEmitter, onAny, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { superClassOf } from '../../common';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\nimport { Unloader } from './unloader.impl';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    unloader: Unloader,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on({\n      supply: receiver.supply.needs(unloader.supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady.tillOff(unloader.supply);\n        const whenComponent = setup.whenComponent.tillOff(unloader.supply);\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return unloader.add(() => setup.perDefinition(spec));\n          },\n          perComponent(spec) {\n            return unloader.add(() => setup.perComponent(spec));\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: ComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return (componentType as any)[PostDefSetup__symbol];\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read.thru(setup => setup ? nextArgs(setup) : nextSkip());\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","import { AfterEvent, EventEmitter, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read.keep.thru_(\n        rev => (context, notifiedRev) => {\n          created.send(context, notifiedRev);\n          return rev;\n        },\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { nextArgs, nextSkip, noop, valueProvider } from 'call-thru';\nimport { ContextRegistry, ContextValues, ContextValueSpec, SingleContextKey, SingleContextRef } from 'context-values';\nimport {\n  EventEmitter,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol, eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { Class } from '../../common';\nimport {\n  ComponentContext as ComponentContext_,\n  ComponentContext__symbol,\n  ComponentDef,\n  ComponentEvent,\n  ComponentMount as ComponentMount_,\n} from '../../component';\nimport {\n  ComponentClass,\n  ComponentFactory as ComponentFactory_,\n  DefinitionContext as DefinitionContext_,\n  DefinitionSetup,\n  ElementDef,\n} from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ComponentContextRegistry } from './component-context-registry.impl';\nimport { DefinitionContextRegistry } from './definition-context-registry.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext_]>;\n  readonly components: EventEmitter<[ComponentContext_]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): ComponentFactory_<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Off,\n  On,\n}\n\nconst ComponentStatus__symbol = (/*#__PURE__*/ Symbol('component-status'));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n\n  const definitionContextRegistry$global = bsContext.get(DefinitionContextRegistry);\n  const componentContextRegistry$global = bsContext.get(ComponentContextRegistry);\n  const definitions = new EventEmitter<[DefinitionContext_]>();\n  const components = new EventEmitter<[ComponentContext_]>();\n\n  return {\n    definitions,\n    components,\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const def = ComponentDef.of(componentType);\n      const whenComponent = new WhenComponent<T>();\n      let componentContextRegistry$perType!: ComponentContextRegistry;\n      const ready = trackValue(false);\n      const whenReady: OnEvent<[]> = ready.read.thru(cls => cls ? nextArgs() : nextSkip());\n      // eslint-disable-next-line prefer-const\n      let definitionContext: DefinitionContext;\n\n      function createComponentContextRegistry(): ContextRegistry<ComponentContext_<T>> {\n        return componentContextRegistry$global.append(componentContextRegistry$perType);\n      }\n\n      class ComponentFactory extends ComponentFactory_ < T > {\n\n        get componentType(): ComponentClass<T> {\n          return definitionContext.componentType;\n        }\n\n        get elementType(): Class {\n          return definitionContext.elementType;\n        }\n\n        get elementDef(): ElementDef {\n          return definitionContext.elementDef;\n        }\n\n        mountTo(element: any): ComponentMount_<T> {\n          if (element[ComponentContext__symbol]) {\n            throw new Error(`Element ${element} already bound to component`);\n          }\n\n          const mount = createComponent({\n            definitionContext,\n            whenComponent,\n            registry: createComponentContextRegistry(),\n            element,\n            elementSuper(key) {\n              return element[key];\n            },\n            createMount(context: ComponentContext_<T>) {\n\n              class ComponentMount extends ComponentMount_<T> {\n\n                get context(): ComponentContext_<T> {\n                  return context;\n                }\n\n                get connected(): boolean {\n                  return elementStatus(element).it === ComponentStatus.On;\n                }\n\n                set connected(value: boolean) {\n                  elementStatus(element).it = value ? ComponentStatus.On : ComponentStatus.Off;\n                }\n\n                checkConnected(): boolean {\n\n                  const el: Element = element;\n                  const doc = el.ownerDocument;\n\n                  return this.connected = doc != null && doc.contains(el);\n                }\n\n              }\n\n              return new ComponentMount();\n            },\n          }).mount as ComponentMount_<T>;\n\n          mount.checkConnected();\n          componentCreated(mount.context);\n\n          return mount;\n        }\n\n      }\n\n      const componentFactory = new ComponentFactory();\n\n      class DefinitionContext extends DefinitionContext_<T> {\n\n        readonly get: ContextValues['get'];\n        readonly whenReady: OnEvent<[this]>;\n\n        get componentType(): ComponentClass<T> {\n          return componentType;\n        }\n\n        get whenComponent(): OnEvent<[ComponentContext_<T>]> {\n          return whenComponent.onCreated;\n        }\n\n        get elementType(): Class {\n          throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n        }\n\n        constructor() {\n          super();\n\n          const context = this;\n\n          this.whenReady = whenReady.thru_(valueProvider(this)).once as OnEvent<[this]>;\n\n          const definitionContextRegistry = new DefinitionContextRegistry(\n              definitionContextRegistry$global.seedIn(this),\n          );\n\n          definitionContextRegistry.provide({ a: DefinitionContext_, is: this });\n          definitionContextRegistry.provide({ a: ComponentFactory_, is: componentFactory });\n          this.get = definitionContextRegistry.newValues().get;\n          componentContextRegistry$perType = new ComponentContextRegistry(definitionContextRegistry.seedIn(this));\n\n          const definitionSetup: DefinitionSetup<T> = {\n            get componentType() {\n              return componentType;\n            },\n            get whenReady() {\n              return context.whenReady;\n            },\n            get whenComponent() {\n              return context.whenComponent;\n            },\n            perDefinition(spec) {\n              return definitionContextRegistry.provide(spec);\n            },\n            perComponent(spec) {\n              return componentContextRegistry$perType.provide(spec);\n            },\n          };\n\n          def.setup?.(definitionSetup);\n          postDefSetup(componentType).setup(definitionSetup);\n        }\n\n        perComponent<Deps extends any[], Src, Seed>(\n            spec: ContextValueSpec<ComponentContext_<T>, any, Deps, Src, Seed>,\n        ): () => void {\n          return componentContextRegistry$perType.provide(spec);\n        }\n\n      }\n\n      definitionContext = new DefinitionContext();\n\n      def.define?.(definitionContext);\n      definitions.send(definitionContext);\n\n      const elementType = createElementType(definitionContext, whenComponent, createComponentContextRegistry);\n\n      Object.defineProperty(definitionContext, 'elementType', {\n        configurable: true,\n        enumerable: true,\n        value: elementType,\n      });\n\n      ready.it = true;\n\n      return componentFactory;\n    },\n  };\n\n  function createElementType<T extends object>(\n      definitionContext: DefinitionContext_<T>,\n      whenComponent: WhenComponent<T>,\n      createRegistry: () => ContextRegistry<ComponentContext_<T>>,\n  ): Class {\n\n    const elementDef = definitionContext.get(ElementDef);\n\n    class Element extends elementDef.extend.type {\n\n      // Component context reference\n      [ComponentContext__symbol]: ComponentContext_<T>;\n\n      constructor() {\n        super();\n\n        const context = createComponent({\n          definitionContext,\n          whenComponent,\n          registry: createRegistry(),\n          element: this,\n          createMount: noop,\n          elementSuper: key => super[key],\n        });\n\n        componentCreated(context);\n      }\n\n      connectedCallback(): void {\n        elementStatus(this).it = ComponentStatus.On;\n      }\n\n      disconnectedCallback(): void {\n        elementStatus(this).it = ComponentStatus.Off;\n      }\n\n    }\n\n    return Element;\n  }\n\n  function createComponent<T extends object>(\n      {\n        definitionContext,\n        whenComponent,\n        registry,\n        element,\n        createMount,\n        elementSuper,\n      }: {\n        definitionContext: DefinitionContext_<T>;\n        whenComponent: WhenComponent<T>;\n        registry: ComponentContextRegistry;\n        element: any;\n        elementSuper(name: PropertyKey): any;\n        createMount(context: ComponentContext_<T>): ComponentMount_<T> | undefined;\n      },\n  ): ComponentContext_<T> {\n\n    const status = trackValue<ComponentStatus>(ComponentStatus.Building);\n    const destructionReason = trackValue<[any] | undefined>();\n\n    status.on(noop).whenOff(reason => destructionReason.it = [reason]);\n\n    const destroyed: OnEvent<[any]> = destructionReason.read.thru(reason => reason ? nextArgs(reason[0]) : nextSkip());\n    const whenDestroyed: OnEvent<[any]> = destroyed.once;\n\n    const whenOff: OnEvent<[]> = status.read.thru_(sts => sts === ComponentStatus.Off ? nextArgs() : nextSkip());\n    const whenOn: OnEvent<[EventSupply]> = status.read.thru_(\n        sts => {\n          if (sts !== ComponentStatus.On) {\n            return nextSkip();\n          }\n\n          const offSupply = eventSupply();\n\n          whenOff.once(() => offSupply.off());\n\n          return nextArgs(offSupply);\n        },\n    );\n\n    let mount: ComponentMount_<T> | undefined;\n    const values = registry.newValues();\n\n    class ComponentContext extends ComponentContext_<T> {\n\n      readonly get = values.get;\n      readonly elementSuper = elementSuper;\n      readonly whenReady: OnEvent<[this]>;\n\n      constructor() {\n        super();\n\n        const whenReady: OnEvent<[this]> = status.read.thru(sts => sts ? nextArgs(this) : nextSkip());\n\n        this.whenReady = whenReady.once;\n      }\n\n      get componentType(): ComponentClass<T> {\n        return definitionContext.componentType;\n      }\n\n      get element(): any {\n        return element;\n      }\n\n      get component(): T {\n        throw new Error('The component is not constructed yet. Consider to use a `whenReady()` callback');\n      }\n\n      get mount(): ComponentMount_<T> | undefined {\n        return mount || (mount = createMount(this));\n      }\n\n      get connected(): boolean {\n        return status.it === ComponentStatus.On;\n      }\n\n      get [EventSupply__symbol](): EventSupply {\n        return eventSupplyOf(status);\n      }\n\n      get whenOn(): OnEvent<[EventSupply]> {\n        return whenOn;\n      }\n\n      get whenOff(): OnEvent<[]> {\n        return whenOff;\n      }\n\n      get whenDestroyed(): OnEvent<[any]> {\n        return whenDestroyed;\n      }\n\n      destroy(reason?: any): void {\n        status.done(reason);\n      }\n\n    }\n\n    const context = new ComponentContext();\n    let lastRev = 0;\n\n    context.whenDestroyed(() => removeElement(context));\n    registry.provide({ a: ComponentContext_, is: context });\n\n    augmentElement();\n\n    whenComponent.readNotifier.once(notifier => lastRev = notifier(context, lastRev));\n    context.whenOn(supply => {\n      whenComponent.readNotifier({\n        supply,\n        receive(_, notifier) {\n          lastRev = notifier(context, lastRev);\n        },\n      });\n    });\n    components.send(context);\n\n    const component = newComponent(definitionContext.componentType, context);\n\n    Object.defineProperty(context, 'component', {\n      configurable: true,\n      enumerable: true,\n      value: component,\n    });\n\n    status.it = ComponentStatus.Ready;\n\n    return context;\n\n    function augmentElement(): void {\n      Object.defineProperty(element, ComponentContext__symbol, { value: context });\n      Object.defineProperty(element, ComponentStatus__symbol, { writable: true, value: status });\n    }\n  }\n\n}\n\n/**\n * Creates new component of the given type.\n *\n * It makes component context available under `[ComponentContext__symbol]` key in constructed component.\n * The component context is also available inside component constructor by temporarily assigning it to component\n * prototype.\n *\n * @typeparam T  A type of component.\n * @param type  Component class constructor.\n * @param context  Target component context.\n */\nfunction newComponent<T extends object>(type: ComponentClass<T>, context: ComponentContext_<T>): T {\n\n  const proto = type.prototype as any;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    Object.defineProperty(component, ComponentContext__symbol, { value: context });\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nfunction elementStatus(element: any): ValueTracker<ComponentStatus> {\n  return element[ComponentStatus__symbol];\n}\n\nfunction componentCreated(context: ComponentContext_): void {\n  context.whenOn.once(\n      () => context.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n  );\n}\n\nfunction removeElement(context: ComponentContext_): void {\n\n  const { element, mount } = context;\n\n  if (mount) {\n    mount.connected = false; // Disconnect mounted element\n  }\n\n  const parentNode: Element = element.parentElement;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by [[ComponentFactory.mountTo]] method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating [[ComponentMount.connected]] property. E.g. by calling a\n * [[ComponentMount.checkConnected]] method. An [[ElementObserver]] and [[AutoConnectSupport]] feature could be used to\n * do it automatically.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * Updating this property triggers appropriate listeners registered in [[ComponentContext]].\n   *\n   * The initial state is set by [[checkConnected]] method.\n   */\n  abstract connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element;\n  }\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { itsEach, overArray } from 'a-iterable';\nimport { noop, valueProvider } from 'call-thru';\nimport { EventSupply, eventSupply } from 'fun-events';\n\n/**\n * @internal\n */\nexport interface Unloader {\n  readonly supply: EventSupply;\n  add(adder: () => () => void): () => void;\n}\n\nconst doNotAdd = valueProvider(noop);\n\n/**\n * @internal\n */\nexport function newUnloader(): Unloader {\n\n  const unloads: (() => void)[] = [];\n  let add = (adder: () => () => void): () => void => {\n\n    const unload = adder();\n\n    unloads.push(unload);\n\n    return unload;\n  };\n  const supply = eventSupply(() => {\n    add = doNotAdd;\n    itsEach(\n        overArray(unloads).reverse(),\n        unload => unload(),\n    );\n    unloads.length = 0;\n  });\n\n  return {\n    supply,\n    add(adder) {\n      return add(adder);\n    },\n  };\n}\n","import { ElementBuilder } from '../../boot/impl';\nimport { ComponentFactory__symbol } from '../../boot/impl/component-factory.symbol.impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._definitionQueue.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const factory = elementBuilder.buildElement(componentType);\n\n      (componentType as any)[ComponentFactory__symbol] = factory;\n\n      this.customElements.define(componentType, factory.elementType);\n    });\n  }\n\n}\n","import { filterIt, mapIt } from 'a-iterable';\nimport { isPresent, nextArgs, NextCall, NextSkip, nextSkip } from 'call-thru';\nimport { ContextRegistry, ContextValueOpts, ContextValues, ContextValueSpec } from 'context-values';\nimport { ContextUpKey } from 'context-values/updatable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  EventKeeper,\n  EventSupply,\n  nextAfterEvent,\n  OnEvent,\n  OnEventCallChain,\n  trackValue,\n} from 'fun-events';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ComponentContextRegistry,\n  DefinitionContextRegistry,\n  ElementBuilder,\n  newUnloader,\n  onPostDefSetup,\n} from '../../boot/impl';\nimport { ArraySet, Class } from '../../common';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = (/*#__PURE__*/ Symbol('feature-key'));\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n    // eslint-disable-next-line no-prototype-builtins\n    return feature.hasOwnProperty(FeatureKey__symbol)\n        ? (feature as any)[FeatureKey__symbol]\n        : ((feature as any)[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): AfterEvent<[FeatureLoader?]> | null | undefined {\n    return loadFeature(\n        opts.context.get(BootstrapContext),\n        opts.seed.keep.thru(preferredFeatureClause),\n    );\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n      case 'is':\n        required = true;\n        if (!preferred) {\n          preferred = clause;\n        }\n        break;\n      case 'has':\n        preferred = clause;\n        break;\n      case 'needs':\n        required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: AfterEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).keep.thru_(({ clause: [clause], deps }): NextCall<OnEventCallChain, [FeatureLoader?]> => {\n      if (!clause) {\n        return nextArgs();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return nextAfterEvent(source); // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return nextAfterEvent(source = bsContext.get(FeatureKey.of(origin)).keep.thru_(\n            loader => {\n              loader!.to(stageId);\n              stageId = loader!.stage;\n              return loader;\n            },\n        ));\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return nextAfterEvent(source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).share()); // Can be accessed again when reused\n    })(receiver);\n  }).keep.thru(\n      preventDuplicateLoader(),\n  );\n}\n\nfunction preventDuplicateLoader():\n    (\n        loader?: FeatureLoader,\n    ) => NextCall<OnEventCallChain, [FeatureLoader?]> | NextSkip {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return (loader?: FeatureLoader) => {\n    if (lastLoader === loader) {\n      return nextSkip();\n    }\n    lastLoader = loader;\n\n    if (!loader) {\n      return nextArgs<[FeatureLoader?]>();\n    }\n\n    return nextArgs<[FeatureLoader?]>(loader);\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.keep.thru_(clause => {\n    if (!clause) {\n      return nextArgs();\n    }\n\n    const [{ def }] = clause;\n    const needs = new ArraySet(def.needs);\n\n    if (!needs.size) {\n      return nextArgs();\n    }\n\n    return nextAfterEvent(\n        afterEach(\n            ...mapIt(\n                needs,\n                dep => bsContext.get(FeatureKey.of(dep)),\n            ),\n        ).keep.thru_(presentFeatureDeps),\n    );\n  });\n}\n\nfunction presentFeatureDeps(...deps: [FeatureLoader?][]): NextCall<OnEventCallChain, FeatureLoader[]> {\n  return nextArgs<FeatureLoader[]>(\n      ...filterIt<FeatureLoader | undefined, FeatureLoader>(\n          mapIt(deps, dep => dep[0]),\n          isPresent,\n      ),\n  );\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    delete this._stage; // Unloaded feature should never be accessed again.\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  idle(): Promise<this> {\n    return Promise.resolve(this);\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after(): 'idle' {\n    return 'idle';\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def } } = this.loader;\n    const [context, supply] = newFeatureContext(bsContext, this.loader);\n\n    def.setup?.(context);\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        () => Promise.resolve(supply.off()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after(): 'setup' {\n    return 'setup';\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { def } } = this.loader;\n\n    def.init?.(this._context);\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after(): 'init' {\n    return 'init';\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  init(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n}\n\nfunction newFeatureContext(\n    bsContext: BootstrapContext,\n    loader: FeatureLoader,\n): [FeatureContext, EventSupply] {\n\n  const unloader = newUnloader();\n  let componentRegistry: ComponentRegistry;\n  const definitionContextRegistry = bsContext.get(DefinitionContextRegistry);\n  const componentContextRegistry = bsContext.get(ComponentContextRegistry);\n  const registry = new ContextRegistry<FeatureContext>(bsContext);\n  const elementBuilder = bsContext.get(ElementBuilder);\n  const onDefinition = elementBuilder.definitions.on.tillOff(unloader.supply);\n  const onComponent = elementBuilder.components.on.tillOff(unloader.supply);\n\n  class Context extends FeatureContext {\n\n    readonly get = registry.newValues().get;\n    readonly whenReady: OnEvent<[FeatureContext]>;\n\n    constructor() {\n      super();\n\n      const whenReady: OnEvent<[FeatureContext]> = afterAll({\n        st: loader.state,\n        bs: trackValue<BootstrapContext>().by(bsContext.whenReady),\n      }).thru(\n          ({ st: [ready], bs: [bs] }) => bs && ready ? nextArgs(this) : nextSkip(),\n      );\n\n      this.whenReady = whenReady.once;\n      registry.provide({ a: FeatureContext, is: this });\n      componentRegistry = new ComponentRegistry(this);\n    }\n\n    get feature(): Class {\n      return loader.request.feature;\n    }\n\n    get onDefinition(): OnEvent<[DefinitionContext]> {\n      return onDefinition;\n    }\n\n    get onComponent(): OnEvent<[ComponentContext]> {\n      return onComponent;\n    }\n\n    provide<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => bsContext.get(BootstrapContextRegistry).provide(spec));\n    }\n\n    perDefinition<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => definitionContextRegistry.provide(spec));\n    }\n\n    perComponent<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => componentContextRegistry.provide(spec));\n    }\n\n    setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n      return onPostDefSetup(componentType, unloader);\n    }\n\n    define<T extends object>(componentType: ComponentClass<T>): void {\n      componentRegistry.define(componentType);\n    }\n\n  }\n\n  return [new Context(), unloader.supply];\n}\n","import { ArraySet, Class, mergeFunctions } from '../../common';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest {\n\n  readonly def: FeatureDef.Options;\n  private _uses = 0;\n\n  constructor(\n      private readonly _requester: FeatureRequester,\n      readonly feature: Class,\n      private _revoke: () => void,\n  ) {\n    this.def = featureDef(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    this._revokeBy(registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }));\n\n    new ArraySet(this.def.has).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n    });\n\n    new ArraySet(this.def.needs).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n    });\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(([{ feature }, reason, need]) => [feature, reason, need]));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse(): void {\n    if (!--this._uses) {\n      this._revoke();\n    }\n  }\n\n  private _revokeBy(revoke: () => void): void {\n    this._revoke = mergeFunctions(revoke, this._revoke);\n  }\n\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapContextRegistry } from '../../boot/impl';\nimport { Class } from '../../common';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = (/*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapContextRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapContextRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature, () => this._map.delete(feature));\n\n    this._map.set(feature, request);\n\n    return request.request(clauses);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip } from 'call-thru';\nimport { AfterEvent, afterEventBy, OnEvent, trackValue } from 'fun-events';\nimport { newNamespaceAliaser } from 'namespace-aliaser';\nimport { Class } from '../../common';\nimport { ComponentClass, ComponentFactory, CustomElements } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { componentFactoryOf } from '../impl/component-factory.symbol.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features  Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature))(loader => {\n    loader!.init().then(complete);\n  });\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class Context extends BootstrapContext {\n\n    readonly get = values.get;\n    readonly whenReady: OnEvent<[BootstrapContext]>;\n\n    constructor() {\n      super();\n\n      const whenReady: OnEvent<[BootstrapContext]> = stage.read.thru(\n          s => s ? nextArgs(this) : nextSkip(),\n      );\n\n      this.whenReady = whenReady.once;\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    async whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n      await new Promise(this.whenReady);\n      await this.get(CustomElements).whenDefined(componentType);\n      return componentFactoryOf(componentType);\n    }\n\n    load(feature: Class<any>): FeatureRef {\n\n      interface FeatureInfo {\n        status: FeatureStatus;\n        down?: Promise<void>;\n      }\n\n      const status = afterEventBy<[FeatureInfo]>(receiver => {\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<FeatureInfo>({\n          status: {\n            feature,\n            ready: false,\n          },\n        });\n\n        this.get(FeatureKey.of(feature))({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              status: {\n                feature: loader.request.feature,\n                ready: loader.ready,\n              },\n              down: loader.down,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  status: {\n                    feature: loader.request.feature,\n                    ready: true,\n                  },\n                  down: loader.down,\n                };\n              });\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).share();\n\n      let whenDown: Promise<void>;\n      const supply = status(({ down }) => {\n        whenDown = down!;\n      });\n      const read: AfterEvent<[FeatureStatus]> = status.keep.thru(\n          info => info.status,\n      ).tillOff(supply);\n\n      class Ref extends FeatureRef {\n\n        get read(): AfterEvent<[FeatureStatus]> {\n          return read;\n        }\n\n        get down(): Promise<void> {\n          return whenDown;\n        }\n\n        dismiss(reason?: any): Promise<void> {\n          supply.off(reason);\n          return whenDown;\n        }\n\n      }\n\n      return new Ref();\n    }\n\n  }\n\n  const bootstrapContext = new Context();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper } from 'fun-events';\nimport { FeatureStatus } from './feature-status';\n\n/**\n * Dynamically loaded feature reference.\n *\n * It is returned from [[BootstrapContext.load]] and can be used to read feature load status and unload it.\n *\n * Implements an `EventKeeper` interface by sending a feature load status updates.\n *\n * @category Core\n */\nexport abstract class FeatureRef implements EventKeeper<[FeatureStatus]> {\n\n  /**\n   * An `AfterEvent` sender of feature load status updates.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[FeatureStatus]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[FeatureStatus]> {\n    return this.read;\n  }\n\n  /**\n   * A promise resolved when feature is unloaded.\n   *\n   * This happens after all feature references dismissed.\n   */\n  abstract readonly down: Promise<void>;\n\n  /**\n   * Dismisses feature reference.\n   *\n   * When all feature references dismissed, then unloads the feature. This removes everything set up by the\n   * feature via [[BootstrapSetup]] and [[DefinitionSetup]].\n   *\n   * @param reason  Arbitrary reason of feature reference dismiss. This will be reported by load status supplies\n   * as their cut off reason.\n   *\n   * @returns A promise resolved when feature is unloaded. This happens only after all feature references dismissed.\n   */\n  abstract dismiss(reason?: any): Promise<void>;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { MultiContextKey, MultiContextRef } from 'context-values';\n\n/**\n * Custom element attribute change callback signature.\n *\n * This function is called whenever a new attribute value assigned.\n *\n * @category Feature\n * @typeparam T  A type of component.\n */\nexport type AttributeChangedCallback<T extends object> =\n/**\n * @param component  Component instance.\n * @param newValue  New attribute value.\n * @param oldValue  Previous attribute value, or `null` if there were no value assigned.\n */\n    (this: void, component: T, newValue: string, oldValue: string | null) => void;\n\n/**\n * Custom element attribute descriptor.\n *\n * Descriptors are to be registered in component's definition context in order to make them available to component.\n * The {@link Attribute @Attribute}, {@link Attributes @Attributes}, and {@link AttributeChanged @AttributeChanged}\n * decorators are doing so.\n *\n * @category Feature\n */\nexport interface AttributeDescriptor<T extends object = any> {\n\n  /**\n   * Attribute name.\n   */\n  readonly name: string;\n\n  /**\n   * Attribute change callback that will be called each time attribute value changes.\n   */\n  readonly change: AttributeChangedCallback<T>;\n\n}\n\n/**\n * A key of component definition context value containing attribute descriptors.\n *\n * @category Feature\n */\nexport const AttributeDescriptor: MultiContextRef<AttributeDescriptor> = (\n    /*#__PURE__*/ new MultiContextKey<AttributeDescriptor>('attribute-descriptor')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath__rootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name  Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface AttributePath__rootKeys {\n  [AttributePath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from 'call-thru';\nimport { StatePath } from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(component, updateState, newValue, oldValue);\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class, mergeFunctions } from '../../common';\nimport { ComponentContext, ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\nconst AttributeRegistry__key = (/*#__PURE__*/ new SingleContextKey<AttributeRegistry>('attribute-registry'));\n\n/**\n * @internal\n */\nexport class AttributeRegistry<T extends object = any> {\n\n  static get [ContextKey__symbol](): ContextKey<AttributeRegistry> {\n    return AttributeRegistry__key;\n  }\n\n  private _attrs?: Map<string, AttributeChangedCallback<T>>;\n\n  constructor(private readonly _context: DefinitionContext) {\n  }\n\n  get attrs(): Map<string, AttributeChangedCallback<T>> {\n    if (this._attrs) {\n      return this._attrs;\n    }\n\n    const attrs = new Map<string, AttributeChangedCallback<T>>();\n\n    this._context.get(AttributeDescriptor).forEach(desc => {\n\n      const { name, change } = desc;\n\n      attrs.set(name, mergeFunctions(attrs.get(name), change));\n    });\n\n    return this._attrs = attrs;\n  }\n\n  define(elementType: Class): void {\n\n    const attrs = this.attrs;\n    const observedAttributes = Array.from(attrs.keys());\n\n    if (!observedAttributes.length) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes,\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: function (name: string, oldValue: string | null, newValue: string) {\n        attrs.get(name)!(ComponentContext.of<T>(this).component, newValue, oldValue);\n      },\n    });\n  }\n\n  mount(mount: ComponentMount<T>): void {\n\n    const element = mount.element;\n    const attrs = this.attrs;\n    const attributeFilter = Array.from(attrs.keys());\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  ComponentContext.of<T>(element).component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { AttributeRegistry } from './attribute-registry.impl';\n\n/**\n * @internal\n */\nconst AttributesSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perDefinition({ as: AttributeRegistry });\n    setup.onDefinition(definitionContext => {\n      // Define element prototype attributes\n      definitionContext.whenReady(\n          ({ elementType }) => definitionContext.get(AttributeRegistry).define(elementType),\n      );\n    });\n    setup.onComponent(componentContext => {\n\n      const mount = componentContext.mount;\n\n      if (mount) {\n        // Mount element attributes\n        componentContext.get(AttributeRegistry).mount(mount);\n      }\n    });\n  },\n};\n\n/**\n * A feature adding attributes to custom elements.\n *\n * This feature is enabled automatically whenever an `@Attribute`, `@Attributes`, or `@AttributeChanged` decorator\n * applied to component.\n *\n * @category Feature\n */\nexport class AttributesSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return AttributesSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeDescriptor } from './attribute-descriptor';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributesSupport } from './attributes-support.feature';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Attribute definition or just an attribute name.\n *\n * @return Component property decorator.\n */\nexport function Attribute<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): ComponentPropertyDecorator<string | null, T> {\n  return ComponentProperty(({ type, key }) => {\n\n    const descriptor = parseAttributeDescriptor(type.prototype, key, def);\n    const { name } = descriptor;\n\n    return {\n      componentDef: {\n        feature: {\n          needs: AttributesSupport,\n        },\n        setup(setup) {\n          setup.perDefinition({ a: AttributeDescriptor, is: descriptor });\n        },\n      },\n      get(component: InstanceType<T>): string | null {\n        return ComponentContext.of(component).element.getAttribute(name);\n      },\n      set(component: InstanceType<T>, newValue: string | null) {\n        ComponentContext.of(component).element.setAttribute(name, newValue);\n      },\n    };\n  });\n}\n","import { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends ComponentClass>(\n    target: InstanceType<T>,\n    propertyKey: string | symbol,\n    opts?: AttributeDef<InstanceType<T>> | string,\n): AttributeDescriptor<InstanceType<T>> {\n\n  let name: string;\n  let change: AttributeChangedCallback<InstanceType<T>>;\n\n  if (typeof opts === 'string') {\n    name = opts;\n    change = attributeStateUpdate(name);\n  } else {\n    if (opts && opts.name) {\n      name = opts.name;\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = propertyKey;\n    }\n\n    change = attributeStateUpdate(name, opts && opts.updateState);\n  }\n\n  return { name, change };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from 'fun-events';\nimport { Class } from '../../common';\nimport { isArray } from '../../common/types.impl';\nimport { Component, ComponentDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { AttributesSupport } from './attributes-support.feature';\n\n/**\n * Creates a component decorator declaring supported custom element's attributes.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param items  Attributes definition options. Either an attribute definition item, or an array of such items.\n *\n * @return New component decorator.\n */\nexport function Attributes<T extends ComponentClass = Class>(\n    items: Attributes.Item<InstanceType<T>> | readonly Attributes.Item<InstanceType<T>>[],\n): ComponentDecorator<T> {\n  return Component({\n    feature: { needs: AttributesSupport },\n    setup(setup) {\n\n      const defineByItem = (item: Attributes.Item<InstanceType<T>>): void => {\n        if (typeof item === 'string') {\n          setup.perDefinition({\n            a: AttributeDescriptor,\n            is: {\n              name: item,\n              change: attributeStateUpdate(item),\n            },\n          });\n        } else {\n          Object.keys(item).forEach(name => {\n            setup.perDefinition({\n              a: AttributeDescriptor,\n              is: {\n                name,\n                change: attributeStateUpdate(name, item[name]),\n              },\n            });\n          });\n        }\n      };\n\n      if (isArray<Attributes.Item<InstanceType<T>>>(items)) {\n        items.forEach(defineByItem);\n      } else {\n        defineByItem(items);\n      }\n    },\n  });\n}\n\nexport namespace Attributes {\n\n  /**\n   * Attribute definition item.\n   *\n   * This is either an attribute name, or a per-attribute options map.\n   *\n   * @typeparam T  A type of component.\n   */\n  export type Item<T extends object> = Map<T> | string;\n\n  /**\n   * Per-attribute definition options.\n   *\n   * This is a map with attribute names as keys and their state update instructions as values.\n   *\n   * The state update instruction can be one of:\n   * - `false` to not update the component state,\n   * - `true` to update the component state with changed attribute key,\n   * - a state value key to update, or\n   * - an attribute update receiver function with custom state update logic.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Map<T extends object> {\n    readonly [name: string]: boolean | StatePath | AttributeUpdateReceiver<T>;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { StateTracker } from 'fun-events';\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new SingleContextKey<ComponentState>('component-state'));\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing component state properties.\n *\n * Thus a property state path is always something like `[StatePropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const StatePropertyPath__root = (/*#__PURE__*/ Symbol('state-property'));\n\n/**\n * A path to the named component property state.\n *\n * @category Feature\n */\nexport type StatePropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof StatePropertyPath__rootKeys, K];\n\n/**\n * Constructs a named component property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function statePropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): StatePropertyPath<K> {\n  return [StatePropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface StatePropertyPath__rootKeys {\n  [StatePropertyPath__root]: true;\n}\n","import { StatePath } from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { StatePropertyPath, statePropertyPathTo } from './state-property-path';\nimport { StatePropertyUpdateReceiver } from './state-property.decorator';\n\n/**\n * @internal\n */\nexport type StatePropertyUpdateCallback<T extends object> = <K extends keyof T>(\n    this: void,\n    component: T,\n    newValue: T[K],\n    oldValue: T[K],\n) => void;\n\n/**\n * @internal\n */\nexport function statePropertyUpdate<T extends object>(\n    propertyKey: PropertyKey,\n    updateState: true | StatePropertyUpdateReceiver<T> | StatePath = true,\n): StatePropertyUpdateCallback<T> {\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = statePropertyPathTo(propertyKey as keyof T);\n    const update = updateState === true ? updateStatePropertyState : updateState;\n\n    return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n    }\n  };\n}\n\nfunction updateStatePropertyState<T extends object, K extends keyof T>(\n    component: T,\n    path: StatePropertyPath<K>,\n    newValue: T[K],\n    oldValue: T[K],\n): void {\n  if (newValue !== oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, StateUpdater } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ComponentState } from './component-state';\n\n/**\n * @internal\n */\nconst StateSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentState,\n      by(context: ComponentContext) {\n\n        const state = new ComponentState();\n\n        context.whenDestroyed(reason => state.done(reason));\n\n        return state;\n      },\n    });\n    setup.perComponent({\n      a: StateUpdater,\n      by(state: ComponentState) {\n        return state.update;\n      },\n      with: [ComponentState],\n    });\n  },\n};\n\n/**\n * Component state support feature.\n *\n * When enabled, it registers the following component context values:\n *\n * - [[StateUpdater]] that allows to update the component state, and\n * - [[ComponentState]] that allows to track component state changes.\n *\n * Other features would use this to notify when the state changes. E.g. [[DomPropertiesSupport]]\n * and [[AttributesSupport]] features issue state updates when needed.\n *\n * @category Feature\n */\nexport class StateSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StateSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from 'fun-events';\nimport { Class } from '../../common';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StatePropertyPath } from './state-property-path';\nimport { statePropertyUpdate } from './state-property-update.impl';\nimport { StateSupport } from './state-support.feature';\n\n/**\n * Creates a decorator of component property containing part of component state.\n *\n * Once such property updated, the component state is {@link ComponentContext.updateState also updated}.\n *\n * Enables [[StateSupport]] feature when applied.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Custom element property definition.\n *\n * @returns Component property decorator.\n */\nexport function StateProperty<V = any, T extends ComponentClass = Class>(\n    { updateState }: StatePropertyDef = {},\n): ComponentPropertyDecorator<V, T> {\n  return ComponentProperty(({ get, set, key }) => {\n    if (updateState !== false) {\n\n      const setValue = set;\n      const update = statePropertyUpdate<InstanceType<T>>(key, updateState);\n\n      set = (component, newValue) => {\n\n        const oldValue = get(component);\n\n        setValue(component, newValue);\n        update(component, newValue, oldValue);\n      };\n    }\n\n    return {\n      componentDef: {\n        feature: {\n          needs: StateSupport,\n        },\n      },\n      get,\n      set,\n    };\n  });\n}\n\n/**\n * Component state property definition.\n *\n * This is a parameter to {@link StateProperty @StateProperty} decorator applied to component property.\n *\n * @category Feature\n */\nexport interface StatePropertyDef<T extends object = any> {\n\n  /**\n   * Whether to update the component state after this property changed.\n   *\n   * Can be one of:\n   * - `false` to not update the component state,\n   * - `true` (the default value) to update the component state with changed property key,\n   * - a state value key to update, or\n   * - an state property update receiver function with custom state update logic.\n   *\n   * By default does not update component state if property value didn't change.\n   */\n  readonly updateState?: boolean | StatePath | StatePropertyUpdateReceiver<T>;\n\n}\n\n/**\n * Component state property updates receiver invoked when its value changed.\n *\n * @category Feature\n * @typeparam T  A type of component.\n */\nexport type StatePropertyUpdateReceiver<T extends object> =\n/**\n * @typeparam K  A type of component property keys.\n * @param component  Component instance.\n * @param path  The changed property state path in the form of `[StatePropertyPath__root, propertyKey]`.\n * @param newValue  New property value.\n * @param oldValue  Previous property value.\n */\n    <K extends keyof T>(\n        this: void,\n        component: T,\n        path: StatePropertyPath<K>,\n        newValue: T[K],\n        oldValue: T[K],\n    ) => void;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs } from 'call-thru';\nimport { EventSupply, eventSupply, EventSupply__symbol, OnEvent, StatePath, ValueTracker } from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires [[AttributesSupport]] feature to be enabled and attribute to be defined. E.g. with {@link Attribute\n * @Attribute}, {@link AttributeChanged @AttributeChanged}, or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context  Target component context.\n * @param name  Attribute name.\n * @param path  Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n\n  const { element }: { element: Element } = context;\n  const state = context.get(ComponentState).track(path);\n  const supply = eventSupply();\n  const on: OnEvent<[string | null, string | null]> = state.onUpdate.thru(\n      (_path, newValue, oldValue) => nextArgs(newValue, oldValue),\n  ).tillOff(supply);\n\n  class AttributeTracker extends ValueTracker<string | null> {\n\n    get on(): OnEvent<[string | null, string | null]> {\n      return on;\n    }\n\n    get [EventSupply__symbol](): EventSupply {\n      return supply;\n    }\n\n    get it(): string | null {\n      return element.getAttribute(name);\n    }\n\n    set it(value: string | null) {\n      if (!supply.isOff) {\n        if (value == null) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value);\n        }\n      }\n    }\n\n  }\n\n  return new AttributeTracker();\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { MultiContextKey, MultiContextRef } from 'context-values';\n\n/**\n * Custom element property descriptor.\n *\n * Descriptors are to be registered in component's definition context in order to make them available to component.\n * The {@link DomProperty @DomProperty} decorator is doing so.\n *\n * @category Feature\n */\nexport interface DomPropertyDescriptor {\n\n  /**\n   * Custom element property key.\n   */\n  readonly key: PropertyKey;\n\n  /**\n   * Custom element property descriptor.\n   */\n  readonly descriptor: PropertyDescriptor;\n\n}\n\n/**\n * A key of component definition context value containing custom element property descriptors.\n *\n * @category Feature\n */\nexport const DomPropertyDescriptor: MultiContextRef<DomPropertyDescriptor> = (\n    /*#__PURE__*/ new MultiContextKey<DomPropertyDescriptor>('dom-property-descriptor')\n);\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Class } from '../../common';\nimport { ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\n\nconst DomPropertyRegistry__key = (/*#__PURE__*/ new SingleContextKey<DomPropertyRegistry>('dom-property-registry'));\n\n/**\n * @internal\n */\nexport class DomPropertyRegistry {\n\n  static get [ContextKey__symbol](): ContextKey<DomPropertyRegistry> {\n    return DomPropertyRegistry__key;\n  }\n\n  private _props?: Map<PropertyKey, PropertyDescriptor>;\n\n  constructor(private readonly _context: DefinitionContext) {\n  }\n\n  get props(): Map<PropertyKey, PropertyDescriptor> {\n    if (this._props) {\n      return this._props;\n    }\n\n    return this._props = new Map<PropertyKey, PropertyDescriptor>(\n        this._context.get(DomPropertyDescriptor)\n            .map(({ key, descriptor }) => [key, descriptor]),\n    );\n  }\n\n  define<T extends object>(elementType: Class<T>): void {\n\n    const prototype = elementType.prototype;\n\n    this.props.forEach((desc, key) => {\n      Object.defineProperty(prototype, key, desc);\n    });\n  }\n\n  mount<T extends object>(mount: ComponentMount<T>): void {\n\n    const element = mount.element;\n\n    this.props.forEach((desc, key) => {\n      Object.defineProperty(element, key, desc);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { DomPropertyRegistry } from './dom-property-registry.impl';\n\n/**\n * @internal\n */\nconst DomPropertiesSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perDefinition({ as: DomPropertyRegistry });\n    setup.onDefinition(definitionContext => {\n      // Define element prototype properties\n      definitionContext.whenReady(\n          ({ elementType }) => definitionContext.get(DomPropertyRegistry).define(elementType),\n      );\n    });\n    setup.onComponent(componentContext => {\n\n      const mount = componentContext.mount;\n\n      if (mount) {\n        // Mount element properties\n        componentContext.get(DomPropertyRegistry).mount(mount);\n      }\n    });\n  },\n};\n\n/**\n * A feature adding properties to custom elements.\n *\n * This feature is enabled automatically whenever a {@link DomProperty @DomProperty} decorator applied to component.\n *\n * @category Feature\n */\nexport class DomPropertiesSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return DomPropertiesSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n */\nexport type DomPropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath__rootKeys, K];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): DomPropertyPath<K> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface DomPropertyPath__rootKeys {\n  [DomPropertyPath__root]: true;\n}\n","import { StatePath } from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { DomPropertyUpdateReceiver } from './dom-property-def';\nimport { DomPropertyPath, domPropertyPathTo } from './dom-property-path';\n\n/**\n * @internal\n */\nexport type DomPropertyUpdateCallback<T extends object> = <K extends keyof T>(\n    this: void,\n    component: T,\n    newValue: T[K],\n    oldValue: T[K],\n) => void;\n\n/**\n * @internal\n */\nexport function domPropertyUpdate<T extends object>(\n    propertyKey: PropertyKey,\n    updateState: true | DomPropertyUpdateReceiver<T> | StatePath = true,\n): DomPropertyUpdateCallback<T> {\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = domPropertyPathTo(propertyKey as keyof T);\n    const update = updateState === true ? updateDomPropertyState : updateState;\n\n    return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n  return (component, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n    }\n  };\n}\n\nfunction updateDomPropertyState<T extends object, K extends keyof T>(\n    component: T,\n    path: DomPropertyPath<K>,\n    newValue: T[K],\n    oldValue: T[K],\n): void {\n  if (newValue !== oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../../common';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { DomPropertiesSupport } from './dom-properties-support.feature';\nimport { DomPropertyDef } from './dom-property-def';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\nimport { domPropertyDescriptor } from './dom-property-descriptor.impl';\nimport { domPropertyUpdate } from './dom-property-update.impl';\n\n/**\n * Creates component property decorator that declares a property to add to custom element created for this component.\n *\n * The value of declared element's property will be read from and written to decorated one.\n *\n * By default does not update component state if property value didn't change.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Custom element property definition.\n *\n * @returns Component property decorator.\n */\nexport function DomProperty<V = any, T extends ComponentClass = Class>(\n    def: DomPropertyDef<T> = {},\n): ComponentPropertyDecorator<V, T> {\n  return ComponentProperty(descriptor => {\n\n    const { key, get } = descriptor;\n    let { set } = descriptor;\n    const domDescriptor = domPropertyDescriptor(descriptor, def);\n\n    if (def.updateState !== false) {\n\n      const updateState = domPropertyUpdate<InstanceType<T>>(key, def.updateState);\n      const setValue = set;\n\n      set = (component, newValue) => {\n\n        const oldValue = get(component);\n\n        setValue(component, newValue);\n        updateState(component, newValue, oldValue);\n      };\n    }\n\n    return {\n      componentDef: {\n        feature: {\n          needs: DomPropertiesSupport,\n        },\n        setup(setup) {\n          setup.perDefinition({ a: DomPropertyDescriptor, is: domDescriptor });\n        },\n      },\n      get,\n      set,\n    };\n  });\n}\n\n/**\n * Component method decorator that declares a method to add to custom element created for this component.\n *\n * This is just an alias of {@link DomProperty @DomProperty} decorator.\n *\n * @category Feature\n */\nexport { DomProperty as DomMethod };\n","import { PropertyAccessorDescriptor } from '../../common';\nimport { ComponentContext, ComponentProperty } from '../../component';\nimport { DomPropertyDef } from './dom-property-def';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\n\n/**\n * @internal\n */\nexport function domPropertyDescriptor<V>(\n    propertyDesc: ComponentProperty.Descriptor<V>,\n    {\n      propertyKey: key = propertyDesc.key,\n      configurable = propertyDesc.configurable,\n      enumerable = propertyDesc.enumerable,\n      writable = propertyDesc.writable,\n    }: DomPropertyDef,\n): DomPropertyDescriptor {\n\n  const componentPropertyKey = propertyDesc.key;\n  const descriptor: PropertyAccessorDescriptor<V> = {\n    configurable,\n    enumerable,\n    get: function (this: any) {\n      return (ComponentContext.of(this).component as any)[componentPropertyKey];\n    },\n    set: writable\n        ? function (this: any, value: any) {\n          (ComponentContext.of(this).component as any)[componentPropertyKey] = value;\n        }\n        : undefined,\n  };\n\n  return { key, descriptor };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from 'call-thru';\nimport { RenderExecution } from 'render-scheduler';\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { RenderDef } from './render-def';\n\n/**\n * Component's element renderer signature.\n *\n * It has no arguments. It may return either nothing, or a function. In the latter case the returned function will be\n * called immediately to render the element. It may, in turn, return a renderer function, and so on.\n *\n * @category Feature\n */\nexport type ElementRenderer =\n/**\n * @param execution  Render shot execution context.\n *\n * @returns Either delegated renderer, or nothing.\n */\n    (\n        this: void,\n        execution: RenderExecution,\n    ) => void | ElementRenderer;\n\nconst enum RenderStatus {\n  Pending,\n  Scheduled,\n  Complete,\n  Cancelled = -1,\n}\n\n/**\n * @category Feature\n */\nexport const ElementRenderer = {\n\n  /**\n   * Enables component element rendering.\n   *\n   * A `renderer` function call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n   *\n   * @param context  Target component context.\n   * @param renderer  Element renderer function.\n   * @param def  Optional element rendering definition.\n   */\n  render(\n      this: void,\n      context: ComponentContext,\n      renderer: ElementRenderer,\n      def: RenderDef = {},\n  ): void {\n\n    const { offline, path = [] } = def;\n    const stateTracker = context.get(ComponentState).track(path);\n    const schedule = context.get(DefaultRenderScheduler)();\n\n    let status = RenderStatus.Pending;\n    const stateSupply = stateTracker.onUpdate(() => {\n      if (offline || context.connected) {\n        scheduleRenderer();\n      } else {\n        status = RenderStatus.Pending; // Require rendering next time online\n      }\n    });\n\n    if (offline) {\n      scheduleRenderer();\n    } else {\n      context.whenOn(supply => {\n        supply.whenOff(cancelRenderer); // Prevent rendering while offline\n        if (status <= 0) { // There is an update to render. Either pending or previously cancelled.\n          scheduleRenderer();\n        }\n      }).whenOff(reason => {\n        // Component destroyed\n        cancelRenderer();\n        stateSupply.off(reason);\n      });\n    }\n\n    function scheduleRenderer(): void {\n      status = RenderStatus.Scheduled;\n      schedule(renderElement);\n    }\n\n    function cancelRenderer(): void {\n      if (status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet\n        schedule(noop);\n        status = RenderStatus.Cancelled;\n      }\n    }\n\n    function renderElement(execution: RenderExecution): void {\n      /* istanbul ignore next */\n      if (status < 0) {\n        // Prevent cancelled rendering\n\n        /*\n        Should never happen since render-scheduler v1.1\n        As disconnecting in another schedule would correctly cancel this one,\n        because it is not executed yet and thus will be replaced by `noop`.\n        */\n        return;\n      }\n      status = RenderStatus.Complete;\n      for (;;) {\n\n        const newRenderer = renderer(execution);\n\n        if (newRenderer === renderer || typeof newRenderer !== 'function') {\n          break;\n        }\n\n        renderer = newRenderer;\n      }\n    }\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { RenderExecution } from 'render-scheduler';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StateSupport } from '../state';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * This decorator automatically enables [[StateSupport]] feature.\n *\n * Utilizes [[ElementRenderer.render]] function to enable rendering.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(\n    def?: RenderDef,\n): ComponentPropertyDecorator<(execution: RenderExecution) => ElementRenderer | void, T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      feature: {\n        needs: StateSupport,\n      },\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n\n            ElementRenderer.render(context, get(component).bind(component), def);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { NamespaceDef } from 'namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n"],"names":["BootstrapContext__key","SingleContextKey","BootstrapContext","ContextValues","ContextKey__symbol","bootstrapDefault","provide","context","key","bootstrapContext","get","ComponentFactory__key","ComponentFactory","[object Object]","element","mount","this","mountTo","connected","BootstrapWindow","byDefault","window","BootstrapRoot","ctx","document","body","DefaultNamespaceAliaser","DefaultRenderSchedulerKey","ContextUpKey","super","upKey","createUpKey","opts","seed","keep","thru","fns","length","toDefaultRenderScheduler","defaultProvider","afterThe","newRenderSchedule","nextAfterEvent","delegated","or","undefined","scheduler","args","options","DefaultRenderScheduler","isArray","value","Array","ArraySet","AIterable","items","Set","size","Symbol","iterator","next","forEach","item","add","superClassOf","type","satisfying","prototype","Object","getPrototypeOf","superType","constructor","decoratePropertyAccessor","target","propertyKey","desc","updateDescriptor","isField","updatedDesc","writable","isPropertyAccessorDescriptor","value__symbol","initial","accessorDesc","set","newValue","toPropertyAccessorDescriptor","fieldKey","String","configurable","enumerable","fieldAccessorDescriptor","defineProperty","mergeFunctions","first","second","merge","_f","s","apply","isElement","node","nodeType","Node","ELEMENT_NODE","MetaAccessor","symbol","hasOwnProperty","ownDef","own","superDef","of","sources","prevMeta","updates","mapIt","source","meta","newMeta","flatMapIt","PromiseResolver","promise","Promise","resolve","reject","_resolve","_reject","error","FeatureDef__symbol","FeatureMeta","defs","itsReduction","prev","def","needs","has","setup","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","FeatureNeedsError","Error","reduce","reason","need","name","ComponentDef__symbol","ComponentMeta","isQualifiedName","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","values","dispatcher","DomEventDispatcher","eventSupplyOf","dispatch","event","on","ContentRoot","StateUpdater","FnContextKey","valueProvider","noop","ComponentContext__symbol","ComponentContext","updateComponentState","bind","TypeError","contentRoot","oldValue","ComponentEvent","Event","AnonymousComponentProperty__symbol","ComponentProperty","decorateWith","readable","component","componentDef","By","provider","result","proto","descriptor","getValue","setValue","call","notReadableAccessor","notWritableAccessor","updated","With","access","As","Bind","binder","accessor__symbol","accessor","existing","ElementAdapterKey","adapters","combined","adapter","defaultElementAdapter","ElementAdapter","ElementObserver","bsContext","DefaultElementObserver","MutationObserver","callback","mutations","mutation","itsEach","overArray","removedNodes","mountOf","checkConnected","filterIt","addedNodes","observe","childList","ComponentFactory__symbol","componentFactoryOf","factory","CustomElements__key","customElements","nsAlias","CustomElements","componentTypeOrName","elementType","html__naming","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","BootstrapContextRegistry__key","BootstrapContextRegistry","ContextRegistry","a","is","newValues","ComponentContextRegistry__key","ComponentContextRegistry","DefinitionContextRegistry__key","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","tracker","trackValue","emitter","EventEmitter","onSetup","read","nextArgs","nextSkip","onAny","superPostDefSetup","send","it","WhenComponent","currentRev","created","onCreated","onEventBy","receiver","receiverRev","supply","receive","eventContext","componentContext","notifiedRev","recurrentReceiver","onRecurrent","recurrentContext","readNotifier","thru_","rev","ElementBuilder","definitionContextRegistry$global","componentContextRegistry$global","definitions","components","whenComponent","componentContextRegistry$perType","ready","whenReady","cls","definitionContext","createComponentContextRegistry","append","componentFactory","ComponentFactory_","createComponent","registry","elementSuper","createMount","elementStatus","el","doc","ownerDocument","contains","componentCreated","DefinitionContext_","once","definitionContextRegistry","seedIn","definitionSetup","perDefinition","spec","perComponent","createRegistry","Element","createElementType","status","destructionReason","whenOff","whenDestroyed","sts","whenOn","offSupply","eventSupply","off","ComponentContext_","EventSupply__symbol","done","lastRev","parentNode","parentElement","removeChild","removeElement","ComponentStatus__symbol","notifier","_","prevContext","newComponent","dispatchEvent","bubbles","doNotAdd","ComponentRegistry","_context","_definitionQueue","definition","push","buildElement","FeatureKey__symbol","FeatureKey","from","preferredFeatureClause","afterEventBy","origin","stageId","afterAll","clause","deps","loadFeatureDeps","request","loader","to","stage","ownLoader","FeatureLoader","ownSource","rcv","unload","share","lastLoader","preventDuplicateLoader","clauses","preferred","required","afterEach","dep","presentFeatureDeps","isPresent","down","_down","_stage","SetupFeatureStage","then","after","state","lastStage","id","prevStage","stop","FeatureStage","_stop","action","map","perDep","unloader","unloads","adder","reverse","newUnloader","componentRegistry","componentContextRegistry","elementBuilder","onDefinition","tillOff","onComponent","st","bs","by","onPostDefSetup","newFeatureContext","InitFeatureStage","ActiveFeatureStage","FeatureRequest","_requester","_revoke","featureDef","requester","isClause","_revokeBy","unuse","_uses","revoke","FeatureRequester__key","FeatureRequester","Map","_map","reuse","delete","bootstrapComponents","features","bootstrapContextRegistry","create","complete","newNamespaceAliaser","info","_ctx","ldr","whenDown","AfterEvent__symbol","initBootstrap","AttributeDescriptor","MultiContextKey","AttributePath__root","attributePathTo","attributeStateUpdate","updateState","path","update","updateAttributeState","AttributeRegistry__key","AttributeRegistry","attrs","_attrs","change","observedAttributes","keys","attributeFilter","records","record","attributeName","getAttribute","attributes","attributeOldValue","AttributesSupport__feature","as","AttributesSupport","Attribute","parseAttributeDescriptor","setAttribute","Attributes","defineByItem","ComponentState__key","ComponentState","StateTracker","StatePropertyPath__root","statePropertyPathTo","updateStatePropertyState","StateSupport__feature","with","StateSupport","StateProperty","statePropertyUpdate","trackAttribute","track","onUpdate","_path","ValueTracker","isOff","removeAttribute","DomPropertyDescriptor","DomPropertyRegistry__key","DomPropertyRegistry","props","_props","DomPropertiesSupport__feature","DomPropertiesSupport","DomPropertyPath__root","domPropertyPathTo","updateDomPropertyState","DomProperty","domDescriptor","propertyDesc","componentPropertyKey","domPropertyDescriptor","domPropertyUpdate","ElementRenderer","renderer","offline","stateTracker","schedule","stateSupply","scheduleRenderer","renderElement","cancelRenderer","execution","newRenderer","Render","defContext","render","Wesib__NS","NamespaceDef"],"mappings":"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"}