{"version":3,"file":"wesib.8c9ee002.js","sources":["../../../../wesib/src/boot/bootstrap-context.key.impl.ts","../../../../wesib/src/boot/bootstrap-context.ts","../../../../wesib/src/boot/bootstrap-default.ts","../../../../wesib/src/common/is-element.ts","../../../../wesib/src/common/meta-accessor.ts","../../../../wesib/src/feature/init-method.impl.ts","../../../../wesib/src/feature/feature-def.ts","../../../../wesib/src/feature/feature.decorator.ts","../../../../wesib/src/feature/feature-context.ts","../../../../wesib/src/feature/loader/bootstrap-workbench.impl.ts","../../../../wesib/src/component/component-def.ts","../../../../wesib/src/component/component.decorator.ts","../../../../wesib/src/component/component-context.key.impl.ts","../../../../wesib/src/component/component-event.key.impl.ts","../../../../wesib/src/component/content-root.ts","../../../../wesib/src/component/state-updater.ts","../../../../wesib/src/component/component-context.ts","../../../../wesib/src/component/component-slot.ts","../../../../wesib/src/component/component-event.ts","../../../../wesib/src/component/component-property.decorator.ts","../../../../wesib/src/common/decorators.ts","../../../../wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../../../wesib/src/boot/impl/component-context-registry.impl.ts","../../../../wesib/src/boot/impl/definition-context-registry.impl.ts","../../../../wesib/src/boot/impl/post-def-setup.impl.ts","../../../../wesib/src/boot/globals/bootstrap-window.ts","../../../../wesib/src/boot/globals/bootstrap-root.ts","../../../../wesib/src/boot/globals/default-namespace-aliaser.ts","../../../../wesib/src/boot/globals/default-render-scheduler.ts","../../../../wesib/src/boot/globals/element-adapter.ts","../../../../wesib/src/boot/globals/element-observer.ts","../../../../wesib/src/boot/impl/definition-context.symbol.impl.ts","../../../../wesib/src/component/definition/custom-elements.ts","../../../../wesib/src/component/definition/definition.context.key.impl.ts","../../../../wesib/src/component/definition/element-def.ts","../../../../wesib/src/component/definition/definition-context.ts","../../../../wesib/src/component/definition/component.impl.ts","../../../../wesib/src/boot/impl/component-status.impl.ts","../../../../wesib/src/boot/impl/component-context.impl.ts","../../../../wesib/src/boot/impl/component-mount.impl.ts","../../../../wesib/src/component/component-mount.ts","../../../../wesib/src/boot/impl/custom-element.impl.ts","../../../../wesib/src/boot/impl/when-component.impl.ts","../../../../wesib/src/boot/impl/definition-context.impl.ts","../../../../wesib/src/boot/impl/element-builder.impl.ts","../../../../wesib/src/feature/loader/component-registry.impl.ts","../../../../wesib/src/feature/loader/feature-context.impl.ts","../../../../wesib/src/feature/loader/feature-module.impl.ts","../../../../wesib/src/boot/impl/when-defined.impl.ts","../../../../wesib/src/boot/bootstrap/bootstrap-components.ts","../../../../wesib/src/feature/attributes/attribute-path.ts","../../../../wesib/src/feature/attributes/attribute-state-update.impl.ts","../../../../wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../../../wesib/src/feature/attributes/attribute-registry.ts","../../../../wesib/src/feature/attributes/attribute.decorator.ts","../../../../wesib/src/feature/attributes/attribute-changed.decorator.ts","../../../../wesib/src/feature/attributes/attributes.decorator.ts","../../../../wesib/src/feature/state/component-state.ts","../../../../wesib/src/feature/state/state-property-path.ts","../../../../wesib/src/feature/state/state-property-update.impl.ts","../../../../wesib/src/feature/state/state-property.decorator.ts","../../../../wesib/src/feature/attributes/track-attribute.ts","../../../../wesib/src/feature/dom-properties/dom-property-registry.ts","../../../../wesib/src/feature/dom-properties/dom-property-path.ts","../../../../wesib/src/feature/dom-properties/dom-property-update.impl.ts","../../../../wesib/src/feature/dom-properties/dom-property.decorator.ts","../../../../wesib/src/feature/dom-properties/dom-property-descriptor.impl.ts","../../../../wesib/src/feature/render/render-def.ts","../../../../wesib/src/feature/render/element-render-ctl.impl.ts","../../../../wesib/src/feature/render/element-render-ctl.ts","../../../../wesib/src/feature/render/element-render-scheduler.ts","../../../../wesib/src/feature/render/render.decorator.ts","../../../../wesib/src/feature/shadow-dom/shadow-content-root.ts","../../../../wesib/src/feature/shadow-dom/shadow-dom-event.ts","../../../../wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../../../wesib/src/feature/shadow-dom/attach-shadow.decorator.ts","../../../../wesib/src/wesib.ns.ts"],"sourcesContent":["import { SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","import { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class, SupplyPeer } from '@proc7ts/primitives';\nimport { ComponentClass, DefinitionContext } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to {@link FeatureDef.Options.init} method so that the feature can configure\n * itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * An `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[BootstrapContext]>;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   *\n   * @return An `OnEvent` sender of definition context sent when the given `componentType` is registered.\n   */\n  abstract whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature - The feature to load.\n   * @param user - The user of the feature. The feature reference will be dismissed once the user's supply is cut off.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class, user?: SupplyPeer): FeatureRef;\n\n}\n","import { ContextKey, ContextKeyDefault } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @typeParam TValue - Context value type.\n * @typeParam TKey - Context key type.\n * @param provide - A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<TValue, TKey extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: TKey) => TValue | null | undefined,\n): ContextKeyDefault<TValue, TKey> {\n  return (context, key): TValue | null | undefined => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext\n        ? provide(bootstrapContext, key)\n        : bootstrapContext.get(key) as TValue;\n  };\n}\n","/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node - A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","import { Class, superClassOf } from '@proc7ts/primitives';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<TMeta, TSrc = TMeta> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): TMeta | undefined {\n    // eslint-disable-next-line no-prototype-builtins,@typescript-eslint/no-unsafe-member-access\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] as TMeta : undefined;\n  }\n\n  of(type: Class): TMeta | undefined {\n\n    const ownDef: TMeta | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<TClass extends Class>(type: TClass, sources: readonly TSrc[]): TClass {\n\n    const prevMeta = this.own(type);\n    const updates = sources.map(source => this.meta(source, type));\n    const newMeta: TMeta = this.merge(prevMeta ? [prevMeta, ...updates] : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: readonly TMeta[]): TMeta;\n\n  protected abstract meta(source: TSrc, type: Class): TMeta;\n\n}\n","/**\n * @internal\n */\nexport type InitMethod<TTarget, TArgs extends any[]> =\n    (this: TTarget, ...args: TArgs) => void | PromiseLike<unknown>;\n\n/**\n * @internal\n */\nexport function mergeInitMethods<TTarget, TArgs extends any[]>(\n    target1: TTarget,\n    method1: InitMethod<TTarget, TArgs> | undefined,\n    target2: TTarget,\n    method2: InitMethod<TTarget, TArgs> | undefined,\n): InitMethod<void, TArgs> | undefined {\n\n  const m1 = method1 && (method1 as () => void | PromiseLike<undefined>).bind(target1) as InitMethod<void, TArgs>;\n  const m2 = method2 && (method2 as () => void | PromiseLike<undefined>).bind(target2) as InitMethod<void, TArgs>;\n\n  if (!m2) {\n    return m1;\n  }\n  if (!m1) {\n    return m2;\n  }\n\n  return async (...args) => {\n    await m1(...args);\n    await m2(...args);\n  };\n}\n","import { Class, elementOrArray, extendSetOfElements, setOfElements } from '@proc7ts/primitives';\nimport { BootstrapSetup } from '../boot';\nimport { MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\nimport { mergeInitMethods } from './init-method.impl';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\n/**\n * @category Core\n */\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup - Bootstrap setup.\n     *\n     * @returns Either nothing when setup completed synchronously, or a promise-like instance resolved when setup\n     * completed asynchronously.\n     */\n    setup?(setup: BootstrapSetup): void | PromiseLike<unknown>;\n\n    /**\n     * Initializes this feature by calling the given bootstrap context constructed.\n     *\n     * @param context - Feature initialization context.\n     *\n     * @returns Either nothing when initialization completed synchronously, or a promise-like instance resolved when\n     * initialization completed asynchronously.\n     */\n    init?(context: FeatureContext): void | PromiseLike<unknown>;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType - A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return defs.reduce<FeatureDef.Options>(\n        (prev, def) => ({\n          needs: elementOrArray(extendSetOfElements(setOfElements(prev.needs), def.needs)),\n          has: elementOrArray(extendSetOfElements(setOfElements(prev.has), def.has)),\n          setup: mergeInitMethods(prev, prev.setup, def, def.setup),\n          init: mergeInitMethods(prev, prev.init, def, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType - Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType - Target feature class constructor.\n   * @param def - A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs - Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs - Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return defs.reduce(\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeParam TClass - Feature type.\n   * @param featureType - Feature class constructor.\n   * @param defs - Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<TClass extends Class>(this: void, featureType: TClass, ...defs: readonly FeatureDef[]): TClass {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","import { Class } from '@proc7ts/primitives';\nimport { TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to {@link bootstrapComponents} function or referenced by other features.\n *\n * This is an alternative to direct call to {@link FeatureDef.define} method.\n *\n * @category Core\n * @typeParam TClass - A type of decorated feature class.\n * @param defs - Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<TClass extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<TClass> {\n  return (type: TClass) => FeatureDef.define(type, ...defs);\n}\n","import { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext\n    extends BootstrapContext\n    implements BootstrapSetup, SupplyPeer {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  /**\n   * An `OnEvent` sender of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[FeatureContext]>;\n\n  /**\n   * An `OnEvent` sender of component definition events.\n   *\n   * The registered receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   */\n  abstract readonly onDefinition: OnEvent<[DefinitionContext]>;\n\n  /**\n   * An `OnEvent` sender of component construction events.\n   *\n   * The registered receiver will be notified right before component is constructed.\n   */\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Feature supply.\n   *\n   * Cut off once feature unloaded.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a {@link BootstrapSetup.provide} method can be used.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   * @param spec - Context value specifier.\n   *\n   * @returns A value supply that removes the given context value specifier once cut off.\n   */\n  abstract provide<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<BootstrapContext, unknown, TSrc, TDeps>,\n  ): Supply;\n\n  abstract perDefinition<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<DefinitionContext, unknown, TSrc, TDeps>,\n  ): Supply;\n\n  abstract perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext, unknown, TSrc, TDeps>,\n  ): Supply;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class, user?: SupplyPeer): FeatureRef {\n    return this.get(BootstrapContext).load(\n        feature,\n        user ? new Supply().needs(this).needs(user) : this,\n    );\n  }\n\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Workbench, WorkStage } from '@proc7ts/workbench';\nimport { bootstrapDefault } from '../../boot';\n\n/**\n * @internal\n */\nexport type BootstrapWorkbench = Workbench;\n\n/**\n * @internal\n */\nexport const BootstrapWorkbench: ContextRef<BootstrapWorkbench> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-workbench',\n    {\n      byDefault: bootstrapDefault(() => new Workbench()),\n    },\n));\n\n/**\n * @internal\n */\nexport const featureSetupStage = (/*#__PURE__*/ new WorkStage('feature setup'));\n\n/**\n * @internal\n */\nexport const featureInitStage = (/*#__PURE__*/ new WorkStage('feature init', { after: featureSetupStage }));\n\n/**\n * @internal\n */\nexport const componentDefStage = (/*#__PURE__*/ new WorkStage('component definition', { after: featureInitStage }));\n\n","import { isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { mergeFunctions } from '@proc7ts/primitives';\nimport { MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\n/**\n * @category Core\n */\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup - Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param defContext - Component definition context.\n     */\n    define?(defContext: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType - A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\ntype ComponentDefHolder<T extends object> =\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | { [ComponentDef__symbol]?: undefined };\n\n/**\n * @internal\n */\ntype FeatureDefHolder =\n    | FeatureDef.Holder\n    | FeatureDef.Factory\n    | { [FeatureDef__symbol]?: undefined };\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: readonly ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return defs.reduce(\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as ComponentDefHolder<T>)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as FeatureDefHolder)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options<T>;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType - Target component class constructor.\n   * @param source - A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeParam T - A type of component.\n   * @param defs - Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeParam T - A type of component.\n   * @param defs - Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return defs.reduce<ComponentDef.Factory<T>>(\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under {@link ComponentDef__symbol} key.\n   *\n   * Each component can be passed directly to {@link bootstrapComponents} function or added as a requirement\n   * of another feature.\n   *\n   * @typeParam TClass - A type of component class.\n   * @param componentType - Component class constructor.\n   * @param defs - Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<TClass extends ComponentClass>(\n      this: void,\n      componentType: TClass,\n      ...defs: ComponentDef<InstanceType<TClass>>[]\n  ): TClass {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","import { Class } from '@proc7ts/primitives';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by {@link Component} function.\n *\n * @category Core\n * @typeParam TClass - A type of decorated component class.\n */\nexport interface ComponentDecorator<TClass extends ComponentClass = Class>\n    extends ComponentDef.Factory<InstanceType<TClass>> {\n\n  (this: void, type: TClass): TClass | void;\n\n}\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with {@link FeatureContext.define} method or used as a feature, e.g. passed to\n * {@link bootstrapComponents} function, or added to {@link FeatureDef.Options.needs} property of another feature.\n *\n * This is an alternative to direct call to {@link ComponentDef.Options.define} method.\n *\n * @category Core\n * @typeParam TClass - A type of decorated component class.\n * @param defs - Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<TClass extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<TClass>>[]\n): ComponentDecorator<TClass> {\n\n  const decorator = ((type: TClass) => ComponentDef.define(type, ...defs)) as ComponentDecorator<TClass>;\n  const def = decorator as ComponentDef.Factory<InstanceType<TClass>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        dispatcher.supply.needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * Either element itself, or its shadow root.\n *\n * @category Core\n */\nexport type ContentRoot = Element | ShadowRoot;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx): ContentRoot {\n        return ctx.get(ComponentContext__key).element as ContentRoot;\n      },\n    },\n));\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, statePath, StatePath } from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\n\n/**\n * Component state updater signature.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeParam TValue - Updated value type\n * @param path - Updated state node path.\n * @param newValue - New value.\n * @param oldValue - Replaced value.\n */\n    <TValue>(this: void, path: StatePath, newValue: TValue, oldValue: TValue) => void;\n\n/**\n * @category Core\n */\nexport namespace StateUpdater {\n\n  /**\n   * Normalized component state updater signature.\n   *\n   * Accepts normalized state path.\n   */\n  export type Normalized =\n  /**\n   * @typeParam TValue - Updated value type\n   * @param path - Normalized path of updated state node.\n   * @param newValue - New value.\n   * @param oldValue - Replaced value.\n   */\n      <TValue>(this: void, path: StatePath.Normalized, newValue: TValue, oldValue: TValue) => void;\n\n}\n\n/**\n * @internal\n */\nclass StateUpdaterKey extends ContextUpKey<StateUpdater, StateUpdater.Normalized> {\n\n  readonly upKey: ContextUpKey.UpKey<StateUpdater, StateUpdater.Normalized>;\n\n  constructor() {\n    super('state-updater');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...fns) => {\n              if (fns.length) {\n\n                const combined: StateUpdater.Normalized = fns.reduce(\n                    (prev, fn) => mergeFunctions(fn, prev),\n                    noop,\n                );\n\n                return afterThe((path, newValue, oldValue) => combined(statePath(path), newValue, oldValue));\n              }\n\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(noop);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          StateUpdater,\n          ContextUpKey.Source<StateUpdater.Normalized>,\n          AfterEvent<StateUpdater.Normalized[]>>,\n  ): void {\n\n    let delegated: StateUpdater;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        () => delegated = noop,\n    );\n\n    slot.insert((path, newValue, oldValue) => delegated(path, newValue, oldValue));\n  }\n\n}\n\n/**\n * A key of component context value containing a component {@link StateUpdater state updater} function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Does nothing by default and after component destruction.\n *\n * When multiple state updaters provided, they all will be called on each state update, in reverse order.\n *\n * @category Core\n */\nexport const StateUpdater: ContextUpRef<StateUpdater, StateUpdater.Normalized> = (/*#__PURE__*/ new StateUpdaterKey());\n","import { OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { AfterEvent, OnEvent, StatePath } from '@proc7ts/fun-events';\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of component instance method returning its component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perComponent}} and {@link DefinitionSetup.perComponent} methods.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements SupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Extracts component context from the given component instance.\n   *\n   * @param component - Target component instance.\n   *\n   * @return Component context reference returned by {@link ComponentContext__symbol} method.\n   *\n   * @throws TypeError  When the given `component` does not contain component context reference.\n   */\n  static of<T extends object>(component: ComponentInstance<T>): ComponentContext<T> {\n    if (typeof component[ComponentContext__symbol] !== 'function') {\n      throw new TypeError(`No component context found in ${String(component)}`);\n    }\n    return component[ComponentContext__symbol]!();\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A {@link whenReady} callback\n   * could be utilized to work this around.\n   */\n  abstract readonly component: ComponentInstance<T>;\n\n  /**\n   * Component mount.\n   *\n   * This is set when component is mounted to arbitrary element by {@link DefinitionContext.mountTo}. It is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the component is ready.\n   *\n   * Set to `true` when {@link component} is available.\n   */\n  abstract readonly ready: boolean;\n\n  /**\n   * An `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly onceReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of single component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   *\n   * In contrast to {@link onceReady}, cuts off the event supply after sending the first event.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * Whether the component is settled.\n   *\n   * Component settlement happens:\n   * - when {@link settle} method is called,\n   * - when component is {@link DefinitionContext.mountTo mounted} to element, or\n   * - when component's element is {@link connected}.\n   *\n   * It is guaranteed that component settlement won't happen inside custom element's constructor. So the settlement\n   * event may be used e.g. to start DOM manipulations, as the latter is prohibited inside custom element constructor.\n   *\n   * This becomes `true` right before {@link whenSettled} event is sent.\n   */\n  abstract readonly settled: boolean;\n\n  /**\n   * An `OnEvent` sender of component settlement event.\n   *\n   * The registered receiver is called when component is {@link settled}. If settled already the receiver is called\n   * immediately.\n   */\n  abstract readonly onceSettled: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of single component settlement event.\n   *\n   * The registered receiver is called when component is {@link settled}. If settled already the receiver is called\n   * immediately.\n   *\n   * In contrast to {@link onceSettled}, cuts off the event supply after sending the first event.\n   */\n  abstract readonly whenSettled: OnEvent<[this]>;\n\n  /**\n   * Whether the component's element is connected.\n   *\n   * This becomes `true` right before {@link whenConnected} event is sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An `OnEvent` sender of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   */\n  abstract readonly onceConnected: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of single component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   *\n   * In contrast to {@link onceConnected}, cuts off the event supply after sending the first event.\n   */\n  abstract readonly whenConnected: OnEvent<[this]>;\n\n  /**\n   * An `AfterEvent` keeper of component status.\n   *\n   * Sends this context instance each time the component status changes.\n   */\n  abstract readonly readStatus: AfterEvent<[this]>;\n\n  /**\n   * An event supply that {@link destroy destroys} component when cut off.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * @typeParam TValue - A type of changed value.\n   * @param key - Changed value key.\n   * @param newValue - New value.\n   * @param oldValue - Previous value.\n   */\n  readonly updateState: StateUpdater;\n\n  constructor() {\n    super();\n    this.updateState = <TValue>(key: StatePath, newValue: TValue, oldValue: TValue): void => {\n      this.get(StateUpdater)(key, newValue, oldValue);\n    };\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): ContentRoot {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Settles component.\n   *\n   * Calling this method has no effect if component is {@link settled} already, when component is not\n   * {@link whenReady ready} yet, or custom element's constructor is not exited.\n   *\n   * Calling this method may trigger DOM manipulations (the latter is prohibited inside custom element's constructor).\n   * This may be desired for rendering optimizations. E.g. to render element's content _before_ adding it to document.\n   *\n   * This method is called automatically when {@link DefinitionContext.mountTo mounting} component to element.\n   */\n  abstract settle(): void;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @typeParam TEvent - DOM event type.\n   * @param type - An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event - An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   * However the component is destroyed automatically once disconnected, i.e. when custom element's\n   * `disconnectedCallback()` method is called.\n   *\n   * @param reason - Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n\n/**\n * A component instance.\n *\n * @category Core\n */\nexport type ComponentInstance<T extends object = any> = T & {\n\n  /**\n   * @returns Component context.\n   */\n  [ComponentContext__symbol]?(): ComponentContext<T>;\n\n};\n","import { AfterEvent, AfterEvent__symbol, digOn_, EventKeeper, onceOn, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { ComponentContext } from './component-context';\n\n/**\n * A component slot.\n *\n * It is added to {@link ComponentElement component element} and contains a bound component context.\n *\n * Notifies on component binding.\n *\n * @category Core\n */\nexport interface ComponentSlot<T extends object = any> extends EventKeeper<[ComponentContext<T>?]> {\n\n  /**\n   * A context of the bound component.\n   */\n  readonly context: ComponentContext<T> | undefined;\n\n  /**\n   * An `AfterEvent` keeper of the bound component context.\n   */\n  readonly read: AfterEvent<[ComponentContext<T>?]>;\n\n  /**\n   * An `OnEvent` sender of the bound component {@link ComponentContext.whenReady readiness} event.\n   */\n  readonly whenReady: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Binds a component to element.\n   *\n   * This method is not typically used by client code.\n   *\n   * @param context - The bound component context.\n   */\n  bind(context: ComponentContext<T>): void;\n\n  /**\n   * Unbinds component from element.\n   *\n   * This method is not typically used by client code.\n   */\n  unbind(): void;\n\n}\n\n/**\n * A key of component element property containing a reference to component slot.\n *\n * @category Core\n */\nexport const ComponentSlot__symbol = (/*#__PURE__*/ Symbol('component-slot'));\n\n/**\n * An element the component can be bound to.\n *\n * Such element may contain a {@link ComponentSlot component slot} containing a bound component context.\n *\n * @category Core\n * @typeParam T - A type of the bound component.\n */\nexport interface ComponentElement<T extends object = any> extends Element {\n\n  /**\n   * A component slot instance.\n   *\n   * A {@link ComponentSlot.of} function may be used to access the slot instance, or construct it when necessary.\n   */\n  [ComponentSlot__symbol]?: ComponentSlot<T>;\n\n}\n\n/**\n * @category Core\n */\nexport const ComponentSlot = {\n\n  /**\n   * Accesses a component slot of the given element. Attaches a new slot if necessary.\n   *\n   * @param element - Target element.\n   *\n   * @returns A component slot instance attached to the element.\n   */\n  of<T extends object>(this: void, element: ComponentElement<T>): ComponentSlot<T> {\n\n    const found = element[ComponentSlot__symbol];\n\n    if (found) {\n      return found;\n    }\n\n    return element[ComponentSlot__symbol] = new ComponentSlot$();\n  },\n\n};\n\nclass ComponentSlot$<T extends object> implements ComponentSlot<T> {\n\n  private readonly _ctx = trackValue<ComponentContext<T>>();\n  readonly whenReady: OnEvent<[ComponentContext<T>]>;\n\n  constructor() {\n    this.whenReady = this._ctx.read.do(\n        digOn_(ctx => ctx && ctx.whenReady),\n        onceOn,\n    );\n  }\n\n  get context(): ComponentContext<T> | undefined {\n    return this._ctx.it;\n  }\n\n  get read(): AfterEvent<[ComponentContext<T>?]> {\n    return this._ctx.read;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[ComponentContext<T>?]> {\n    return this._ctx.read;\n  }\n\n  bind(context: ComponentContext<T>): void {\n    this._ctx.it = context;\n  }\n\n  unbind(): void {\n    this._ctx.it = undefined;\n  }\n\n}\n\n\n","import { OnDomEvent } from '@frontmeans/dom-events';\nimport { SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentElement, ComponentSlot } from './component-slot';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using {@link ComponentEventDispatcher} available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentSlot.of(this.target as ComponentElement).context!;\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param event - An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @typeParam TEvent - DOM event type.\n   * @param type - An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent>;\n\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","import { Class, PropertyAccessorDescriptor, valueProvider } from '@proc7ts/primitives';\nimport { decoratePropertyAccessor } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { Component, ComponentDecorator } from './component.decorator';\nimport { ComponentClass } from './definition';\n\n/**\n * Component property decorator interface.\n *\n * Allows to construct a {@link ComponentDecorator component decorator} by declaring a virtual property to use instead\n * of decorated one.\n *\n * Constructed by {@link ComponentProperty} function.\n *\n * @category Core\n * @typeParam TValue - Property value type.\n * @typeParam TClass - A type of decorated component class.\n */\nexport interface ComponentPropertyDecorator<TValue, TClass extends ComponentClass = Class> {\n\n  /**\n   * Decorates component method.\n   *\n   * @typeParam TPropValue - Property value type.\n   * @param proto - Decorated class prototype.\n   * @param propertyKey - Decorated property key.\n   * @param descriptor - Decorated property descriptor.\n   *\n   * @returns  Either updated property descriptor, or nothing.\n   */\n      <TPropValue extends TValue>(\n      this: void,\n      proto: InstanceType<TClass>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<TPropValue>,\n  ): any | void;\n\n  /**\n   * Builds component decorator assuming the virtual property has the given value.\n   *\n   * @param value - Virtual property value.\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}.\n   *\n   * @returns New component decorator.\n   */\n  As(\n      this: void,\n      value: TValue,\n      key?: string | symbol,\n  ): ComponentDecorator<TClass>;\n\n  /**\n   * Builds component decorator assuming the virtual property value is provided by the given `provider`.\n   *\n   * @param provider - Virtual property read-only value provider.\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}.\n   *\n   * @returns New component decorator.\n   */\n  By(\n      this: void,\n      provider: ComponentProperty.Provider<TValue, InstanceType<TClass>>,\n      key?: string | symbol,\n  ): ComponentDecorator<TClass>;\n\n  /**\n   * Builds component decorator assuming the decorated property is available via the given `accessor`.\n   *\n   * @param accessor - Virtual property accessor.\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}.\n   *\n   * @returns New component decorator.\n   */\n  With(\n      this: void,\n      accessor: ComponentProperty.Accessor<TValue, InstanceType<TClass>>,\n      key?: string | symbol,\n  ): ComponentDecorator<TClass>;\n\n  /**\n   * Builds component decorator assuming the decorated property is bound to component with by the given `binder`.\n   *\n   * @param binder - A binder of virtual property accessor\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}..\n   *\n   * @returns New component decorator.\n   */\n  Bind(\n      this: void,\n      binder: ComponentProperty.Binder<TValue, InstanceType<TClass>>,\n      key?: string | symbol,\n  ): ComponentDecorator<TClass>;\n\n}\n\n/**\n * @category Core\n */\nexport namespace ComponentProperty {\n\n  /**\n   * Component property value provider signature.\n   *\n   * This function will be called each time the property value is requested.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component.\n   */\n  export type Provider<TValue, T extends object = any> =\n  /**\n   * @param component - Component instance.\n   * @param key - Target property key.\n   *\n   * @returns Property value.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => TValue;\n\n  /**\n   * Component property accessor.\n   *\n   * Allows to read and write property value.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component.\n   */\n  export interface Accessor<TValue, T extends object = any> {\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component - Target component instance.\n     * @param key - Property key.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: T, key: string | symbol): TValue;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component - Target component instance.\n     * @param value - New property value.\n     * @param key - Property key.\n     */\n    set(this: void, component: T, value: TValue, key: string | symbol): void;\n\n  }\n\n  /**\n   * Property accessor binder signature.\n   *\n   * This is a function that binds a {@link BoundAccessor property accessor} to target component.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component.\n   */\n  export type Binder<TValue, T extends object = any> =\n  /**\n   * @param component - Target component to bind property accessor to.\n   * @param key - Property key.\n   *\n   * @returns Property accessor bound to `component`.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => BoundAccessor<TValue>;\n\n  export interface BoundAccessor<TValue> {\n\n    /**\n     * Reads bound component's property value.\n     *\n     * An attempt to read the value would throw when omitted.\n     *\n     * @returns Property value.\n     */\n    get?(): TValue;\n\n    /**\n     * Assigns bound component's new property value.\n     *\n     * An attempt to assign the value would throw when omitted.\n     *\n     * @param value - New property value.\n     */\n    set?(value: TValue): void;\n\n  }\n\n  /**\n   * Component property descriptor.\n   *\n   * Passed to {@link Definer property definer} by {@link ComponentProperty @ComponentProperty} decorator to build\n   * a {@link Definition property definition}.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam TClass - A type of component class.\n   */\n  export interface Descriptor<TValue, TClass extends ComponentClass = Class> {\n\n    /**\n     * Component class constructor.\n     */\n    readonly type: TClass;\n\n    /**\n     * Component property key.\n     */\n    readonly key: string | symbol;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.get property read definition}.\n     */\n    readonly readable: boolean;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.set property assignment definition}.\n     */\n    readonly writable: boolean;\n\n    /**\n     * Whether the property is initially enumerable.\n     *\n     * This can be changed by {@link Definition.enumerable property definition}.\n     */\n    readonly enumerable: boolean;\n\n    /**\n     * Whether the property is initially configurable.\n     *\n     * This can be changed by {@link Definition.configurable property definition}.\n     */\n    readonly configurable: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component - Target component instance.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: InstanceType<TClass>): TValue;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component - Target component instance.\n     * @param value - New property value.\n     */\n    set(this: void, component: InstanceType<TClass>, value: TValue): void;\n\n  }\n\n  /**\n   * A signature of component property definition builder.\n   *\n   * This is a function called by {@link ComponentProperty @ComponentProperty} decorator to define the property.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam TClass - A type of component class.\n   */\n  export type Definer<TValue, TClass extends ComponentClass = Class> =\n  /**\n   * @param descriptor - Component property descriptor.\n   *\n   * @returns Component property definition, or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<TValue, TClass>,\n      ) => Definition<TValue, TClass> | void;\n\n  /**\n   * Property definition to apply to existing property.\n   *\n   * When applying to decorated property, this definition updates its definition.\n   *\n   * When applying to virtual property assumed by one of {@link ComponentPropertyDecorator} methods, most of returned\n   * values ignored. Except for {@link Definition.componentDef component definition}, {@link Definition.get value\n   * reader}, and {@link Definition.set value setter}.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam TClass - A type of component class.\n   */\n  export interface Definition<TValue, TClass extends ComponentClass = Class> {\n\n    /**\n     * Component definition to apply to component.\n     *\n     * When specified, it is used to enable certain functionality for decorated (or virtual) property.\n     */\n    readonly componentDef?: ComponentDef<InstanceType<TClass>>;\n\n    /**\n     * Whether to make the property enumerable.\n     *\n     * When specified, it is used as `enumerable` attribute value of decorated property descriptor.\n     */\n    readonly enumerable?: boolean;\n\n    /**\n     * Whether to make the property configurable.\n     *\n     * When specified, it is used as `configurable` attribute value of decorated property descriptor.\n     */\n    readonly configurable?: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * When specified it changes how the property value is read.\n     *\n     * When neither {@link get}, nor {@link set} specified, the property access does not change.\n     *\n     * @param component - Target component instance.\n     * @param key - Property key.\n     *\n     * @returns Property value.\n     */\n    get?(this: void, component: InstanceType<TClass>, key: string | symbol): TValue;\n\n    /**\n     * Assigns new property value.\n     *\n     * When specified it changes how the property value is assigned.\n     *\n     * When neither {@link get}, nor {@link set} specified, the property access does not change.\n     *\n     * @param component - Target component instance.\n     * @param value - New property value.\n     * @param key - Property key.\n     */\n    set?(this: void, component: InstanceType<TClass>, value: TValue, key: string | symbol): void;\n\n  }\n\n}\n\n/**\n * Anonymous component property key.\n *\n * Used as a default virtual property key.\n *\n * @category Core\n */\nexport const AnonymousComponentProperty__symbol = (/*#__PURE__*/ Symbol('anonymous-component-property'));\n\n/**\n * Decorator of component property.\n *\n * Updates decorated property and component definition. Can be converted to {@link ComponentDecorator component\n * decorator} by calling appropriate method of returned decorator instance.\n *\n * @category Core\n * @typeParam TValue - Decorated property value type.\n * @typeParam TClass - A type of decorated component class.\n * @param define - Component property definition builders.\n *\n * @returns Component property decorator.\n */\nexport function ComponentProperty<TValue, TClass extends ComponentClass = Class>(\n    ...define: ComponentProperty.Definer<TValue, TClass>[]\n): ComponentPropertyDecorator<TValue, TClass> {\n\n  const decorator = (\n      proto: InstanceType<TClass>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<TValue>,\n  ): any | void => {\n\n    const updateDescriptor = ComponentProperty$updateDescriptor<TValue, TClass>(proto, propertyKey);\n\n    return decoratePropertyAccessor(\n        proto,\n        propertyKey,\n        descriptor,\n        desc => define.reduce(updateDescriptor, desc),\n    );\n  };\n  const decorateWith = (\n      accessor: ComponentProperty.Accessor<TValue, InstanceType<TClass>>,\n      key: string | symbol = AnonymousComponentProperty__symbol,\n      writable: boolean,\n  ): ComponentDecorator<TClass> => Component({\n    [ComponentDef__symbol](type: InstanceType<TClass>) {\n\n      const defineBy = ComponentProperty$defineBy(type, accessor, key, writable);\n\n      return ComponentDef.all(...define.map(defineBy));\n    },\n  });\n  const By = (\n      provider: ComponentProperty.Provider<TValue, InstanceType<TClass>>,\n      key?: string | symbol,\n  ): ComponentDecorator<TClass> => decorateWith(\n      {\n        get(component, key) {\n          return provider(component, key);\n        },\n      } as ComponentProperty.Accessor<TValue>,\n      key,\n      false,\n  );\n\n  const result = decorator as ComponentPropertyDecorator<TValue, TClass>;\n\n  result.With = (access, key) => decorateWith(access, key, true);\n  result.By = By;\n  result.As = (value, key?) => By(valueProvider(value), key);\n  result.Bind = (binder, key = AnonymousComponentProperty__symbol) => {\n\n    const accessor__symbol = Symbol(`${String(key)}:accessor`);\n\n    interface HostComponent {\n      [accessor__symbol]?: {\n        get(): TValue;\n        set(value: TValue): void;\n      };\n    }\n\n    const accessor = (component: HostComponent): {\n      get(): TValue;\n      set(value: TValue): void;\n    } => {\n\n      const existing = component[accessor__symbol];\n\n      if (existing) {\n        return existing;\n      }\n\n      const accessor = binder(component as InstanceType<TClass>, key);\n\n      return component[accessor__symbol] = {\n        get: accessor.get ? accessor.get.bind(accessor) : ComponentProperty$notReadable(key),\n        set: accessor.set ? accessor.set.bind(accessor) : ComponentProperty$notWritable(key),\n      };\n    };\n\n    return decorateWith(\n        {\n          get(component) {\n            return accessor(component).get();\n          },\n          set(component, value) {\n            return accessor(component).set(value);\n          },\n        },\n        key,\n        true,\n    );\n  };\n\n  return result;\n}\n\nfunction ComponentProperty$updateDescriptor<TValue, TClass extends ComponentClass>(\n    proto: InstanceType<TClass>,\n    propertyKey: string | symbol,\n): (\n    desc: PropertyAccessorDescriptor<TValue>,\n    definer: ComponentProperty.Definer<TValue, TClass>,\n) => PropertyAccessorDescriptor<TValue> {\n  return (\n      desc: PropertyAccessorDescriptor<TValue>,\n      definer: ComponentProperty.Definer<TValue, TClass>,\n  ): PropertyAccessorDescriptor<TValue> => {\n\n    const { get: getValue, set: setValue } = desc;\n    const type = proto.constructor as TClass;\n    const { get, set, configurable, enumerable, componentDef = {} } = definer({\n      type,\n      key: propertyKey,\n      readable: !!desc.get,\n      writable: !!desc.set,\n      enumerable: !!desc.enumerable,\n      configurable: !!desc.configurable,\n      get: getValue\n          ? ((component: InstanceType<TClass>) => getValue.call(component))\n          : ComponentProperty$notReadable(propertyKey),\n      set: setValue\n          ? ((component, value) => setValue.call(component, value))\n          : ComponentProperty$notWritable(propertyKey),\n    }) || {};\n\n    ComponentDef.define(type, componentDef);\n\n    const updated: PropertyAccessorDescriptor<TValue> = {\n      ...desc,\n      configurable: configurable ?? desc.configurable,\n      enumerable: enumerable ?? desc.enumerable,\n    };\n\n    if (get || set) {\n      updated.get = get && function (this: InstanceType<TClass>) {\n        return get(this, propertyKey);\n      };\n      updated.set = set && function (this: InstanceType<TClass>, value: TValue) {\n        set(this, value, propertyKey);\n      };\n    }\n\n    return updated;\n  };\n}\n\nfunction ComponentProperty$notReadable(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not readable`); };\n}\n\nfunction ComponentProperty$notWritable(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not writable`); };\n}\n\nfunction ComponentProperty$defineBy<TValue, TClass extends ComponentClass>(\n    type: InstanceType<TClass>,\n    { get, set }: ComponentProperty.Accessor<TValue, InstanceType<TClass>>,\n    key: string | symbol,\n    writable: boolean,\n): (\n    definer: ComponentProperty.Definer<TValue, TClass>,\n) => ComponentDef<InstanceType<TClass>> {\n  return definer => {\n\n    const def = definer({\n      type,\n      key,\n      readable: true,\n      writable,\n      enumerable: false,\n      configurable: false,\n      get: component => get(component, key),\n      set: (component, value) => set(component, value, key),\n    });\n\n    return (def && def.componentDef) || {};\n  };\n}\n","import {\n  Class,\n  fieldAccessorDescriptor,\n  PropertyAccessorDescriptor,\n  toPropertyAccessorDescriptor,\n} from '@proc7ts/primitives';\n\n/**\n * Typed class decorator.\n *\n * @category Utility\n * @typeParam TClass - A type of class to decorate.\n */\nexport type TypedClassDecorator<TClass extends Class> = (type: TClass) => TClass | void;\n\n/**\n * Typed property decorator.\n *\n * @category Utility\n * @typeParam TClass - A type of class the decorated property belongs to.\n */\nexport type TypedPropertyDecorator<TClass extends Class> =\n    <TValue>(\n        target: InstanceType<TClass>,\n        propertyKey: string | symbol,\n        descriptor?: TypedPropertyDescriptor<TValue>,\n    ) => any | void;\n\n/**\n * Property decorator helper converting a field or property to the one with accessor (`get` and optionally `set`).\n *\n * @category Utility\n * @typeParam T - A type of target object.\n * @typeParam TValue - A property value type.\n * @param target - Target object containing the property.\n * @param propertyKey - Target property key.\n * @param desc - Target property descriptor, or `undefined` for object fields.\n * @param updateDescriptor - Descriptor updater. Accepts the accessor descriptor as the only argument. If returns\n * a descriptor, then it is applied to the property. Otherwise the target property descriptor is never updated.\n *\n * @returns Updated property descriptor to return from decorator to apply to the property, or `undefined` if there is\n * nothing to update.\n */\nexport function decoratePropertyAccessor<T, TValue>(\n    target: T,\n    propertyKey: string | symbol,\n    desc: TypedPropertyDescriptor<TValue> | undefined,\n    updateDescriptor: (desc: PropertyAccessorDescriptor<TValue>) => PropertyAccessorDescriptor<TValue>,\n): PropertyAccessorDescriptor<TValue> | undefined {\n\n  const isField = !desc;\n  const accessorDesc = desc\n      ? toPropertyAccessorDescriptor(desc)\n      : fieldAccessorDescriptor(target, propertyKey as keyof T) as unknown as PropertyAccessorDescriptor<TValue>;\n  const updatedDesc = updateDescriptor(accessorDesc);\n\n  if (isField && updatedDesc) {\n    Object.defineProperty(target, propertyKey, updatedDesc);\n    return;\n  }\n\n  return updatedDesc;\n}\n","import {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextRef, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nexport type PerComponentRegistry = ComponentContextRegistry;\n\nexport const PerComponentRegistry: ContextRef<PerComponentRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'per-component-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n}\n","import { ContextRef, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\n/**\n * @internal\n */\nexport type PerDefinitionRegistry = DefinitionContextRegistry;\n\n/**\n * @internal\n */\nexport const PerDefinitionRegistry: ContextRef<PerDefinitionRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'per-definition-registry',\n    {\n      byDefault: bootstrapDefault(bsContext => new DefinitionContextRegistry(bsContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n}\n","import { EventEmitter, onAny, OnEvent, onEventBy, supplyOn, trackValue, valueOn } from '@proc7ts/fun-events';\nimport { asis, superClassOf, Supply } from '@proc7ts/primitives';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    supply: Supply,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on({\n      supply: receiver.supply.needs(supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady.do(supplyOn(supply));\n        const whenComponent = setup.whenComponent.do(supplyOn(supply));\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return setup.perDefinition(spec).needs(supply);\n          },\n          perComponent(spec) {\n            return setup.perComponent(spec).needs(supply);\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\ninterface PostDefComponentClass<T extends object> extends ComponentClass<T> {\n  [PostDefSetup__symbol]?: PostDefSetup<T>;\n}\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: PostDefComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return componentType[PostDefSetup__symbol] as PostDefSetup<T>;\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read.do(valueOn(asis));\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = Element;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of {@link BootstrapWindow}.\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { ContextValues, ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nclass DefaultRenderSchedulerKey extends ContextUpKey<DefaultRenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<DefaultRenderScheduler, RenderScheduler>;\n\n  constructor() {\n    super('default-render-scheduler');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...fns) => {\n              if (fns.length) {\n                return afterThe(toDefaultRenderScheduler(slot.context, fns[fns.length - 1]));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n              return afterThe(toDefaultRenderScheduler(slot.context, newRenderSchedule));\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          DefaultRenderScheduler,\n          ContextUpKey.Source<RenderScheduler>,\n          AfterEvent<RenderScheduler[]>>,\n  ): void {\n\n    let delegated: DefaultRenderScheduler;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        scheduler => delegated = toDefaultRenderScheduler(slot.context, scheduler),\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toDefaultRenderScheduler(\n    context: ContextValues,\n    scheduler: RenderScheduler,\n): DefaultRenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n\n/**\n * A key of bootstrap, definition, or component context value containing {@link DefaultRenderScheduler} instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new DefaultRenderSchedulerKey()\n);\n","import { html__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentElement, ComponentSlot__symbol } from '../../component';\nimport { DefaultNamespaceAliaser } from './default-namespace-aliaser';\n\n/**\n * Element adapter is a function able to bind a component to element. E.g. to mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * An element adapter is formed out of {@link ComponentBinder component binders} registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element - Target element to adapt.\n *\n * @returns Either a bound component's context, or `undefined` if element is not adapted.\n */\n    (this: void, element: ComponentElement) => ComponentContext | undefined;\n\n/**\n * A binder of component to element.\n *\n * Component binders form an {@link ElementAdapter element adapter} available in bootstrap context.\n *\n * @category Core\n */\nexport interface ComponentBinder {\n\n  /**\n   * Matching element name.\n   *\n   * The binder is applied only to elements with matching names.\n   */\n  readonly to: QualifiedName;\n\n  /**\n   * Binds component to element if applicable.\n   *\n   * @param element - Target element to adapt.\n   */\n  bind(element: ComponentElement): void;\n\n}\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ComponentBinder> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ComponentBinder>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(\n            digAfter((...binders: ComponentBinder[]): AfterEvent<[ElementAdapter]> => {\n              if (binders.length === 0) {\n                return slot.hasFallback && slot.or\n                    ? slot.or\n                    : afterThe(defaultElementAdapter);\n              }\n\n              const nsAlias = slot.context.get(DefaultNamespaceAliaser);\n              const adapterByName = new Map<string, ElementAdapter>();\n\n              for (const spec of binders) {\n\n                const name = html__naming.name(spec.to, nsAlias).toLowerCase();\n                const prev = adapterByName.get(name) || defaultElementAdapter;\n\n                adapterByName.set(\n                    name,\n                    element => {\n\n                      const context = prev(element);\n\n                      if (context) {\n                        return context;\n                      }\n\n                      spec.bind(element);\n\n                      return defaultElementAdapter(element);\n                    },\n                );\n              }\n\n              const combined = (element: ComponentElement): ComponentContext | undefined => {\n\n                const adapter = adapterByName.get(element.tagName.toLowerCase()) || defaultElementAdapter;\n\n                return adapter(element);\n              };\n\n              return afterThe(combined);\n            }),\n        )),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ElementAdapter,\n          ContextUpKey.Source<ComponentBinder>,\n          AfterEvent<ComponentBinder[]>>,\n  ): void {\n\n    let delegated: ElementAdapter;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        adapter => delegated = adapter,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert(element => delegated(element));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: ComponentElement): ComponentContext | undefined {\n\n  const slot = element[ComponentSlot__symbol];\n\n  return slot && slot.context;\n}\n\n/**\n * A key of bootstrap context value containing combined {@link ElementAdapter} instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ComponentBinder> = (\n    /*#__PURE__*/ new ElementAdapterKey()\n);\n","import { FnContextKey } from '@proc7ts/context-values/updatable';\nimport { filterArray, itsEach, overArray } from '@proc7ts/push-iterator';\nimport { isElement } from '../../common';\nimport { ComponentElement, ComponentMount, ComponentSlot__symbol } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * {@link disconnect}.\n   *\n   * @param target - A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options - An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new {@link ElementObserver} instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node as ComponentElement)?.checkConnected(),\n                );\n                itsEach(\n                    filterArray(mutation.addedNodes, isElement),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: ComponentElement): ComponentMount | undefined {\n  return node[ComponentSlot__symbol]?.context?.mount;\n}\n","import { ComponentClass, DefinitionContext } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const DefinitionContext__symbol = (/*#__PURE__*/ Symbol('definition-context'));\n\n/**\n * @internal\n */\nexport interface ComponentDefinitionClass<T extends object> extends ComponentClass<T> {\n  [DefinitionContext__symbol]?: DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport function definitionContextOf<T extends object>(\n    componentType: ComponentDefinitionClass<T>,\n): DefinitionContext<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (!componentType.hasOwnProperty(DefinitionContext__symbol)) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n  return componentType[DefinitionContext__symbol] as DefinitionContext<T>;\n}\n","import { html__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { Class, newPromiseResolver, PromiseResolver } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { definitionContextOf } from '../../boot/impl/definition-context.symbol.impl';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: bootstrapDefault(createCustomElements),\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName - A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType - A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName - Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(bsContext: BootstrapContext): CustomElements {\n\n  const customElements: CustomElementRegistry = bsContext.get(BootstrapWindow).customElements;\n  const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n\n  class CustomElements$ extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name, extend } = defContext.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name } = defContext.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise();\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new CustomElements$();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\ninterface CustomComponentClass<T extends object = any> extends ComponentClass<T> {\n  [ComponentResolver__symbol]?: PromiseResolver;\n}\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: CustomComponentClass): PromiseResolver {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(ComponentResolver__symbol)) {\n    return componentType[ComponentResolver__symbol] as PromiseResolver;\n  }\n  return componentType[ComponentResolver__symbol] = newPromiseResolver();\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n *\n * @category Core\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '../component-context';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentElement } from '../component-slot';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perDefinition} and {@link DefinitionSetup.perDefinition} methods. All {@link BootstrapContext}\n * values are available too.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * {@link ComponentDef.define} function. In such case you may wish to add a `whenReady()` callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * An `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   */\n  abstract readonly whenComponent: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element - Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: ComponentElement<T>): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element - Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connect();\n\n    return mount;\n  }\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeParam TSrc - The type of context value sources.\n   * @typeParam TDeps - A type of dependencies.\n   * @param spec - Component context value specifier.\n   *\n   * @returns A value supply that removes the given context value specifier once cut off.\n   */\n  abstract perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext<T>, unknown, TSrc, TDeps>,\n  ): Supply;\n\n}\n","import { ComponentContext, ComponentContext__symbol } from '../component-context';\nimport { ComponentClass } from './component-class';\n\nconst ComponentConstructor__symbol = (/*#__PURE__*/ Symbol('newComponent'));\n\ntype ComponentConstructor<T extends object> = (this: ComponentType<T>, context: ComponentContext<T>) => T;\n\ninterface ComponentType<T extends object> extends ComponentClass<T> {\n\n  [ComponentConstructor__symbol]?: ComponentConstructor<T>;\n\n}\n\n/**\n * @internal\n */\nexport function newComponent<T extends object>(context: ComponentContext<T>): T {\n\n  const componentType = context.componentType as ComponentType<T>;\n\n  if (!componentType[ComponentConstructor__symbol]) {\n    componentType[ComponentConstructor__symbol] = newComponentConstructor(componentType);\n  }\n\n  return componentType[ComponentConstructor__symbol]!(context);\n}\n\nfunction newComponentConstructor<T extends object>(componentType: ComponentType<T>): ComponentConstructor<T> {\n\n  // Component context reference specific to component class.\n  const context__symbol = Symbol('component-context');\n\n  type ComponentInstance = T & {\n    [context__symbol]?: ComponentContext<T>;\n  };\n\n  let defaultContext: ComponentContext<T> | undefined;\n\n  componentType.prototype[ComponentContext__symbol] = function (\n      this: ComponentInstance,\n  ): ComponentContext<T> {\n    return this[context__symbol] || (this[context__symbol] = defaultContext!);\n  };\n\n  return function (this: ComponentType<T>, context: ComponentContext<T>): T {\n\n    const prevContext = defaultContext;\n\n    // Ensure the component context is available in component constructor.\n    defaultContext = context;\n    try {\n\n      const component = new this(context) as ComponentInstance;\n\n      component[context__symbol] = context;\n\n      return component;\n    } finally {\n      defaultContext = prevContext;\n    }\n  };\n}\n","import { AfterEvent, filterOn_, mapAfter_, onceOn, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { Supply, valueProvider } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\n\nconst enum ComponentStatusValue {\n  Building,\n  Ready,\n  Settled,\n  Connected,\n}\n\n/**\n * @internal\n */\nexport class ComponentStatus<TCtx extends ComponentContext> {\n\n  private readonly _val = trackValue<ComponentStatusValue>(ComponentStatusValue.Building);\n  private _canSettle: 0 | 1 = 0;\n\n  constructor(private readonly _ctx: TCtx) {\n  }\n\n  get supply(): Supply {\n    return this._val.supply;\n  }\n\n  read(): AfterEvent<[TCtx]> {\n    return (this.read = valueProvider(this._val.read.do(\n        mapAfter_(valueProvider(this._ctx)),\n    )))();\n  }\n\n  isReady(): boolean {\n    return !!this._val.it && !this._val.supply.isOff;\n  }\n\n  onceReady(): OnEvent<[TCtx]> {\n    return (this.onceReady = valueProvider(this.read().do(\n        ComponentStatus$once(({ ready }) => ready),\n    )))();\n  }\n\n  whenReady(): OnEvent<[TCtx]> {\n    return (this.whenReady = valueProvider(this.onceReady().do(\n        onceOn,\n    )))();\n  }\n\n  isSettled(): boolean {\n    return this._val.it >= ComponentStatusValue.Settled && !this._val.supply.isOff;\n  }\n\n  onceSettled(): OnEvent<[TCtx]> {\n    return (this.onceSettled = valueProvider(this.read().do(\n        ComponentStatus$once(({ settled }) => settled),\n    )))();\n  }\n\n  whenSettled(): OnEvent<[TCtx]> {\n    return (this.whenSettled = valueProvider(this.onceSettled().do(\n        onceOn,\n    )))();\n  }\n\n  isConnected(): boolean {\n    return this._val.it >= ComponentStatusValue.Connected && !this._val.supply.isOff;\n  }\n\n  onceConnected(): OnEvent<[TCtx]> {\n    return (this.onceConnected = valueProvider(this.read().do(\n        // Filtering is enough, as there is no status after \"connected\"\n        filterOn_(({ connected }) => connected),\n    )))();\n  }\n\n  whenConnected(): OnEvent<[TCtx]> {\n    return (this.whenConnected = valueProvider(this.onceConnected().do(\n        onceOn,\n    )))();\n  }\n\n  ready(): void {\n    this._val.it = ComponentStatusValue.Ready;\n  }\n\n  settle(): void {\n    if (this._canSettle && this._val.it < ComponentStatusValue.Settled) {\n      // Prevent settling until exiting custom element constructor\n      this._val.it = ComponentStatusValue.Settled;\n    }\n  }\n\n  connect(): void {\n    this._val.it = ComponentStatusValue.Connected;\n  }\n\n  create(): void {\n    this._canSettle = 1; // Can settle now\n  }\n\n}\n\nfunction ComponentStatus$once<TCtx extends ComponentContext>(\n    test: (context: TCtx) => boolean,\n): (input: OnEvent<[TCtx]>) => OnEvent<[TCtx]> {\n  return input => onEventBy(receiver => {\n\n      let value = false;\n\n      input({\n        supply: receiver.supply,\n        receive(eventCtx, componentCtx) {\n\n          const newValue = test(componentCtx);\n\n          if (newValue && !value) {\n            value = newValue;\n            receiver.receive(eventCtx, componentCtx);\n          }\n        },\n      });\n    });\n}\n","import { AfterEvent, onceOn, OnEvent } from '@proc7ts/fun-events';\nimport { Supply, valueProvider } from '@proc7ts/primitives';\nimport {\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n  ComponentInstance,\n  ComponentSlot,\n} from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { newComponent } from '../../component/definition/component.impl';\nimport { ComponentStatus } from './component-status.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport abstract class ComponentContext$<T extends object> extends ComponentContext<T> {\n\n  readonly get: ComponentContext<T>['get'];\n  private readonly _status: ComponentStatus<this>;\n\n  constructor(\n      readonly _definitionContext: DefinitionContext$<T>,\n      readonly element: any,\n  ) {\n    super();\n\n    const registry = _definitionContext._newComponentRegistry();\n\n    registry.provide({ a: ComponentContext, is: this });\n    this.get = registry.newValues().get;\n    this._status = new ComponentStatus(this);\n  }\n\n  get componentType(): ComponentClass<T> {\n    return this._definitionContext.componentType;\n  }\n\n  get component(): ComponentInstance<T> {\n    return this._component();\n  }\n\n  get supply(): Supply {\n    return this._status.supply;\n  }\n\n  get ready(): boolean {\n    return this._status.isReady();\n  }\n\n  get onceReady(): OnEvent<[this]> {\n    return this._status.onceReady();\n  }\n\n  get whenReady(): OnEvent<[this]> {\n    return this._status.whenReady();\n  }\n\n  get settled(): boolean {\n    return this._status.isSettled();\n  }\n\n  get onceSettled(): OnEvent<[this]> {\n    return this._status.onceSettled();\n  }\n\n  get whenSettled(): OnEvent<[this]> {\n    return this._status.whenSettled();\n  }\n\n  get connected(): boolean {\n    return this._status.isConnected();\n  }\n\n  get onceConnected(): OnEvent<[this]> {\n    return this._status.onceConnected();\n  }\n\n  get whenConnected(): OnEvent<[this]> {\n    return this._status.whenConnected();\n  }\n\n  get readStatus(): AfterEvent<[this]> {\n    return this._status.read();\n  }\n\n  _component(): T {\n    throw new TypeError('Component is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  settle(): void {\n    this._status.settle();\n  }\n\n  destroy(reason?: any): void {\n    try {\n      this._status.supply.off(reason);\n    } finally {\n      delete this.component[ComponentContext__symbol];\n      this._component = componentDestroyed;\n      ComponentSlot.of(this.element).unbind();\n      removeElement(this.element);\n    }\n  }\n\n  _createComponent(): this {\n\n    const whenComponent = this._definitionContext._whenComponent;\n\n    let lastRev = 0;\n\n    ComponentSlot.of<T>(this.element).bind(this);\n    whenComponent.readNotifier.do(onceOn)(notifier => lastRev = notifier(this, lastRev));\n    this.whenConnected(() => {\n      whenComponent.readNotifier({\n        supply: new Supply().needs(this),\n        receive: (_, notifier) => {\n          lastRev = notifier(this, lastRev);\n        },\n      });\n    });\n    this._definitionContext._elementBuilder.components.send(this);\n\n    const component = newComponent(this);\n\n    this._component = valueProvider(component);\n    this._status.ready();\n\n    return this;\n  }\n\n  _connect(): void {\n    this._status.connect();\n  }\n\n  _created(): void {\n    this._status.create();\n    this.whenConnected(\n        () => this.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n    );\n  }\n\n}\n\nfunction removeElement(element: Element): void {\n\n  const { parentNode } = element;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n\nfunction componentDestroyed(): never {\n  throw new TypeError('Component destroyed already');\n}\n","import { ComponentMount } from '../../component';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass ComponentMount$<T extends object> extends ComponentMount<T> {\n\n  constructor(readonly context: ComponentContext$<T>) {\n    super();\n  }\n\n  get connected(): boolean {\n    return this.context.connected;\n  }\n\n  connect(): void {\n    this.context._connect();\n  }\n\n  checkConnected(): boolean {\n\n    const el = this.context.element as Element;\n    const doc = el.ownerDocument;\n    const connected = doc != null && doc.contains(el);\n\n    if (connected !== this.connected) {\n      if (connected) {\n        this.connect();\n      } else {\n        this.context.destroy();\n      }\n    }\n\n    return connected;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class MountComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  readonly mount: ComponentMount<T>;\n\n  constructor(definitionContext: DefinitionContext$<T>, element: any) {\n    super(definitionContext, element);\n    this.mount = this.mount = new ComponentMount$<T>(this);\n  }\n\n}\n","import { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by {@link DefinitionContext.mountTo} method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating {@link ComponentMount.connected} property. E.g. by calling a\n * {@link ComponentMount.checkConnected} method. An {@link ElementObserver} and {@link AutoConnectSupport} feature\n * could be used to do it automatically.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * The initial state is set by {@link checkConnected} method.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element as unknown;\n  }\n\n  /**\n   * Forcibly connects mounted component element to the document.\n   */\n  abstract connect(): void;\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * When component is disconnected after it has been connected, the component is {@link ComponentContext.destroy\n   * destroyed}.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { Class } from '@proc7ts/primitives';\nimport { CustomElementClass } from '../../common';\nimport { ComponentElement, ComponentSlot } from '../../component';\nimport { ElementDef } from '../../component/definition';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass CustomComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  get mount(): undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nexport function customElementType<T extends object>(\n    definitionContext: DefinitionContext$<T>,\n): Class {\n\n  const elementDef = definitionContext.get(ElementDef);\n\n  class CustomElement$ extends (elementDef.extend.type as CustomElementClass) implements ComponentElement {\n\n    constructor() {\n      super();\n\n      const context = new CustomComponentContext$(definitionContext, this);\n\n      context._createComponent();\n      context._created();\n    }\n\n    connectedCallback(): void {\n      super.connectedCallback?.();\n      (ComponentSlot.of<T>(this).context as ComponentContext$<T>)._connect();\n    }\n\n    disconnectedCallback(): void {\n      (ComponentSlot.of<T>(this).context as ComponentContext$<T>).destroy();\n      super.disconnectedCallback?.();\n    }\n\n  }\n\n  return CustomElement$;\n}\n","import { AfterEvent, EventEmitter, mapAfter_, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read.do(\n        mapAfter_(\n            rev => (context, notifiedRev) => {\n              created.send(context, notifiedRev);\n              return rev;\n            },\n        ),\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { mapOn_, onceOn, OnEvent, trackValue, translateOn, ValueTracker } from '@proc7ts/fun-events';\nimport { Class, Supply, valueProvider } from '@proc7ts/primitives';\nimport { ComponentContext, ComponentDef, ComponentElement, ComponentMount, ComponentSlot } from '../../component';\nimport { DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { ComponentContextRegistry, PerComponentRegistry } from './component-context-registry.impl';\nimport { MountComponentContext$ } from './component-mount.impl';\nimport { customElementType } from './custom-element.impl';\nimport { DefinitionContextRegistry, PerDefinitionRegistry } from './definition-context-registry.impl';\nimport { ComponentDefinitionClass, DefinitionContext__symbol } from './definition-context.symbol.impl';\nimport { ElementBuilder } from './element-builder.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport class DefinitionContext$<T extends object> extends DefinitionContext<T> {\n\n  readonly whenReady: OnEvent<[this]>;\n  readonly get: ContextValues['get'];\n  private readonly _def: ComponentDef.Options<T>;\n  readonly _whenComponent = new WhenComponent<T>();\n  private readonly _ready: ValueTracker<boolean>;\n  private readonly _whenReady: OnEvent<[]>;\n  private readonly _perComponentRegistry: ComponentContextRegistry;\n\n  constructor(\n      readonly _bsContext: BootstrapContext,\n      readonly _elementBuilder: ElementBuilder,\n      readonly componentType: ComponentDefinitionClass<T>,\n  ) {\n    super();\n    this._ready = trackValue(false);\n    this._whenReady = this._ready.read.do(translateOn((send, ready) => ready && send()));\n    this._def = ComponentDef.of(componentType);\n\n    const definitionContextRegistry = new DefinitionContextRegistry(_bsContext.get(PerDefinitionRegistry).seeds());\n\n    definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n\n    this.get = definitionContextRegistry.newValues().get;\n\n    const parentPerComponentRegistry = _bsContext.get(PerComponentRegistry).append(seedKey => this.get(seedKey));\n    this._perComponentRegistry = new ComponentContextRegistry(parentPerComponentRegistry.seeds());\n\n    this.whenReady = this._whenReady.do(mapOn_(valueProvider(this)), onceOn);\n\n    const definitionSetup: DefinitionSetup<T> = {\n      get componentType() {\n        return componentType;\n      },\n      whenReady: this.whenReady,\n      whenComponent: this.whenComponent,\n      perDefinition: spec => definitionContextRegistry.provide(spec),\n      perComponent: spec => this._perComponentRegistry.provide(spec),\n    };\n\n    this._def.setup?.(definitionSetup);\n    postDefSetup(componentType).setup(definitionSetup);\n  }\n\n  get elementType(): Class {\n    return this._elementType();\n  }\n\n  get whenComponent(): OnEvent<[ComponentContext<T>]> {\n    return this._whenComponent.onCreated;\n  }\n\n  mountTo(element: ComponentElement<T>): ComponentMount<T> {\n\n    const slot = ComponentSlot.of(element);\n\n    if (slot.context) {\n      throw new Error(`Element ${String(element)} already bound to component`);\n    }\n\n    const context = new MountComponentContext$(this, element);\n\n    context._createComponent();\n\n    const { mount } = context;\n\n    mount.checkConnected();\n    context._created();\n    context.settle();\n\n    return mount;\n  }\n\n  perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext<T>, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._perComponentRegistry.provide(spec);\n  }\n\n  _newComponentRegistry(): ComponentContextRegistry {\n    return new ComponentContextRegistry(this._perComponentRegistry.seeds());\n  }\n\n  _elementType(): Class {\n    throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  _define(): void {\n    this._def.define?.(this);\n    this._elementBuilder.definitions.send(this);\n    this._elementType = valueProvider(customElementType(this));\n    this.componentType[DefinitionContext__symbol] = this;\n    this._ready.it = true;\n  }\n\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { EventEmitter } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext]>;\n  readonly components: EventEmitter<[ComponentContext]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n  return {\n    definitions: new EventEmitter<[DefinitionContext]>(),\n    components: new EventEmitter<[ComponentContext]>(),\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const definitionContext = new DefinitionContext$(bsContext, this, componentType);\n\n      definitionContext._define();\n\n      return definitionContext;\n    },\n  };\n\n}\n","import { ContextModule } from '@proc7ts/context-values/updatable';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { ElementBuilder } from '../../boot/impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { BootstrapWorkbench, componentDefStage } from './bootstrap-workbench.impl';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _components?: ComponentClass[] = undefined;\n\n  constructor(private readonly _setup: ContextModule.Setup) {\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    if (this._components) {\n      this._components.push(componentType);\n    } else {\n      this._components = [componentType];\n      this._defineAll(this._components);\n    }\n  }\n\n  private _defineAll(components: readonly ComponentClass[]): void {\n\n    const workbench = this._setup.get(BootstrapWorkbench);\n    const whenDefined = workbench.work(componentDefStage).run(() => {\n\n      const customElements = this._setup.get(CustomElements);\n      const elementBuilder = this._setup.get(ElementBuilder);\n\n      components.forEach(componentType => {\n\n        const defContext = elementBuilder.buildElement(componentType);\n\n        customElements.define(componentType, defContext.elementType);\n      });\n\n      this._components = undefined;\n    });\n\n    this._setup.initBy(valueProvider(whenDefined));\n  }\n\n}\n","import { ContextRegistry, ContextValueSpec } from '@proc7ts/context-values';\nimport { ContextModule } from '@proc7ts/context-values/updatable';\nimport { onceOn, OnEvent, supplyOn, valueOn_ } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ElementBuilder,\n  onPostDefSetup,\n  PerComponentRegistry,\n  PerDefinitionRegistry,\n} from '../../boot/impl';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\n\n/**\n * @internal\n */\nexport class FeatureContext$ extends FeatureContext {\n\n  readonly whenReady: OnEvent<[FeatureContext]>;\n  private _onDefinition?: OnEvent<[DefinitionContext]>;\n  private _onComponent?: OnEvent<[ComponentContext]>;\n  readonly get: FeatureContext['get'];\n  private readonly _bsContext: BootstrapContext;\n  private readonly _componentRegistry: ComponentRegistry;\n\n  constructor(readonly feature: Class, private readonly _setup: ContextModule.Setup) {\n    super();\n\n    this._bsContext = _setup.get(BootstrapContext);\n\n    const handle = _setup.get(_setup.module);\n    const registry = new ContextRegistry<FeatureContext>(this._bsContext);\n\n    registry.provide({ a: FeatureContext, is: this });\n    this.get = registry.newValues().get;\n\n    this.whenReady = handle.read.do(\n        valueOn_(({ ready }) => ready && this),\n        onceOn,\n    );\n\n    this._componentRegistry = new ComponentRegistry(this._setup);\n  }\n\n  get supply(): Supply {\n    return this._setup.supply;\n  }\n\n  get onDefinition(): OnEvent<[DefinitionContext]> {\n    return this._onDefinition\n        || (this._onDefinition = this._setup.get(ElementBuilder).definitions.on.do(supplyOn(this)));\n  }\n\n  get onComponent(): OnEvent<[ComponentContext]> {\n    return this._onComponent\n        || (this._onComponent = this._setup.get(ElementBuilder).components.on.do(supplyOn(this)));\n  }\n\n  provide<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<BootstrapContext, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._bsContext.get(BootstrapContextRegistry).provide(spec).needs(this);\n  }\n\n  perDefinition<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<DefinitionContext, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._bsContext.get(PerDefinitionRegistry).provide(spec).needs(this);\n  }\n\n  perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._bsContext.get(PerComponentRegistry).provide(spec).needs(this);\n  }\n\n  setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n    return onPostDefSetup(componentType, this.supply);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._componentRegistry.define(componentType);\n  }\n\n}\n","import { ContextModule } from '@proc7ts/context-values/updatable';\nimport { Class, setOfElements, valueProvider } from '@proc7ts/primitives';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { BootstrapWorkbench, featureInitStage, featureSetupStage } from './bootstrap-workbench.impl';\nimport { FeatureContext$ } from './feature-context.impl';\n\nconst FeatureModule__symbol = (/*#__PURE__*/ Symbol('feature-module'));\n\ninterface FeatureClass extends Class {\n\n  [FeatureModule__symbol]?: FeatureModule;\n\n}\n\n/**\n * @internal\n */\nexport class FeatureModule extends ContextModule {\n\n  static of(feature: FeatureClass): FeatureModule {\n    if (Object.prototype.hasOwnProperty.call(feature, FeatureModule__symbol)) {\n      return feature[FeatureModule__symbol]!;\n    }\n    return feature[FeatureModule__symbol] = new FeatureModule(feature);\n  }\n\n  constructor(readonly feature: Class) {\n    super(feature.name, FeatureModule$options(feature));\n  }\n\n  async setup(setup: ContextModule.Setup): Promise<void> {\n\n    const workbench = setup.get(BootstrapWorkbench);\n\n    await workbench.work(featureSetupStage).run(() => super.setup(setup));\n  }\n\n}\n\nfunction FeatureModule$options(feature: Class): ContextModule.Options {\n\n  const def = featureDef(feature);\n  const has: FeatureModule[] = [];\n  const needs: FeatureModule[] = [];\n\n  for (const replaced of setOfElements(def.has)) {\n    has.push(FeatureModule.of(replaced));\n  }\n  for (const required of setOfElements(def.needs)) {\n    needs.push(FeatureModule.of(required));\n  }\n\n  return {\n    needs,\n    has,\n    async setup(setup) {\n\n      const workbench = setup.get(BootstrapWorkbench);\n      const featureContext = new FeatureContext$(feature, setup);\n\n      if (def.init) {\n\n        const whenInit = workbench.work(featureInitStage).run(async () => {\n          await def.init!(featureContext);\n        });\n\n        setup.initBy(valueProvider(whenInit));\n      }\n\n      await def.setup?.(featureContext);\n    },\n  };\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n","import { OnEvent, onPromise } from '@proc7ts/fun-events';\nimport { ComponentClass, CustomElements, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { definitionContextOf } from './definition-context.symbol.impl';\n\n/**\n * @internal\n */\nexport const WhenDefined__symbol = (/*#__PURE__*/ Symbol('when-defined'));\n\ninterface WhenDefinedComponentClass<T extends object> extends ComponentClass<T> {\n  [WhenDefined__symbol]?: OnEvent<[DefinitionContext<T>]>;\n}\n\n/**\n * @internal\n */\nexport function whenDefined<T extends object>(\n    bsContext: BootstrapContext,\n    componentType: WhenDefinedComponentClass<T>,\n): OnEvent<[DefinitionContext<T>]> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(WhenDefined__symbol)) {\n    return componentType[WhenDefined__symbol] as OnEvent<[DefinitionContext<T>]>;\n  }\n\n  const result: OnEvent<[DefinitionContext<T>]> = onPromise(\n      Promise.resolve(bsContext.whenReady)\n          .then(() => bsContext.get(CustomElements).whenDefined(componentType))\n          .then(() => definitionContextOf(componentType)),\n  );\n\n  return componentType[WhenDefined__symbol] = result;\n}\n","import { newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { ContextModule } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, AfterEvent__symbol, onceOn, OnEvent, trackValue, valueOn, valueOn_ } from '@proc7ts/fun-events';\nimport { Class, SupplyPeer, valueProvider } from '@proc7ts/primitives';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureModule } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { whenDefined } from '../impl/when-defined.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features - Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.load(feature)\n      .read\n      .do(\n          valueOn_(({ ready }) => ready),\n          onceOn,\n      )\n      .then(complete)\n      .catch(console.error);\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class BootstrapContext$ extends BootstrapContext {\n\n    readonly whenReady: OnEvent<[BootstrapContext]>;\n    readonly get = values.get;\n\n    constructor() {\n      super();\n      this.whenReady = stage.read.do(\n          valueOn(bsStage => !!bsStage && this),\n          onceOn,\n      );\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]> {\n      return whenDefined(this, componentType);\n    }\n\n    load(feature: Class, user?: SupplyPeer): FeatureRef {\n\n      const module = FeatureModule.of(feature);\n      const supply = bootstrapContextRegistry.provide(module);\n\n      if (user) {\n        supply.needs(user);\n      } else {\n        user = supply;\n      }\n\n      const use = this.get(module).use(user);\n      const read = FeatureRef$read(feature, use);\n\n      return {\n        read,\n        whenReady: read.do(\n            valueOn_(status => status.ready && status),\n            onceOn,\n        ),\n        [AfterEvent__symbol]: valueProvider(read),\n        supply,\n      };\n    }\n\n  }\n\n  const bootstrapContext = new BootstrapContext$();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n\nfunction FeatureRef$read(\n    feature: Class,\n    use: ContextModule.Use,\n): AfterEvent<[FeatureStatus]> {\n\n  const status = trackValue<FeatureStatus>({ feature, ready: false });\n\n  use.read(({ module, ready }) => {\n\n    const feature = (module as FeatureModule).feature;\n    const lastStatus = status.it;\n\n    if (!lastStatus || lastStatus.feature !== feature || lastStatus.ready !== ready) {\n      status.it = {\n        feature,\n        ready,\n      };\n    }\n  }).needs(use);\n  status.supply.needs(use);\n\n  return status.read;\n}\n","/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath.RootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name - Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\nexport namespace AttributePath {\n  export interface RootKeys {\n    [AttributePath__root]: true;\n  }\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(\n      component,\n      updateState,\n      newValue,\n      oldValue,\n  );\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string | null,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","import { hyphenateDecapName } from '@frontmeans/httongue';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends object>(\n    target: T,\n    propertyKey: string | symbol,\n    def?: AttributeDef<T> | string,\n): AttributeDescriptor<T> {\n\n  let name: string;\n  let change: AttributeChangedCallback<T>;\n\n  if (typeof def === 'string') {\n    name = hyphenateDecapName(def);\n    change = attributeStateUpdate(name);\n  } else {\n    if (def && def.name) {\n      name = hyphenateDecapName(def.name);\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = hyphenateDecapName(propertyKey);\n    }\n\n    change = attributeStateUpdate(name, def && def.updateState);\n  }\n\n  return { name, change };\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { mergeFunctions } from '@proc7ts/primitives';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { CustomElementClass } from '../../common';\nimport { ComponentElement, ComponentMount, ComponentSlot } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\n/**\n * A registry of component's element attributes.\n *\n * @category Feature\n */\nexport interface AttributeRegistry {\n\n  /**\n   * Declares component element's attribute.\n   *\n   * @param descriptor - Attribute descriptor.\n   */\n  declareAttribute(descriptor: AttributeDescriptor): void;\n\n}\n\n/**\n * A key of component definition context value containing {@link AttributeRegistry attribute registry}.\n *\n * @category Feature\n */\nexport const AttributeRegistry: ContextRef<AttributeRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<AttributeRegistry>(\n        'attribute-registry',\n        {\n          byDefault(context) {\n            return new AttributeRegistry$(context.get(DefinitionContext));\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nclass AttributeRegistry$ implements AttributeRegistry {\n\n  private readonly attrs = new Map<string, AttributeChangedCallback<any>>();\n\n  constructor(private readonly _context: DefinitionContext) {\n    _context.whenReady(({ elementType }) => this.define(elementType as CustomElementClass));\n    _context.whenComponent(({ mount }) => {\n      if (mount) {\n        // Mount element attributes\n        this.mount(mount);\n      }\n    });\n  }\n\n  declareAttribute({ name, change }: AttributeDescriptor): void {\n    this.attrs.set(name, mergeFunctions(this.attrs.get(name), change));\n  }\n\n  private define(elementType: CustomElementClass): void {\n\n    const { attrs } = this;\n\n    if (!attrs.size) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes(elementType, [...attrs.keys()]),\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: attributeChangedCallback(elementType, attrs),\n    });\n  }\n\n  private mount(mount: ComponentMount): void {\n\n    const { element } = mount as { element: ComponentElement };\n    const { attrs } = this;\n    const attributeFilter = [...attrs.keys()];\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  mount.context.component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n\n/**\n * @internal\n */\ntype ElementAttributeChanged = (\n    this: any,\n    name: string,\n    oldValue: string | null,\n    newValue: string | null,\n) => void;\n\n/**\n * @internal\n */\nfunction observedAttributes(\n    elementType: CustomElementClass,\n    attrs: readonly string[],\n): readonly string[] {\n\n  const alreadyObserved = elementType.observedAttributes;\n\n  if (Array.isArray(alreadyObserved)) {\n\n    const newAttrs = new Set<string>(alreadyObserved);\n\n    attrs.forEach(attr => newAttrs.add(attr));\n\n    attrs = [...newAttrs];\n  }\n\n  return attrs;\n}\n\n/**\n * @internal\n */\nfunction attributeChangedCallback<T extends object>(\n    elementType: CustomElementClass,\n    attrs: Map<string, AttributeChangedCallback<T>>,\n): ElementAttributeChanged {\n\n  const prevCallback = elementType.prototype.attributeChangedCallback;\n\n  if (!prevCallback) {\n    return function (this: ComponentElement<T>, name, oldValue, newValue) {\n      ComponentSlot.of(this).whenReady(({ component }) => {\n        attrs.get(name)!(component, newValue, oldValue);\n      });\n    };\n  }\n\n  return function (this: ComponentElement<T>, name, oldValue, newValue) {\n\n    const attrChanged = attrs.get(name);\n\n    if (attrChanged) {\n      ComponentSlot.of(this).whenReady(({ component }) => attrChanged(component, newValue, oldValue));\n    } else {\n      prevCallback.call(this, name, oldValue, newValue);\n    }\n  };\n}\n","import { ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributeRegistry } from './attribute-registry';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` removes corresponding attribute.\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param def - Attribute definition or just an attribute name (either _camelCase_ or _dash-style_).\n *\n * @return Component property decorator.\n */\nexport function Attribute<TClass extends ComponentClass>(\n    def?: AttributeDef<InstanceType<TClass>> | string,\n): ComponentPropertyDecorator<string | null, TClass> {\n  return ComponentProperty(({ type, key }) => {\n\n    const descriptor = parseAttributeDescriptor(type.prototype, key, def);\n    const { name } = descriptor;\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(AttributeRegistry).declareAttribute(descriptor);\n        },\n      },\n      get(component: InstanceType<TClass>): string | null {\n        return (ComponentContext.of(component).element as Element).getAttribute(name);\n      },\n      set(component: InstanceType<TClass>, newValue: string | null) {\n\n        const { element } = ComponentContext.of(component) as { element: Element };\n\n        if (newValue != null) {\n          element.setAttribute(name, newValue);\n        } else {\n          element.removeAttribute(name);\n        }\n      },\n    };\n  });\n}\n","import { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributeRegistry } from './attribute-registry';\n\n/**\n * Creates a component method decorator for custom element attribute change callback.\n *\n * The decorated method should have up to two parameters:\n *\n * - the first one accepts new attribute value.\n * - the second one accepts old attribute value (or `null`),\n *\n * Example:\n * ```TypeScript\n * @Component('my-component')\n * class MyComponent {\n *\n *   @AttributeChanged('my-attribute')\n *   myAttributeChanged(newValue: string, oldValue: string | null) {\n *     console.log(`my-attribute value changed from ${oldValue} to ${newValue}`);\n *   }\n *\n * }\n * ```\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param def - Attribute definition or just an attribute name.\n *\n * @return Component method decorator.\n */\nexport function AttributeChanged<TClass extends ComponentClass>(\n    def?: AttributeDef<InstanceType<TClass>> | string,\n): ComponentPropertyDecorator<(newValue: string | null, oldValue: string | null) => void, TClass> {\n  return ComponentProperty(({ type, get, key }) => {\n\n    const { name, change } = parseAttributeDescriptor(type.prototype, key, def);\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(AttributeRegistry).declareAttribute({\n            name,\n            change(\n                component: InstanceType<TClass>,\n                newValue: string | null,\n                oldValue: string | null,\n            ) {\n\n              const callback = get(component);\n\n              callback.call(component, newValue, oldValue);\n              change(component, newValue, oldValue);\n            },\n          });\n        },\n      },\n    };\n  });\n}\n","import { hyphenateDecapName } from '@frontmeans/httongue';\nimport { StatePath } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { Component, ComponentDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeRegistry } from './attribute-registry';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\n\n/**\n * Creates a component decorator declaring supported custom element's attributes.\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param items - Attributes definition options.\n *\n * @return New component decorator.\n */\nexport function Attributes<TClass extends ComponentClass = Class>(\n    ...items: readonly Attributes.Item<InstanceType<TClass>>[]\n): ComponentDecorator<TClass> {\n  return Component({\n    define(defContext) {\n\n      const registry = defContext.get(AttributeRegistry);\n\n      for (const item of items) {\n        if (typeof item === 'string') {\n\n          const name = hyphenateDecapName(item);\n\n          registry.declareAttribute({\n            name,\n            change: attributeStateUpdate(name),\n          });\n        } else {\n          for (const [key, updateState] of Object.entries(item)) {\n\n            const name = hyphenateDecapName(key);\n\n            registry.declareAttribute({\n              name,\n              change: attributeStateUpdate(name, updateState),\n            });\n          }\n        }\n      }\n    },\n  });\n}\n\n/**\n * @category Feature\n */\nexport namespace Attributes {\n\n  /**\n   * Attribute definition item.\n   *\n   * This is either an attribute name (_camelCase_ or _dash-style_), or a per-attribute options map.\n   *\n   * @typeParam T - A type of component.\n   */\n  export type Item<T extends object> = Map<T> | string;\n\n  /**\n   * Per-attribute definition options.\n   *\n   * This is a map with attribute names as keys (either _camelCase_ or _dash-style_), and their state update\n   * instructions as values.\n   *\n   * The state update instruction can be one of:\n   * - `false` to not update the component state,\n   * - `true` to update the component state with changed attribute key,\n   * - a state value key to update, or\n   * - an attribute update receiver function with custom state update logic.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Map<T extends object> {\n    readonly [name: string]: boolean | StatePath | AttributeUpdateReceiver<T>;\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextValueSlot, SimpleContextKey } from '@proc7ts/context-values';\nimport { StateTracker } from '@proc7ts/fun-events';\nimport { ComponentContext, StateUpdater } from '../../component';\n\nclass ComponentStateKey extends SimpleContextKey<ComponentState> {\n\n  constructor() {\n    super('component-state');\n  }\n\n  grow(\n      slot: ContextValueSlot<ComponentState, ComponentState, SimpleContextKey.Seed<ComponentState>>,\n  ): void {\n\n    const provided = slot.seed();\n    let state: ComponentState;\n\n    if (provided != null) {\n      state = provided;\n      slot.insert(state);\n    } else if (slot.hasFallback) {\n      return;\n    } else {\n      state = new ComponentState();\n      slot.context.get(ComponentContext).supply.whenOff(reason => state.done(reason));\n      slot.insert(state);\n    }\n\n    slot.setup(({ registry }) => {\n      registry.provide({ a: StateUpdater, is: state.update });\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new ComponentStateKey());\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * A path to sub-state containing component state properties.\n *\n * Thus a property state path is always something like `[StatePropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const StatePropertyPath__root = (/*#__PURE__*/ Symbol('state-property'));\n\n/**\n * A path to the named component property state.\n *\n * @category Feature\n * @typeParam TKey - Target property key type.\n */\nexport type StatePropertyPath<TKey extends PropertyKey = PropertyKey> = readonly [\n  keyof StatePropertyPath.RootKeys,\n  TKey,\n];\n\n/**\n * Constructs a named component property state path.\n *\n * @category Feature\n * @typeParam TKey - Target property key type.\n * @param key - Target property key.\n *\n * @return DOM property state path.\n */\nexport function statePropertyPathTo<TKey extends PropertyKey = PropertyKey>(key: TKey): StatePropertyPath<TKey> {\n  return [StatePropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\nexport namespace StatePropertyPath {\n  export interface RootKeys {\n    [StatePropertyPath__root]: true;\n  }\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { StatePropertyPath, statePropertyPathTo } from './state-property-path';\nimport { StatePropertyUpdateReceiver } from './state-property.decorator';\n\n/**\n * @internal\n */\nexport type StatePropertyUpdateCallback<T extends object> = <TKey extends keyof T>(\n    this: void,\n    component: T,\n    newValue: T[TKey],\n    oldValue: T[TKey],\n) => void;\n\n/**\n * @internal\n */\nexport function statePropertyUpdate<T extends object>(\n    propertyKey: PropertyKey,\n    updateState: true | StatePropertyUpdateReceiver<T> | StatePath = true,\n): StatePropertyUpdateCallback<T> {\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = statePropertyPathTo(propertyKey as keyof T);\n    const update = updateState === true ? updateStatePropertyState : updateState;\n\n    return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n    }\n  };\n}\n\nfunction updateStatePropertyState<T extends object, TKey extends keyof T>(\n    component: T,\n    path: StatePropertyPath<TKey>,\n    newValue: T[TKey],\n    oldValue: T[TKey],\n): void {\n  if (newValue !== oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n  }\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StatePropertyPath } from './state-property-path';\nimport { statePropertyUpdate } from './state-property-update.impl';\n\n/**\n * Creates a decorator of component property containing part of component state.\n *\n * Once such property updated, the component state is {@link ComponentContext.updateState also updated}.\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param def - Custom element property definition.\n *\n * @returns Component property decorator.\n */\nexport function StateProperty<TValue = any, TClass extends ComponentClass = Class>(\n    { updateState }: StatePropertyDef<InstanceType<TClass>> = {},\n): ComponentPropertyDecorator<TValue, TClass> {\n  return ComponentProperty(({ get, set, key }) => {\n    if (updateState !== false) {\n\n      const setValue = set;\n      const update = statePropertyUpdate(key, updateState);\n\n      set = (component, newValue) => {\n\n        const oldValue = get(component);\n\n        setValue(component, newValue);\n        update(component, newValue, oldValue);\n      };\n    }\n\n    return {\n      get,\n      set,\n    };\n  });\n}\n\n/**\n * Component state property definition.\n *\n * This is a parameter to {@link StateProperty @StateProperty} decorator applied to component property.\n *\n * @category Feature\n */\nexport interface StatePropertyDef<T extends object = any> {\n\n  /**\n   * Whether to update the component state after this property changed.\n   *\n   * Can be one of:\n   * - `false` to not update the component state,\n   * - `true` (the default value) to update the component state with changed property key,\n   * - a state value key to update, or\n   * - an state property update receiver function with custom state update logic.\n   *\n   * By default does not update component state if property value didn't change.\n   */\n  readonly updateState?: boolean | StatePath | StatePropertyUpdateReceiver<T>;\n\n}\n\n/**\n * Component state property updates receiver invoked when its value changed.\n *\n * @category Feature\n * @typeParam T - A type of component.\n */\nexport type StatePropertyUpdateReceiver<T extends object> =\n/**\n * @typeParam TKey - A type of component property keys.\n * @param component - Component instance.\n * @param path - The changed property state path in the form of `[StatePropertyPath__root, propertyKey]`.\n * @param newValue - New property value.\n * @param oldValue - Previous property value.\n */\n    <TKey extends keyof T>(\n        this: void,\n        component: T,\n        path: StatePropertyPath<TKey>,\n        newValue: T[TKey],\n        oldValue: T[TKey],\n    ) => void;\n","import { OnEvent, StatePath, supplyOn, translateOn, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly on: OnEvent<[string | null, string | null]>;\n  readonly supply = new Supply();\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _name: string,\n      path: StatePath,\n  ) {\n    super();\n    this.on = this._context.get(ComponentState).track(path).onUpdate.do(\n        translateOn((send, _path, newValue, oldValue) => send(newValue, oldValue)),\n        supplyOn(this),\n    );\n  }\n\n  get it(): string | null {\n    return (this._context.element as Element).getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (!this.supply.isOff) {\n      if (value == null) {\n        (this._context.element as Element).removeAttribute(this._name);\n      } else {\n        (this._context.element as Element).setAttribute(this._name, value);\n      }\n    }\n  }\n\n}\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires attribute to be defined. E.g. with {@link Attribute @Attribute}, {@link AttributeChanged @AttributeChanged},\n * or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context - Target component context.\n * @param name - Attribute name.\n * @param path - Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n  return new AttributeTracker(context, name, path);\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\n\n/**\n * A registry of component's element properties.\n *\n * @category Feature\n */\nexport interface DomPropertyRegistry {\n\n  /**\n   * Declares component element's property.\n   *\n   * @param descriptor - Property descriptor.\n   */\n  declareDomProperty(descriptor: DomPropertyDescriptor): void;\n\n}\n\n/**\n * A key of component definition context value containing {@link DomPropertyRegistry DOM property registry}.\n *\n * @category Feature\n */\nexport const DomPropertyRegistry: ContextRef<DomPropertyRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<DomPropertyRegistry>(\n        'dom-property-registry',\n        {\n          byDefault(context) {\n            return new DomPropertyRegistry$(context.get(DefinitionContext));\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nclass DomPropertyRegistry$ implements DomPropertyRegistry {\n\n  private readonly props = new Map<PropertyKey, PropertyDescriptor>();\n\n  constructor(defContext: DefinitionContext) {\n    defContext.whenReady(\n        ({ elementType }) => this.define(elementType),\n    );\n    defContext.whenComponent(({ mount }) => {\n      if (mount) {\n        // Mount element properties\n        this.mount(mount);\n      }\n    });\n  }\n\n  declareDomProperty({ key, descriptor }: DomPropertyDescriptor): void {\n    this.props.set(key, descriptor);\n  }\n\n  private define<T extends object>(elementType: Class<T>): void {\n\n    const prototype = elementType.prototype;\n\n    this.props.forEach((desc, key) => {\n      Object.defineProperty(prototype, key, desc);\n    });\n  }\n\n  private mount<T extends object>({ element }: ComponentMount<T>): void {\n    this.props.forEach((desc, key) => {\n      Object.defineProperty(element, key, desc);\n    });\n  }\n\n}\n","/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n * @typeParam TKey - Property key type.\n */\nexport type DomPropertyPath<TKey extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath.RootKeys, TKey];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @typeParam TKey - Property key type.\n * @param key - Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<TKey extends PropertyKey = PropertyKey>(key: TKey): DomPropertyPath<TKey> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\nexport namespace DomPropertyPath {\n  export interface RootKeys {\n    [DomPropertyPath__root]: true;\n  }\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { DomPropertyUpdateReceiver } from './dom-property-def';\nimport { DomPropertyPath, domPropertyPathTo } from './dom-property-path';\n\n/**\n * @internal\n */\nexport type DomPropertyUpdateCallback<T extends object> = <TKey extends keyof T>(\n    this: void,\n    component: T,\n    newValue: T[TKey],\n    oldValue: T[TKey],\n) => void;\n\n/**\n * @internal\n */\nexport function domPropertyUpdate<T extends object>(\n    propertyKey: PropertyKey,\n    updateState: true | DomPropertyUpdateReceiver<T> | StatePath = true,\n): DomPropertyUpdateCallback<T> {\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = domPropertyPathTo(propertyKey as keyof T);\n    const update = updateState === true ? updateDomPropertyState : updateState;\n\n    return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n  return (component, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n    }\n  };\n}\n\nfunction updateDomPropertyState<T extends object, TKey extends keyof T>(\n    component: T,\n    path: DomPropertyPath<TKey>,\n    newValue: T[TKey],\n    oldValue: T[TKey],\n): void {\n  if (newValue !== oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n  }\n}\n","import { Class } from '@proc7ts/primitives';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { DomPropertyDef } from './dom-property-def';\nimport { domPropertyDescriptor } from './dom-property-descriptor.impl';\nimport { DomPropertyRegistry } from './dom-property-registry';\nimport { domPropertyUpdate } from './dom-property-update.impl';\n\n/**\n * Creates component property decorator that declares a property to add to custom element created for this component.\n *\n * The value of declared element's property will be read from and written to decorated one.\n *\n * By default does not update component state if property value didn't change.\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param def - Custom element property definition.\n *\n * @returns Component property decorator.\n */\nexport function DomProperty<TValue = any, TClass extends ComponentClass = Class>(\n    def: DomPropertyDef<InstanceType<TClass>> = {},\n): ComponentPropertyDecorator<TValue, TClass> {\n  return ComponentProperty(descriptor => {\n\n    const { key, get } = descriptor;\n    let { set } = descriptor;\n    const domDescriptor = domPropertyDescriptor(descriptor, def);\n\n    if (def.updateState !== false) {\n\n      const updateState = domPropertyUpdate<InstanceType<TClass>>(key, def.updateState);\n      const setValue = set;\n\n      set = (component, newValue) => {\n\n        const oldValue = get(component);\n\n        setValue(component, newValue);\n        updateState(component, newValue, oldValue);\n      };\n    }\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(DomPropertyRegistry).declareDomProperty(domDescriptor);\n        },\n      },\n      get,\n      set,\n    };\n  });\n}\n\n/**\n * Component method decorator that declares a method to add to custom element created for this component.\n *\n * This is just an alias of {@link DomProperty @DomProperty} decorator.\n *\n * @category Feature\n */\nexport { DomProperty as DomMethod };\n","import { PropertyAccessorDescriptor } from '@proc7ts/primitives';\nimport { ComponentElement, ComponentProperty, ComponentSlot } from '../../component';\nimport { DomPropertyDef } from './dom-property-def';\nimport { DomPropertyDescriptor } from './dom-property-descriptor';\n\n/**\n * @internal\n */\nexport function domPropertyDescriptor<TValue>(\n    propertyDesc: ComponentProperty.Descriptor<TValue>,\n    {\n      propertyKey: key = propertyDesc.key,\n      configurable = propertyDesc.configurable,\n      enumerable = propertyDesc.enumerable,\n      writable = propertyDesc.writable,\n    }: DomPropertyDef,\n): DomPropertyDescriptor {\n\n  type ComponentType = { [TKey in ComponentProperty.Descriptor<TValue>['key']]: TValue };\n\n  const componentPropertyKey = propertyDesc.key as string;\n  const descriptor: PropertyAccessorDescriptor<TValue> = {\n    configurable,\n    enumerable,\n    get: function (this: ComponentElement<ComponentType>): TValue {\n      return ComponentSlot.of(this).context?.component[componentPropertyKey] as TValue;\n    },\n    set: writable\n        ? function (this: ComponentElement<ComponentType>, value: TValue) {\n          ComponentSlot.of(this).whenReady(({ component }) => component[componentPropertyKey] = value);\n        }\n        : undefined,\n  };\n\n  return { key, descriptor };\n}\n","import {\n  EventSender,\n  isEventSender,\n  OnEvent,\n  onSupplied,\n  StatePath,\n  supplyOn,\n  translateOn_,\n} from '@proc7ts/fun-events';\nimport { valueByRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\n\n/**\n * Element rendering definition.\n *\n * This is either a {@link RenderDef.Spec rendering specifier}, or its {@link RenderDef.Provider provider function}.\n *\n * @category Feature\n */\nexport type RenderDef =\n    | RenderDef.Spec\n    | RenderDef.Provider;\n\n/**\n * @category Feature\n */\nexport namespace RenderDef {\n\n  /**\n   * Rendering options.\n   */\n  export interface Options {\n\n    /**\n     * When to start the rendering.\n     *\n     * One of:\n     * - `settled` (the default) - start rendering when component is {@link ComponentContext.settled settled}.\n     * - `connected` - start rendering when component's element is {@link ComponentContext.connected connected}\n     *   to document.\n     */\n    readonly when?: 'settled' | 'connected';\n\n    /**\n     * Reports rendering error. E.g. a render shot execution failure.\n     *\n     * @param messages - Error messages to report.\n     */\n    error?(...messages: any[]): void;\n\n  }\n\n  /**\n   * Rendering specifier.\n   */\n  export interface Spec extends Options {\n\n    /**\n     * A trigger that issues rendering.\n     *\n     * This can be useful e.g. when component has multiple independent sub-views.\n     *\n     * This can be one of the following:\n     * - A path to component state part the renderer should track. The rendering would trigger only when the target\n     *   state part is updated.\n     * - Arbitrary event sender. The rendering would be triggered on any event from this sender.\n     *\n     * A root state path is tracked when omitted.\n     *\n     * When trigger is a root path (the default value), then the rendering will be triggered by any state update.\n     * Except for updates of sub-states inside {@link RenderPath__root}.\n     */\n    readonly on?: StatePath | EventSender<[]>;\n\n  }\n\n  /**\n   * Rendering specifier provider signature.\n   */\n  export type Provider =\n  /**\n   * @param context - A context of component to render.\n   *\n   * @returns Rendering specifier.\n   */\n      (\n          this: void,\n          context: ComponentContext,\n      ) => RenderDef.Spec;\n\n}\n\n/**\n * A root path to sub-states updates to which will be ignored by default.\n *\n * This can be used to create sub-states that won't trigger rendering occasionally, but only when requested explicitly.\n *\n * @category Feature\n */\nexport const RenderPath__root = (/*#__PURE__*/ Symbol('render'));\n\n/**\n * @category Feature\n */\nexport const RenderDef = {\n\n  /**\n   * Builds a rendering specifier for component by its definition.\n   *\n   * @param context - A context of component to render.\n   * @param def - Arbitrary rendering definition.\n   *\n   * @returns Rendering specifier.\n   */\n  spec(\n      this: void,\n      context: ComponentContext,\n      def: RenderDef,\n  ): RenderDef.Spec {\n    return valueByRecipe(def, context);\n  },\n\n  /**\n   * Fulfills rendering specifier with the given defaults.\n   *\n   * @param base - Base rendering specifier to fulfill.\n   * @param defaults - Defaults that will be applied unless defined in `base` specifier.\n   *\n   * @return `base` rendering specifier fulfilled by `defaults`.\n   */\n  fulfill(this: void, base: RenderDef.Spec, defaults: RenderDef.Spec = {}): RenderDef.Spec {\n\n    const { on = defaults.on, error } = base;\n\n    return {\n      on,\n      error: error ? error.bind(base) : defaults.error && defaults.error.bind(defaults),\n    };\n  },\n\n  /**\n   * Builds a trigger issuing rendering updates.\n   *\n   * @param context - Rendered component context.\n   * @param spec - Rendering specifier.\n   *\n   * @returns `OnEvent` sender that sends an event each time the rendering required.\n   */\n  trigger(\n      this: void,\n      context: ComponentContext,\n      spec: RenderDef.Spec = {},\n  ): OnEvent<[]> {\n\n    const { on = [] } = spec;\n\n    if ((typeof on === 'object' || typeof on === 'function') && isEventSender(on)) {\n      return onSupplied(on).do(supplyOn(context));\n    }\n\n    const trigger = context\n        .get(ComponentState)\n        .track(on)\n        .onUpdate.do(\n            supplyOn(context),\n        );\n\n    if (Array.isArray(on) && !on.length) {\n      return trigger.do(translateOn_(\n          (send, path: StatePath.Normalized) => path[0] !== RenderPath__root && send(),\n      ));\n    }\n\n    return trigger;\n  },\n\n};\n","import { immediateRenderScheduler, RenderExecution } from '@frontmeans/render-scheduler';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * @internal\n */\nconst enum RenderStatus {\n  Cancelled = -1,\n  Complete = 0,\n  Pending = 1,\n  Scheduled = 2,\n}\n\n/**\n * @internal\n */\nexport class ElementRenderCtl$ implements ElementRenderCtl {\n\n  private readonly _renders = new Set<() => void>();\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  renderBy(\n      renderer: ElementRenderer,\n      def: RenderDef = {},\n  ): Supply {\n\n    const spec = RenderDef.spec(this._context, def);\n    const trigger = RenderDef.trigger(this._context, spec);\n    const schedule = this._context.get(DefaultRenderScheduler)({\n      ...RenderDef.fulfill(spec),\n      node: this._context.element as Element,\n    });\n    const whenConnected = spec.when === 'connected';\n    let status = RenderStatus.Pending;\n    const startRendering = (): 0 | void => status /* there is an update to render */ && scheduleRenderer();\n    const onUpdate = whenConnected\n        ? () => this._context.connected && scheduleRenderer()\n        : () => this._context.settled && scheduleRenderer();\n    const supply = trigger(onUpdate)\n        .needs(this._context)\n        .whenOff(cancelRenderer);\n\n    (whenConnected ? this._context.whenConnected : this._context.whenSettled)(startRendering);\n\n    const immediateSchedule = immediateRenderScheduler();\n\n    this._renders.add(renderNow);\n\n    return supply.whenOff(() => this._renders.delete(renderNow));\n\n    function scheduleRenderer(): void {\n      status = RenderStatus.Scheduled;\n      schedule(renderElement);\n    }\n\n    function renderNow(): void {\n      immediateSchedule(renderElement);\n    }\n\n    function cancelRenderer(): void {\n      if (status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet\n        schedule(noop);\n      }\n      status = RenderStatus.Cancelled;\n    }\n\n    function renderElement(execution: RenderExecution): void {\n      if (status > RenderStatus.Complete) { // Prevent excessive rendering\n        status = RenderStatus.Complete;\n        for (; ;) {\n\n          const newRenderer = renderer(execution);\n\n          if (newRenderer === renderer || typeof newRenderer !== 'function') {\n            break;\n          }\n\n          renderer = newRenderer;\n        }\n      }\n    }\n  }\n\n  renderNow(): void {\n    this._renders.forEach(render => render());\n  }\n\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl$ } from './element-render-ctl.impl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A render control of component's element.\n *\n * Controls rendering by {@link ElementRenderer element renderers}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport interface ElementRenderCtl {\n\n  /**\n   * Enables component element rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by {@link DefaultRenderScheduler} once component state updated.\n   *\n   * @param renderer - Element renderer function.\n   * @param def - Optional element rendering definition.\n   *\n   * @returns Render shots supply. Element `renderer` will stop rendering once this supply is cut off.\n   */\n  renderBy(\n      renderer: ElementRenderer,\n      def?: RenderDef,\n  ): Supply;\n\n  /**\n   * Executes scheduled element render shots immediately.\n   *\n   * Uses `immediateRenderScheduler` for that.\n   *\n   * Does not execute element renderers that are not scheduled. I.e. if no corresponding state updates happened.\n   */\n  renderNow(): void;\n\n}\n\n/**\n * A key of component context value containing {@link ElementRenderCtl element render control}.\n *\n * @category Feature\n */\nexport const ElementRenderCtl: ContextRef<ElementRenderCtl> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderCtl>(\n        'element-render-ctl',\n        {\n          byDefault(values) {\n            return new ElementRenderCtl$(values.get(ComponentContext));\n          },\n        },\n    )\n);\n","import { RenderSchedule, RenderScheduleOptions, RenderShot } from '@frontmeans/render-scheduler';\nimport { ContextRef, ContextValues, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A signature of element render scheduler.\n *\n * Schedules render shots to be executed by {@link ElementRenderCtl element render control}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport type ElementRenderScheduler =\n/**\n * @param options - Options of constructed element render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: ElementRenderScheduleOptions) => RenderSchedule;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link ElementRenderScheduler element render scheduler} when constructing new render schedule.\n *\n * Generic `RenderSchedule` options are ignored.\n *\n * @category Feature\n */\nexport interface ElementRenderScheduleOptions extends RenderScheduleOptions, RenderDef.Options {\n\n  /**\n   * When to start the rendering.\n   *\n   * One of:\n   * - `settled` - start rendering when component is {@link ComponentContext.settled settled}.\n   * - `connected` (the default) - start rendering when component's element is {@link ComponentContext.connected\n   *   connected} to document.\n   */\n  readonly when?: 'settled' | 'connected';\n\n  /**\n   * Reports rendering error. E.g. a render shot execution failure.\n   *\n   * @param messages - Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * @internal\n */\nfunction newElementRenderScheduler(context: ContextValues): ElementRenderScheduler {\n\n  const renderCtl = context.get(ElementRenderCtl);\n\n  return (opts = {}): RenderSchedule => {\n\n    const recentShot = trackValue<RenderShot>(noop);\n    const renderer: ElementRenderer = execution => {\n      recentShot.it(execution);\n    };\n\n    renderCtl.renderBy(renderer, RenderDef.fulfill({ on: recentShot.on }, opts));\n\n    return (shot: RenderShot): void => {\n      recentShot.it = execution => shot(execution); // Ensure render shot always updated\n    };\n  };\n}\n\n/**\n * A key of component context value containing {@link ElementRenderScheduler element render scheduler}.\n *\n * @category Feature\n */\nexport const ElementRenderScheduler: ContextRef<ElementRenderScheduler> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderScheduler>(\n        'element-render-scheduler',\n        {\n          byDefault: newElementRenderScheduler,\n        },\n    )\n);\n","import { RenderExecution } from '@frontmeans/render-scheduler';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by {@link DefaultRenderScheduler} once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * Enables rendering with {@link ElementRenderCtl.renderBy element render control}.\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param def - Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<TClass extends ComponentClass>(\n    def?: RenderDef,\n): ComponentPropertyDecorator<(execution: RenderExecution) => ElementRenderer | void, TClass> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n            const renderer = get(component).bind(component);\n\n            context.get(ElementRenderCtl).renderBy(renderer, def);\n          });\n        });\n      },\n    },\n  }));\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> = (\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root')\n);\n","/**\n * An event related to element's shadow DOM.\n *\n * The following event types supported:\n * - `wesib:shadowAttached` is dispatched when a shadow root is attached to element.\n *   In particular, it is dispatched for components decorated with {@link AttachShadow @AttachShadow}.\n *   The event is dispatched when component is connected for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Feature\n */\nexport class ShadowDomEvent extends Event {\n\n  /**\n   * Shadow root this event relates to.\n   */\n  get shadowRoot(): ShadowRoot {\n    return (this.target as Element).shadowRoot as ShadowRoot;\n  }\n\n}\n","import { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { ComponentContext } from '../../component';\nimport { ShadowContentDef } from './attach-shadow.decorator';\nimport { ShadowDomEvent } from './shadow-dom-event';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses one.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context - Target component context.\n * @param init - Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>(\n        'shadow-root-builder',\n        {\n          byDefault() {\n            return attachShadow;\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const element = context.element as Element;\n  const shadowRoot = shadowRootOf(element, init);\n\n  if (shadowRoot) {\n    context.whenConnected(() => context.dispatchEvent(new ShadowDomEvent(\n        'wesib:shadowAttached',\n        { bubbles: true },\n    )));\n  }\n\n  return shadowRoot;\n}\n\n/**\n * @internal\n */\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n\n","import { Class } from '@proc7ts/primitives';\nimport { Component, ComponentContext, ComponentDecorator, ContentRoot } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\n/**\n * Creates a component decorator that attaches shadow root to decorated component instance.\n *\n * @category Feature\n * @typeParam TClass - A type of decorated component class.\n * @param def - Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component decorator.\n */\nexport function AttachShadow<TClass extends ComponentClass = Class>(\n    def: ShadowContentDef = defaultShadowContentDef,\n): ComponentDecorator<TClass> {\n  return Component({\n    setup(setup) {\n      setup.perComponent(\n          {\n            a: ShadowContentRoot,\n            by(ctx: ComponentContext<InstanceType<TClass>>) {\n              return ctx.get(ShadowRootBuilder)(ctx, def);\n            },\n          },\n      );\n      setup.perComponent({ // Content root is an alias of shadow root when present.\n        a: ContentRoot,\n        by(context: ComponentContext<InstanceType<TClass>>) {\n          return context.get(ShadowContentRoot, { or: null });\n        },\n      });\n    },\n  });\n}\n","import { NamespaceDef } from '@frontmeans/namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n"],"names":["BootstrapContext__key","SingleContextKey","BootstrapContext","ContextValues","ContextKey__symbol","bootstrapDefault","provide","context","key","bootstrapContext","get","isElement","node","nodeType","Node","ELEMENT_NODE","MetaAccessor","[object Object]","symbol","this","type","hasOwnProperty","undefined","ownDef","own","superType","superClassOf","superDef","of","merge","sources","prevMeta","updates","map","source","meta","newMeta","Object","defineProperty","configurable","value","mergeInitMethods","target1","method1","target2","method2","m1","bind","m2","async","args","FeatureDef__symbol","Symbol","FeatureMeta","super","defs","reduce","prev","def","needs","elementOrArray","extendSetOfElements","setOfElements","has","setup","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","user","load","Supply","BootstrapWorkbench","byDefault","Workbench","featureSetupStage","WorkStage","featureInitStage","after","componentDefStage","ComponentDef__symbol","ComponentMeta","mergeFunctions","isQualifiedName","name","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","values","dispatcher","DomEventDispatcher","element","supply","dispatch","event","on","ContentRoot","ctx","StateUpdaterKey","ContextUpKey","upKey","createUpKey","slot","insert","seed","do","digAfter","fns","length","combined","fn","noop","afterThe","path","newValue","oldValue","statePath","hasFallback","or","delegated","whenOff","StateUpdater","ComponentContext__symbol","ComponentContext","updateState","component","TypeError","String","contentRoot","ComponentSlot__symbol","ComponentSlot","found","ComponentSlot$","trackValue","whenReady","_ctx","read","digOn_","onceOn","it","AfterEvent__symbol","ComponentEvent","Event","target","AnonymousComponentProperty__symbol","ComponentProperty","decorateWith","accessor","writable","defineBy","set","definer","readable","enumerable","componentDef","ComponentProperty$defineBy","By","provider","result","proto","propertyKey","descriptor","updateDescriptor","desc","getValue","setValue","constructor","call","ComponentProperty$notReadable","ComponentProperty$notWritable","updated","ComponentProperty$updateDescriptor","isField","updatedDesc","toPropertyAccessorDescriptor","fieldAccessorDescriptor","decoratePropertyAccessor","With","access","As","valueProvider","Bind","binder","accessor__symbol","existing","BootstrapContextRegistry__key","BootstrapContextRegistry","ContextRegistry","a","is","newValues","PerComponentRegistry","ComponentContextRegistry","PerDefinitionRegistry","bsContext","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","tracker","emitter","EventEmitter","onSetup","valueOn","asis","onAny","superPostDefSetup","send","BootstrapWindow","window","BootstrapRoot","document","body","DefaultNamespaceAliaser","DefaultRenderSchedulerKey","toDefaultRenderScheduler","newRenderSchedule","scheduler","reason","contextDestroyed","options","DefaultRenderScheduler","ElementAdapterKey","binders","defaultElementAdapter","nsAlias","adapterByName","Map","spec","html__naming","to","toLowerCase","tagName","adapter","ElementAdapter","ElementObserver","FnContextKey","DefaultElementObserver","MutationObserver","callback","mutations","forEach","mutation","itsEach","overArray","removedNodes","mount","mountOf","checkConnected","filterArray","addedNodes","observe","childList","DefinitionContext__symbol","definitionContextOf","CustomElements__key","customElements","CustomElements","componentTypeOrName","elementType","defContext","extend","elementDef","extends","componentResolver","resolve","promise","ComponentResolver__symbol","newPromiseResolver","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","mountTo","connect","ComponentConstructor__symbol","newComponent","context__symbol","defaultContext","prototype","prevContext","newComponentConstructor","ComponentStatus","_val","mapAfter_","isOff","onceReady","ComponentStatus$once","ready","onceSettled","settled","whenSettled","onceConnected","filterOn_","connected","whenConnected","_canSettle","test","input","onEventBy","receiver","eventCtx","componentCtx","receive","ComponentContext$","_definitionContext","registry","_newComponentRegistry","_status","_component","isReady","isSettled","isConnected","readStatus","settle","off","componentDestroyed","unbind","parentNode","removeChild","removeElement","whenComponent","_whenComponent","lastRev","readNotifier","notifier","_","_elementBuilder","components","create","dispatchEvent","bubbles","ComponentMount$","_connect","el","doc","ownerDocument","contains","destroy","MountComponentContext$","definitionContext","CustomComponentContext$","WhenComponent","currentRev","created","onCreated","receiverRev","eventContext","componentContext","notifiedRev","recurrentReceiver","onRecurrent","recurrentContext","rev","DefinitionContext$","_bsContext","_ready","_whenReady","translateOn","_def","definitionContextRegistry","seeds","parentPerComponentRegistry","append","seedKey","_perComponentRegistry","mapOn_","definitionSetup","perDefinition","perComponent","_elementType","Error","_createComponent","_created","definitions","CustomElement$","connectedCallback","disconnectedCallback","customElementType","ElementBuilder","_define","ComponentRegistry","_setup","_components","push","_defineAll","work","run","elementBuilder","buildElement","initBy","FeatureContext$","handle","module","valueOn_","_componentRegistry","onDefinition","_onDefinition","supplyOn","onComponent","_onComponent","onPostDefSetup","FeatureModule__symbol","FeatureModule","ContextModule","featureDef","replaced","required","workbench","featureContext","whenInit","FeatureModule$options","WhenDefined__symbol","bootstrapComponents","features","bootstrapContextRegistry","complete","stage","BootstrapContext$","bsStage","by","newNamespaceAliaser","onPromise","Promise","then","use","status","lastStatus","FeatureRef$read","initBootstrap","catch","console","error","AttributePath__root","attributePathTo","attributeStateUpdate","update","updateAttributeState","parseAttributeDescriptor","change","hyphenateDecapName","AttributeRegistry","AttributeRegistry$","_context","attrs","size","observedAttributes","keys","attributeChangedCallback","attributeFilter","records","record","attributeName","getAttribute","attributes","attributeOldValue","alreadyObserved","Array","isArray","newAttrs","Set","attr","add","prevCallback","attrChanged","Attribute","declareAttribute","setAttribute","removeAttribute","AttributeChanged","Attributes","items","item","entries","ComponentStateKey","SimpleContextKey","provided","state","ComponentState","done","ComponentState__key","StateTracker","StatePropertyPath__root","statePropertyPathTo","updateStatePropertyState","StateProperty","statePropertyUpdate","AttributeTracker","ValueTracker","_name","track","onUpdate","_path","trackAttribute","DomPropertyRegistry","DomPropertyRegistry$","props","DomPropertyPath__root","domPropertyPathTo","updateDomPropertyState","DomProperty","domDescriptor","propertyDesc","componentPropertyKey","domPropertyDescriptor","domPropertyUpdate","declareDomProperty","RenderPath__root","RenderDef","valueByRecipe","base","defaults","isEventSender","onSupplied","trigger","translateOn_","ElementRenderCtl$","renderer","schedule","fulfill","when","scheduleRenderer","immediateSchedule","immediateRenderScheduler","_renders","renderNow","delete","renderElement","execution","newRenderer","render","ElementRenderCtl","ElementRenderScheduler","renderCtl","opts","recentShot","renderBy","shot","Render","ShadowContentRoot","ShadowDomEvent","shadowRoot","ShadowRootBuilder","attachShadow","shadowRootOf","defaultShadowContentDef","mode","AttachShadow","Wesib__NS","NamespaceDef"],"mappings":"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"}