{"version":3,"file":"input-aspects.e48d1860.js","sources":["../../../node_modules/input-aspects/src/aspect.ts","../../../node_modules/input-aspects/src/aspect.impl.ts","../../../node_modules/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../node_modules/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../node_modules/input-aspects/src/converter.ts","../../../node_modules/input-aspects/src/control.ts","../../../node_modules/input-aspects/src/controls/value-of.control.ts","../../../node_modules/input-aspects/src/controls/abstract.control.ts","../../../node_modules/input-aspects/src/containers/container.control.ts","../../../node_modules/input-aspects/src/containers/parents.aspect.ts","../../../node_modules/input-aspects/src/element.control.ts","../../../node_modules/input-aspects/src/data/mode.aspect.ts","../../../node_modules/input-aspects/src/data/data.aspect.ts","../../../node_modules/input-aspects/src/containers/group.control.ts","../../../node_modules/input-aspects/src/validation/require-nothing.validator.ts","../../../node_modules/input-aspects/src/validation/validator.ts","../../../node_modules/input-aspects/src/validation/validator.impl.ts","../../../node_modules/input-aspects/src/validation/validation.aspect.ts","../../../node_modules/input-aspects/src/validation/require-all.validator.ts","../../../node_modules/input-aspects/src/validation/require-present.validator.ts","../../../node_modules/input-aspects/src/submit.aspect.ts","../../../node_modules/input-aspects/src/data/modes/mode-by-form.ts","../../../node_modules/input-aspects/src/data/modes/mode-by-validity.ts","../../../node_modules/input-aspects/src/elements/abstract-element.control.ts","../../../node_modules/input-aspects/src/elements/text.control.ts","../../../node_modules/input-aspects/src/elements/focus/focus.aspect.ts","../../../node_modules/input-aspects/src/elements/focus/status.aspect.ts","../../../node_modules/input-aspects/src/elements/forms/form-element.control.ts","../../../node_modules/input-aspects/src/elements/forms/submit-button.control.ts","../../../node_modules/input-aspects/src/elements/style/styled-element.aspect.ts","../../../node_modules/input-aspects/src/elements/style/css-classes.aspect.ts","../../../node_modules/input-aspects/src/elements/style/css-error.ts","../../../node_modules/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Value, Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by [[InControl.convert]] method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<To, ConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of [[convertTo]] when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<Value>): Applied<Value, Instance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<OfValue, Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance, Kind>,\n    build: <V>(this: void, control: InControl<V>, origin?: InControl<any>) => Instance,\n    instance?: Instance,\n    origin?: InControl<any>,\n): InAspect.Applied<Value, Instance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<To>(target: InControl<To>): InAspect.Applied<To, Instance> {\n      return inAspectSameOrBuild<To, Instance, Kind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<Value>): InAspect.Applied<Value, Instance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as Instance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance | null, Kind>,\n    instance: Instance | null = null,\n): InAspect.Applied<Value, Instance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<any, Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from 'namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * [[InNamespaceAliaser.to]] converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @param nsAlias  Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by [[InRenderScheduler.to]] converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @param scheduler  Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(scheduler: InRenderScheduler): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, flatMapIt, itsReduction, mapIt } from 'a-iterable';\nimport { isPresent, noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Conversion<From, To>\n    | InConverter.Factory<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<From, To>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Conversion<From, To> =\n      | InConverter.Value.Conversion<From, To>\n      | InConverter.Aspect.Conversion<To>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Value<From, To> =\n      | InConverter.Value.Factory<From, To>\n      | InConverter.Value.Conversion<From, To>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To = From> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Conversion<From, To>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: To): From;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To = From> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<Value>(\n    ...converters: InConverter.Aspect<Value, Value>[]\n): InConverter.Aspect.Factory<Value, Value>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter.Value<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Value.Factory<From, To>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter?: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> {\n\n  type AspectApplicator = <Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<From, To> => {\n\n    const conversion = converter(from, to);\n    const conversions = flatMapIt<InConverter.Conversion<From, To>>([\n        [conversion],\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    ]);\n\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<From, To>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeparam Value  Input value type.\n * @param aspects  Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<Value>(\n    aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[],\n): InConverter.Aspect.Factory<Value> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<Value>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion  Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return !(conversion as any).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Value<From, To>,\n): InConverter.Value.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { asis, noop } from 'call-thru';\nimport {\n  EventEmitter,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get [EventSupply__symbol](): EventSupply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<Value, Value>[]\n  ): InControl<Value>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   * @param and  Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      by: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<To>;\n\n  convert<To>(\n      by?: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<Value> | InControl<To> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<From, To> extends InControl<To> {\n\n  private readonly _supply: EventSupply;\n  private readonly _on = new EventEmitter<[To, To]>();\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(src: InControl<From>, by: InConverter.Factory<From, To>) {\n    super();\n    this._supply = eventSupply().needs(src);\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: From) => To;\n    let get: (value: To) => From;\n    let convertAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    if (isInAspectConversion(conversion)) {\n      set = asis as (value: From) => To;\n      get = asis as (value: To) => From;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    eventSupplyOf(this._it).needs(this._supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  on(): OnEvent<[To, To]>;\n  on(receiver: EventReceiver<[To, To]>): EventSupply;\n  on(receiver?: EventReceiver<[To, To]>): OnEvent<[To, To]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { EventReceiver, EventSupply, eventSupply, EventSupply__symbol, OnEvent } from 'fun-events';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nclass InSameValueControl<Value> extends InControl<Value> {\n\n  private _supply?: EventSupply;\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply || (this._supply = eventSupply().needs(this._control));\n  }\n\n  get it(): Value {\n    return this._control.it;\n  }\n\n  set it(value: Value) {\n    this._control.it = value;\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._control.on().F)(receiver);\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @param control  Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<Value>(control: InControl<Value>): InControl<Value> {\n  return new InSameValueControl(control);\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n *\n * @category Control\n */\nexport abstract class AbstractInControl<Value> extends InControl<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<Value>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender, EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends AbstractInControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * Builds an `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container updates sender.\n   */\n  abstract on(): OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * Starts sending container updates to the given receiver.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * @param receiver  Target container updates receiver.\n   *\n   * @returns Container updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InContainer.Entry[], InContainer.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container contents snapshot keeper.\n   */\n  abstract read(): AfterEvent<[InContainer.Snapshot]>;\n\n  /**\n   * Starts sending container contents and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of container snapshot updates.\n   *\n   * @returns Container contents supply.\n   */\n  abstract read(receiver: EventReceiver<[InContainer.Snapshot]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read();\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of parent updates.\n   */\n  abstract on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * Starts sending parent updates to the given `receiver`.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * @param receiver  Target parent updates receiver.\n   *\n   * @returns Parent updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of control parents.\n   */\n  abstract read(): AfterEvent<[InParents.All]>;\n\n  /**\n   * Starts sending control parents and updates to the given `receiver`\n   *\n   * @param receiver  Target control parents receiver.\n   *\n   * @returns Control parents supply.\n   */\n  abstract read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read();\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    eventSupplyOf(this._on).needs(this._control);\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n  on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InParents.Entry[], InParents.Entry[]]>,\n  ): OnEvent<[InParents.Entry[], InParents.Entry[]]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  read(): AfterEvent<[InParents.All]>;\n  read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n  read(receiver?: EventReceiver<[InParents.All]>): AfterEvent<[InParents.All]> | EventSupply {\n\n    const allParents = (): IterableIterator<InParents.Entry> => this._map.keys();\n\n    return (this.read = afterSent(\n        this.on().thru(allParents),\n        () => [allParents()],\n    ).F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, EventReceiver, EventSupply } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends AbstractInControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of user input.\n   *\n   * @returns `AfterEvent` keeper of user input.\n   */\n  abstract input(): AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * Starts sending user input and updates to the given `receiver`.\n   *\n   * @param receiver  Target user input receiver.\n   *\n   * @returns User input supply.\n   */\n  abstract input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<Value, any>,\n        ) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt } from 'a-iterable';\nimport { nextArgs, NextCall, nextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * Creates an `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of input mode updates.\n   */\n  abstract on(): OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * Starts sending input mode updates to the given `receiver`\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * @param receiver  Target input mode updates receiver.\n   *\n   * @returns Input mode updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input mode.\n   */\n  abstract read(): AfterEvent<[InMode.Value]>;\n\n  /**\n   * Starts sending input mode and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of input mode.\n   *\n   * @returns Input mode supply.\n   */\n  abstract read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read();\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._tracker);\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n      case 'off':\n      case 'ro':\n      case '-on':\n      case '-ro':\n        break;\n      default:\n        value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    return (this.on = this._tracker.on().F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on().thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keepThru(\n        (set: Set<AfterEvent<[InMode.Value]>>) => nextAfterEvent(afterEach(...set)),\n        mergeInModes,\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): EventSupply {\n\n    const supply = eventSupply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    eventSupplyOf(this.own).needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read().keepThru_(parentsInMode));\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  read(): AfterEvent<[InMode.Value]>;\n  read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n  read(receiver?: EventReceiver<[InMode.Value]>): AfterEvent<[InMode.Value]> | EventSupply {\n\n    let last: InMode.Value = 'on';\n\n    return (this.read = afterSent<[InMode.Value]>(\n            afterAll({\n              derived: this._derived.read,\n              own: this.own,\n            }).thru(\n                ({\n                  derived: [derived],\n                  own: [own],\n                }) => {\n\n                  let next: InMode.Value;\n\n                  if (own === 'off' || derived === 'off') {\n                    next = 'off';\n                  } else {\n\n                    let off = false;\n\n                    if (own[0] === '-') {\n                      off = true;\n                      own = own.substring(1) as InMode.Value;\n                    }\n                    if (derived[0] === '-') {\n                      off = true;\n                      derived = derived.substring(1) as InMode.Value;\n                    }\n                    next = derived === 'ro' ? 'ro' : own;\n                    if (off) {\n                      next = '-' + next as InMode.Value;\n                    }\n                  }\n\n                  return last === next ? nextSkip() : nextArgs(last = next);\n                },\n            ),\n            valuesProvider<[InMode.Value]>(last),\n        ).F\n    )(receiver);\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    let lastUpdate: InMode.Value = 'on';\n\n    return (this.on = this.read().thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    }).F)(receiver);\n  }\n\n  derive(source: InMode.Source): EventSupply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control))\n            .tillOff(this._control),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n    case 'off':\n      element.setAttribute('disabled', '');\n      break;\n    case 'ro':\n    case '-ro':\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      element.setAttribute('readonly', '');\n      break;\n    default:\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('readonly', '');\n      element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): NextCall<OnEventCallChain, [InMode.Value]> {\n\n  const parentList = Array.from(parents);\n\n  if (!parentList.length) {\n    return nextArgs('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return nextAfterEvent(afterEach(...parentModes).keepThru_(mergeInModes));\n}\n\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...flatMapIt<InMode.Value>(modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes  Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n      case 'off':\n        return 'off';\n      case 'ro':\n        ro = true;\n        break;\n      case '-on':\n        off = true;\n        break;\n      case '-ro':\n        off = true;\n        ro = true;\n        break;\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll, AfterEvent } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <V>(ctrl: InControl<V>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).keepThru(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? nextArgs(value as any)\n            : nextArgs(),\n    ));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<Value, InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from 'a-iterable';\nimport { nextArg, nextArgs, NextCall, noop } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  nextAfterEvent,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<Instance, Model, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  abstract on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n\n  abstract read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  abstract read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): EventSupply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<Model>): EventSupply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof Model): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<Model> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, InGroupEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, InGroupEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, InGroupEntry][],\n      removed: [keyof Model, InGroupEntry][],\n  ): EventSupply {\n\n    const replaced = this._map.get(key);\n    let supply: EventSupply;\n\n    if (control) {\n      supply = eventSupply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = noEventSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]>,\n      supply: EventSupply,\n  ): InGroupEntry {\n    return [\n      control,\n      eventSupply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof Model, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof Model, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n  clear(): [keyof Model, InGroupEntry][] {\n\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, InGroupEntry][], [keyof Model, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const applyModelToControls = (model: Model): void => {\n      this.read().once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<Model>(this);\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>,\n  ): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]> | EventSupply {\n    return (this.on = this._updates.on().thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ).F)(receiver);\n  }\n\n  read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n  read(receiver?: EventReceiver<[InGroup.Snapshot<Model>]>): AfterEvent<[InGroup.Snapshot<Model>]> | EventSupply {\n    return (this.read = afterSent(\n        this._updates.on().thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()],\n    ).F)(receiver);\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined,\n  ): EventSupply {\n\n    const group = this._group;\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n    let supply: EventSupply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = eventSupply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: Model | undefined;\n\n      added.forEach(([key, [control, supply]]) => {\n        control.aspect(InParents)\n            .add({ parent: group })\n            .needs(supply)\n            .cuts(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(([key, [control, supply]]) => {\n        control.read().tillOff(supply).to(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, InGroupEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(\n      model: Model,\n      opts: {\n        readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    eventSupplyOf(this).whenOff(() => this.controls.clear());\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._model);\n  }\n\n  get it(): Model {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  on(): OnEvent<[Model, Model]>;\n  on(receiver: EventReceiver<[Model, Model]>): EventSupply;\n  on(receiver?: EventReceiver<[Model, Model]>): OnEvent<[Model, Model]> | EventSupply {\n    return (this.on = this._model.on().F)(receiver);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keepThru_(\n      readInGroupData,\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    },\n): NextCall<OnEventCallChain, [InData.DataType<Model>?]> {\n  if (!InMode.hasData(mode)) {\n    return nextArgs();\n  }\n\n  const csData: { [key in keyof Model]: InData<any> } = {} as any;\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return nextAfterEvent(afterAll(csData).keepThru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(overEntries(controlsData), ([key, [controlData]]) => {\n      data[key] = controlData;\n    });\n\n    return nextArg(data as InData.DataType<Model>);\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(\n    model: Model,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n    } = {},\n): InGroup<Model> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<OfValue extends object ? OfValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, afterThe } from 'fun-events';\n\n/**\n * @internal\n */\nconst _requireNothing = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return _requireNothing;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { CallChain, nextArgs, NextCall, valueProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>,\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read().keepThru(simpleInValidator(control, validator));\n}\n\n/**\n * @internal\n */\nfunction simpleInValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): (value: Value) => NextCall<CallChain, InValidation.Message[]> {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : nextArgs(messages);\n  };\n}\n","import { flatMapIt, itsEach } from 'a-iterable';\nimport { asis, noop, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this._messages = afterEventBy(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider()).to(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator.to(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share().tillOff(control);\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from 'a-iterable';\nimport { nextArgs, NextCall } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEventCallChain,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild<Value, InValidation<Value>, 'validation'>(\n        control,\n        InValidation,\n        <V>(ctrl: InControl<V>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<V>(ctrl);\n\n          if (origin) {\n\n            const from = origin.aspect(InValidation);\n\n            validation.by(from.read().keepThru(result => nextArgs(...result.messages())));\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @return `AfterEvent` keeper of validation result keeper.\n   */\n  abstract read(): AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Starts sending validation result and updates to the given `receiver`\n   *\n   * @param receiver  Target validation result receiver.\n   *\n   * @returns Validation results supply.\n   */\n  abstract read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read();\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes  Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code, [message]);\n              }\n            }\n          });\n\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        },\n    );\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): IterableIterator<InValidation.Message> {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n  read(): AfterEvent<[InValidation.Result]>;\n  read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n  read(receiver?: EventReceiver<[InValidation.Result]>): AfterEvent<[InValidation.Result]> | EventSupply {\n    return (this.read = afterSupplied(this._messages).keepThru(inValidationResult).F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read().keepThru(\n      nestedInValidations,\n      combineInValidationResults,\n  );\n}\n\n/**\n * @internal\n */\nfunction nestedInValidations(\n    controls: InContainer.Snapshot,\n): NextCall<OnEventCallChain, [InValidation.Result][]> {\n  return nextAfterEvent(afterEach(...mapIt(controls, control => control.aspect(InValidation))));\n}\n\n/**\n * @internal\n */\nfunction combineInValidationResults(\n    ...results: [InValidation.Result][]\n): NextCall<OnEventCallChain, InValidation.Message[]> {\n  return nextArgs<InValidation.Message[]>(\n      ...flatMapIt(mapIt(results, result => result[0])),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { EventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read().keepThru(value => value ? nextArgs() : { missing: 'missing' })\n      : requirePresent;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEvery, mapIt } from 'a-iterable';\nimport { nextArgs } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  eventSupplyOf,\n  trackValue,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrBuild } from './aspect.impl';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors  Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...mapIt(errors, message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason  A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * [input data]: InData\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InSubmit<Value> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of submit status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of submit status flags.\n   */\n  abstract read(): AfterEvent<[InSubmit.Flags]>;\n\n  /**\n   * Starts sending submit status flags and updates to the given `receiver`\n   *\n   * @param receiver  Target submit status flags receiver.\n   *\n   * @returns Submit status flags supply.\n   */\n  abstract read(receiver: EventReceiver<[InSubmit.Flags]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read();\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @param submitter  A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Result  Submit result value type.\n   */\n  export type Submitter<Value, Result> =\n  /**\n   * @param data  Input data to submit.\n   * @param control  Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          this: void,\n          data: Value extends undefined ? never : Value,\n          control: InControl<Value>,\n      ) => Promise<Result>;\n\n}\n\nclass InControlSubmit<Value> extends InSubmit<Value> {\n\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read().keepThru(\n        messages => nextArgs(...messages),\n    ));\n  }\n\n  read(): AfterEvent<[InSubmit.Flags]>;\n  read(receiver: EventReceiver<[InSubmit.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InSubmit.Flags]>): AfterEvent<[InSubmit.Flags]> | EventSupply {\n    return (this.read = afterAll({\n      flags: this._flags,\n      data: this._control.aspect(InData),\n      messages: this._control.aspect(InValidation),\n    })\n        .tillOff(this._control)\n        .keepThru(\n            ({\n              flags: [flags],\n              data: [data],\n              messages: [messages],\n            }): InSubmit.Flags => ({\n              ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n              submitted: flags.submitted,\n              busy: flags.busy,\n            }),\n        ).F)(receiver);\n  }\n\n  async submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result> {\n    if (eventSupplyOf(this._control).isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    function submitData(): Promise<Value extends undefined ? never : Value> {\n      return new Promise((resolve, reject) => {\n        afterAll({\n          data: control.aspect(InData),\n          flags: submit,\n        }).once(({ data: [d], flags: [{ ready }] }) => {\n          if (!ready) {\n            reject(new InSubmitRejectedError('notReady'));\n          } else {\n            resolve(d as any);\n          }\n        });\n      });\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form  Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady  Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid  Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy  Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read().keepThru(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid  Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore  Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read().keepThru(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  );\n}\n","import { asis, nextArgs, nextSkip } from 'call-thru';\nimport {\n  AfterEvent,\n  afterSent,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n} from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport class AbstractInElement<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: AbstractInElement<Value, Elt>) => Value;\n  private readonly _set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private _value: Value;\n  private _update: (value: Value, oldValue: Value) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element  HTML input element the constructed control is based on.\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get  Input value getter.\n   * @param set  Input value setter.\n   */\n  constructor(\n      readonly element: Elt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n        readonly get: (this: AbstractInElement<Value, Elt>) => Value;\n        readonly set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: Value, oldValue: Value): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    eventSupplyOf(this.events).needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    function update(input: InElement.Input<Value>, oldValue: Value): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._input);\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  input(): AfterEvent<[InElement.Input<Value>]>;\n  input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n  input(receiver?: EventReceiver<[InElement.Input<Value>]>): AfterEvent<[InElement.Input<Value>]> | EventSupply {\n    return (this.input = afterSent<[InElement.Input<Value>]>(\n        this._input.on().thru(asis), // remove the second parameter\n        () => [{ value: this.it }],\n    ).F)(receiver);\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._input.on().thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    ).F)(receiver);\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update  Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<Value>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input').to(onInput);\n    this.events.on('change').to(onInput);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot | null = element.getRootNode\n        ? element.getRootNode() as any\n        : element.ownerDocument;\n\n    this._it = trackValue(!!owner && owner.activeElement === element);\n    eventSupplyOf(this).needs(inElement);\n\n    events.on('focus').to(() => this._it.it = true);\n    events.on('blur').to(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._it);\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  on(): OnEvent<[boolean, boolean]>;\n  on(receiver: EventReceiver<[boolean, boolean]>): EventSupply;\n  on(receiver?: EventReceiver<[boolean, boolean]>): OnEvent<[boolean, boolean]> | EventSupply {\n    return (this.on = this._it.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, mapIt } from 'a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  eventSupplyOf,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * Builds `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input status flags.\n   */\n  abstract read(): AfterEvent<[InStatus.Flags]>;\n\n  /**\n   * Starts sending input status flags and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of input status flags.\n   *\n   * @returns Input status flags supply.\n   */\n  abstract read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read();\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    eventSupplyOf(this._flags).needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = this._flags.read().F)(receiver);\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input().keepThru(({ event }) => !!event) : afterThe(false),\n  }).keepThru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  );\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = containerInStatusFlags(this._container).F)(receiver);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markEdited(edited),\n        ),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markTouched(touched),\n        ),\n    );\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read().tillOff(container).keepThru_(\n      (snapshot: InContainer.Snapshot) => nextAfterEvent(afterEach(...inControlStatuses(snapshot))),\n      combineInStatusFlags,\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { eventSupplyOf } from 'fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by [[inFormElement]] function.\n *\n * @category Control\n * @typeparam Elt  A type of HTML form element.\n */\nexport type InFormElement<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element  HTML element to create control for.\n * @param options  Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<Elt extends HTMLElement>(\n    element: Elt,\n    options: InFormElement.Options,\n): InFormElement<Elt> {\n\n  const { form, aspects, modes } = options;\n  const control = new AbstractInElement<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, modes));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { eventSupplyOf } from 'fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form submit button control.\n *\n * It is connected to control to submit (form) and may change submit button state depending on form submit status.\n * E.g. by disabling it when submit is {@link InSubmit.Flags.ready not ready}, or while {@link InSubmit.Flags.busy\n * submitting} the form.\n *\n * Submit button control can be created by [[inSubmitButton]] function.\n *\n * @category Control\n * @typeparam Elt  A type of submit button element.\n */\nexport type InSubmitButton<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InSubmitButton {\n\n  /**\n   * Submit button control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to submit button control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `off` (disable) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `off` (disabled) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element  Submit button element to create control for.\n * @param options  Submit button control options.\n *\n * @returns New submit button control.\n */\nexport function inSubmitButton<Elt extends HTMLElement>(\n    element: Elt,\n    options: InSubmitButton.Options,\n): InSubmitButton<Elt> {\n\n  const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n  const control = new AbstractInElement<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, { notReady, invalid, busy }));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @param element  A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(element: InStyledElement | null = null): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { DeltaSet } from 'delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventKeeper,\n  EventNotifier,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { css__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { RenderSchedule } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of CSS classes map.\n   */\n  abstract read(): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Starts sending CSS classes for styled element and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of CSS classes map.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @returns `AfterEvent` keeper of added and removed classes.\n   */\n  abstract track(): AfterEvent<[readonly string[], readonly string[]]>;\n\n  /**\n   * Starts sending current, added and removed CSS classes to the given `receiver`\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @param receiver  Target receiver of added and removed CSS classes.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element  Target element to apply CSS classes to.\n   * @param schedule  DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by [[InNamespaceAliaser]] aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  private readonly _sources: ValueTracker<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]> = trackValue([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n\n    eventSupplyOf(_control).whenOff(reason => this.done(reason));\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  read(): AfterEvent<[InCssClasses.Map]>;\n  read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n  read(receiver?: EventReceiver<[InCssClasses.Map]>): AfterEvent<[InCssClasses.Map]> | EventSupply {\n    return (this.read = this._sources.read().tillOff(this._control).keepThru_(\n        ([sources]) => nextAfterEvent(afterEach(...sources.keys())),\n        (...classes) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        },\n    ).F)(receiver);\n  }\n\n  track(): AfterEvent<[readonly string[], readonly string[]]>;\n  track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n  track(\n      receiver?: EventReceiver<[readonly string[], readonly string[]]>,\n  ): AfterEvent<[readonly string[], readonly string[]]> | EventSupply {\n    return (this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    }).F)(receiver);\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).keepThru(\n        (...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        },\n    );\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const inSupply = eventSupplyOf(this._control);\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source).to({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): EventSupply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark  Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when  {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  let marks: InCssClasses.Spec[];\n\n  if (!mark) {\n    marks = defaultInCssErrorMarks;\n  } else if (Array.isArray(mark)) {\n    marks = mark.length ? mark : defaultInCssErrorMarks;\n  } else {\n    marks = [mark];\n  }\n\n  return control => control.aspect(InValidation).read().keepThru(\n      errors => hasError(errors) ? nextArgs(...marks) : nextArgs(),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll } from 'fun-events';\nimport { NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InStatus } from '../focus';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns  A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keepThru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          return nextArgs(...names);\n        },\n    );\n  };\n}\n"],"names":["InAspect__symbol","Symbol","inAspectNull","instance","convertTo","noop","inAspectSameOrBuild","control","aspectKey","build","origin","undefined","target","attachTo","aspect","inAspectSameOrNull","valueProvider","inAspectValue","[object Object]","this","InputAspects__NS","NamespaceDef","InNamespaceAliaser__aspect","applyTo","newNamespaceAliaser","InNamespaceAliaser","to","nsAlias","applyAspect","InRenderScheduler__aspect","newRenderSchedule","InRenderScheduler","scheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","length","aspectConverters","mapIt","from","conversion","conversions","flatMapIt","filterIt","acf","isPresent","itsReduction","prev","cv","isInAspectConversion","set","bind","get","intoConvertedAspects","aspects","value","Array","isArray","noopInConversion","InControl","ValueTracker","Map","_aspect","aspectKeyOrSetup","aspectSetup","by","and","InConverted","existing","_aspects","applied","_applyAspect","src","super","EventEmitter","_supply","eventSupply","needs","backward","lastRev","convertAspect","asis","fallback","_it","trackValue","it","eventSupplyOf","on","newValue","oldValue","_on","send","cuts","rev","EventSupply__symbol","prevValue","prevRev","receiver","F","InSameValueControl","_control","AbstractInControl","_aspectConversion","InContainer__aspect","InContainer","InParents__aspect","InControlParents","InParents","OnEvent__symbol","AfterEvent__symbol","read","entry","existingSupply","_map","supply","delete","parent","allParents","keys","afterSent","thru","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","reason","own","done","OwnModeTracker","element","_tracker","getAttribute","initialInMode","DerivedInModes","Set","sources","_all","valuesProvider","keepThru","nextAfterEvent","afterEach","mergeInModes","source","add","derive","InParentsAspect","keepThru_","parentsInMode","setAttribute","removeAttribute","applyInMode","last","afterAll","derived","_derived","next","off","substring","nextSkip","nextArgs","lastUpdate","old","afterSupplied","isEventKeeper","tillOff","parents","parentList","parentModes","map","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","inControlReplacedReason","InGroupSnapshot","key","iterator","itsIterable","values","entries","InGroupMap","_controls","added","removed","replaced","newEntry","sendUpdate","push","modify","noEventSupply","remove","whenOff","_shot","itsEach","k","e","InGroupControlControls","_group","model","once","snapshot","withValues","overEntries","has","_updates","controlEntryToGroupEntry","keyOrControls","newControl","group","newModel","forEach","applyControlsToModel","clear","InGroupControl","opts","_model","controls","cs","readInGroupData","csData","controlsData","data","controlData","nextArg","inGroup","_requireNothing","afterThe","requireNothing","inValidator","validator","messages","validate","simpleInValidator","dontRemove","InValidationMessages","emitter","validators","validatorMessages","_messages","afterEventBy","resultSupply","validatorSupply","size","share","InValidation__aspect","InValidation","validation","InControlValidation","result","noInValidationErrors","ok","hasBut","InValidationErrors","message","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","container","nestedInValidations","combineInValidationResults","nestedInValidationMessages","numValidators","requireAll","results","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","Error","errors","submit","InSubmitRejectedError","rejected","submitted","busy","_errors","flags","_flags","ready","itsEvery","submitter","isOff","Promise","resolve","reject","d","error","toInSubmitMessages","inModeByForm","form","notReady","invalid","inModeByValidity","ignore","validity","AbstractInElement","self","_get","_set","_value","doUpdate","_update","update","input","correction","_input","events","DomEventDispatcher","listenForInput","onInput","event","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","ownerDocument","activeElement","ctx","onRecurrent","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","c","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","options","inSubmitButton","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","schedule","_schedule","controlSchedule","_sources","classes","mergeInCssClassesMap","track","DeltaSet","EventNotifier","classesSent","flag","name","delta","redelta","undelta","specs","names","isQualifiedName","css__naming","inSupply","classesSupply","context","receive","classList","updateClasses","node","defaultInCssErrorMarks","defaultInCssHasError","inCssError","mark","when","hasError","marks","inCssInfo","ns","cls","md","vl","st","valid"],"mappings":"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"}