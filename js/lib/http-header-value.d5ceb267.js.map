{"version":3,"file":"http-header-value.d5ceb267.js","sources":["../../../node_modules/http-header-value/src/hthv-partial.impl.ts","../../../node_modules/http-header-value/src/parser/add-param.ts","../../../node_modules/http-header-value/src/parser/next-in-item.ts","../../../node_modules/http-header-value/src/parser/parse-date-time.ts","../../../node_modules/http-header-value/src/parser/parse-none.ts","../../../node_modules/http-header-value/src/parser/item-parser.ts","../../../node_modules/http-header-value/src/parser/quoted-string-parser.ts","../../../node_modules/http-header-value/src/parser/angle-brackets-parser.ts","../../../node_modules/http-header-value/src/parser/next-in-comment.ts","../../../node_modules/http-header-value/src/parser/spaces-parser.ts","../../../node_modules/http-header-value/src/parser/param-parser.ts","../../../node_modules/http-header-value/src/parser/parser-config.ts","../../../node_modules/http-header-value/src/hthv-parser.ts","../../../node_modules/http-header-value/src/parser/item-delimit-parser.ts","../../../node_modules/http-header-value/src/parser/comment-parser.ts","../../../node_modules/http-header-value/src/hthv-parse.ts","../../../node_modules/http-header-value/src/hthv-quote.ts"],"sourcesContent":["import { HthvItem } from './hthv-item';\n\n/**\n * @internal\n */\nexport interface HthvPartial<I extends HthvItem<any, any, any> = HthvItem> {\n  $: I['$'];\n  n?: I['n'];\n  t?: I['t'];\n  v: I['v'];\n  x?: I['x'];\n  p?: I['p'];\n  pl?: I['pl'];\n}\n\n/**\n * @internal\n */\nexport function hthvItem<I extends HthvItem<any, any, any>>(\n    {\n      $,\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<I>,\n): I {\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as I;\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam({ p, pl }: HthvItem, param: HthvParamItem) {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = config.delimiterOf(c);\n\n    return c;\n  };\n}\n","// tslint:disable-next-line:max-line-length\nimport { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (input.s.match(datePattern)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","/**\n * @internal\n */\nexport const parseNone = () => false;\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseDateTime } from './parse-date-time';\nimport { parseNone } from './parse-none';\nimport { quotedStringParser } from './quoted-string-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport interface ItemParserOpts {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseQuotedString = quotedStringParser(config);\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem),\n    )) ; // tslint:disable-line:curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (config.delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = config.delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = config.delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser(config: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(config.delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport { HthvDelimitConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  delimiterOf(char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n    }: {\n      delimit?: HthvDelimitConfig;\n    } = {}): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = /*#__PURE__*/ buildParserConfig();\n\n/**\n * @internal\n */\nexport const commentParserConfig = /*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n});\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiterChar } from './hthv-delimiter';\nimport { HthvItem } from './hthv-item';\nimport { hthvItem } from './hthv-partial.impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeparam N  Whether parsed items have {@link HthvItem.n names}.\n * @typeparam T  Whether parsed items have {@link HthvItem.t tags}.\n * @typeparam P  Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    N extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    T extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    P extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value  HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<N, T, P>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse comments.\n   *\n   * `false` by default.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // tslint:disable-line\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (config.delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport { spacesParser } from './spaces-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const commentParserOpts: ItemParserOpts = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserOpts);\n  const parseParam = paramParser(config, commentParserOpts);\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while (\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        ) ; /* tslint:disable-line:curly */\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @module http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser =\n    /*#__PURE__*/ newHthvParser();\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = defaultParserConfig.delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n"],"names":["hthvItem","$","n","t","v","x","p","pl","addParam","param","key","prev","push","nextInItem","config","input","c","s","i","d","delimiterOf","datePattern","parseDateTime","out","substring","match","parseNone","itemParser","named","tagged","extra","next","parseQuotedString","unquoted","length","quotedStringParser","parseAngleBrackets","result","angleBracketsParser","parseExtra","tag","value","item","name","type","undefined","extraItem","nextInComment","spacesParser","start","paramParser","opts","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParserOpts","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter"],"mappings":"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"}