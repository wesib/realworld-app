{"version":3,"file":"input-aspects.963c1cb4.js","sources":["../../../node_modules/input-aspects/src/aspect.ts","../../../node_modules/input-aspects/src/aspect.impl.ts","../../../node_modules/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../node_modules/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../node_modules/input-aspects/src/converter.ts","../../../node_modules/input-aspects/src/control.ts","../../../node_modules/input-aspects/src/controls/abstract.control.ts","../../../node_modules/input-aspects/src/controls/value-of.control.ts","../../../node_modules/input-aspects/src/containers/container.control.ts","../../../node_modules/input-aspects/src/containers/parents.aspect.ts","../../../node_modules/input-aspects/src/element.control.ts","../../../node_modules/input-aspects/src/data/mode.aspect.ts","../../../node_modules/input-aspects/src/data/data.aspect.ts","../../../node_modules/input-aspects/src/containers/group.control.ts","../../../node_modules/input-aspects/src/validation/require-nothing.validator.ts","../../../node_modules/input-aspects/src/validation/validator.ts","../../../node_modules/input-aspects/src/validation/validator.impl.ts","../../../node_modules/input-aspects/src/validation/validation.aspect.ts","../../../node_modules/input-aspects/src/validation/require-all.validator.ts","../../../node_modules/input-aspects/src/validation/require-present.validator.ts","../../../node_modules/input-aspects/src/submit.aspect.ts","../../../node_modules/input-aspects/src/data/modes/mode-by-form.ts","../../../node_modules/input-aspects/src/data/modes/mode-by-validity.ts","../../../node_modules/input-aspects/src/elements/element.impl.ts","../../../node_modules/input-aspects/src/elements/text.control.ts","../../../node_modules/input-aspects/src/elements/focus/focus.aspect.ts","../../../node_modules/input-aspects/src/elements/focus/status.aspect.ts","../../../node_modules/input-aspects/src/elements/forms/form-element.control.ts","../../../node_modules/input-aspects/src/elements/forms/submit-button.control.ts","../../../node_modules/input-aspects/src/elements/style/styled-element.aspect.ts","../../../node_modules/input-aspects/src/elements/style/css-classes.aspect.ts","../../../node_modules/input-aspects/src/elements/style/css-error.ts","../../../node_modules/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Value, Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by [[InControl.convert]] method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<To, ConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of [[convertTo]] when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<Value>): Applied<Value, Instance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<OfValue, Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance, Kind>,\n    build: <V>(this: void, control: InControl<V>, origin?: InControl<any>) => Instance,\n    instance?: Instance,\n    origin?: InControl<any>,\n): InAspect.Applied<Value, Instance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<To>(target: InControl<To>): InAspect.Applied<To, Instance> {\n      return inAspectSameOrBuild<To, Instance, Kind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<Value>): InAspect.Applied<Value, Instance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as Instance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance | null, Kind>,\n    instance: Instance | null = null,\n): InAspect.Applied<Value, Instance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<any, Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from 'namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * [[InNamespaceAliaser.to]] converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @param nsAlias  Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by [[InRenderScheduler.to]] converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @param scheduler  Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(scheduler: InRenderScheduler): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, flatMapIt, itsReduction, mapIt } from 'a-iterable';\nimport { isPresent, noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Conversion<From, To>\n    | InConverter.Factory<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<From, To>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Conversion<From, To> =\n      | InConverter.Value.Conversion<From, To>\n      | InConverter.Aspect.Conversion<To>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Value<From, To> =\n      | InConverter.Value.Factory<From, To>\n      | InConverter.Value.Conversion<From, To>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To = From> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Conversion<From, To>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: To): From;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To = From> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<Value>(\n    ...converters: InConverter.Aspect<Value, Value>[]\n): InConverter.Aspect.Factory<Value, Value>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter.Value<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Value.Factory<From, To>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter?: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> {\n\n  type AspectApplicator = <Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<From, To> => {\n\n    const conversion = converter(from, to);\n    const conversions = flatMapIt<InConverter.Conversion<From, To>>([\n        [conversion],\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    ]);\n\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev, cv) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeparam Value  Input value type.\n * @param aspects  Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<Value>(\n    aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[],\n): InConverter.Aspect.Factory<Value> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<Value>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion  Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return !(conversion as any).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Value<From, To>,\n): InConverter.Value.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { asis, noop } from 'call-thru';\nimport {\n  EventEmitter,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get [EventSupply__symbol](): EventSupply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<Value, Value>[]\n  ): InControl<Value>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   * @param and  Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      by: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<To>;\n\n  convert<To>(\n      by?: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<Value> | InControl<To> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<From, To> extends InControl<To> {\n\n  private readonly _supply: EventSupply;\n  readonly on: OnEvent<[To, To]>;\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(src: InControl<From>, by: InConverter.Factory<From, To>) {\n    super();\n    this._supply = eventSupply().needs(src);\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const on = new EventEmitter<[To, To]>();\n\n    this.on = on.on;\n\n    const conversion = by(src, this);\n    let set: (value: From) => To;\n    let get: (value: To) => From;\n    let convertAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    if (isInAspectConversion(conversion)) {\n      set = asis as (value: From) => To;\n      get = asis as (value: To) => From;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    eventSupplyOf(this._it).needs(this._supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        on.send(newValue, oldValue);\n      }\n    }).whenOff(reason => on.done(reason));\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).whenOff(reason => this.done(reason));\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n */\nexport abstract class AbstractInControl<Value> extends InControl<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<Value>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { EventSupply, eventSupply, EventSupply__symbol, OnEvent } from 'fun-events';\nimport { InControl } from '../control';\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @param control  Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<Value>(control: InControl<Value>): InControl<Value> {\n\n  let supply: EventSupply | undefined;\n\n  class InSameValue extends InControl<Value> {\n\n    get it(): Value {\n      return control.it;\n    }\n\n    set it(value: Value) {\n      control.it = value;\n    }\n\n    get on(): OnEvent<[Value, Value]> {\n      return control.on;\n    }\n\n    get [EventSupply__symbol](): EventSupply {\n      return supply || (supply = eventSupply().needs(control));\n    }\n\n  }\n\n  return new InSameValue();\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends AbstractInControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n  readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n  readonly read: AfterEvent<[InParents.All]>;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const map = this._map;\n\n    this.on = this._on.on.tillOff(_control);\n    this.read = afterEventBy(\n        this.on.thru(\n            allParents,\n        ),\n        () => [allParents()],\n    );\n\n    function allParents(): IterableIterator<InParents.Entry> {\n      return map.keys();\n    }\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends AbstractInControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<Value, any>,\n        ) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt } from 'a-iterable';\nimport { nextArgs, NextCall, nextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates. Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  get [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get on(): OnEvent<[InMode.Value, InMode.Value]> {\n    return this._tracker.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._tracker);\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n      case 'off':\n      case 'ro':\n      case '-on':\n      case '-ro':\n        break;\n      default:\n        value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterEventBy(\n        this._on.on.thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keep.thru(\n        (set: Set<AfterEvent<[InMode.Value]>>) => nextAfterEvent(afterEach(...set)),\n        mergeInModes,\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): EventSupply {\n\n    const supply = eventSupply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly read: AfterEvent<[InMode.Value]>;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    eventSupplyOf(this.own).needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read.keep.thru_(parentsInMode));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterEventBy<[InMode.Value]>(\n        afterAll({\n          derived: this._derived.read,\n          own: this.own,\n        }).thru(({ derived: [derived], own: [own] }) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          return last === next ? nextSkip() : nextArgs(last = next);\n        }),\n        valuesProvider<[InMode.Value]>(last),\n    ).tillOff(_control);\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    });\n  }\n\n  derive(source: InMode.Source): EventSupply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control))\n            .tillOff(this._control),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n    case 'off':\n      element.setAttribute('disabled', '');\n      break;\n    case 'ro':\n    case '-ro':\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      element.setAttribute('readonly', '');\n      break;\n    default:\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('readonly', '');\n      element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): NextCall<OnEventCallChain, [InMode.Value]> {\n\n  const parentList = Array.from(parents);\n\n  if (!parentList.length) {\n    return nextArgs('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return nextAfterEvent(afterEach(...parentModes).keep.thru_(mergeInModes));\n}\n\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...flatMapIt<InMode.Value>(modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes  Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n      case 'off':\n        return 'off';\n      case 'ro':\n        ro = true;\n        break;\n      case '-on':\n        off = true;\n        break;\n      case '-ro':\n        off = true;\n        ro = true;\n        break;\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll, AfterEvent } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <V>(ctrl: InControl<V>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).keep.thru(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? nextArgs(value as InData.DataType<V>)\n            : nextArgs(),\n    ));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<Value, InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from 'a-iterable';\nimport { nextArg, nextArgs, NextCall, noop } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  nextAfterEvent,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<Instance, Model, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): EventSupply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<Model>): EventSupply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof Model): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<Model> {\n\n  readonly [OnEvent__symbol]: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  readonly [AfterEvent__symbol]: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, InGroupEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, InGroupEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, InGroupEntry][],\n      removed: [keyof Model, InGroupEntry][],\n  ): EventSupply {\n\n    const replaced = this._map.get(key);\n    let supply: EventSupply;\n\n    if (control) {\n      supply = eventSupply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = noEventSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]>,\n      supply: EventSupply,\n  ): InGroupEntry {\n    return [\n      control,\n      eventSupply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof Model, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof Model, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n  clear(): [keyof Model, InGroupEntry][] {\n\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, InGroupEntry][], [keyof Model, InGroupEntry][]]>();\n  readonly on: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const self = this;\n\n    this._map = new InGroupMap<Model>(this);\n    this.on = this._updates.on.thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    );\n    this.read = afterEventBy(\n        this._updates.on.thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()],\n    );\n    this._map._supply.needs(_group.read(applyModelToControls));\n\n    function applyModelToControls(model: Model): void {\n      self.read.once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    }\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined,\n  ): EventSupply {\n\n    const group = this._group;\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n    let supply: EventSupply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = eventSupply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: Model | undefined;\n\n      added.forEach(([key, [control, supply]]) => {\n        supply.needs(control.aspect(InParents).add({ parent: group }).needs(supply));\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(([key, [control, supply]]) => {\n        supply.needs(control.read(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).needs(supply));\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, InGroupEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(\n      model: Model,\n      opts: {\n        readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    eventSupplyOf(this).whenOff(() => this.controls.clear());\n  }\n\n  get on(): OnEvent<[Model, Model]> {\n    return this._model.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._model);\n  }\n\n  get it(): Model {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keep.thru_(\n      readInGroupData,\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    },\n): NextCall<OnEventCallChain, [InData.DataType<Model>?]> {\n  if (!InMode.hasData(mode)) {\n    return nextArgs();\n  }\n\n  const csData: { [key in keyof Model]: InData<any> } = {} as any;\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return nextAfterEvent(afterAll(csData).keep.thru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(overEntries(controlsData), ([key, [controlData]]) => {\n      data[key] = controlData;\n    });\n\n    return nextArg(data as InData.DataType<Model>);\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(\n    model: Model,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n    } = {},\n): InGroup<Model> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<OfValue extends object ? OfValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, afterThe } from 'fun-events';\n\n/**\n * @internal\n */\nconst _requireNothing = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return _requireNothing;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { CallChain, nextArgs, NextCall, valueProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>,\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read.keep.thru(simpleInValidator(control, validator));\n}\n\n/**\n * @internal\n */\nfunction simpleInValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): (value: Value) => NextCall<CallChain, InValidation.Message[]> {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : nextArgs(messages);\n  };\n}\n","import { flatMapIt, itsEach } from 'a-iterable';\nimport { asis, noop, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly [AfterEvent__symbol]: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this[AfterEvent__symbol] = afterEventBy(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share().tillOff(control);\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from 'a-iterable';\nimport { nextArgs, NextCall } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  EventKeeper,\n  EventSupply,\n  nextAfterEvent,\n  OnEventCallChain,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild<Value, InValidation<Value>, 'validation'>(\n        control,\n        InValidation,\n        <V>(ctrl: InControl<V>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<V>(ctrl);\n\n          if (origin) {\n\n            const from = origin.aspect(InValidation);\n\n            validation.by(from.read.keep.thru(result => nextArgs(...result.messages())));\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes  Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code, [message]);\n              }\n            }\n          });\n\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        },\n    );\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): IterableIterator<InValidation.Message> {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n\n    this.read = afterSupplied(this._messages).keep.thru(inValidationResult);\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.keep.thru(\n      nestedInValidations,\n      combineInValidationResults,\n  );\n}\n\n/**\n * @internal\n */\nfunction nestedInValidations(\n    controls: InContainer.Snapshot,\n): NextCall<OnEventCallChain, [InValidation.Result][]> {\n  return nextAfterEvent(afterEach(...mapIt(controls, control => control.aspect(InValidation))));\n}\n\n/**\n * @internal\n */\nfunction combineInValidationResults(\n    ...results: [InValidation.Result][]\n): NextCall<OnEventCallChain, InValidation.Message[]> {\n  return nextArgs<InValidation.Message[]>(\n      ...flatMapIt(mapIt(results, result => result[0])),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { EventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control ? control.read.keep.thru(value => value ? nextArgs() : { missing: 'missing' }) : requirePresent;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEvery, mapIt } from 'a-iterable';\nimport { nextArgs } from 'call-thru';\nimport { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper, eventSupplyOf, trackValue } from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrBuild } from './aspect.impl';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors  Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...mapIt(errors, message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason  A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * [input data]: InData\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InSubmit<Value> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of submit status flag.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @param submitter  A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Result  Submit result value type.\n   */\n  export type Submitter<Value, Result> =\n  /**\n   * @param data  Input data to submit.\n   * @param control  Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          data: Value extends undefined ? never : Value,\n          control: InControl<Value>,\n      ) => Promise<Result>;\n\n}\n\nclass InControlSubmit<Value> extends InSubmit<Value> {\n\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n  readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read.keep.thru(\n        messages => nextArgs(...messages),\n    ));\n    this.read = afterAll({\n      flags: this._flags,\n      data: _control.aspect(InData),\n      messages: validation,\n    }).keep.thru(({ flags: [flags], data: [data], messages: [messages] }) => ({\n      ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n      submitted: flags.submitted,\n      busy: flags.busy,\n    })).tillOff(_control);\n  }\n\n  async submit<Result>(submitter: InSubmit.Submitter<Value, Result>): Promise<Result> {\n    if (eventSupplyOf(this._control).isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    function submitData(): Promise<Value extends undefined ? never : Value> {\n      return new Promise((resolve, reject) => {\n        afterAll({\n          data: control.aspect(InData),\n          flags: submit.read,\n        }).once(({ data: [d], flags: [{ ready }] }) => {\n          if (!ready) {\n            reject(new InSubmitRejectedError('notReady'));\n          } else {\n            resolve(d as any);\n          }\n        });\n      });\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form  Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady  Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid  Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy  Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read.keep.thru(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid  Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore  Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read.keep.thru(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  );\n}\n","import { asis, nextArgs, nextSkip } from 'call-thru';\nimport {\n  AfterEvent,\n  afterSupplied,\n  EventEmitter,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n} from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nexport class InElementControl<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly input: AfterEvent<[InElement.Input<Value>]>;\n  readonly on: OnEvent<[Value, Value]>;\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: InElementControl<Value, Elt>) => Value;\n  private readonly _set: (this: InElementControl<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private _value: Value;\n  // noinspection TypeScriptFieldCanBeMadeReadonly\n  private _update: (value: Value, oldValue: Value) => void;\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._input);\n  }\n\n  constructor(\n      readonly element: Elt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n        readonly get: (this: InElementControl<Value, Elt>) => Value;\n        readonly set: (this: InElementControl<Value, Elt>, value: Value) => void;\n      },\n  ) {\n    super({ aspects });\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const update = this._update = (value: Value, oldValue: Value): void => send({ value }, oldValue);\n\n    this.input = afterSupplied<[InElement.Input<Value>]>(\n        this._input.on.thru(asis),\n        () => [{ value: this.it }],\n    );\n\n    this.on = this._input.on.thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    );\n\n    this.events = new DomEventDispatcher(element);\n\n    const self = this;\n    const supply = eventSupplyOf(this);\n    const onInput = (event: Event): void => send({ value: self.it, event }, self._value);\n\n    this.events.on('input')(onInput).needs(supply);\n    this.events.on('change')(onInput).needs(supply);\n\n    function send(input: InElement.Input<Value>, oldValue: Value): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = update;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { InElementControl } from './element.impl';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new InElementControl(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { EventSupply, EventSupply__symbol, eventSupplyOf, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot | null = element.getRootNode\n        ? element.getRootNode() as any\n        : element.ownerDocument;\n\n    this._it = trackValue(!!owner && owner.activeElement === element);\n    eventSupplyOf(this).needs(inElement);\n\n    events.on('focus')(() => this._it.it = true);\n    events.on('blur')(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get on(): OnEvent<[boolean, boolean]> {\n    return this._it.on;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._it);\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, mapIt } from 'a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.by(elementInStatusFlags(this._flags, control));\n    this.read = this._flags.read.tillOff(control);\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.keep.thru(({ event }) => !!event) : afterThe(false),\n  }).keep.thru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  );\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n    this.read = containerInStatusFlags(_container).tillOff(_container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markEdited(edited),\n        ),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markTouched(touched),\n        ),\n    );\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.keep.thru_(\n      (snapshot: InContainer.Snapshot) => nextAfterEvent(afterEach(...inControlStatuses(snapshot))),\n      combineInStatusFlags,\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { eventSupplyOf } from 'fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { InElementControl } from '../element.impl';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by [[inFormElement]] function.\n *\n * @category Control\n * @typeparam Elt  A type of HTML form element.\n */\nexport type InFormElement<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element  HTML element to create control for.\n * @param options  Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<Elt extends HTMLElement>(\n    element: Elt,\n    options: InFormElement.Options,\n): InFormElement<Elt> {\n\n  const { form, aspects, modes } = options;\n  const control = new InElementControl<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, modes));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport { eventSupplyOf } from 'fun-events';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { InElementControl } from '../element.impl';\n\n/**\n * Form submit button control.\n *\n * It is connected to control to submit (form) and may change submit button state depending on form submit status.\n * E.g. by disabling it when submit is {@link InSubmit.Flags.ready not ready}, or while {@link InSubmit.Flags.busy\n * submitting} the form.\n *\n * Submit button control can be created by [[inSubmitButton]] function.\n *\n * @category Control\n * @typeparam Elt  A type of submit button element.\n */\nexport type InSubmitButton<Elt extends HTMLElement = HTMLElement> = InElement<void, Elt>;\n\nexport namespace InSubmitButton {\n\n  /**\n   * Submit button control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to submit button control by [[inModeByForm]].\n     */\n    modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `off` (disable) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `off` (disabled) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element  Submit button element to create control for.\n * @param options  Submit button control options.\n *\n * @returns New submit button control.\n */\nexport function inSubmitButton<Elt extends HTMLElement>(\n    element: Elt,\n    options: InSubmitButton.Options,\n): InSubmitButton<Elt> {\n\n  const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n  const control = new InElementControl<void, Elt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  eventSupplyOf(control).needs(form);\n  control.aspect(InMode).derive(inModeByForm(form, { notReady, invalid, busy }));\n\n  return control;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @param element  A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(element: InStyledElement | null = null): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { DeltaSet } from 'delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventKeeper,\n  EventNotifier,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { css__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { RenderSchedule } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Reports current CSS classes as added ones on receiver registration.\n   */\n  abstract readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element  Target element to apply CSS classes to.\n   * @param schedule  DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by [[InNamespaceAliaser]] aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n  private readonly _sources: ValueTracker<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]> = trackValue([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this.read = this._sources.read.keep.thru_(\n        ([sources]) => nextAfterEvent(afterEach(...sources.keys())),\n        (...classes) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        },\n    ).tillOff(_control);\n    this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    }).tillOff(_control);\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n\n    eventSupplyOf(_control).whenOff(reason => this.done(reason));\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).keep.thru(\n        (...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        },\n    );\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const inSupply = eventSupplyOf(this._control);\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source)({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): EventSupply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark  Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when  {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  let marks: InCssClasses.Spec[];\n\n  if (!mark) {\n    marks = defaultInCssErrorMarks;\n  } else if (Array.isArray(mark)) {\n    marks = mark.length ? mark : defaultInCssErrorMarks;\n  } else {\n    marks = [mark];\n  }\n\n  return control => control.aspect(InValidation).read.keep.thru(\n      errors => hasError(errors) ? nextArgs(...marks) : nextArgs(),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll } from 'fun-events';\nimport { NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InStatus } from '../focus';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns  A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keep.thru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          return nextArgs(...names);\n        },\n    );\n  };\n}\n"],"names":["InAspect__symbol","Symbol","inAspectNull","instance","convertTo","noop","inAspectSameOrBuild","control","aspectKey","build","origin","undefined","target","attachTo","aspect","inAspectSameOrNull","valueProvider","inAspectValue","[object Object]","this","InputAspects__NS","NamespaceDef","InNamespaceAliaser__aspect","applyTo","newNamespaceAliaser","InNamespaceAliaser","to","nsAlias","applyAspect","InRenderScheduler__aspect","newRenderSchedule","InRenderScheduler","scheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","length","aspectConverters","mapIt","from","conversion","conversions","flatMapIt","filterIt","acf","isPresent","itsReduction","prev","cv","isInAspectConversion","set","bind","get","intoConvertedAspects","aspects","value","Array","isArray","noopInConversion","InControl","ValueTracker","Map","_aspect","aspectKeyOrSetup","aspectSetup","by","and","InConverted","existing","_aspects","applied","_applyAspect","src","super","_supply","eventSupply","needs","backward","lastRev","on","EventEmitter","convertAspect","asis","fallback","_it","trackValue","it","eventSupplyOf","newValue","oldValue","send","whenOff","reason","done","rev","EventSupply__symbol","prevValue","prevRev","AbstractInControl","_aspectConversion","supply","inValueOf","InContainer__aspect","InContainer","InParents__aspect","InControlParents","InParents","OnEvent__symbol","AfterEvent__symbol","read","_control","map","_map","allParents","keys","_on","tillOff","afterEventBy","thru","entry","existingSupply","delete","parent","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","own","OwnModeTracker","element","_tracker","getAttribute","initialInMode","DerivedInModes","Set","sources","_all","valuesProvider","keep","nextAfterEvent","afterEach","mergeInModes","source","add","derive","InParentsAspect","thru_","parentsInMode","last","afterAll","derived","_derived","next","off","substring","nextSkip","nextArgs","setAttribute","removeAttribute","applyInMode","lastUpdate","old","afterSupplied","isEventKeeper","parents","parentList","parentModes","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","inControlReplacedReason","InGroupSnapshot","key","iterator","itsIterable","values","entries","InGroupMap","_controls","added","removed","replaced","newEntry","sendUpdate","push","modify","noEventSupply","remove","_shot","itsEach","k","e","InGroupControlControls","_group","self","_updates","controlEntryToGroupEntry","snapshot","model","once","withValues","overEntries","has","keyOrControls","newControl","group","newModel","forEach","applyControlsToModel","clear","InGroupControl","opts","_model","controls","cs","readInGroupData","csData","controlsData","data","controlData","nextArg","inGroup","_requireNothing","afterThe","requireNothing","inValidator","validator","messages","validate","simpleInValidator","dontRemove","InValidationMessages","emitter","validators","validatorMessages","receiver","resultSupply","validatorSupply","size","share","InValidation__aspect","InValidation","validation","InControlValidation","result","noInValidationErrors","ok","hasBut","InValidationErrors","message","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","_messages","container","nestedInValidations","combineInValidationResults","nestedInValidationMessages","numValidators","requireAll","results","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","Error","errors","submit","InSubmitRejectedError","rejected","submitted","busy","_errors","flags","_flags","ready","itsEvery","submitter","isOff","Promise","resolve","reject","d","error","toInSubmitMessages","inModeByForm","form","notReady","invalid","inModeByValidity","ignore","validity","InElementControl","_get","_set","_value","update","_update","input","_input","events","DomEventDispatcher","onInput","event","correction","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","ownerDocument","activeElement","ctx","onRecurrent","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","c","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","options","inSubmitButton","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_sources","classes","mergeInCssClassesMap","track","DeltaSet","EventNotifier","classesSent","flag","name","delta","redelta","undelta","schedule","_schedule","controlSchedule","specs","names","isQualifiedName","css__naming","inSupply","classesSupply","context","receive","classList","updateClasses","node","defaultInCssErrorMarks","defaultInCssHasError","inCssError","mark","when","hasError","marks","inCssInfo","ns","cls","md","vl","st","valid"],"mappings":"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"}