{"version":3,"file":"lib.c50838ef.js","sources":["../../node_modules/call-thru/src/next-call.ts","../../node_modules/call-thru/src/passed-thru.ts","../../node_modules/call-thru/src/call-thru.ts","../../node_modules/call-thru/src/misc/asis.ts","../../node_modules/call-thru/src/misc/noop.ts","../../node_modules/call-thru/src/misc/presence.ts","../../node_modules/call-thru/src/misc/value-providers.ts","../../node_modules/call-thru/src/passes/args.ts","../../node_modules/call-thru/src/passes/each.ts","../../node_modules/call-thru/src/passes/iteration.ts","../../node_modules/call-thru/src/passes/skip.ts","../../node_modules/a-iterable/src/api.ts","../../node_modules/a-iterable/src/revertible-iterable.ts","../../node_modules/a-iterable/src/util.ts","../../node_modules/a-iterable/src/reverse.ts","../../node_modules/a-iterable/src/termination.ts","../../node_modules/a-iterable/src/thru.ts","../../node_modules/a-iterable/src/transform.ts","../../node_modules/a-iterable/src/a-iterable.ts","../../node_modules/a-iterable/src/construction.ts","../../node_modules/fun-events/src/event-keeper.ts","../../node_modules/fun-events/src/event-supply.ts","../../node_modules/fun-events/src/event-receiver.ts","../../node_modules/fun-events/src/event-sender.ts","../../node_modules/fun-events/src/impl/once.ts","../../node_modules/fun-events/src/event-notifier.ts","../../node_modules/fun-events/src/impl/share.ts","../../node_modules/fun-events/src/impl/till-off.ts","../../node_modules/fun-events/src/on-event.ts","../../node_modules/fun-events/src/after-event.ts","../../node_modules/fun-events/src/dom/on-dom-event.ts","../../node_modules/fun-events/src/dom/dom-event-dispatcher.ts","../../node_modules/fun-events/src/event-emitter.ts","../../node_modules/fun-events/src/keepers/after-all.ts","../../node_modules/fun-events/src/keepers/after-each.ts","../../node_modules/fun-events/src/senders/on-any.ts","../../node_modules/fun-events/src/state/state-path.ts","../../node_modules/fun-events/src/state/state-tracker.ts","../../node_modules/fun-events/src/value/value-tracker.ts","../../node_modules/fun-events/src/value/track-value.ts","../../node_modules/context-values/src/context-key.ts","../../node_modules/context-values/src/context-key-error.ts","../../node_modules/context-values/src/context-value-spec.ts","../../node_modules/context-values/src/context-values.ts","../../node_modules/context-values/src/context-registry.ts","../../node_modules/context-values/src/context-up-key.ts","../../node_modules/context-values/src/fn-context-key.ts","../../node_modules/context-values/src/simple-context-key.ts","../../node_modules/namespace-aliaser/src/namings.ts","../../node_modules/namespace-aliaser/src/naming.ts","../../node_modules/namespace-aliaser/src/namespace.ts","../../node_modules/namespace-aliaser/src/name.ts","../../node_modules/namespace-aliaser/src/namespace-aliaser.ts","../../node_modules/render-scheduler/src/render-schedule.ts","../../node_modules/render-scheduler/src/custom-render-scheduler.ts","../../node_modules/render-scheduler/src/animation-render-scheduler.ts","../../node_modules/render-scheduler/src/render-scheduler.ts","../../node_modules/http-header-value/src/hthv-partial.impl.ts","../../node_modules/http-header-value/src/parser/add-param.ts","../../node_modules/http-header-value/src/parser/next-in-item.ts","../../node_modules/http-header-value/src/parser/parse-date-time.ts","../../node_modules/http-header-value/src/parser/parse-none.ts","../../node_modules/http-header-value/src/parser/item-parser.ts","../../node_modules/http-header-value/src/parser/quoted-string-parser.ts","../../node_modules/http-header-value/src/parser/angle-brackets-parser.ts","../../node_modules/http-header-value/src/parser/next-in-comment.ts","../../node_modules/http-header-value/src/parser/spaces-parser.ts","../../node_modules/http-header-value/src/parser/param-parser.ts","../../node_modules/http-header-value/src/parser/parser-config.ts","../../node_modules/http-header-value/src/hthv-parser.ts","../../node_modules/http-header-value/src/parser/item-delimit-parser.ts","../../node_modules/http-header-value/src/parser/comment-parser.ts","../../node_modules/http-header-value/src/hthv-parse.ts","../../node_modules/http-header-value/src/hthv-quote.ts","../../node_modules/style-producer/src/internal/types.ts","../../node_modules/style-producer/src/selector/selector.impl.ts","../../node_modules/style-producer/src/selector/query.ts","../../node_modules/style-producer/src/rule/rule.ts","../../node_modules/style-producer/src/rule/rules.impl.ts","../../node_modules/style-producer/src/rule/rules.ts"],"sourcesContent":["/**\n * @module call-thru\n */\nimport { CallOutcome } from './call-outcome';\n\n/**\n * A key of a [[NextCall]] method responsible for calling the next function in chain.\n */\nexport const NextCall__symbol = /*#__PURE__*/ Symbol('next-call');\n\n/**\n * A key of a [[NextCall]] method responsible for returning the outcome of the las pass in chain.\n */\nexport const NextCall_lastOutcome__symbol = /*#__PURE__*/ Symbol('next-call:last-outcome');\n\n/**\n * A call of the next function in chain.\n *\n * This is basically a function with additional method, which is treated specially by call chaining functions.\n * When previous function in chain returns a [[NextCall]] instance, it will be used to call the next function in chain.\n * Otherwise the next function will be called with single argument containing a value returned.\n *\n * A [[NextCall]] is a function returning itself. So it can be chained like any other function.\n *\n * A [[nextCall]] function can be used to construct a next call.\n *\n * @typeparam OutKind  A kind of the call outcome.\n * @typeparam NextThis  A type of `this` context object reference of the next function.\n * @typeparam NextArgs  A type of argument tuple of the next function.\n * @typeparam NextReturn  A return type of the next function.\n * @typeparam Out  A type of the next function call outcome.\n * @typeparam Last  A type of the outcome of the next call returned from the last pass in chain.\n */\nexport abstract class NextCall<\n    OutKind extends CallOutcome.Kind,\n    NextArgs extends any[],\n    NextReturn,\n    Out = NextReturn,\n    Last = CallOutcome.OfKind<OutKind, NextArgs[0], Out>> extends Function {\n\n  /**\n   * Checks whether the `target` value is a next function call.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true`.\n   */\n  static is<V extends NextCall.Any>(target: V): target is V;\n\n  /**\n   * Checks whether the `target` value is a next function call.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true` if the `target` value is a function with a `[NextCall.mark]` property, or `false` otherwise.\n   */\n  static is(target: any): target is NextCall.Any;\n\n  static is(target: any): target is NextCall.Any {\n    return typeof target === 'function' && NextCall__symbol in target;\n  }\n\n  /**\n   * Converts a value returned from previous chained function call to the call of the next function in chain.\n   *\n   * @param nextCall  A next function call to return.\n   *\n   * @returns A `nextCall` itself.\n   */\n  static of<V extends NextCall.Any>(nextCall: V): V;\n\n  /**\n   * Converts a value returned from previous chained function call to the call of the next function in chain.\n   *\n   * @param value  A value to convert.\n   *\n   * @returns Either a `value` itself if it is a next function call, or a new next function call instance that passes\n   * a `value` as the only argument to the callee.\n   */\n  static of<V, Out>(value: V): NextCall<'default', [V], Out, Out, Out>;\n\n  static of<V, NextReturn>(value: V): NextCall<any, NextCall.Callee.Args<V>, NextReturn> {\n    if (NextCall.is(value)) {\n      return value;\n    }\n    return nextCall((callee: any) => callee(value));\n  }\n\n  /**\n   * Calls the next function in chain.\n   *\n   * This is invoked only when there _is_ a next function. When next call is returned by the last pass a\n   * `[NextCall_lastOutcome__symbol]()` is invoked instead.\n   *\n   * @param callee  A function to call.\n   *\n   * @returns A call outcome.\n   */\n  abstract [NextCall__symbol](callee: (this: void, ...args: NextArgs) => NextReturn): Out;\n\n  /**\n   * Builds an outcome of the last pass in chain.\n   *\n   * This is invoked for the last pass in chain only. If there is the next pass, a `[NextCall__symbol]()` is invoked\n   * instead.\n   */\n  abstract [NextCall_lastOutcome__symbol](): Last;\n\n}\n\nexport interface NextCall<\n    OutKind extends CallOutcome.Kind,\n    NextArgs extends any[],\n    NextReturn,\n    Out = NextReturn,\n    Last = CallOutcome.OfKind<OutKind, NextArgs[0], Out>> {\n\n  /**\n   * Returns itself to add it to functions chain.\n   */\n  (): NextCall<OutKind, NextArgs, NextReturn, Out, Last>; // tslint:disable-line:callable-types\n\n}\n\nexport namespace NextCall {\n\n  /**\n   * Any call of the next function.\n   */\n  export type Any = NextCall<any, any, any, any, any>;\n\n  export namespace Callee {\n\n    /**\n     * Arguments tuple type of a callee. Either extracted from [[NextCall]], or consisting of single argument of type\n     * `V`.\n     */\n    export type Args<V> = V extends NextCall<any, infer NextArgs, any, any, any> ? NextArgs : [V];\n\n    /**\n     * A return type of a callee. Either extracted from [[NextCall]], or `V` itself.\n     */\n    export type Return<V> = V extends NextCall<any, any, infer NextReturn, any, any> ? NextReturn : V;\n\n  }\n\n  /**\n   * A type of next call outcome. Either extracted from [[NextCall]], or `Return`.\n   */\n  export type Outcome<V, Return> = V extends NextCall<infer OutKind, any, any, infer Out, any>\n      ? CallOutcome.OfKind<OutKind, Return, Out>\n      : Return;\n\n  /**\n   * A type of last call outcome. Either extracted from the last call, or the value itself.\n   */\n  export type LastOutcome<V> = V extends NextCall<any, any, any, any, infer Last> ? Last : V;\n\n  /**\n   * A type of the result returned from chained function call, except for the last one.\n   *\n   * This may be either a [[NextCall]] instance, or single value.\n   *\n   * In any case the result provides arguments for the next pass in chain and thus should be compatible with next\n   * function signature.\n   *\n   * @typeparam NextArgs  A type of argument tuple of the next function in chain.\n   */\n  export type CallResult<NextArgs extends any[]> =\n      NextArgs extends [infer Result]\n          // Next function expects single argument.\n          // So the previous one may return either a single value, or a [[NextCall]] with compatible argument.\n          ? (Result | NextCall<any, NextArgs, any, any, any>)\n          // Next function expects multiple arguments.\n          // So the previous one should always return a [[NextCall]] instance with compatible arguments.\n          : NextCall<any, NextArgs, any, any, any>;\n\n  /**\n   * A result returned by last function in chain.\n   *\n   * This may be either a [[NextCall]] instance, or single value.\n   *\n   * @typeparam Last  A type of outcome of the last pass in chain.\n   */\n  export type LastResult<Last> =\n      Last | NextCall<any, any, any, any, Last>;\n\n}\n\nconst firstArg: (...args: any[]) => any = (arg: any) => arg;\n\n/**\n * Constructs a call to the next function.\n *\n * @param callNext  A next function caller function.\n * @param lastOutcome  A function building an outcome of the last pass in chain.\n *\n * @returns A next function call performed by the given `callNext` function.\n */\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out, Last>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out,\n    lastOutcome: (this: void) => Last):\n    NextCall<OutKind, NextArgs, NextReturn, Out, Last>;\n\n/**\n * Constructs a call to the next function with default last pass outcome implementation.\n *\n * The last pass outcome is detected by passing to `callNext` a function that just returns its first argument.\n *\n * @param callNext  A next function caller function.\n *\n * @returns A next function call performed by the given `callNext` function.\n */\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out):\n    NextCall<OutKind, NextArgs, NextReturn, Out>;\n\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out, Last>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out,\n    lastOutcome: (this: void) => Last = () => callNext(firstArg) as any):\n    NextCall<OutKind, NextArgs, NextReturn, Out, Last> {\n\n  const result = (() => result) as NextCall<OutKind, NextArgs, NextReturn, Out, Last>;\n\n  result[NextCall__symbol] = callee => callNext(callee);\n  result[NextCall_lastOutcome__symbol] = lastOutcome;\n\n  return result;\n}\n","/**\n * @module call-thru\n */\n/**\n * A key of a [[PassedThru]] property containing the actual outcome value.\n */\nexport const PassedThru__symbol = /*#__PURE__*/ Symbol('passed-thru');\n\n/**\n * An chained pass outcome value wrapping the actual outcome.\n *\n * When the outcome of the last chained pass is a [[PassedThru]] instance, it is be replaced with the value of its\n * [[PassedThru__symbol]] property.\n *\n * Also extends an `Iterable` interface, so that e.g. [[nextEach]] and [[nextFlatEach]] unwrap the passed through value\n * to convert it to arbitrary number of elements. Including zero, which is the case when `nextSkip()` is returned.\n */\nexport abstract class PassedThru<V, I = V> implements Iterable<I> {\n\n  /**\n   * The actual passed thru value.\n   */\n  abstract readonly [PassedThru__symbol]: V;\n\n  /**\n   * Checks whether `target` value is a [[PassedThru]] instance.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true`.\n   */\n  static is<V extends PassedThru<any, any>>(target: V): target is V;\n\n  /**\n   * Checks whether `target` value is a [[PassedThru]] instance.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true` if the `target` value is an object with a [[PassedThru__symbol]] property, or `false` otherwise.\n   */\n  static is<V>(target: any): target is PassedThru<V, any>;\n\n  static is(target: any): target is PassedThru<any, any> {\n    return typeof target === 'object' && PassedThru__symbol in target;\n  }\n\n  /**\n   * Extracts the passed through value.\n   *\n   * @param outcome  The outcome to extract the value from.\n   *\n   * @returns A [[PassedThru__symbol]] property value is the given `outcome` is a [[PassedThru]] instance, or `outcome`\n   * itself otherwise.\n   */\n  static get<V>(outcome: V): PassedThru.Value<V> {\n    if (PassedThru.is<V>(outcome)) {\n      return outcome[PassedThru__symbol] as PassedThru.Value<V>;\n    }\n    return outcome as PassedThru.Value<V>;\n  }\n\n  /**\n   * Extracts the passed through items.\n   *\n   * @param outcome  The outcome to extract the items from.\n   *\n   * @return An iterable of passed through items if the the given `outcome` is a [[PassedThru]] instance, or an iterable\n   * containing the `outcome` itself otherwise.\n   */\n  static items<V>(outcome: V): Iterable<PassedThru.Item<V>> {\n    if (PassedThru.is<V>(outcome)) {\n      return outcome;\n    }\n    return {\n      * [Symbol.iterator]() {\n        yield outcome as PassedThru.Item<V>;\n      },\n    };\n  }\n\n  abstract [Symbol.iterator](): Iterator<I>;\n\n}\n\nexport namespace PassedThru {\n\n  /**\n   * A type of the passed though value.\n   */\n  export type Value<V> = V extends PassedThru<infer T, any> ? T : V;\n\n  /**\n   * A type of the passed though item.\n   */\n  export type Item<V> = V extends PassedThru<any, infer I> ? I : V;\n\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from './next-call';\nimport { PassedThru } from './passed-thru';\nimport Last = NextCall.LastResult;\nimport Out = NextCall.Outcome;\nimport Result = NextCall.CallResult;\n\n/**\n * Constructs a function that invokes the chained passes.\n *\n * Each pass is function accepts argument(s) passed from the previous one.\n *\n * The value returned from the pass is treated the following way:\n *\n * - When a [[NextCall]] is returned, this instance is used to perform the next function call.\n * - When plain value returned, this value is passed to the next function as the only argument.\n * - When a [[NextCall]] is returned by the last pass, it is used to construct the outcome.\n * - When a plain value is returned by the last pass, it is used as outcome.\n *\n * A [[NextCall]] instance returned the pass is responsible for next function call and may modify the call outcome.\n */\nexport function callThru<P extends any[], R>(\n    fn: (this: void, ...args: P) => Last<R>,\n): (this: void, ...args: P) =>\n    PassedThru.Value<R>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => Last<R2>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, R2>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => Last<R3>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, R3>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => Last<R4>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, R4>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => Last<R5>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4, R5>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => Last<R6>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, R6>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => Last<R7>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, R7>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => Last<R8>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, R8>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => Last<R9>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, R9>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => Last<R10>):\n    (this: void, ...args: P1) => PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9, R10>>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => Last<R11>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9,\n            Out<R10, R11>>>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => Last<R12>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9,\n            Out<R10, Out<R11, R12>>>>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12 extends Result<P13>,\n    P13 extends any[], R13>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => R12,\n    fn13: (this: void, ...args: P13) => Last<R13>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9,\n            Out<R10, Out<R11, Out<R12, R13>>>>>>>>>>>>>;\n\nexport function callThru<R>(...fns: ((...args: any[]) => any)[]): (...args: any[]) => R {\n\n  function callNext(idx: number, prev: any): any {\n\n    const len = fns.length;\n\n    if (idx < len) {\n      // There is a next pass in chain\n      if (!NextCall.is(prev)) {\n        return callNext(idx + 1, fns[idx].call(null, prev));\n      }\n      return prev[NextCall__symbol](function (this: any, ...args: any[]) {\n        return callNext(idx + 1, fns[idx].apply(this, args));\n      });\n    }\n\n    // Last in chain\n    if (!NextCall.is(prev)) {\n      return prev;\n    }\n\n    return prev[NextCall_lastOutcome__symbol]();\n  }\n\n  return function (this: any, ...args: any[]) {\n    return PassedThru.get(callNext(1, fns[0].apply(this, args)));\n  };\n}\n","/**\n * @module call-thru\n */\n/**\n * A function that returns its argument as is.\n *\n * @param value  A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * @module call-thru\n */\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","/**\n * @module call-thru\n */\n/**\n * A function that checks whether the given value is present.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","/**\n * @module call-thru\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value  A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return () => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return () => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return () => [...values] as T;\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, nextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\n\nexport interface NextArgs<Args extends any[], NextReturn>\n    extends NextCall<'default', Args, NextReturn, NextReturn, Args> {\n\n  (): NextArgs<Args, NextReturn>;\n\n  [NextCall__symbol](callee: (this: void, ...args: Args) => NextReturn): NextReturn;\n\n  [NextCall_lastOutcome__symbol](): Args;\n\n}\n\n/**\n * Constructs arguments for the next function call.\n *\n * When returned from the lass pass, the outcome will contain a tuple containing `args`.\n *\n * @param args  Next function call arguments.\n *\n * @return A next function call with the given arguments.\n */\nexport function nextArgs<Args extends any[], NextReturn>(...args: Args): NextArgs<Args, NextReturn> {\n  return nextCall(callee => callee.apply(undefined, args), () => args);\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, nextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\nimport { PassedThru } from '../passed-thru';\nimport { forEachItem, lastItems } from './iteration';\n\ndeclare module '../call-outcome' {\n  export namespace CallOutcome {\n    export interface Map<Return, Out> {\n\n      /**\n       * Iterable outcome type.\n       */\n      each(): Iterable<PassedThru.Item<NextCall.Callee.Return<Return>>>;\n\n    }\n  }\n}\n\nexport interface NextEach<NextItem, NextReturn> extends NextCall<\n    'each',\n    NextCall.Callee.Args<NextItem>,\n    NextReturn,\n    Iterable<PassedThru.Item<NextCall.Callee.Return<NextReturn>>>,\n    Iterable<PassedThru.Item<NextCall.LastOutcome<NextItem>>>> {\n\n  (): NextEach<NextItem, NextReturn>;\n\n  [NextCall__symbol](callee: (this: void, ...args: NextCall.Callee.Args<NextItem>) => NextReturn):\n      Iterable<PassedThru.Item<NextCall.Callee.Return<NextReturn>>>;\n\n  [NextCall_lastOutcome__symbol](): Iterable<PassedThru.Item<NextCall.LastOutcome<NextItem>>>;\n\n}\n\n/**\n * Creates an next call that invokes subsequent passes for each item in the given iterable.\n *\n * If `items` are [[NextCall]] implementations, then the next pass will be processed by them.\n *\n * When returned from the last pass, the chain outcome will be an iterable of the last pass outcomes of the `items`.\n * Or an iterable of `items` if they are not implementing [[NextCall]].\n *\n * @param items  An iterable of items to invoke the passes for.\n */\nexport function nextEach<NextItem, NextReturn>(items: Iterable<NextItem>): NextEach<NextItem, NextReturn> {\n  return nextCall(\n      callee => ({\n        [Symbol.iterator]() {\n          return forEachItem(items, callee);\n        },\n      }),\n      () => ({\n        [Symbol.iterator]() {\n          return lastItems(items);\n        },\n      }));\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\nimport { PassedThru } from '../passed-thru';\n\nexport function *forEachItem<NextItem, NextReturn>(\n    items: Iterable<NextItem>,\n    callee: (this: void, ...args: NextCall.Callee.Args<NextItem>) => NextReturn) {\n  for (const item of items) {\n    yield* PassedThru.items(\n        NextCall.is(item)\n            ? item[NextCall__symbol](callee)\n            : (callee as (arg: NextItem) => NextReturn)(item));\n  }\n}\n\nexport function *lastItems<NextItem>(items: Iterable<NextItem>) {\n  for (const item of items) {\n    yield* PassedThru.items(\n        NextCall.is(item)\n            ? item[NextCall_lastOutcome__symbol]()\n            : item);\n  }\n}\n\nexport function *flatItems<I>(items: Iterable<unknown>, depth: number): IterableIterator<any> {\n  if (!depth) {\n    yield *items;\n    return;\n  }\n  for (const item of items) {\n    if (isIterable(item)) {\n      yield *flatItems(item, depth - 1);\n    } else {\n      yield item;\n    }\n  }\n}\n\nfunction isIterable<I>(value: any): value is Iterable<I> {\n\n  const type = typeof value;\n\n  return (type === 'object' || type === 'function') && Symbol.iterator in value;\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, nextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\nimport { PassedThru, PassedThru__symbol } from '../passed-thru';\n\ndeclare module '../call-outcome' {\n  export namespace CallOutcome {\n    export interface Map<Return, Out> {\n\n      /**\n       * Skipped call outcome type. Always `undefined`.\n       */\n      skip(): PassedThru<undefined, never>;\n\n    }\n  }\n}\n\nexport type SkippedThru = PassedThru<undefined, never>;\n\nexport interface NextSkip<NextArgs extends any[], NextReturn>\n    extends NextCall<'skip', NextArgs, NextReturn, SkippedThru> {\n\n  (): NextSkip<NextArgs, NextReturn>;\n\n  [NextCall__symbol](callee: (this: void, ...args: NextArgs) => NextReturn): SkippedThru;\n\n  [NextCall_lastOutcome__symbol](): SkippedThru;\n\n}\n\nconst SKIP: SkippedThru = {\n  [PassedThru__symbol]: undefined,\n  * [Symbol.iterator](): Iterator<never> {},\n};\n\nfunction _skip(): SkippedThru {\n  return SKIP;\n}\n\nconst _nextSkip: NextCall<'skip', any[], any, SkippedThru> = nextCall(_skip, _skip);\n\n/**\n * Constructs a next call that skips the rest of the chain.\n *\n * This has the same effect as `nextReturn(undefined)`.\n */\nexport function nextSkip<NextArgs extends any[], NextReturn>(): NextSkip<NextArgs, NextReturn> {\n  return _nextSkip as NextCall<'skip', NextArgs, NextReturn, SkippedThru>;\n}\n","/**\n * @module a-iterable\n */\n/**\n * A type of elements of iterable.\n *\n * @typeparam T  A type of iterable.\n */\nexport type IterableElement<T extends Iterable<any>> = T extends Iterable<infer E> ? E : never;\n\n/**\n * Arbitrary class implementing `Iterable` interface.\n *\n * @typeparam T  A type of iterable.\n * @typeparam E  A type of elements to iterate.\n */\nexport interface IterableClass<T extends Iterable<E>, E = IterableElement<T>> extends Function {\n  prototype: T;\n  new (...args: any[]): T;\n}\n\n/**\n * Checks whether the given value is array-like.\n *\n * @param target  A value to check.\n *\n * @returns `true` if the `value` has a `length` property, or `false` otherwise.\n */\nexport function isArrayLike<T>(target: any): target is ArrayLike<T> {\n  return 'length' in target;\n}\n","/**\n * @module a-iterable\n */\n/**\n * An iterable which elements order can be reversed.\n *\n * Arrays implement this interface.\n */\nexport interface RevertibleIterable<T> extends Iterable<T> {\n\n  /**\n   * Returns an iterable containing this iterable's elements in reverse order.\n   *\n   * Corresponds to `Array.prototype.reverse()`. Note however, that the array counterpart reverses elements _in place_\n   * rather than creating a new array.\n   *\n   * @return Reversed iterable instance.\n   */\n  reverse(): Iterable<T>;\n\n}\n\n/**\n * Checks whether the given iterable is revertible.\n *\n * This is always `true` for arrays.\n *\n * @param iterable  Iterable to check.\n *\n * @returns `true` if `iterable` has a `reverse` property, or `false` otherwise.\n */\nexport function itsRevertible<T>(iterable: Iterable<T>): iterable is RevertibleIterable<T> {\n  return 'reverse' in iterable;\n}\n","/**\n * @module a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  return function* () { yield* iterable; }();\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (!reverse) {\n    return iterable;\n  }\n\n  const reversible = iterable as RevertibleIterable<T>;\n\n  reversible.reverse = reverse;\n\n  return reversible;\n}\n","/**\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Constructs a reversed iterable.\n *\n * If the `source` iterable is an array-like structure, then uses `reverseArray()` function to revert the constructed\n * iterable.\n * If the `source` iterable is revertible, then uses its `reverse()` method to revert the constructed one.\n * Otherwise stores elements to array and reverts them with `reverseArray()` function.\n *\n * @param source  A source iterable.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseIt<T>(source: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): Iterable<T> {\n  if (isArrayLike(source)) {\n    return reverseArray(source);\n  }\n  if (itsRevertible(source)) {\n\n    const reversed = source.reverse();\n\n    return makeIt(() => itsIterator(reversed));\n  }\n  return reverseArray([...source]);\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): Iterable<T> {\n  return makeIt(\n      function* () {\n\n        const len = array.length;\n\n        for (let i = len - 1; i >= 0; --i) {\n          yield array[i];\n        }\n      });\n}\n","/**\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (element: T) => void) {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  return itsIterator(iterable).next().value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (prev: R, element: T) => R,\n    initialValue: R): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @module a-iterable\n */\nimport { callThru, NextCall, nextEach, PassedThru } from 'call-thru';\nimport Last = NextCall.LastResult;\nimport Out = NextCall.Outcome;\nimport Result = NextCall.CallResult;\n\n/**\n * Passes each element of the given iterable trough a chain of transformation passes.\n *\n * The passes are preformed by `callThru()` function.\n *\n * @returns Next iterable of transformed elements.\n */\nexport function thruIt<T, R1>(\n    it: Iterable<T>,\n    fn: (this: void, arg: T) => Last<R1>,\n): Iterable<PassedThru.Item<R1>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => Last<R2>,\n): Iterable<PassedThru.Item<Out<R1, R2>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => Last<R3>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, R3>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => Last<R4>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Last<R4>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => Last<R5>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, R5>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => Last<R6>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    R6>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => Last<R7>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, R7>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => Last<R8>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, R8>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => Last<R9>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, R9>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => Last<R10>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, R10>>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => Last<R11>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n        R11>>>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => Last<R12>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n        Out<R11, R12>>>>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12 extends Result<P13>,\n    P13 extends any[], R13>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => R12,\n    fn13: (this: void, ...args: P13) => Last<R13>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n        Out<R11, Out<R12, R13>>>>>>>>>>>>>>;\n\nexport function thruIt<T, R>(\n    it: Iterable<T>,\n    ...fns: ((...args: any[]) => any)[]): Iterable<PassedThru.Item<R>> {\n\n  const thru: () => Iterable<PassedThru.Item<R>> = (callThru as any)(\n      nextEach(it),\n      ...fns);\n\n  return thru();\n}\n","/**\n * @module a-iterable\n */\nimport { makeIt } from './util';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(source: Iterable<T>, test: (element: T) => boolean): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(source: Iterable<T>, test: (element: T) => element is R): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (element: T) => boolean): Iterable<T> {\n  return makeIt(function* () {\n    for (const element of source) {\n      if (test(element)) {\n        yield element;\n      }\n    }\n  });\n}\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (element: T) => Iterable<R>): Iterable<R> {\n  return makeIt(function* () {\n    for (const element of source) {\n      yield* convert(element);\n    }\n  });\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (element: T) => R): Iterable<R> {\n  return makeIt(function* () {\n    for (const element of source) {\n      yield convert(element);\n    }\n  });\n}\n","/**\n * @module a-iterable\n */\nimport { NextCall, PassedThru } from 'call-thru';\nimport { IterableClass, IterableElement } from './api';\nimport { ArrayLikeIterable } from './array-like-iterable';\nimport { reverseArray, reverseIt } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { itsEach, itsEvery, itsReduction } from './termination';\nimport { thruIt } from './thru';\nimport { filterIt, flatMapIt, mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\nimport Result = NextCall.CallResult;\nimport Last = NextCall.LastResult;\nimport Out = NextCall.Outcome;\n\nconst API_METHODS: (keyof ArrayLikeIterable<any>)[] = [\n  'every',\n  'filter',\n  'flatMap',\n  'forEach',\n  'map',\n  'reduce',\n  'reverse',\n];\n\n/**\n * Abstract `Iterable` implementation with array-like iteration operations.\n *\n * @typeparam T  A type of elements.\n */\nexport abstract class AIterable<T> implements ArrayLikeIterable<T> {\n\n  /**\n   * Returns an iterable without elements.\n   *\n   * @returns An empty iterable instance.\n   */\n  static none<T>(): AIterable<T> {\n    return NONE; // tslint:disable-line:no-use-before-declare\n  }\n\n  /**\n   * Checks whether the given iterable is an array-like one.\n   *\n   * @param source  An iterable to check.\n   *\n   * @returns `true` is the `source` has all `ArrayLikeIterable` methods (like `Array` or `AIterable` instance),\n   * or `false` otherwise.\n   */\n  static is<T>(source: Iterable<T>): source is ArrayLikeIterable<T> {\n    return API_METHODS.every(name => name in source);\n  }\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source array-like iterable.\n   *\n   * @return A `source` itself.\n   */\n  static of<T>(source: ArrayLikeIterable<T>): typeof source;\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Either `source` itself if it implements `ArrayLikeIterable` already (see `is()` method),\n   * or new [[AIterable]] instance iterating over the `source`.\n   */\n  static of<T>(source: Iterable<T>): AIterable<T>;\n\n  static of<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): ArrayLikeIterable<T> {\n    if (AIterable.is(source)) {\n      return source;\n    }\n    return AIterable.from(source);\n  }\n\n  /**\n   * Creates an `AIterable` instance that iterates over the same elements as the given one.\n   *\n   * Uses [[reverseIt]] function to reverse the constructed iterable.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Always new `AIterable` instance.\n   */\n  static from<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): AIterable<T> {\n    return make(() => source, () => reverseIt(source));\n  }\n\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.every()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n   * and return `false` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n   * Returns `true` for empty iterable.\n   */\n  every(test: (element: T) => boolean): boolean {\n    return itsEvery(this, test);\n  }\n\n  /**\n   * Creates an iterable with all elements that pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n   * It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter(test: (element: T) => boolean): AIterable<T>;\n\n  /**\n   * Creates an iterable with all elements extending the given type.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @typeparam R  Target type.\n   * @param test  A predicate function to test that element extends the type R. Returns `true` to keep the element, or\n   * `false` otherwise. It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter<R extends T>(test: (element: T) => element is R): AIterable<R>;\n\n  filter(test: (element: T) => boolean): AIterable<T> {\n    return make(\n        () => filterIt(this, test),\n        () => filterIt(this.reverse(), test));\n  }\n\n  /**\n   * First maps each element using a mapping function, then flattens the result into a new iterable.\n   *\n   * Corresponds to `Array.prototype.flatMap()`.\n   *\n   * Note that the overridden `flatMap` method of `ArrayLikeIterable` expects an array to be returned from `convert`\n   * callback, while in this method it may return arbitrary iterable.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n   *\n   * @returns A new [[AIterable]] with each element being the flattened result of the `convert` function call.\n   */\n  flatMap<R>(convert: (element: T) => Iterable<R>): AIterable<R> {\n    return make(\n        () => flatMapIt(this, convert),\n        () => flatMapIt(this.reverse(), element => reverseIt(convert(element))));\n  }\n\n  /**\n   * Performs the given `action` for each element.\n   *\n   * Corresponds to `Array.prototype.forEach()`.\n   *\n   * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n   * parameter.\n   */\n  forEach(action: (element: T) => void) {\n    itsEach(this, action);\n  }\n\n  /**\n   * Creates a new iterable with the results of calling a provided function on every element.\n   *\n   * Corresponds to `Array.prototype.map()`.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n   * parameter.\n   *\n   * @return A new [[AIterable]] with each element being the result of the `convert` function call.\n   */\n  map<R>(convert: (element: T) => R): AIterable<R> {\n    return make(\n        () => mapIt(this, convert),\n        () => mapIt(this.reverse(), convert));\n  }\n\n  /**\n   * Applies a function against an accumulator and each element to reduce elements to a single value.\n   *\n   * Corresponds to `Array.prototype.reduce()`.\n   *\n   * @typeparam R  A type of reduced value.\n   * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n   * @param initialValue  Initial value passed to the first `reducer` call.\n   *\n   * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in this\n   * iterable.\n   */\n  reduce<R>(reducer: (prev: R, element: T) => R, initialValue: R): R {\n    return itsReduction(this, reducer, initialValue);\n  }\n\n  /**\n   * Constructs an iterable containing this iterable's elements in reverse order.\n   *\n   * By default this method converts iterable to array and then reverts its elements with [[reverseArray]] function.\n   *\n   * @return Reversed [[AIterable]] instance.\n   */\n  reverse(): AIterable<T> {\n\n    const elements = this;\n\n    return make(() => reverseArray([...elements]), () => this);\n  }\n\n  /**\n   * Passes each element of this iterable trough a chain of transformation passes.\n   *\n   * The passes are preformed by `callThru()` function.\n   *\n   * @returns Next iterable of transformed elements.\n   */\n  thru<R1>(\n      fn: (this: void, arg: T) => Last<R1>,\n  ): AIterable<PassedThru.Item<R1>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => Last<R2>,\n  ): AIterable<PassedThru.Item<Out<R1, R2>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => Last<R3>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, R3>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => Last<R4>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Last<R4>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => Last<R5>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, R5>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => Last<R6>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      R6>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => Last<R7>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, R7>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => Last<R8>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, R8>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => Last<R9>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, R9>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => Last<R10>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, R10>>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => Last<R11>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n          R11>>>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => Last<R12>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n          Out<R11, R12>>>>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => Last<R13>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n          Out<R11, Out<R12, R13>>>>>>>>>>>>>>;\n\n  thru<R>(...fns: ((...args: any[]) => any)[]): AIterable<PassedThru.Item<R>> {\n\n    const thru = thruIt as any;\n\n    return make(() => thru(this, ...fns));\n  }\n\n}\n\nclass None extends AIterable<any> {\n\n  *[Symbol.iterator](): Iterator<any> {}\n\n  reverse() {\n    return this;\n  }\n\n}\n\nconst NONE = /*#__PURE__*/ new None();\n\nfunction make<T>(iterate: () => Iterable<T>, reverse?: () => Iterable<T>): AIterable<T> {\n\n  class Iterable extends AIterable<T> {\n\n    [Symbol.iterator]() {\n      return itsIterator(iterate());\n    }\n\n    reverse(): Iterable {\n      if (!reverse) {\n        return super.reverse();\n      }\n      return AIterable.from(makeIt(() => itsIterator(reverse()), () => this));\n    }\n\n  }\n\n  return new Iterable();\n}\n\n/**\n * Extends an iterable class with `AIterable` API.\n *\n * @typeparam C  A type of iterable class to extend.\n * @typeparam E  A type of elements to iterate.\n * @param iterableClass  A class to extend.\n *\n * @returns A new class extending original `iterableClass` and implementing the missing [[AIterable]] methods.\n */\nexport function toAIterable<C extends IterableClass<any, E>, E = IterableElement<InstanceType<C>>>(\n    iterableClass: C):\n    C & IterableClass<AIterable<E>, E> {\n\n  class ExtendedIterable extends iterableClass {\n  }\n\n  const extended = ExtendedIterable;\n  const proto = extended.prototype;\n\n  API_METHODS.forEach(name => {\n    if (!(name in proto)) {\n      Object.defineProperty(proto, name, {\n        configurable: true,\n        value: AIterable.prototype[name],\n      });\n    }\n  });\n\n  return extended as C & IterableClass<AIterable<E>, E>;\n}\n","/**\n * @module a-iterable\n */\nimport { reverseArray } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * Builds an iterable over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      function* () {\n        for (let i = 0; i < array.length; ++i) {\n          yield array[i];\n        }\n      },\n      () => reverseArray(array));\n}\n\nconst NONE: RevertibleIterable<any> = {\n\n  *[Symbol.iterator](): Iterator<any> {},\n\n  reverse() { return this; },\n\n};\n\n/**\n * Returns an iterable without elements.\n *\n * @typeparam T  A type of constructed iterable elements.\n *\n * @returns An empty iterable instance revertible to itself.\n */\nexport function overNone<T>(): RevertibleIterable<T> {\n  return NONE;\n}\n","/**\n * @module fun-events\n */\nimport { EventReceiver } from './event-receiver';\nimport { EventSupply } from './event-supply';\n\n/**\n * A key of event receiver registration method of [[EventKeeper]].\n *\n * @category Core\n */\nexport const AfterEvent__symbol = /*#__PURE__*/ Symbol('after-event');\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<E extends any[]> {\n\n  /**\n   * Registers a receiver of events kept and sent by this keeper.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  [AfterEvent__symbol](receiver: EventReceiver<E>): EventSupply;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeparam T  Target event keeper.\n   */\n  export type Event<T extends EventKeeper<any>> = T extends EventKeeper<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventKeeper]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains an `[AfterEvent__symbol]` property, or `false` otherwise.\n */\nexport function isEventKeeper<E extends any[]>(value: object): value is EventKeeper<E> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\n\n/**\n * A supply of events from {@link EventSupplier event supplier} to {@link EventReceiver event receiver}.\n *\n * When no longer needed the supply may be {@link off cut off}.\n *\n * May be constructed using [[eventSupply]] function.\n *\n * @category Core\n */\nexport abstract class EventSupply {\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means the events will no longer be supplied.\n   */\n  abstract readonly isOff: boolean;\n\n  /**\n   * Cuts off the supply of events.\n   *\n   * After this method call the receiver will no longer receive events.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason  An optional reason why supply is cut off. It will be reported to [[whenOff]] callbacks.\n   * @returns A cut off event supply instance.\n   */\n  abstract off(reason?: any): EventSupply;\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if [[isOff]] is `true`.\n   *\n   * @param callback  A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means normal completion.\n   *\n   * @returns `this` instance.\n   */\n  abstract whenOff(callback: (this: void, reason?: any) => void): this;\n\n  /**\n   * Declares this event supply depends on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one is will be cut off with the same reason.\n   *\n   * @param another  An event supply this one depends on.\n   *\n   * @return `this` instance.\n   */\n  needs(another: EventSupply): this {\n    another.whenOff(reason => this.off(reason));\n    return this;\n  }\n\n}\n\n/**\n * Constructs new {@link EventSupply event supply}.\n *\n * @category Core\n * @param off  A function to call when supply will supply is {@link EventSupply.off cut off}. Accepts optional\n * cut off reason as its only parameter. No-op by default.\n */\nexport function eventSupply(off: (this: void, reason?: any) => void = noop): EventSupply {\n\n  let whenOff: (callback: (reason?: any) => void) => void;\n  let cutOff: (reason?: any) => void = reason => {\n    whenOff = callback => callback(reason);\n    cutOff = noop;\n    off(reason);\n  };\n\n  whenOff = callback => {\n\n    const prev = cutOff;\n\n    cutOff = reason => {\n      prev(reason);\n      callback(reason);\n    };\n  };\n\n  class Supply extends EventSupply {\n\n    get isOff() {\n      return cutOff === noop;\n    }\n\n    off(reason?: any): EventSupply {\n      cutOff(reason);\n      return this;\n    }\n\n    whenOff(callback: (reason?: any) => void): this {\n      whenOff(callback);\n      return this;\n    }\n\n  }\n\n  return new Supply();\n}\n\nclass NoSupply extends EventSupply {\n\n  get isOff() {\n    return true;\n  }\n\n  off() {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n}\n\nconst noSupply =\n    /*#__PURE__*/ new NoSupply();\n\n/**\n * Returns a no-event supply.\n *\n * @category Core\n *\n * @returns An event supply that is already cut off without any particular reason.\n */\nexport function noEventSupply(): EventSupply {\n  return noSupply;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { eventSupply, EventSupply } from './event-supply';\n\n/**\n * Event receiver is called on each event sent by [[EventSender]] when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of [[EventReceiver.Object.receive]] method.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<E extends any[]> = EventReceiver.Function<E> | EventReceiver.Object<E>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<E extends any[]> =\n  /**\n   * @param event  An event represented by function call arguments.\n   */\n      (this: void, ...event: E) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<E extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link EventSupply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: EventSupply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context  An event processing context.\n     * @param event  An event represented as the rest of arguments.\n     */\n    receive(context: Context<E>, ...event: E): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by [[eventReceiver]] function.\n   *\n   * In contrast to [[Object]] this one always has a supply.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<E extends any[]> extends Object<E> {\n\n    readonly supply: EventSupply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to [[Object]] receivers.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<E extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver  Recurrent events receiver function.\n     */\n    onRecurrent(receiver: Function<E>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n * @param receiver  An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<E extends any[]>(receiver: EventReceiver<E>): EventReceiver.Generic<E> {\n\n  let generic: {\n    readonly supply: EventSupply;\n    receive: (context: EventReceiver.Context<E>, ...event: E) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: eventSupply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || eventSupply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","/**\n * @module fun-events\n */\nimport { EventReceiver } from './event-receiver';\nimport { EventSupply } from './event-supply';\n\n/**\n * A key of event receiver registration method of [[EventSender]].\n *\n * @category Core\n */\nexport const OnEvent__symbol = /*#__PURE__*/ Symbol('on-event');\n\n/**\n * A sender of events.\n *\n * It is able to register event receivers.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<E extends any[]> {\n\n  /**\n   * Registers a receiver of events sent by this sender.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  [OnEvent__symbol](receiver: EventReceiver<E>): EventSupply;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeparam T  Target event sender.\n   */\n  export type Event<T extends EventSender<any>> = T extends EventSender<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventSender]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains `[OnEvent__symbol]` property, or `false` otherwise.\n */\nexport function isEventSender<E extends any[]>(value: object): value is EventSender<E> {\n  return OnEvent__symbol in value;\n}\n","import { EventReceiver } from '../event-receiver';\n\n/**\n * @internal\n */\nexport function once<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<E>) => void,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => register({\n    supply: receiver.supply,\n    receive: (context, ...event) => {\n      receiver.receive(context, ...event);\n      receiver.supply.off();\n    },\n  });\n}\n","/**\n * @module fun-events\n */\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { EventSupply } from './event-supply';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an [[OnEvent]] interface though. Use an [[EventEmitter]] if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link EventSupply.off cut off}.\n *\n * Can be used as [[EventSender]].\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<E extends any[]> implements EventSender<E> {\n\n  /**\n   * @internal\n   */\n  private readonly _rcvs = new Set<EventReceiver.Generic<E>>();\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event  An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: E) => void = receiveEventsByEach(this._rcvs);\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcvs.size;\n  }\n\n  [OnEvent__symbol](receiver: EventReceiver<E>): EventSupply {\n    return this.on(receiver);\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<E>): EventSupply {\n\n    const generic = eventReceiver(receiver);\n\n    this._rcvs.add(generic);\n\n    return generic.supply.whenOff(() => this._rcvs.delete(generic));\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive any events.\n   *\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this._rcvs.forEach(({ supply }) => supply.off(reason));\n    return this;\n  }\n\n}\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @category Core\n * @param receivers  An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nfunction receiveEventsByEach<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n): (this: void, ...event: E) => void  {\n\n  let send: (this: void, event: E) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: E) {\n\n    let actualReceivers = receivers;\n    const received: E[] = [];\n\n    send = sendRecurrent;\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n\n    function sendRecurrent(recurrent: E) {\n      received.push(recurrent);\n    }\n  }\n}\n\nfunction processEvent<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n    event: E,\n): EventReceiver.Generic<E>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<E>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<E> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","import { EventNotifier } from '../event-notifier';\nimport { EventReceiver } from '../event-receiver';\nimport { eventSupply, EventSupply } from '../event-supply';\n\n/**\n * @internal\n */\nexport function share<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<E>) => EventSupply,\n): (receiver: EventReceiver.Generic<E>) => void {\n\n  const shared = new EventNotifier<E>();\n  let sharedSupply: EventSupply;\n  let initialEvents: E[] | undefined;\n\n  return receiver => {\n    if (!shared.size) {\n      initialEvents = [];\n      sharedSupply = eventSupply(() => initialEvents = undefined);\n\n      register({\n        supply: sharedSupply,\n        receive(_ctx, ...event) {\n          if (initialEvents) {\n            if (shared.size) {\n              // More events received\n              // Stop sending initial ones\n              initialEvents = undefined;\n            } else {\n              // Record events received during first receiver registration\n              // to send them to all receivers until more event received\n              initialEvents.push(event);\n            }\n          }\n          shared.send(...event);\n        },\n      });\n    }\n\n    receiver.supply.needs(sharedSupply);\n    shared.on(receiver).whenOff((reason?: any) => {\n      if (!shared.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatcher = new EventNotifier<E>();\n\n      dispatcher.on(receiver);\n      initialEvents.forEach(event => dispatcher.send(...event));\n    }\n  };\n}\n","import { EventReceiver } from '../event-receiver';\nimport { EventSupply } from '../event-supply';\n\n/**\n * @internal\n */\nexport function tillOff<E extends any[]>(\n    register: (receiver: EventReceiver.Generic<E>) => void,\n    supply: EventSupply,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => {\n    receiver.supply.needs(supply);\n    register(receiver);\n  };\n}\n","/**\n * @module fun-events\n */\nimport { callThru, NextCall } from 'call-thru';\nimport { AfterEvent__symbol } from './event-keeper';\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, isEventSender, OnEvent__symbol } from './event-sender';\nimport { EventSupplier } from './event-supplier';\nimport { eventSupply, EventSupply, noEventSupply } from './event-supply';\nimport { once, share, tillOff } from './impl';\nimport Result = NextCall.CallResult;\n\n/**\n * An event receiver registration function interface.\n *\n * A registered event receiver would receive upcoming events, until the returned event supply will be\n * {@link EventSupply.off cut off}.\n *\n * An [[OnEvent]] function also has a set of handy methods. More could be added later. It also can be used as\n * [[EventSender]].\n *\n * To convert a plain event receiver registration function to [[OnEvent]] an [[onEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport abstract class OnEvent<E extends any[]> extends Function implements EventSender<E> {\n\n  get [OnEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * An [[OnEvent]] sender derived from this one that stops sending events to registered receiver after the first one.\n   */\n  get once(): OnEvent<E> {\n    return onEventBy(once(this));\n  }\n\n  /**\n   * Builds an [[OnEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * @param supply  The required event supply.\n   *\n   * @returns New event sender.\n   */\n  tillOff(supply: EventSupply): OnEvent<E> {\n    return onEventBy(tillOff(this, supply));\n  }\n\n  /**\n   * Extracts event suppliers from incoming events.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event supplier from incoming event. May return `undefined` when nothing\n   * extracted.\n   *\n   * @returns An [[OnEvent]] sender of events from extracted suppliers. The events supply is cut off once the incoming\n   * events supply do. The returned sender shares the supply of extracted events among receivers.\n   */\n  dig<F extends any[]>(\n      extract: (this: void, ...event: E) => EventSupplier<F> | void | undefined,\n  ): OnEvent<F> {\n    return onEventBy(share(this.dig_(extract)));\n  }\n\n  /**\n   * Extracts event suppliers from incoming events without sharing extracted events supply.\n   *\n   * This method does the same as [[OnEvent.dig]] one, except it does not share the supply of extracted events among\n   * receivers. This may be useful e.g. when the result will be further transformed. It is wise to {@link share share}\n   * the supply of events from final result in this case.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event supplier from incoming event. May return `undefined` when\n   * nothing extracted.\n   *\n   * @returns An [[OnEvent]] sender of events from extracted suppliers. The events supply is cut off once the incoming\n   * events supply do.\n   */\n  dig_<F extends any[]>(\n      extract: (this: void, ...event: E) => EventSupplier<F> | void | undefined,\n  ): OnEvent<F> {\n    return onEventBy((receiver: EventReceiver.Generic<F>) => {\n\n      let nestedSupply = noEventSupply();\n\n      this({\n        supply: receiver.supply,\n        receive(_context, ...event: E)  {\n\n          const prevSupply = nestedSupply;\n          const extracted = extract(...event);\n\n          try {\n            nestedSupply = extracted\n                ? onSupplied(extracted)({\n                  supply: eventSupply().needs(receiver.supply),\n                  receive(context, ...nestedEvent) {\n                    receiver.receive(context, ...nestedEvent);\n                  },\n                })\n                : noEventSupply();\n          } finally {\n            prevSupply.off();\n          }\n        },\n      });\n    });\n  }\n\n  /**\n   * Consumes events.\n   *\n   * @param consume  A function consuming events. This function may return an {@link EventSupply event supply} instance\n   * when registers a nested event receiver. This supply will be cut of on new event.\n   *\n   * @returns An event supply that will stop consuming events once {@link EventSupply.off cut off}.\n   */\n  consume(consume: (...event: E) => EventSupply | void | undefined): EventSupply {\n\n    let consumerSupply = noEventSupply();\n    const senderSupply = this((...event: E) => {\n\n      const prevSupply = consumerSupply;\n\n      try {\n        consumerSupply = consume(...event) || noEventSupply();\n      } finally {\n        prevSupply.off();\n      }\n    });\n\n    return eventSupply(reason => {\n      consumerSupply.off(reason);\n      senderSupply.off(reason);\n    }).needs(senderSupply);\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender that shares events supply among all registered receivers.\n   *\n   * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * supplies do.\n   *\n   * @returns An [[OnEvent]] sender sharing a common supply of events originated from this sender.\n   */\n  share(): OnEvent<E> {\n    return onEventBy(share(this));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `callThru()` function. The event receivers registered by resulting event sender\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes. The returned sender shares the supply\n   * of transformed events among receivers.\n   */\n  thru<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, void, void, void>,\n  ): OnEvent<R1>;\n\n  thru<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): OnEvent<[R1]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, void, void, void>,\n  ): OnEvent<R2>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): OnEvent<[R2]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): OnEvent<R3>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): OnEvent<[RE]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): OnEvent<[R4]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, void, void, void>,\n  ): OnEvent<R5>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): OnEvent<[R5]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, void, void, void>,\n  ): OnEvent<R6>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): OnEvent<[R6]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, void, void, void>,\n  ): OnEvent<R7>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): OnEvent<[R7]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, void, void, void>,\n  ): OnEvent<R8>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): OnEvent<[R8]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, void, void, void>,\n  ): OnEvent<R9>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): OnEvent<[R9]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, void, void, void>,\n  ): OnEvent<R10>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): OnEvent<[R10]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, void, void, void>,\n  ): OnEvent<R11>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): OnEvent<[R11]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, void, void, void>,\n  ): OnEvent<R12>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): OnEvent<[R12]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, void, void, void>,\n  ): OnEvent<R13>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): OnEvent<[R13]>;\n\n  thru(...fns: any[]): OnEvent<any[]> {\n    return onEventBy(share((this as any).thru_(...fns)));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[OnEvent.thru]] one, except it does not share the supply of transformed events\n   * among receivers. This may be useful e.g. when the result will be further transformed anyway. It is wise to\n   * {@link share share} the supply of events from final result in this case.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes.\n   */\n  thru_<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, void, void, void>,\n  ): OnEvent<R1>;\n\n  thru_<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): OnEvent<[R1]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, void, void, void>,\n  ): OnEvent<R2>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): OnEvent<[R2]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): OnEvent<R3>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): OnEvent<[RE]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): OnEvent<[R4]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, void, void, void>,\n  ): OnEvent<R5>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): OnEvent<[R5]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, void, void, void>,\n  ): OnEvent<R6>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): OnEvent<[R6]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, void, void, void>,\n  ): OnEvent<R7>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): OnEvent<[R7]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, void, void, void>,\n  ): OnEvent<R8>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): OnEvent<[R8]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, void, void, void>,\n  ): OnEvent<R9>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): OnEvent<[R9]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, void, void, void>,\n  ): OnEvent<R10>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): OnEvent<[R10]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, void, void, void>,\n  ): OnEvent<R11>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): OnEvent<[R11]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, void, void, void>,\n  ): OnEvent<R12>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): OnEvent<[R12]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, void, void, void>,\n  ): OnEvent<R13>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): OnEvent<[R13]>;\n\n  thru_(...fns: any[]): OnEvent<any[]> {\n\n    const thru = callThru as any;\n\n    return onEventBy(receiver =>\n        this({\n          supply: receiver.supply,\n          receive(context, ...event) {\n            thru(\n                ...fns,\n                (...transformed: any[]) => receiver.receive(context, ...transformed),\n            )(...event);\n          },\n        }));\n  }\n\n}\n\nexport interface OnEvent<E extends any[]> {\n\n  /**\n   * Registers a receiver of events sent by this sender.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  (this: void, receiver: EventReceiver<E>): EventSupply; // tslint:disable-line:callable-types\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[OnEvent]] sender.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An [[OnEvent]] sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n): OnEvent<E> {\n\n  const onEvent = ((receiver: EventReceiver<E>) => {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      register(generic);\n    }\n\n    return supply;\n  }) as OnEvent<E>;\n\n  Object.setPrototypeOf(onEvent, OnEvent.prototype);\n\n  return onEvent;\n}\n\n/**\n * Builds an [[OnEvent]] sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n *\n * @returns An [[OnEvent]] sender of events originated from the given `supplier`.\n */\nexport function onSupplied<E extends any[]>(supplier: EventSupplier<E>): OnEvent<E> {\n\n  const onEvent = isEventSender(supplier) ? supplier[OnEvent__symbol] : supplier[AfterEvent__symbol];\n\n  if (onEvent instanceof OnEvent) {\n    return onEvent;\n  }\n\n  return onEventBy(onEvent.bind(supplier));\n}\n\n/**\n * An [[OnEvent]] sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> =\n    /*#__PURE__*/ onEventBy(({ supply }) => supply.off());\n","/**\n * @module fun-events\n */\nimport { NextCall, noop, valueProvider } from 'call-thru';\nimport { AfterEvent__symbol, EventKeeper, isEventKeeper } from './event-keeper';\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { EventSupplier } from './event-supplier';\nimport { EventSupply, eventSupply } from './event-supply';\nimport { once, share, tillOff } from './impl';\nimport { OnEvent } from './on-event';\nimport Result = NextCall.CallResult;\n\n/**\n * A subset of [[AfterEvent]] transformation methods inherited that return [[AfterEvent]] keepers instead of\n * [[OnEvent]] senders.\n *\n * This can not be done automatically, as not every transformation results to [[EventKeeper]]. E.g. when some events\n * are filtered out.\n *\n * An instance of this class can be obtained from [[AfterEvent.keep]] property.\n *\n * @category Core\n */\nexport class AfterEventKeep<E extends any[]> {\n\n  /**\n   * @internal\n   */\n  private readonly _keeper: AfterEvent<E>;\n\n  constructor(keeper: AfterEvent<E>) {\n    this._keeper = keeper;\n  }\n\n  /**\n   * Extracts event keepers from incoming events.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event keeper from incoming event.\n   *\n   * @returns An [[AfterEvent]] keeper of extracted events. The events supply is cut off once the incoming events supply\n   * do. The returned keeper shares the supply of extracted events among receivers.\n   */\n  dig<F extends any[]>(extract: (this: void, ...event: E) => EventKeeper<F>): AfterEvent<F> {\n    return this.dig_(extract).share();\n  }\n\n  /**\n   * Extracts event keepers from incoming events without sharing extracted events supply.\n   *\n   * This method does the same as [[AfterEventKeep.dig]] one, except it does not share the supply of extracted events\n   * among receivers. This may be useful e.g. when the result will be further transformed. It is wise to\n   * {@link AfterEvent.share share} the supply of events from the final result in this case.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event keeper from incoming event.\n   *\n   * @returns An [[AfterEvent]] keeper of extracted events. The events supply is cut off once the incoming events\n   * supply do.\n   */\n  dig_<F extends any[]>(extract: (this: void, ...event: E) => EventKeeper<F>): AfterEvent<F> {\n    return afterSupplied(this._keeper.dig_((...event) => afterSupplied(extract(...event))));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `callThru()` function. The event receivers registered by resulting event keeper\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes. The returned keeper shares the supply\n   * of transformed events among receivers.\n   */\n  thru<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, void, void, void>,\n  ): AfterEvent<R1>;\n\n  thru<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): AfterEvent<[R1]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, void, void, void>,\n  ): AfterEvent<R2>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): AfterEvent<[R2]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): AfterEvent<R3>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): AfterEvent<[RE]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): AfterEvent<[R4]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, void, void, void>,\n  ): AfterEvent<R5>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): AfterEvent<[R5]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, void, void, void>,\n  ): AfterEvent<R6>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): AfterEvent<[R6]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, void, void, void>,\n  ): AfterEvent<R7>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): AfterEvent<[R7]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, void, void, void>,\n  ): AfterEvent<R8>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): AfterEvent<[R8]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, void, void, void>,\n  ): AfterEvent<R9>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): AfterEvent<[R9]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, void, void, void>,\n  ): AfterEvent<R10>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): AfterEvent<[R10]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, void, void, void>,\n  ): AfterEvent<R11>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): AfterEvent<[R11]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, void, void, void>,\n  ): AfterEvent<R12>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): AfterEvent<[R12]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, void, void, void>,\n  ): AfterEvent<R13>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): AfterEvent<[R13]>;\n\n  thru(...fns: any[]): AfterEvent<any[]> {\n    return (this as any).thru_(...fns).share();\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[AfterEventKeep.thru]] one, except it does not share the supply of transformed\n   * events among receivers. This may be useful e.g. when the result will be further transformed anyway.\n   * It is wise to {@link AfterEvent.share share} the supply of events from final result in this case.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes.\n   */\n  thru_<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, void, void, void>,\n  ): AfterEvent<R1>;\n\n  thru_<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): AfterEvent<[R1]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, void, void, void>,\n  ): AfterEvent<R2>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): AfterEvent<[R2]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): AfterEvent<R3>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): AfterEvent<[RE]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): AfterEvent<[R4]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, void, void, void>,\n  ): AfterEvent<R5>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): AfterEvent<[R5]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, void, void, void>,\n  ): AfterEvent<R6>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): AfterEvent<[R6]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, void, void, void>,\n  ): AfterEvent<R7>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): AfterEvent<[R7]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, void, void, void>,\n  ): AfterEvent<R8>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): AfterEvent<[R8]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, void, void, void>,\n  ): AfterEvent<R9>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): AfterEvent<[R9]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, void, void, void>,\n  ): AfterEvent<R10>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): AfterEvent<[R10]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, void, void, void>,\n  ): AfterEvent<R11>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): AfterEvent<[R11]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, void, void, void>,\n  ): AfterEvent<R12>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): AfterEvent<[R12]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, void, void, void>,\n  ): AfterEvent<R13>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): AfterEvent<[R13]>;\n\n  thru_(...fns: any[]): AfterEvent<any[]> {\n    return afterSupplied((this._keeper as any).thru_(...fns));\n  }\n\n}\n\n/**\n * A kept and upcoming events receiver registration function interface.\n *\n * A registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * To convert a plain event receiver registration function to [[AfterEvent]] an [[afterEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport abstract class AfterEvent<E extends any[]> extends OnEvent<E> implements EventKeeper<E> {\n\n  get [AfterEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * A subset of [[AfterEvent]] transformation methods that return [[AfterEvent]] keepers instead of [[OnEvent]]\n   * senders.\n   *\n   * Note that not every transformation can properly result to [[EventKeeper]]. E.g. some events may be filtered out and\n   * the resulting [[AfterEvent]] would rise an exception on receiver registration, as it won't have any events to send.\n   */\n  get keep(): AfterEventKeep<E> {\n    return new AfterEventKeep(this);\n  }\n\n  /**\n   * An [[AfterEvent]] keeper derived from this one that sends currently the kept event to registered receiver\n   * and stops sending them after that.\n   */\n  get once(): AfterEvent<E> {\n    return afterEventBy(once(this));\n  }\n\n  /**\n   * Builds an [[AfterEvent]] keeper that sends events from this one until the required `supply` is cut off.\n   *\n   * @param supply  The required event supply.\n   *\n   * @returns New event keeper.\n   */\n  tillOff(supply: EventSupply): AfterEvent<E> {\n    return afterEventBy(tillOff(this, supply));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper that shares events supply among all registered receivers.\n   *\n   * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * event supplies do.\n   *\n   * @returns An [[AfterEvent]] keeper sharing a common supply of events originating from this keeper.\n   */\n  share(): AfterEvent<E> {\n    return afterEventBy(share(this));\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[AfterEvent]] keeper with a fallback.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n    fallback: (this: void) => E = noEvent,\n): AfterEvent<E> {\n\n  let lastEvent: E | undefined;\n  let numReceivers = 0;\n\n  const afterEvent = ((receiver: EventReceiver<E>) => {\n\n    let dest: (context: EventReceiver.Context<E>, ...event: E) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = eventSupply().needs(generic.supply);\n    let reported = false;\n\n    register({\n      supply,\n      receive(context, ...event: E) {\n        reported = true;\n        lastEvent = event;\n        dest(context, ...event);\n      },\n    });\n    ++numReceivers;\n\n    if (!supply.isOff || reported) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(lastEvent || (lastEvent = fallback())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(reason => {\n      if (!--numReceivers) {\n        lastEvent = undefined;\n      }\n      generic.supply.off(reason);\n    });\n\n    return supply;\n  }) as AfterEvent<E>;\n\n  Object.setPrototypeOf(afterEvent, AfterEvent.prototype);\n\n  return afterEvent;\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param keeper  A keeper of events.\n *\n * @returns An [[AfterEvent]] keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<E extends any[]>(keeper: EventKeeper<E>): AfterEvent<E>;\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * This is a synonym of [[afterSent]], unless `sender` is an [[EventKeeper]].\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSupplied<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E>;\n\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  if (!isEventKeeper(supplier)) {\n    return afterSent(supplier, fallback);\n  }\n\n  const afterEvent = supplier[AfterEvent__symbol];\n\n  if (afterEvent instanceof AfterEvent) {\n    return afterEvent;\n  }\n\n  return afterEventBy(afterEvent.bind(supplier));\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return afterEventBy(receiver => sender[OnEvent__symbol](receiver), fallback);\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of the given `event`.\n *\n * @category Core\n * @param event  An event that will be sent to all receivers upon registration.\n *\n * @returns An [[AfterEvent]] keeper that always sends the given `event`.\n */\nexport function afterThe<E extends any[]>(...event: E): AfterEvent<E> {\n  return afterEventBy(() => eventSupply(), valueProvider(event));\n}\n\n/**\n * An [[AfterEvent]] keeper that never sends any events.\n *\n * @category Core\n */\nexport const afterNever: AfterEvent<any> =\n    /*#__PURE__*/ afterEventBy(({ supply }) => supply.off());\n\nfunction noEvent(): never {\n  throw new Error('No events to send');\n}\n","/**\n * @module fun-events\n */\nimport { eventReceiver, EventReceiver } from '../event-receiver';\nimport { EventSupply } from '../event-supply';\nimport { once, tillOff } from '../impl';\nimport { OnEvent } from '../on-event';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport type DomEventListener<E extends Event> = EventReceiver<[E]>;\n\n/**\n * A DOM event listener registrar signature.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport abstract class OnDomEvent<E extends Event> extends OnEvent<[E]> {\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that stops sending events to registered listener after the first\n   * one.\n   */\n  get once(): OnDomEvent<E> {\n    return onDomEventBy(once(this));\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * @param supply  The required event supply.\n   *\n   * @returns New DOM event sender.\n   */\n  tillOff(supply: EventSupply): OnDomEvent<E> {\n    return onDomEventBy(tillOff(this, supply));\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that enables event capturing by default.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   */\n  get capture(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this(listener, true);\n      }\n      if (typeof opts === 'object' && opts.capture == null) {\n        return this(listener, { ...opts, capture: true });\n      }\n      return this(listener, opts);\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers listeners to invoke instead of the default action.\n   *\n   * It invokes an `Event.preventDefault()` method prior to calling the registered listeners.\n   */\n  get instead(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.preventDefault();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers listeners preventing further propagation of\n   * current event in the capturing and bubbling phases.\n   *\n   * It invokes an `Event.stopPropagation()` method prior to calling the registered listeners.\n   */\n  get just(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopPropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers the last event listener.\n   *\n   * It invokes an `Event.stopImmediatePropagation()` method prior to calling the registered listeners.\n   */\n  get last(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopImmediatePropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that accepts listeners never calling `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   */\n  get passive(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this(listener, { passive: true });\n      }\n      if (typeof opts === 'boolean') {\n        return this(listener, { capture: opts, passive: true });\n      }\n      if (opts.passive == null) {\n        return this(listener, { ...opts, passive: true });\n      }\n      return this(listener, opts);\n    });\n  }\n\n}\n\nexport interface OnDomEvent<E extends Event> {\n\n  /**\n   * Registers a DOM event listener.\n   *\n   * @param listener  A DOM event listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @return A DOM events supply.\n   */\n  // tslint:disable-next-line:callable-types\n  (this: void, listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n}\n\n/**\n * Converts a plain DOM event listener registration function to [[OnDomEvent]] sender.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n * @param register  A generic DOM event listener registration function.\n *\n * @returns An [[OnDomEvent]] sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<E extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[E]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<E> {\n\n  const onDomEvent = (\n      (\n          listener: DomEventListener<E>,\n          opts?: AddEventListenerOptions | boolean,\n      ) => {\n\n        const receiver = eventReceiver(listener);\n\n        register(receiver, opts);\n\n        return receiver.supply;\n      }\n  ) as OnDomEvent<E>;\n\n  Object.setPrototypeOf(onDomEvent, OnDomEvent.prototype);\n\n  return onDomEvent;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { EventReceiver } from '../event-receiver';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\nconst domEventContext: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners and dispatch events.\n *\n * @category DOM\n */\nexport class DomEventDispatcher {\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target  Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link EventSupply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link EventSupply.off cut off}.\n   *\n   * @typeparam E  Supported DOM event type.\n   * @param type  DOM event type name.\n   *\n   * @returns [[OnDomEvent]] sender of DOM events of the given `type`.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return onDomEventBy<E>((listener, opts) => {\n\n      // Create unique DOM listener instance\n      const domListener: EventListener = event => listener.receive(domEventContext, event as E);\n\n      this._target.addEventListener(type, domListener, opts);\n      listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean {\n    return this._target.dispatchEvent(event);\n  }\n\n}\n","/**\n * @module fun-events\n */\nimport { EventNotifier } from './event-notifier';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { OnEvent, onEventBy } from './on-event';\n\n/**\n * Event emitter is a handy implementation of [[OnEvent]] sender.\n *\n * Extends [[EventNotifier]] by making its [[EventNotifier.on]] method implement an [[OnEvent]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<E extends any[]> extends EventNotifier<E> implements EventSender<E> {\n\n  /**\n   * An [[OnEvent]] sender.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  readonly on = onEventBy<E>(receiver => super.on(receiver));\n\n  readonly [OnEvent__symbol]: OnEvent<E> = this.on;\n\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterNever, afterSupplied } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper } from '../event-keeper';\nimport { EventNotifier } from '../event-notifier';\nimport { EventReceiver } from '../event-receiver';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeparam S  A type of `sources` map.\n * @param sources  A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each event keeper. Each event in this map has the\n * same name as its originating event keeper in `sources`.\n */\nexport function afterAll<S extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: S,\n): AfterEvent<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  if (!keys.length) {\n    return afterNever;\n  }\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>,\n  ): void {\n\n    const notifier = new EventNotifier<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>();\n    const supply = notifier.on(receiver);\n    let send: () => void = noop;\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(readFrom);\n\n    if (!supply.isOff) {\n      send = () => notifier.send(result);\n    }\n\n    function readFrom(key: keyof S) {\n      supply.needs(sources[key][AfterEvent__symbol]((...event) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    }\n  }\n\n  function latestEvent(): [{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }] {\n\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(key =>\n        afterSupplied(sources[key])\n            .once((...event) => result[key as keyof S] = event));\n\n    return [result];\n  }\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterNever, afterSupplied } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper } from '../event-keeper';\nimport { EventNotifier } from '../event-notifier';\nimport { EventReceiver } from '../event-receiver';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeparam E  A type of events sent by each source.\n * @param sources  An array of source event keepers.\n *\n * @returns An event keeper sending events received from each event keeper. Each event item is an event tuple originated\n * from event keeper under the same index in `sources` array.\n */\nexport function afterEach<E extends any[]>(...sources: EventKeeper<E>[]): AfterEvent<E[]> {\n  if (!sources.length) {\n    return afterNever;\n  }\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(receiver: EventReceiver.Generic<E[]>): void {\n\n    const notifier = new EventNotifier<E[]>();\n    const supply = notifier.on(receiver);\n    let send: () => void = noop;\n    const result: E[] = [];\n\n    sources.forEach(readFrom);\n\n    if (!supply.isOff) {\n      send = () => notifier.send(...result);\n    }\n\n    function readFrom(source: EventKeeper<E>, index: number) {\n      supply.needs(source[AfterEvent__symbol]((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    }\n  }\n\n  function latestEvent() {\n\n    const result: E[] = [];\n\n    sources.forEach(source =>\n        afterSupplied(source)\n            .once((...event) => result.push(event)));\n\n    return result;\n  }\n}\n","/**\n * @module fun-events\n */\nimport { EventReceiver } from '../event-receiver';\nimport { EventSupplier } from '../event-supplier';\nimport { eventSupply } from '../event-supply';\nimport { OnEvent, onEventBy, onNever, onSupplied } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param suppliers  Original event suppliers.\n *\n * @returns An [[OnEvent]] sender of all supplied events.\n */\nexport function onAny<E extends any[]>(...suppliers: EventSupplier<E>[]): OnEvent<E> {\n  if (!suppliers.length) {\n    return onNever;\n  }\n\n  return onEventBy<E>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any) => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<E>, ...event: E) => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier)({\n          supply: eventSupply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  }).share();\n}\n","/**\n * @module fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @param key  A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<K extends PropertyKey>(key: K): [K];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path  Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return Array.isArray(path) ? path : [path];\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { EventEmitter } from '../event-emitter';\nimport { EventSender, OnEvent__symbol } from '../event-sender';\nimport { eventSupply, EventSupply } from '../event-supply';\nimport { onEventBy } from '../on-event';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n      path = statePath(path);\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): EventSupply {\n\n    const entry = this;\n    const supply = this.emitter.on(receiver);\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      entry._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: any) {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.done(reason);\n  }\n\n  private _remove(key: PropertyKey) {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty() {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): EventSupply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<V>(path: StatePath.Normalized, newValue: V, oldValue: V) {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: any) {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void = (<V>(path: StatePath, newValue: V, oldValue: V) => {\n    this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n  });\n\n  readonly onUpdate: OnStateUpdate =\n      onEventBy<[StatePath, any, any]>(receiver => this._trackers.on(this._path, receiver));\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  get _tracker() {\n    return this;\n  }\n\n  get [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: any) {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under [[StatePath]].\n *\n * When node modified a [[StateTracker.update]] should be called. Then all state update receivers registered by\n * [[StateTracker.onUpdate]] will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * A {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   */\n  get onUpdate(): OnStateUpdate {\n    return this._tracker.onUpdate;\n  }\n\n  get [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with [[onUpdate]] will receive this update.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  get update(): <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path  A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason  An optional reason to stop tracking.\n   */\n  done(reason?: any) {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @module fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, isEventKeeper } from '../event-keeper';\nimport { EventReceiver } from '../event-receiver';\nimport { EventSender, OnEvent__symbol } from '../event-sender';\nimport { EventSupplier } from '../event-supplier';\nimport { EventSupply, noEventSupply } from '../event-supply';\nimport { OnEvent, onSupplied } from '../on-event';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an [[EventSender]] interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an [[EventKeeper]] interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeparam T  Tracked value type.\n * @typeparam N  New (updated) value type.\n */\nexport abstract class ValueTracker<T = any, N extends T = T> implements EventSender<[N, T]>, EventKeeper<[T]> {\n\n  /**\n   * @internal\n   */\n  private _by = noEventSupply();\n\n  /**\n   * An [[OnEvent]] sender of value changes. The new value is sent as first argument, and the old value as a second one.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[N, T]>;\n\n  /**\n   * An [[AfterEvent]] keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  readonly read: AfterEvent<[T]> = afterEventBy<[T]>(\n      receiver => this.on(receiveNewValue(receiver)),\n      () => [this.it],\n  );\n\n  get [OnEvent__symbol](): OnEvent<[N, T]> {\n    return this.on;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier  The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeparam S  Source value type.\n   * @param supplier  The event supplier to extract value suppliers from.\n   * @param extract  A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<S extends any[]>(\n      supplier: EventSupplier<S>,\n      extract: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<S extends any[]>(\n      supplier: EventSupplier<S> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const self = this;\n\n    this.byNone();\n\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<S>;\n\n      this._by = onSupplied(container).consume((...event: S) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      });\n    }\n    this._by.whenOff(() => this._by = noEventSupply());\n\n    return this;\n\n    function acceptValuesFrom(sender: EventSupplier<[T]>): EventSupply {\n\n      const registrar = isEventKeeper(sender) ? sender[AfterEvent__symbol] : sender[OnEvent__symbol];\n\n      return registrar(value => self.it = value);\n    }\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason  Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive events.\n\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nfunction receiveNewValue<T, N extends T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[N, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","/**\n * @module fun-events\n */\nimport { EventEmitter } from '../event-emitter';\nimport { EventKeeper } from '../event-keeper';\nimport { ValueTracker } from './value-tracker';\n\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get on() {\n    return this._on.on;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n  done(reason?: any): this {\n    this._on.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier  The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeparam S  Source value type.\n * @param supplier  The event keeper to extract value keepers from.\n * @param extract  A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S>,\n    extract: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as any).by(supplier, extract);\n}\n","/**\n * @module context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @typeparam Ctx  Context type.\n   * @param opts  Context value growth options.\n   *\n   * @returns Single context value, or `undefined` if there is no default value.\n   */\n  abstract grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Value, Src, Seed>): Value | null | undefined;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value growth options.\n *\n * An instance of these options is passed to [[ContextKey.grow]] method to provide the necessary value growth context.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport interface ContextValueOpts<Ctx extends ContextValues, Value, Src, Seed> {\n\n  /**\n   * Target context.\n   */\n  readonly context: Ctx;\n\n  /**\n   * Context value seeder.\n   */\n  readonly seeder: ContextSeeder<Ctx, Src, Seed>;\n\n  /**\n   * Context value seed.\n   */\n  readonly seed: Seed;\n\n  /**\n   * A fallback value to use if there is no value associated with the given key.\n   *\n   * Can be `null` or `undefined`.\n   */\n  readonly or?: Value | null;\n\n  /**\n   * Handles missing context value.\n   *\n   * It can be called to prefer a fallback value over the default one specified in the value key.\n   *\n   * @param defaultProvider  Default value provider. It is called unless a fallback value is specified.\n   * If it returns a non-null/non-undefined value, then the returned value will be associated with the context key.\n   */\n  byDefault(defaultProvider: () => Value | null | undefined): Value | null | undefined;\n\n}\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Seed, Src, Seed>): Seed | null | undefined {\n\n    const { seeder, seed } = opts;\n\n    return seeder.isEmpty(seed) ? opts.byDefault(() => seed) : seed;\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message: string = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { valueProvider } from 'call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: Ctx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: Ctx) {\n        return new DepType(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${spec}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @module context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @module context-values\n */\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\n/**\n * @internal\n */\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n\n    const values = this.newValues(cache);\n\n    return <Src, Seed>(key: ContextSeedKey<Src, Seed>) =>\n        values.get.call<Ctx, [ContextSeedKey<Src, Seed>], Seed>(context, key);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, defaultUsed] = growValue(context, key, opts);\n\n        if (cache && !defaultUsed) {\n          values.set(key, constructed);\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> | undefined,\n    ): [Value | null | undefined, boolean] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let defaultUsed = false;\n\n      const valueOpts: {\n        -readonly [K in keyof ContextValueOpts<Ctx, Value, Src, Seed>]: ContextValueOpts<Ctx, Value, Src, Seed>[K];\n      } = {\n        context,\n        seeder,\n        seed,\n        byDefault: (opts && 'or' in opts)\n            ? () => {\n              defaultUsed = true;\n              return opts.or;\n            } : defaultProvider => {\n\n              const defaultValue = defaultProvider();\n\n              if (defaultValue == null) {\n                throw new ContextKeyError(key);\n              }\n\n              return defaultValue;\n            },\n      };\n\n      if (opts && 'or' in opts) {\n        valueOpts.or = opts.or;\n      }\n\n      return [\n        key.grow(valueOpts),\n        defaultUsed,\n      ];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n    return new ContextRegistry(<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx) => {\n\n      const [seeder, factory] = this._seeding(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { flatMapIt, mapIt, overArray } from 'a-iterable';\nimport { asis, NextArgs, nextArgs, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { ContextKey, ContextKey__symbol, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keep.thru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read.keep.dig(\n      providers => !providers.length ? afterThe() : afterEach(\n          ...mapIt(\n              mapIt(\n                  overArray(providers),\n                  prov => prov(context),\n              ),\n              toUpSrcKeeper,\n          ),\n      ).keep.thru(\n          flatUpSources,\n      ));\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<Src, NextReturn>(...sources: Src[][]): NextArgs<Src[], NextReturn> {\n  return nextArgs<Src[], NextReturn>(\n      ...flatMapIt(overArray(sources), asis),\n  );\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport interface ContextUpRef<Value, Src> extends ContextRef<Value, Src | EventKeeper<Src[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<Value, Src>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<Value, Src>\n    extends ContextKey<ContextUpKey.Up<Value>, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  get seedKey() {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<Value, Src>,\n      readonly grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ) {\n    super(_key.name + ':up');\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src> {\n\n  readonly seedKey: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[growUp]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<Value, Src>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ): ContextUpKey.UpKey<Value, Src> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeparam Value  Original context value type.\n   */\n  export type Up<Value> = Value extends AfterEvent<any>\n      ? Value\n      : (Value extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[Value]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   */\n  export type UpKey<Value, Src> = ContextKey<ContextUpKey.Up<Value>, Src>;\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextUpRef<Value> = ContextUpRef<AfterEvent<[Value]>, Value>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value | EventKeeper<Value[]>, AfterEvent<Value[]>>,\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): AfterEvent<[Value]> {\n    return opts.seed.keep.dig((...sources) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return afterThe(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue && afterThe(defaultValue);\n      });\n\n      if (backup != null) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      });\n    });\n  }\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Src  Source value type.\n */\nexport type MultiContextUpRef<Src> = ContextUpRef<AfterEvent<Src[]>, Src>;\n\n/**\n * Multiple updatable context values key.\n *\n * The associated value is an `AfterEvent` keeper of the source values. It is always present, even though\n * the array can be empty.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Src  Source value type.\n */\nexport class MultiContextUpKey<Src>\n    extends ContextUpKey<AfterEvent<Src[]>, Src>\n    implements MultiContextUpRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs multiple updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>,\n        byDefault?: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<Src[]>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ): AfterEvent<Src[]> {\n    return opts.seed.keep.dig((...sources) => {\n      if (sources.length) {\n        // Sources present. Use them.\n        return afterThe(...sources);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue ? afterThe(...defaultValue) : afterThe();\n      });\n\n      if (backup != null) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<Src[]>(() => {\n        throw new ContextKeyError(this);\n      });\n    });\n  }\n\n}\n","import { noop } from 'call-thru';\nimport { AfterEvent, afterThe, EventKeeper } from 'fun-events';\nimport { ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\nimport { ContextValues } from './context-values';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport type FnContextRef<Args extends any[], Ret = void> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<\n            ((this: void, ...args: Args) => Ret) | EventKeeper<((this: void, ...args: Args) => Ret)[]>,\n            AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.dig((...fns) => {\n          if (fns.length) {\n            return afterThe(fns[fns.length - 1]);\n          }\n\n          const defaultProvider = () => afterThe<[(this: void, ...args: Args) => Ret]>(this.byDefault(\n              opts.context,\n              this,\n          ));\n\n          return opts.byDefault(defaultProvider)! || defaultProvider();\n        }),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): (this: void, ...args: Args) => Ret {\n\n    let delegated!: (this: void, ...args: Args) => Ret;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(fn => delegated = fn);\n\n    return (...args) => delegated(...args);\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { AIterable, itsEmpty, itsLast, overArray, overNone } from 'a-iterable';\nimport { asis, isPresent, noop, valuesProvider } from 'call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\nclass SimpleContextSeeder<Ctx extends ContextValues, Src> implements ContextSeeder<Ctx, Src, AIterable<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.push(provider);\n    return () => {\n\n      const found = this._providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AIterable<Src> = AIterable.from(overNone())): AIterable<Src> {\n    return AIterable.from([\n      initial,\n      sourceValues(context, this._providers),\n    ]).flatMap(asis);\n  }\n\n  isEmpty(seed: AIterable<Src>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: AIterable<Src>, second: AIterable<Src>): AIterable<Src> {\n    return AIterable.from([first, second]).flatMap(asis);\n  }\n\n}\n\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, AIterable<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects value sources into iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, AIterable<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, AIterable<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, AIterable<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextRef<Value> = ContextRef<Value, Value>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, AIterable<Value>>,\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, Value, Value, AIterable<Value>>,\n  ): Value | null | undefined {\n\n    const value = itsLast(opts.seed);\n\n    if (value != null) {\n      return value;\n    }\n\n    return opts.byDefault(() => this.byDefault(opts.context, this));\n  }\n\n}\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport type MultiContextRef<Src> = ContextRef<readonly Src[], Src>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport class MultiContextKey<Src>\n    extends SimpleContextKey<readonly Src[], Src>\n    implements MultiContextRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<Src, AIterable<Src>>,\n        byDefault?: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, readonly Src[], Src, AIterable<Src>>,\n  ): readonly Src[] | null | undefined {\n\n    const result = Array.from(opts.seed);\n\n    if (result.length) {\n      return result;\n    }\n\n    return opts.byDefault(() => {\n\n      const defaultSources = this.byDefault(opts.context, this);\n\n      if (defaultSources) {\n        return Array.from(defaultSources);\n      }\n\n      return;\n    });\n  }\n\n}\n\n/**\n * Context value provider and cached context value source.\n *\n * @internal\n */\ntype SourceEntry<Ctx extends ContextValues, Src> = [ContextValueProvider<Ctx, Src>, (Src | null | undefined)?];\n\n/**\n * @internal\n */\nfunction sourceValues<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providers: ContextValueProvider<Ctx, Src>[],\n): AIterable<Src> {\n  return AIterable.from(overArray(providers.map<SourceEntry<Ctx, Src>>(provider => [provider])))\n      .map(entry => {\n        if (entry.length > 1) {\n          return entry[1];\n        }\n\n        const source = entry[0](context);\n\n        entry.push(source);\n\n        return source;\n      })\n      .filter<Src>(isPresent);\n}\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\n\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = (/*#__PURE__*/ new CssNaming());\n","/**\n * @module namespace-aliaser\n */\nimport { QualifiedName } from './name';\nimport { NamespaceDef } from './namespace';\nimport { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url  Unique namespace URL.\n   * @param aliases  Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for [default namespace][[DEFAULT__NS]].\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls [[Naming.applyAlias]] by default.\n   *\n   * @param alias  Namespace alias to apply to the name.\n   * @param name  A name to convert.\n   * @param naming  Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of [[NamespaceDef]]. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: any): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of [[NamespaceDef]].\n * Or `false` otherwise.\n */\nexport function isQualifiedName(value: any): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name  Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name  Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","/**\n * @module namespace-aliaser\n */\nimport { NamespaceDef } from './namespace';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns  A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = mostPreferred + (++nsNumRegistered);\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { ScheduledRender } from './scheduled-render';\n\n/**\n * Render schedule signature.\n *\n * This function accepts {@link ScheduledRender renders} to schedule.\n *\n * If multiple renders scheduled before execution starts, only the last one will be executed to limit their execution\n * rate.\n *\n * The render execution may fail. This should not prevent other scheduled or postponed renders from being executed.\n * The render execution failure reason is expected to be reported with [[RenderScheduleConfig.error]] method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by [[newRenderSchedule]] function\n * that uses the {@link setRenderScheduler default scheduler} for that.\n */\nexport type RenderSchedule =\n/**\n * @param render  A render to schedule.\n */\n    (this: void, render: ScheduledRender) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by [[nodeWindow]] by default, if [[node]] is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing [[window]] option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error(...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render scheduler by its options.\n   *\n   * @param options  Render scheduler options the configuration should be base on.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n\n    return {\n      get node() {\n        return options.node;\n      },\n      get window() {\n        return win || (win = options.window || (options.node && nodeWindow(options.node)) || window);\n      },\n      error(...messages) {\n        if (options && options.error) {\n          options.error(...messages);\n        } else {\n          console.error(...messages);\n        }\n      },\n    };\n  },\n\n};\n\n/**\n * Detects a window the given DOM node is attached to.\n *\n * @param node  Target DOM node.\n *\n * @returns A window of the owner document, or `null` if absent.\n */\nexport function nodeWindow(node: Node): Window | null {\n\n  const document = node.ownerDocument || node as Document;\n\n  return document.defaultView;\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { RenderScheduleConfig } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { ScheduledRender, ScheduledRenderExecution } from './scheduled-render';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to [[customRenderScheduler]] function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config  Render schedule configuration.\n   *\n   * @returns  Scheduled render queue.\n   */\n  newQueue(config: RenderScheduleConfig): ScheduledRenderQueue;\n\n}\n\n/**\n * A queue of scheduled renders.\n *\n * Utilized by render scheduler in order to collect scheduled renders and schedule their execution.\n *\n * The default implementation may constructed using [[ScheduledRenderQueue.by]] function.\n */\nexport interface ScheduledRenderQueue {\n\n  /**\n   * Adds a render to this queue.\n   *\n   * @param render  Scheduled render to add.\n   */\n  add(render: ScheduledRender): void;\n\n  /**\n   * Retrieves the first added render and removes it from the queue.\n   *\n   * @returns  Either pulled out scheduled render, or `undefined` when there is no more renders.\n   */\n  pull(): ScheduledRender | undefined;\n\n  /**\n   * Schedules queued renders execution.\n   *\n   * @param task  A function that performs scheduled renders execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled renders from now on.\n   */\n  reset(): ScheduledRenderQueue;\n\n}\n\nexport const ScheduledRenderQueue = {\n\n  /**\n   * Builds the default implementation of scheduled renders queue.\n   *\n   * @param schedule  Schedules queued renders execution. This is an implementation of\n   * [[ScheduledRenderQueue.schedule]] method.\n   * @param replace  Called right after [[ScheduledRenderQueue.reset]] method in order to inform on queue that will\n   * collect scheduled renders from now.\n   *\n   * @returns New scheduled render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = () => {/* do not replace */},\n      }: {\n        schedule(this: ScheduledRenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: ScheduledRenderQueue): void;\n      },\n  ): ScheduledRenderQueue {\n\n    const renders: ScheduledRender[] = [];\n\n    return {\n      schedule,\n      add(render) {\n        renders.push(render);\n      },\n      pull() {\n        return renders.shift();\n      },\n      reset() {\n\n        const next = ScheduledRenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n\n/**\n * @internal\n */\nconst ScheduledRenderQ__symbol = Symbol('scheduled-render-q');\n\n/**\n * @internal\n */\nclass ScheduledRenderQ {\n\n  readonly ref: [ScheduledRenderQ];\n  schedule: (this: ScheduledRenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: ScheduledRenderQueue, ref?: [ScheduledRenderQ]): ScheduledRenderQ {\n    return (queue as any)[ScheduledRenderQ__symbol]\n        || ((queue as any)[ScheduledRenderQ__symbol] = new ScheduledRenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: ScheduledRenderQueue, ref?: [ScheduledRenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this];\n  }\n\n  add(render: ScheduledRender): void {\n    this.q.add(render);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    this.schedule = () => {/* do not schedule */};\n\n    const execution: ScheduledRenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone: postponed => this.add(postponed),\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: ScheduledRenderExecution): void {\n    for (; ;) {\n\n      const render = this.q.pull();\n\n      if (!render) {\n        break;\n      }\n      render(execution);\n    }\n  }\n\n  private reset(): ScheduledRenderQ {\n    return this.ref[0] = ScheduledRenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {/* do not schedule */};\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options  Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return scheduleOptions => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef = ScheduledRenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [ScheduledRenderQ, ScheduledRender] | [] = [];\n\n    return render => {\n\n      const [lastQueue] = enqueued;\n      const [nextQueue] = queueRef;\n\n      if (lastQueue === nextQueue) {\n        enqueued[1] = render;\n      } else {\n\n        const nextEnqueued = enqueued = [nextQueue, render];\n\n        nextQueue.add((execution: ScheduledRenderExecution) => {\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      nextQueue.schedule(config);\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { customRenderScheduler, ScheduledRenderQueue } from './custom-render-scheduler';\nimport { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, ScheduledRenderQueue>());\n\n/**\n * A render scheduler that executes the scheduled renders within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The renders scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link ScheduledRenderExecution.postpone postponed} renders are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = ScheduledRenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { animationRenderScheduler } from './animation-render-scheduler';\nimport { RenderSchedule, RenderScheduleOptions } from './render-schedule';\n\n/**\n * Render scheduler signature.\n *\n * This function constructs {@link RenderSchedule render schedules} according to the given options.\n *\n * The default render scheduler is always available as [[newRenderSchedule]] function.\n *\n * There are several scheduler implementations exist:\n * - [[animationRenderScheduler]] (used by default),\n * - [[asyncRenderScheduler]],\n * - [[immediateRenderScheduler]],\n * - [[ManualRenderScheduler]],\n * - [[noopRenderScheduler]].\n *\n * Custom scheduler implementations could be created using [[customRenderScheduler]] function.\n */\nexport type RenderScheduler =\n/**\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: RenderScheduleOptions) => RenderSchedule;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler  New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n","import { HthvItem } from './hthv-item';\n\n/**\n * @internal\n */\nexport interface HthvPartial<I extends HthvItem<any, any, any> = HthvItem> {\n  $: I['$'];\n  n?: I['n'];\n  t?: I['t'];\n  v: I['v'];\n  x?: I['x'];\n  p?: I['p'];\n  pl?: I['pl'];\n}\n\n/**\n * @internal\n */\nexport function hthvItem<I extends HthvItem<any, any, any>>(\n    {\n      $,\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<I>,\n): I {\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as I;\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam({ p, pl }: HthvItem, param: HthvParamItem) {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = config.delimiterOf(c);\n\n    return c;\n  };\n}\n","// tslint:disable-next-line:max-line-length\nimport { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (input.s.match(datePattern)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","/**\n * @internal\n */\nexport const parseNone = () => false;\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseDateTime } from './parse-date-time';\nimport { parseNone } from './parse-none';\nimport { quotedStringParser } from './quoted-string-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport interface ItemParserOpts {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseQuotedString = quotedStringParser(config);\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem),\n    )) ; // tslint:disable-line:curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (config.delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = config.delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = config.delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser(config: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(config.delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport { HthvDelimitConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  delimiterOf(char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n    }: {\n      delimit?: HthvDelimitConfig;\n    } = {}): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = /*#__PURE__*/ buildParserConfig();\n\n/**\n * @internal\n */\nexport const commentParserConfig = /*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n});\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiterChar } from './hthv-delimiter';\nimport { HthvItem } from './hthv-item';\nimport { hthvItem } from './hthv-partial.impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeparam N  Whether parsed items have {@link HthvItem.n names}.\n * @typeparam T  Whether parsed items have {@link HthvItem.t tags}.\n * @typeparam P  Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    N extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    T extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    P extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value  HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<N, T, P>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse comments.\n   *\n   * `false` by default.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // tslint:disable-line\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (config.delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport { spacesParser } from './spaces-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const commentParserOpts: ItemParserOpts = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserOpts);\n  const parseParam = paramParser(config, commentParserOpts);\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while (\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        ) ; /* tslint:disable-line:curly */\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @module http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser =\n    /*#__PURE__*/ newHthvParser();\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = defaultParserConfig.delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","/**\n * @internal\n */\nexport function isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): array is readonly [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: T[]): array is [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): boolean {\n  return !!array.length;\n}\n","import { flatMapIt } from 'a-iterable';\nimport { compareNames, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { isNotEmptyArray, isReadonlyArray } from '../internal';\nimport { StypPureSelector } from './pure-selector';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSubSelector } from './sub-selector';\n\n/**\n * @internal\n */\nexport function isCombinator(\n    item: string | StypSelector.Part | StypSelector.Combinator,\n): item is StypSelector.Combinator {\n  return item === '>' || item === '+' || item === '~';\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized {\n  if (!isReadonlyArray(selector)) {\n    return [normalizeKey(selector)];\n  }\n\n  const normalized: StypSelector.Mutable = [];\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (const item of selector) {\n\n    const prevCombinator = combinator;\n\n    if (combinator) {\n      normalized.push(combinator);\n      combinator = undefined;\n    }\n\n    let part: StypSelector.NormalizedPart;\n\n    if (isCombinator(item)) {\n      combinator = item;\n      if (!prevCombinator) {\n        continue;\n      }\n      part = {};\n    } else {\n      part = normalizeKey(item);\n    }\n\n    normalized.push(part);\n  }\n  if (combinator) {\n    normalized.push(combinator, {});\n  }\n\n  return normalized;\n}\n\nfunction normalizeKey(key: StypSelector.Part | string): StypSelector.NormalizedPart {\n  if (typeof key === 'string') {\n    if (!key) {\n      return {};\n    }\n    return { s: key };\n  }\n  return normalizeStypSelectorPart(key);\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelectorPart(part: StypSelector.Part): StypSelector.NormalizedPart {\n\n  const ns = part.ns || undefined;\n  const i = part.i || undefined;\n  const c = normalizeClasses(part.c);\n  const u = normalizeSubSelectors(part.u);\n\n  return {\n    ns,\n    e: (part.e !== '*' || !ns && !i && !c && u && isPseudoSubSelector(u[0])) && part.e || undefined,\n    i,\n    c,\n    u,\n    s: part.s || undefined,\n    $: normalizeQualifiers(part.$),\n  };\n}\n\nfunction normalizeClasses(\n    classes: QualifiedName | readonly QualifiedName[] | undefined,\n): readonly [QualifiedName, ...QualifiedName[]] | undefined {\n  if (!classes) {\n    return;\n  }\n  if (isQualifiedName(classes)) {\n    return [classes];\n  }\n\n  const result = classes.filter(c => !!c);\n\n  return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\n\nfunction normalizeSubSelectors(\n    subs: StypSubSelector | readonly StypSubSelector[] | undefined,\n): readonly [StypSubSelector.Normalized, ...StypSubSelector.Normalized[]] | undefined {\n  if (!subs) {\n    return;\n  }\n  if (/*#__INLINE__*/ isSubSelectorsArray(subs)) {\n\n    const result = subs.map(normalizeSubSelector);\n\n    return isNotEmptyArray(result) ? result : undefined;\n  }\n\n  return [normalizeSubSelector(subs)];\n}\n\nfunction isSubSelectorsArray(\n    subs: StypSubSelector | readonly StypSubSelector[],\n): subs is readonly StypSubSelector[] {\n  return typeof subs[0] !== 'string';\n}\n\nfunction normalizeSubSelector(sub: StypSubSelector): StypSubSelector.Normalized {\n  if (!isPseudoSubSelector(sub)) {\n    return sub;\n  }\n  if (sub.length < 3) {\n    return sub as StypSubSelector.Normalized;\n  }\n\n  const [prefix, name, ...params] = sub;\n\n  if (/*#__INLINE__*/ isSubSelectorParametersArray(params)) {\n    return [prefix, name, ...params.map(normalizeStypSelector)];\n  }\n\n  return [prefix, name, normalizeStypSelector(params)];\n}\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector.Normalized): sub is StypSubSelector.NormalizedPseudo;\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo;\n\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo {\n  return sub.length > 1 && (sub[0] === ':' || sub[0] === '::');\n}\n\nfunction isSubSelectorParametersArray(\n    param: StypSubSelector.Parameter | readonly StypSubSelector.Parameter[],\n): param is readonly StypSubSelector.Parameter[] {\n  return isReadonlyArray(param[0]);\n}\n\nfunction normalizeQualifiers(\n    qualifiers: string | readonly string[] | undefined,\n): readonly [string, ...string[]] | undefined {\n  if (!qualifiers) {\n    return;\n  }\n\n  if (!isReadonlyArray(qualifiers)) {\n    qualifiers = [...exposeQualifier(qualifiers)];\n  } else {\n    qualifiers = [...new Set(flatMapIt(qualifiers, exposeQualifier))].sort();\n  }\n\n  return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\n\nconst noQualifiers: Set<string> = new Set();\n\nfunction exposeQualifier(qualifier: string): Set<string> {\n  if (!qualifier) {\n    return noQualifiers;\n  }\n\n  const eqIdx = qualifier.indexOf('=');\n  const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n  const exposed = new Set<string>();\n  let lastExposed: string | undefined;\n\n  for (const part of name.split(':')) {\n    if (lastExposed) {\n      lastExposed += ':' + part;\n    } else {\n      lastExposed = part;\n    }\n    exposed.add(lastExposed);\n  }\n  if (eqIdx >= 0) {\n    exposed.add(qualifier);\n  }\n\n  return exposed;\n}\n\nconst noKeyAndTail: [[]] = [[]];\n\n/**\n * @internal\n */\nexport function stypRuleKeyAndTail(\n    selector: StypSelector.Normalized,\n): readonly [[]] | readonly [StypRuleKey.Nested, StypSelector.Normalized?] {\n  if (!selector.length) {\n    return noKeyAndTail;\n  }\n\n  let i = 0;\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (;;) {\n\n    const part = selector[i++];\n\n    if (isCombinator(part)) {\n      combinator = part;\n      continue;\n    }\n\n    const key: StypRuleKey = combinator ? [combinator, part] : [part];\n\n    return [key, selector.slice(i)];\n  }\n}\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * @internal\n */\nexport function stypOuterSelector(\n    selector: StypSelector.Normalized,\n): StypSelector.Normalized | undefined {\n\n  let i = selector.length - 1;\n\n  if (i <= 0) {\n    return i ? undefined : rootSelector;\n  }\n\n  do {\n    --i;\n    switch (selector[i]) {\n      case '>':\n        return selector.slice(0, i);\n      case '+':\n      case '~':\n        --i;\n        continue;\n      default:\n        return selector.slice(0, i + 1);\n    }\n  } while (i > 0);\n\n  return;\n}\n","/**\n * @module style-producer\n */\nimport { namesEqual, NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * CSS rule query.\n *\n * It may represent a selector like `element-name#id.class1.classN` with any of sub-parts omitted.\n *\n * Queries are used to grab a subset of matching rules from `StypRule`.\n *\n * All of its properties are optional.\n *\n * @category CSS Rule\n */\nexport interface StypQuery {\n\n  /**\n   * Element namespace.\n   */\n  readonly ns?: string | NamespaceDef;\n\n  /**\n   * Element name.\n   *\n   * This is the same as `*` when absent.\n   */\n  readonly e?: QualifiedName;\n\n  /**\n   * Element identifier.\n   */\n  readonly i?: QualifiedName;\n\n  /**\n   * Element class name or names.\n   */\n  readonly c?: QualifiedName | readonly QualifiedName[];\n\n  /**\n   * Qualifier or qualifiers.\n   */\n  readonly $?: string | readonly string[];\n\n}\n\nexport namespace StypQuery {\n\n  /**\n   * Normalized CSS rule query.\n   */\n  export type Normalized = StypQuery & StypSelector.NormalizedPart;\n\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query  CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nexport function stypQuery(query: StypQuery): StypQuery.Normalized {\n  return normalizeStypSelectorPart(query);\n}\n\n/**\n * Checks whether the given structured CSS `selector` matches target `query`.\n *\n * @category CSS Rule\n * @param selector  Normalized structured CSS selector.\n * @param query  Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nexport function stypSelectorMatches(\n    selector: StypSelector.Normalized | StypPureSelector.Normalized,\n    query: StypQuery.Normalized,\n): boolean {\n  if (!selector.length) {\n    return false;\n  }\n\n  const part = selector[selector.length - 1] as StypSelector.NormalizedPart;\n\n  if (query.ns && part.ns !== query.ns) {\n    return false;\n  }\n  if (query.e && part.e !== query.e) {\n    return false;\n  }\n  if (query.i && part.i !== query.i) {\n    return false;\n  }\n  if (query.c && !classesMatch(part.c, query.c)) {\n    return false;\n  }\n  // noinspection RedundantIfStatementJS\n  if (query.$ && !classesMatch(part.$, query.$)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction classesMatch(classes: readonly QualifiedName[] | undefined, query: readonly QualifiedName[]) {\n  return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n","/**\n * @module style-producer\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { StypQuery, StypRuleKey, StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { StypRules } from './rules';\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nexport abstract class StypRule implements EventKeeper<[StypProperties]> {\n\n  /**\n   * A reference to the root CSS rule.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * A reference to outer CSS rule.\n   *\n   * The outer rule is the one for enclosing element.\n   * I.e. for the rule with selector is `a b+c` the parent one is `a b`, while the outer one is `a`.\n   *\n   * This is `null` for the root rule and may be `null` for the rule removed from hierarchy.\n   */\n  abstract readonly outer: StypRule | null;\n\n  /**\n   * CSS selector of this rule.\n   */\n  abstract readonly selector: StypSelector.Normalized;\n\n  /**\n   * A key of this rule in the enclosing one.\n   */\n  abstract readonly key: StypRuleKey;\n\n  /**\n   * Whether this rule's properties are empty.\n   *\n   * This is `true` when the rule properties are constant and empty.\n   *\n   * Empty CSS rules returned from `rule()` method when there is no matching rule found.\n   */\n  abstract readonly empty: boolean;\n\n  /**\n   * `AfterEvent` CSS properties receiver registrar.\n   */\n  abstract readonly read: AfterEvent<[StypProperties]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[StypProperties]> {\n    return this.read;\n  }\n\n  /**\n   * Dynamic list of all CSS rules in hierarchy starting from this one.\n   */\n  abstract readonly rules: StypRuleHierarchy;\n\n  /**\n   * Sets CSS properties of this rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: StypProperties.Spec): this;\n\n  /**\n   * Appends CSS properties to this rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  add(properties: StypProperties.Spec): this {\n    return this.rules.add([], properties) as this;\n  }\n\n  /**\n   * Clears CSS properties of this rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n  /**\n   * Removes this rule from hierarchy along with all nested rules.\n   *\n   * @param reason  Optional removal reason.\n   *\n   * @returns `this` (just removed) rule instance.\n   */\n  abstract remove(reason?: any): this;\n\n}\n\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleList implements StypRules, EventKeeper<[StypRuleList]> {\n\n  /**\n   * An `AfterEvent` registrar of rule list receiver.\n   *\n   * An `[AfterEvent__symbol]` property is just an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[StypRuleList]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[StypRuleList]> {\n    return this.read;\n  }\n\n  /**\n   * An `OnEvent` registrar of list updates receiver.\n   *\n   * The list updates receiver accepts two arguments:\n   * - An array of added rules\n   * - An array of removed rules.\n   *\n   * An `[OnEvent__symbol]` property is just an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n    return this.onUpdate;\n  }\n\n  abstract [Symbol.iterator](): IterableIterator<StypRule>;\n\n  /**\n   * Grabs rules from this list matching the given `query`.\n   *\n   * @param query  CSS rule query to match.\n   *\n   * @returns Dynamic list of rules in this list matching the given query.\n   */\n  abstract grab(query: StypQuery): StypRuleList;\n\n}\n\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleHierarchy extends StypRuleList {\n\n  /**\n   * Dynamic list containing only root CSS rule.\n   *\n   * This list never changes actually.\n   */\n  abstract readonly self: StypRuleList;\n\n  /**\n   * Dynamic list of all CSS rules directly nested within the root one.\n   */\n  abstract readonly nested: StypRuleList;\n\n  /**\n   * Appends CSS properties to nested rule.\n   *\n   * Creates target rule if necessary.\n   *\n   * @param selector  Target rule selector.\n   * @param properties  Optional CSS properties specifier.\n   *\n   * @returns Modified CSS rule.\n   */\n  abstract add(selector: StypSelector, properties?: StypProperties.Spec): StypRule;\n\n  /**\n   * Returns nested CSS rule matching the given `selector`.\n   *\n   * @param selector  Target rule selector.\n   *\n   * @returns Either matching CSS rule, or `undefined` if not found.\n   */\n  abstract get(selector: StypSelector): StypRule | undefined;\n\n  /**\n   * Watches for CSS rule properties.\n   *\n   * The properties are empty when the watched rule does not exist.\n   *\n   * @param selector  CSS selector of watched rule.\n   *\n   * @returns An `AfterEvent` registrar of CSS properties receiver.\n   */\n  abstract watch(selector: StypSelector): AfterEvent<[StypProperties]>;\n\n}\n","import { filterIt, itsIterable } from 'a-iterable';\nimport { asis, valueProvider, valuesProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, OnEvent, onEventBy, onSupplied } from 'fun-events';\nimport { stypQuery, StypQuery, stypSelectorMatches } from '../selector';\nimport { StypRule, StypRuleList } from './rule';\nimport { StypRules } from './rules';\n\n/**\n * @internal\n */\nexport class Rules extends StypRuleList {\n\n  readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n  readonly read: AfterEvent<[Rules]>;\n  readonly [Symbol.iterator]: () => IterableIterator<StypRule>;\n\n  constructor(list: StypRules, ruleMatches?: (rule: StypRule) => boolean) {\n    super();\n\n    let buildList: () => Iterable<StypRule>;\n    let filterArray: (rules: StypRule[]) => StypRule[];\n\n    if (ruleMatches) {\n      buildList = () => filterIt(list, ruleMatches);\n      filterArray = rules => rules.filter(ruleMatches);\n    } else {\n      buildList = () => list;\n      filterArray = asis;\n    }\n\n    let ruleSet: Set<StypRule> | undefined; // `undefined` updates are not tracked\n\n    this.onUpdate = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n      const rules = ruleSet || (ruleSet = new Set(buildList()));\n\n      onSupplied(list)({\n        supply: receiver.supply.whenOff(() => ruleSet = undefined),\n        receive(context, added, removed) {\n          added = filterArray(added);\n          removed = filterArray(removed);\n          if (removed.length || added.length) {\n            removed.forEach(rule => rules.delete(rule));\n            added.forEach(rule => rules.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        },\n      });\n    }).share();\n\n    this.read = afterSupplied<[Rules]>(this.onUpdate.thru(valueProvider(this)), valuesProvider(this));\n\n    this[Symbol.iterator] = () => {\n      if (ruleSet) {\n        // List changes are tracked.\n        return ruleSet.values();\n      }\n      // List changes are not currently tracked.\n      // Request the rules explicitly.\n      return itsIterable(buildList());\n    };\n\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function grabRules(list: StypRuleList, query: StypQuery): StypRuleList {\n\n  const q = stypQuery(query);\n\n  return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n","/**\n * @module style-producer\n */\nimport { itsEach } from 'a-iterable';\nimport {\n  EventNotifier,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  isEventSender,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  onEventBy, onNever,\n  onSupplied,\n} from 'fun-events';\nimport { StypRule, StypRuleList } from './rule';\nimport { Rules } from './rules.impl';\n\n/**\n * Dynamically updated CSS rule set.\n *\n * This is an iterable of rules, and an `EventSender` of their updates.\n *\n * @category CSS Rule\n */\nexport interface StypRules extends Iterable<StypRule>, EventSender<[StypRule[], StypRule[]]> {\n\n  [Symbol.iterator](): IterableIterator<StypRule>;\n\n}\n\nexport namespace StypRules {\n\n  /**\n   * A source of CSS rules.\n   *\n   * A dynamically updated CSS rule set can be constructed out of one or more sources by [[stypRules]] and\n   * [[lazyStypRules]] functions.\n   *\n   * This can be one of:\n   * - Single `StypRule` instance.\n   *   A `StypRule.rules.self` is used instead. I.e. a list containing only the rule itself.\n   * - A `StypRules` instance.\n   *   It is used as is.\n   * - A promise of one of the above.\n   *   The resolved value is used as an actual source.\n   *   No rules are available until resolution.\n   * - A function returning one of the above.\n   *   The function call result is used as an actual source.\n   *   The function will be called lazily upon rules access.\n   */\n  export type Source =\n      | StypRule\n      | StypRules\n      | Promise<StypRule | StypRules>\n      | ((this: void) => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n\nconst noStypRules: StypRuleList =\n    /*#__PURE__*/ new Rules({\n  [OnEvent__symbol]: onNever,\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return [][Symbol.iterator]();\n  },\n});\n\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function stypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n\nfunction rulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to [[stypRules]] this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function lazyStypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n\nfunction lazyRulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n\nfunction rulesByList(sources: StypRules[]): StypRuleList {\n  if (sources.length === 1) {\n\n    const source = sources[0];\n\n    return source instanceof StypRuleList ? source : new Rules(source);\n  }\n  return new Rules({\n    * [Symbol.iterator](): IterableIterator<StypRule> {\n      for (const rules of sources) {\n        yield* rules;\n      }\n    },\n    get [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n      return onEventBy<[StypRule[], StypRule[]]>(receiver => {\n        sources.forEach(source => onSupplied(source)({\n          supply: eventSupply().needs(receiver.supply),\n          receive(context, added, removed) {\n            receiver.receive(context, added, removed);\n          },\n        }));\n      }).share();\n    },\n  });\n}\n\nfunction evalRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  let _rules: StypRules | undefined;\n\n  return {\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return rules()[Symbol.iterator]();\n    },\n    get [OnEvent__symbol]() {\n      return rules()[OnEvent__symbol];\n    },\n  };\n\n  function rules(): StypRules {\n    return _rules || (_rules = rulesByValue(source()));\n  }\n}\n\nfunction lazyRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy(receiver => {\n\n    const rules = rulesByValue(source());\n\n    reportExistingRules(rules, ruleSet, receiver);\n    rules[OnEvent__symbol]({\n      supply: receiver.supply.whenOff(() => ruleSet.clear()),\n      receive(context, added, removed) {\n        removed.forEach(rule => ruleSet.delete(rule));\n        added.forEach(rule => ruleSet.add(rule));\n        receiver.receive(context, added, removed);\n      },\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]: onEvent,\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\nfunction rulesByValue(source: StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n  return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n\nfunction asyncRules(source: Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    let sourceSupply = noEventSupply();\n    const { supply } = receiver;\n\n    supply.whenOff(reason => {\n      sourceSupply.off(reason);\n      ruleSet.clear();\n    });\n\n    source.then(resolution => {\n      if (!supply.isOff) {\n\n        const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n\n        reportExistingRules(rules, ruleSet, receiver);\n\n        sourceSupply = onSupplied(rules)({\n          receive(context, added, removed) {\n            removed.forEach(rule => ruleSet.delete(rule));\n            added.forEach(rule => ruleSet.add(rule));\n            receiver.receive(context, added, removed);\n          },\n        }).needs(supply);\n      }\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]: onEvent,\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\nfunction reportExistingRules(\n    rules: StypRules,\n    ruleSet: Set<StypRule>,\n    receiver: EventReceiver.Generic<[StypRule[], StypRule[]]>,\n) {\n\n  const existing: StypRule[] = [];\n\n  itsEach(rules, rule => {\n    existing.push(rule);\n    ruleSet.add(rule);\n  });\n  if (existing.length) {\n\n    const dispatcher = new EventNotifier<[StypRule[], StypRule[]]>();\n\n    dispatcher.on(receiver);\n    dispatcher.send(existing, []); // Report existing rules as just added\n  }\n}\n"],"names":["NextCall__symbol","Symbol","NextCall_lastOutcome__symbol","NextCall","Function","[object Object]","target","value","is","nextCall","callee","firstArg","arg","callNext","lastOutcome","result","PassedThru__symbol","PassedThru","outcome","iterator","callThru","fns","args","get","idx","prev","len","length","apply","this","call","asis","noop","isPresent","valueProvider","nextArgs","undefined","nextEach","items","item","forEachItem","lastItems","SKIP","_skip","_nextSkip","nextSkip","isArrayLike","itsRevertible","iterable","itsIterator","makeIt","iterate","reverse","reversible","reverseIt","source","reverseArray","reversed","array","i","itsEach","action","element","itsFirst","next","itsReduction","reducer","initialValue","reduced","thruIt","it","thru","filterIt","test","flatMapIt","convert","mapIt","API_METHODS","AIterable","NONE","every","name","from","make","itsEvery","elements","None","super","overArray","AfterEvent__symbol","isEventKeeper","EventSupply","another","whenOff","reason","off","eventSupply","cutOff","callback","isOff","NoSupply","noSupply","noEventSupply","eventReceiver","receiver","generic","supply","_context","event","context","receive","OnEvent__symbol","isEventSender","once","register","EventNotifier","Set","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","push","processEvent","shift","receiveEventsByEach","_rcvs","size","on","add","delete","forEach","recurrentReceivers","recurrentReceiver","recurrentEvent","share","shared","sharedSupply","initialEvents","_ctx","needs","dispatcher","tillOff","OnEvent","onEventBy","extract","dig_","nestedSupply","prevSupply","extracted","onSupplied","nestedEvent","consume","consumerSupply","senderSupply","thru_","transformed","onEvent","Object","setPrototypeOf","prototype","supplier","bind","onNever","AfterEventKeep","keeper","_keeper","afterSupplied","AfterEvent","keep","afterEventBy","fallback","noEvent","lastEvent","numReceivers","afterEvent","dest","reported","sender","afterSent","afterThe","afterNever","Error","OnDomEvent","onDomEventBy","capture","listener","opts","instead","preventDefault","just","stopPropagation","last","stopImmediatePropagation","passive","onDomEvent","domEventContext","onRecurrent","DomEventDispatcher","_target","type","domListener","addEventListener","removeEventListener","dispatchEvent","EventEmitter","afterAll","sources","keys","notifier","key","afterEach","index","onAny","suppliers","remained","removeSupplier","statePath","path","Array","isArray","PathEntry","_drop","Map","emitter","newValue","oldValue","nested","_nested","slice","entry","_dropIfEmpty","dontCreateMissing","found","created","_remove","set","values","done","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","_tracker","onUpdate","StateTracker","update","subTracker","track","ValueTracker","valueReceiver","recurrentValue","read","self","byNone","container","_by","acceptValuesFrom","TrackedValue","_it","_on","trackValue","initial","ContextKey__symbol","ContextKey","ContextSeedKey","seedKey","seeder","seed","isEmpty","byDefault","ContextKeyError","message","contextValueSpec","spec","byProvider","withDeps","a","by","with","deps","map","dep","isConstant","viaAlias","via","ctx","asInstance","selfInstance","as","toAsInstance","Type","DepType","TypeError","ContextValues","ContextRegistry","_initial","_seeding","provide","_seeds","seeding","factory","cache","newValues","_nonCachedValues","registry","Values","cached","constructed","defaultUsed","findSeed","valueOpts","or","defaultProvider","defaultValue","grow","growValue","other","combine","ContextUpSeeder","provider","_providers","providers","indexOf","concat","providersTracker","dig","prov","toUpSrcKeeper","flatUpSources","upSrcKeepers","first","second","src","isUpSrcKeeper","ContextSeedUpKey","ContextUpKeyUpKey","_key","ContextUpKey","FnContextKey","upKey","createUpKey","delegated","fn","SimpleContextSeeder","splice","sourceValues","flatMap","SimpleSeedKey","SimpleContextKey","SingleContextKey","itsLast","filter","DefaultNaming","nsAlias","local","ns","alias","default__naming","html__naming","NamespaceDef","url","aliases","naming","applyAlias","isQualifiedName","isNameAndNamespace","compareNames","compareStrings","firstName","firstUrl","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","RenderScheduleConfig","options","win","node","window","ownerDocument","defaultView","messages","error","console","ScheduledRenderQueue","schedule","replace","renders","render","pull","ScheduledRenderQ__symbol","ScheduledRenderQ","q","ref","doSchedule","queue","config","execution","postpone","postponed","reset","suspend","exec","resume","scheduled","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","nextQueue","nextEnqueued","e","animationRenderQueues","WeakMap","defaultRenderScheduler","existing","task","requestAnimationFrame","replacement","newRenderSchedule","hthvItem","$","n","t","v","x","p","pl","addParam","param","nextInItem","input","c","s","d","delimiterOf","datePattern","parseDateTime","out","substring","match","parseNone","itemParser","named","tagged","extra","parseQuotedString","unquoted","quotedStringParser","parseAngleBrackets","angleBracketsParser","parseExtra","tag","extraItem","nextInComment","spacesParser","start","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParserOpts","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","isReadonlyArray","isNotEmptyArray","isCombinator","normalizeStypSelector","selector","normalizeKey","normalized","combinator","prevCombinator","part","normalizeStypSelectorPart","classes","sort","normalizeClasses","u","subs","isSubSelectorsArray","normalizeSubSelector","normalizeSubSelectors","isPseudoSubSelector","normalizeQualifiers","sub","prefix","params","qualifiers","exposeQualifier","noQualifiers","qualifier","eqIdx","exposed","lastExposed","split","classesMatch","query","qClass","find","mClass","namesEqual","StypRule","properties","rules","StypRuleList","Rules","list","ruleMatches","buildList","filterArray","ruleSet","added","removed","rule","valuesProvider","stypQuery","stypSelectorMatches","grabRules","noStypRules","stypRules","rulesByList","rulesFromSource","_rules","rulesByValue","evalRules","sourceSupply","clear","then","resolution","reportExistingRules","asyncRules"],"mappings":"AAQA,MAAaA,EAAiCC,OAAO,aAKxCC,EAA6CD,OAAO,0BAoBjE,MAAsBE,UAK4CC,SAoBhEC,UAAUC,GACR,MAAyB,mBAAXA,GAAyBN,KAAoBM,EAsB7DD,UAAyBE,GACvB,OAAIJ,EAASK,GAAGD,GACPA,EAEFE,EAAUC,GAAgBA,EAAOH,KAwG5C,MAAMI,EAAqCC,GAAaA,EA4BxD,SAAgBH,EACZI,EACAC,EAAoC,KAAMD,EAASF,KAGrD,MAAMI,MAAgBA,EAKtB,OAHAA,EAAOf,GAAoBU,GAAUG,EAASH,GAC9CK,EAAOb,GAAgCY,EAEhCC,EC7NT,MAAaC,EAAmCf,OAAO,eAWvD,MAAsBgB,EAyBpBZ,UAAUC,GACR,MAAyB,iBAAXA,GAAuBU,KAAsBV,EAW7DD,WAAca,GACZ,OAAID,EAAWT,GAAMU,GACZA,EAAQF,GAEVE,EAWTb,aAAgBa,GACd,OAAID,EAAWT,GAAMU,GACZA,EAEF,CACLb,EAAGJ,OAAOkB,kBACFD,KCxEd,SAuQgBE,KAAeC,GAwB7B,OAAO,YAAwBC,GAC7B,OAAOL,EAAWM,IAvBpB,SAASV,EAASW,EAAaC,GAE7B,MAAMC,EAAML,EAAIM,OAEhB,OAAIH,EAAME,EAEHvB,EAASK,GAAGiB,GAGVA,EAAKzB,IAAkB,YAAwBsB,GACpD,OAAOT,EAASW,EAAM,EAAGH,EAAIG,GAAKI,MAAMC,KAAMP,OAHvCT,EAASW,EAAM,EAAGH,EAAIG,GAAKM,KAAK,KAAML,IAQ5CtB,EAASK,GAAGiB,GAIVA,EAAKvB,KAHHuB,EAOaZ,CAAS,EAAGQ,EAAI,GAAGO,MAAMC,KAAMP,MCzRzD,SAAgBS,EAAQxB,GACtB,OAAOA,ECHT,SAAgByB,KCEhB,SAAgBC,EAAa1B,GAC3B,OAAgB,MAATA,ECDT,SAAgB2B,EAAiB3B,GAC/B,MAAO,IAAMA,ECcf,SAAgB4B,KAA4Cb,GAC1D,OAAOb,EAASC,GAAUA,EAAOkB,WAAMQ,EAAWd,GAAO,IAAMA,GCoBjE,SAAgBe,EAA+BC,GAC7C,OAAO7B,EACHC,KACEL,CAACJ,OAAOkB,UAAS,IC9CzB,UAIImB,EACA5B,GACF,IAAK,MAAM6B,KAAQD,QACVrB,EAAWqB,MACdnC,EAASK,GAAG+B,GACNA,EAAKvC,GAAkBU,GACtBA,EAAyC6B,IDqCvCC,CAAYF,EAAO5B,KAG9B,MACEL,CAACJ,OAAOkB,UAAS,ICrCzB,UAAqCmB,GACnC,IAAK,MAAMC,KAAQD,QACVrB,EAAWqB,MACdnC,EAASK,GAAG+B,GACNA,EAAKrC,KACLqC,GDiCGE,CAAUH,MEpD3B,MA6BMI,EAAoB,CACxBrC,CAACW,QAAqBoB,EACtB/B,EAAGJ,OAAOkB,eAGZ,SAASwB,IACP,OAAOD,EAGT,MAAME,EAAuDnC,EAASkC,EAAOA,GAO7E,SAAgBE,IACd,OAAOD,ECrBT,SAAgBE,EAAexC,GAC7B,MAAO,WAAYA,ECErB,SAAgByC,EAAiBC,GAC/B,MAAO,YAAaA,EClBtB,SAAgBC,EAAeD,GAC7B,OAAOA,EAAS/C,OAAOkB,YAoCzB,SAAgB+B,EACZC,EACAC,GAEF,MAAMJ,EAAwB,CAC5B3C,CAACJ,OAAOkB,UAAWgC,GAGrB,IAAKC,EACH,OAAOJ,EAGT,MAAMK,EAAaL,EAInB,OAFAK,EAAWD,QAAUA,EAEdC,EChDT,SAAgBC,EAAaC,GAC3B,GAAIT,EAAYS,GACd,OAAOC,EAAaD,GAEtB,GAAIR,EAAcQ,GAAS,CAEzB,MAAME,EAAWF,EAAOH,UAExB,OAAOF,EAAO,IAAMD,EAAYQ,IAElC,OAAOD,EAAa,IAAID,IAU1B,SAAgBC,EAAgBE,GAC9B,OAAOR,GACH,YAIE,IAAK,IAAIS,EAFGD,EAAM/B,OAEC,EAAGgC,GAAK,IAAKA,QACxBD,EAAMC,MC/BtB,SAAgBC,EAAWZ,EAAuBa,GAChD,IAAK,MAAMC,KAAWd,EACpBa,EAAOC,GA2CX,SAAgBC,EAAYf,GAC1B,OAAOC,EAAYD,GAAUgB,OAAOzD,MA4CtC,SAAgB0D,EACZjB,EACAkB,EACAC,GAEF,IAAIC,EAAUD,EAEd,IAAK,MAAML,KAAWd,EACpBoB,EAAUF,EAAQE,EAASN,GAG7B,OAAOM,ECjHT,SAgQgBC,EACZC,KACGjD,GAML,OAJkDD,EAC9CiB,EAASiC,MACNjD,EAEAkD,GCxQT,SA6BgBC,EAAYjB,EAAqBkB,GAC/C,OAAOvB,GAAO,YACZ,IAAK,MAAMY,KAAWP,EAChBkB,EAAKX,WACDA,MAiBd,SAAgBY,EAAgBnB,EAAqBoB,GACnD,OAAOzB,GAAO,YACZ,IAAK,MAAMY,KAAWP,QACboB,EAAQb,MAcrB,SAAgBc,EAAYrB,EAAqBoB,GAC/C,OAAOzB,GAAO,YACZ,IAAK,MAAMY,KAAWP,QACdoB,EAAQb,MCzDpB,MAAMe,EAAgD,CACpD,QACA,SACA,UACA,UACA,MACA,SACA,WAQF,MAAsBC,EAOpBzE,cACE,OAAO0E,EAWT1E,UAAakD,GACX,OAAOsB,EAAYG,MAAMC,GAAQA,KAAQ1B,GAsB3ClD,UAAakD,GACX,OAAIuB,EAAUtE,GAAG+C,GACRA,EAEFuB,EAAUI,KAAK3B,GAYxBlD,YAAekD,GACb,OAAO4B,EAAK,IAAM5B,EAAQ,IAAMD,EAAUC,IAgB5ClD,MAAMoE,GACJ,OHhEJ,SAA4BzB,EAAuByB,GACjD,IAAK,MAAMX,KAAWd,EACpB,IAAKyB,EAAKX,GACR,OAAO,EAGX,OAAO,EG0DEsB,CAASvD,KAAM4C,GA8BxBpE,OAAOoE,GACL,OAAOU,EACH,IAAMX,EAAS3C,KAAM4C,GACrB,IAAMD,EAAS3C,KAAKuB,UAAWqB,IAgBrCpE,QAAWsE,GACT,OAAOQ,EACH,IAAMT,EAAU7C,KAAM8C,GACtB,IAAMD,EAAU7C,KAAKuB,UAAWU,GAAWR,EAAUqB,EAAQb,MAWnEzD,QAAQwD,GACND,EAAQ/B,KAAMgC,GAchBxD,IAAOsE,GACL,OAAOQ,EACH,IAAMP,EAAM/C,KAAM8C,GAClB,IAAMC,EAAM/C,KAAKuB,UAAWuB,IAelCtE,OAAU6D,EAAqCC,GAC7C,OAAOF,EAAapC,KAAMqC,EAASC,GAUrC9D,UAEE,MAAMgF,EAAWxD,KAEjB,OAAOsD,EAAK,IAAM3B,EAAa,IAAI6B,IAAY,IAAMxD,MAiPvDxB,QAAWgB,GAET,MAAMkD,EAAOF,EAEb,OAAOc,EAAK,IAAMZ,EAAK1C,QAASR,KAKpC,MAAMiE,UAAaR,EAEjBzE,EAAEJ,OAAOkB,aAETd,UACE,OAAOwB,MAKX,MAAMkD,EAAqB,IAAIO,EAE/B,SAASH,EAAQhC,EAA4BC,GAiB3C,OAAO,IAfP,cAAuB0B,EAErBzE,CAACJ,OAAOkB,YACN,OAAO8B,EAAYE,KAGrB9C,UACE,OAAK+C,EAGE0B,EAAUI,KAAKhC,EAAO,IAAMD,EAAYG,KAAY,IAAMvB,OAFxD0D,MAAMnC,YC5drB,SAAgBoC,EAAa9B,GAC3B,OAAOR,GACH,YACE,IAAK,IAAIS,EAAI,EAAGA,EAAID,EAAM/B,SAAUgC,QAC5BD,EAAMC,KAGhB,IAAMH,EAAaE,IAGzB,MAAMqB,EAAgC,CAEpC1E,EAAEJ,OAAOkB,cAETd,UAAY,OAAOwB,aCjBR4D,EAAmCxF,OAAO,eA4CvD,SAAgByF,EAA+BnF,GAC7C,OAAOkF,KAAsBlF,EC1C/B,MAAsBoF,EAyCpBtF,MAAMuF,GAEJ,OADAA,EAAQC,QAAQC,GAAUjE,KAAKkE,IAAID,IAC5BjE,MAYX,SAAgBmE,EAAYD,EAA0C/D,GAEpE,IAAI6D,EACAI,EAAiCH,IACnCD,EAAUK,GAAYA,EAASJ,GAC/BG,EAASjE,EACT+D,EAAID,IAGND,EAAUK,IAER,MAAMzE,EAAOwE,EAEbA,EAASH,IACPrE,EAAKqE,GACLI,EAASJ,KAsBb,OAAO,IAlBP,cAAqBH,EAEnBQ,YACE,OAAOF,IAAWjE,EAGpB3B,IAAIyF,GAEF,OADAG,EAAOH,GACAjE,KAGTxB,QAAQ6F,GAEN,OADAL,EAAQK,GACDrE,OAQb,MAAMuE,UAAiBT,EAErBQ,YACE,OAAO,EAGT9F,MACE,OAAOwB,KAGTxB,QAAQ6F,GAEN,OADAA,IACOrE,MAKX,MAAMwE,EACY,IAAID,EAStB,SAAgBE,IACd,OAAOD,ECdT,SAAgBE,EAA+BC,GAE7C,IAAIC,EA6BJ,OAvBEA,EADsB,mBAAbD,EACC,CACRE,OAAQV,IACR3F,QAAQsG,KAAaC,GACnBJ,KAAYI,KAIN,CACRF,OAAQF,EAASE,QAAUV,IAC3B3F,QAAQwG,KAAYD,GACb/E,KAAK6E,OAAOP,OAGfK,EAASM,QAAQD,KAAYD,KAQrCH,EAAQC,OAAOb,QAAQ,IAAMY,EAAQK,QAAU9E,GAExCyE,QC/IIM,EAAgC9G,OAAO,YA2CpD,SAAgB+G,EAA+BzG,GAC7C,OAAOwG,KAAmBxG,EClD5B,SAAgB0G,EACZC,GAEF,OAAOV,GAAYU,EAAS,CAC1BR,OAAQF,EAASE,OACjBI,QAAS,CAACD,KAAYD,KACpBJ,EAASM,QAAQD,KAAYD,GAC7BJ,EAASE,OAAOX,SCQtB,MAAaoB,EAAb9G,cAKmBwB,WAAQ,IAAIuF,IAOpBvF,UAyDX,SACIwF,GAGF,IAAIC,EAIJ,SAASC,EAAiBX,GAExB,IAAIY,EAAkBH,EACtB,MAAMI,EAAgB,GAEtBH,EAkBA,SAAuBI,GACrBD,EAASE,KAAKD,IAjBhB,IACE,OAAU,CACRF,EAAkBI,EAAaJ,EAAiBZ,GAEhD,MAAMc,EAAYD,EAASI,QAE3B,IAAKH,EACH,MAGFd,EAAQc,WAGVJ,EAAOC,IAtBX,MAAO,IAAIX,IAAUU,EAAKV,GA/DyBkB,CAAoBjG,KAAKkG,OAK5EC,WACE,OAAOnG,KAAKkG,MAAMC,KAGpB3H,CAAC0G,GAAiBP,GAChB,OAAO3E,KAAKoG,GAAGzB,GAcjBnG,GAAGmG,GAED,MAAMC,EAAUF,EAAcC,GAI9B,OAFA3E,KAAKkG,MAAMG,IAAIzB,GAERA,EAAQC,OAAOb,QAAQ,IAAMhE,KAAKkG,MAAMI,OAAO1B,IAYxDpG,KAAKyF,GAEH,OADAjE,KAAKkG,MAAMK,QAAQ,EAAG1B,OAAAA,KAAaA,EAAOX,IAAID,IACvCjE,MAkDX,SAAS+F,EACLP,EACAT,GAGF,MAAMyB,EAAiD,GAEvD,IAAK,MAAM7B,KAAYa,EAAW,CAEhC,MAAM7F,EAAM6G,EAAmB1G,OAE/B0G,EAAmBV,KAAKnB,GAExB,MAAMK,EAAoC,CACxCxG,YAAYiI,GACVD,EAAmB7G,GAAO+E,EAAc,CACtCG,OAAQF,EAASE,OACjBrG,QAAQsG,KAAa4B,GACnBD,KAAqBC,QAM7B/B,EAASM,QAAQD,KAAYD,GAG/B,OAAOyB,EClJT,SAAgBG,EACZtB,GAGF,MAAMuB,EAAS,IAAItB,EACnB,IAAIuB,EACAC,EAEJ,OAAOnC,IA+BL,GA9BKiC,EAAOT,OACVW,EAAgB,GAChBD,EAAe1C,EAAY,IAAM2C,OAAgBvG,GAEjD8E,EAAS,CACPR,OAAQgC,EACRrI,QAAQuI,KAAShC,GACX+B,IACEF,EAAOT,KAGTW,OAAgBvG,EAIhBuG,EAAchB,KAAKf,IAGvB6B,EAAOnB,QAAQV,OAKrBJ,EAASE,OAAOmC,MAAMH,GACtBD,EAAOR,GAAGzB,GAAUX,QAASC,IACtB2C,EAAOT,MACVU,EAAa3C,IAAID,KAIjB6C,EAAe,CAGjB,MAAMG,EAAa,IAAI3B,EAEvB2B,EAAWb,GAAGzB,GACdmC,EAAcP,QAAQxB,GAASkC,EAAWxB,QAAQV,MC9CxD,SAAgBmC,EACZ7B,EACAR,GAEF,OAAOF,IACLA,EAASE,OAAOmC,MAAMnC,GACtBQ,EAASV,ICcb,MAAsBwC,UAAiC5I,SAErD2G,IAAKA,KACH,OAAOlF,KAMToF,WACE,OAAOgC,GAAUhC,EAAKpF,OAUxBxB,QAAQqG,GACN,OAAOuC,GAAUF,EAAQlH,KAAM6E,IAajCrG,IACI6I,GAEF,OAAOD,GAAUT,EAAM3G,KAAKsH,KAAKD,KAiBnC7I,KACI6I,GAEF,OAAOD,GAAWzC,IAEhB,IAAI4C,EAAe9C,IAEnBzE,KAAK,CACH6E,OAAQF,EAASE,OACjBrG,QAAQsG,KAAaC,GAEnB,MAAMyC,EAAaD,EACbE,EAAYJ,KAAWtC,GAE7B,IACEwC,EAAeE,EACTC,GAAWD,EAAXC,CAAsB,CACtB7C,OAAQV,IAAc6C,MAAMrC,EAASE,QACrCrG,QAAQwG,KAAY2C,GAClBhD,EAASM,QAAQD,KAAY2C,MAG/BlD,YAEN+C,EAAWtD,YAerB1F,QAAQoJ,GAEN,IAAIC,EAAiBpD,IACrB,MAAMqD,EAAe9H,KAAK,IAAI+E,KAE5B,MAAMyC,EAAaK,EAEnB,IACEA,EAAiBD,KAAW7C,IAAUN,YAEtC+C,EAAWtD,SAIf,OAAOC,EAAYF,IACjB4D,EAAe3D,IAAID,GACnB6D,EAAa5D,IAAID,KAChB+C,MAAMc,GAYXtJ,QACE,OAAO4I,GAAUT,EAAM3G,OAybzBxB,QAAQgB,GACN,OAAO4H,GAAUT,EAAO3G,KAAa+H,SAASvI,KA0bhDhB,SAASgB,GAEP,MAAMkD,EAAOnD,EAEb,OAAO6H,GAAUzC,GACb3E,KAAK,CACH6E,OAAQF,EAASE,OACjBrG,QAAQwG,KAAYD,GAClBrC,KACOlD,EACH,IAAIwI,IAAuBrD,EAASM,QAAQD,KAAYgD,GAF5DtF,IAGKqC,QA8BjB,SAAgBqC,GACZ/B,GAGF,MAAM4C,EAAYtD,IAEhB,MAAMC,EAAUF,EAAcC,IACxBE,OAAEA,GAAWD,EAMnB,OAJKC,EAAOP,OACVe,EAAST,GAGJC,GAKT,OAFAqD,OAAOC,eAAeF,EAASd,EAAQiB,WAEhCH,EAYT,SAAgBP,GAA4BW,GAE1C,MAAMJ,EAAU9C,EAAckD,GAAYA,EAASnD,GAAmBmD,EAASzE,GAE/E,OAAIqE,aAAmBd,EACdc,EAGFb,GAAUa,EAAQK,KAAKD,IAQhC,MAAaE,GACKnB,GAAU,EAAGvC,OAAAA,KAAaA,EAAOX,OCzkCnD,MAAasE,GAOXhK,YAAYiK,GACVzI,KAAK0I,QAAUD,EAYjBjK,IAAqB6I,GACnB,OAAOrH,KAAKsH,KAAKD,GAASV,QAgB5BnI,KAAsB6I,GACpB,OAAOsB,GAAc3I,KAAK0I,QAAQpB,KAAK,IAAIvC,IAAU4D,GAActB,KAAWtC,MAybhFvG,QAAQgB,GACN,OAAQQ,KAAa+H,SAASvI,GAAKmH,QA0brCnI,SAASgB,GACP,OAAOmJ,GAAe3I,KAAK0I,QAAgBX,SAASvI,KAgBxD,MAAsBoJ,WAAoCzB,EAExDvD,IAAKA,KACH,OAAO5D,KAUT6I,WACE,OAAO,IAAIL,GAAexI,MAO5BoF,WACE,OAAO0D,GAAa1D,EAAKpF,OAU3BxB,QAAQqG,GACN,OAAOiE,GAAa5B,EAAQlH,KAAM6E,IAYpCrG,QACE,OAAOsK,GAAanC,EAAM3G,QAoB9B,SAAgB8I,GACZzD,EACA0D,EAA8BC,IAGhC,IAAIC,EACAC,EAAe,EAEnB,MAAMC,EAAexE,IAEnB,IAAIyE,EAAiEjJ,EACrE,MAAMyE,EAAUF,EAAcC,GAE9B,GAAIC,EAAQC,OAAOP,MACjB,OAAOM,EAAQC,OAGjB,MAAMA,EAASV,IAAc6C,MAAMpC,EAAQC,QAC3C,IAAIwE,GAAW,EA+Bf,OA7BAhE,EAAS,CACPR,OAAAA,EACArG,QAAQwG,KAAYD,GAClBsE,GAAW,EACXJ,EAAYlE,EACZqE,EAAKpE,KAAYD,QAGnBmE,EAEGrE,EAAOP,QAAS+E,IACnBzE,EAAQK,QACJ,CACEzG,YAAYqH,GACVuD,EAAO,CAACtE,KAAaC,IAAUc,KAAad,QAG5CkE,IAAcA,EAAYF,MAElCK,EAAO,CAACpE,KAAYD,IAAUH,EAAQK,QAAQD,KAAYD,IAG5DF,EAAOb,QAAQC,MACNiF,IACLD,OAAY1I,GAEdqE,EAAQC,OAAOX,IAAID,KAGdY,GAKT,OAFAqD,OAAOC,eAAegB,EAAYP,GAAWR,WAEtCe,EAkCT,SAAgBR,GACZN,EACAU,GAEF,IAAKlF,EAAcwE,GACjB,OAyBJ,SACIiB,EACAP,GAEF,OAAOD,GAAanE,GAAY2E,EAAOpE,GAAiBP,GAAWoE,GA7B1DQ,CAAUlB,EAAUU,GAG7B,MAAMI,EAAad,EAASzE,GAE5B,OAAIuF,aAAsBP,GACjBO,EAGFL,GAAaK,EAAWb,KAAKD,IA+BtC,SAAgBmB,MAA6BzE,GAC3C,OAAO+D,GAAa,IAAM3E,IAAe9D,EAAc0E,IAQzD,MAAa0E,GACKX,GAAa,EAAGjE,OAAAA,KAAaA,EAAOX,OAEtD,SAAS8E,KACP,MAAM,IAAIU,MAAM,qBC/nClB,MAAsBC,WAAoCxC,EAMxD/B,WACE,OAAOwE,GAAaxE,EAAKpF,OAU3BxB,QAAQqG,GACN,OAAO+E,GAAa1C,EAAQlH,KAAM6E,IASpCgF,cACE,OAAOD,GAAa,CAChBE,EACAC,IAEU,MAARA,EACK/J,KAAK8J,GAAU,GAEJ,iBAATC,GAAqC,MAAhBA,EAAKF,QAC5B7J,KAAK8J,iCAAeC,IAAMF,SAAS,KAErC7J,KAAK8J,EAAUC,IAS1BC,cACE,OAAOJ,GAAa,CAChBE,EACAC,KAGF,MAAMpF,EAAWD,EAAcoF,GAE/B,OAAO9J,KACH,CACE6E,OAAQF,EAASE,OACjBrG,QAAQwG,EAASD,GACfA,EAAMkF,iBACNtF,EAASM,QAAQD,EAASD,KAG9BgF,KAWRG,WACE,OAAON,GAAa,CAChBE,EACAC,KAGF,MAAMpF,EAAWD,EAAcoF,GAE/B,OAAO9J,KACH,CACE6E,OAAQF,EAASE,OACjBrG,QAAQwG,EAASD,GACfA,EAAMoF,kBACNxF,EAASM,QAAQD,EAASD,KAG9BgF,KAURK,WACE,OAAOR,GAAa,CAChBE,EACAC,KAGF,MAAMpF,EAAWD,EAAcoF,GAE/B,OAAO9J,KACH,CACE6E,OAAQF,EAASE,OACjBrG,QAAQwG,EAASD,GACfA,EAAMsF,2BACN1F,EAASM,QAAQD,EAASD,KAG9BgF,KAURO,cACE,OAAOV,GAAa,CAChBE,EACAC,IAEU,MAARA,EACK/J,KAAK8J,EAAU,CAAEQ,SAAS,IAEf,kBAATP,EACF/J,KAAK8J,EAAU,CAAED,QAASE,EAAMO,SAAS,IAE9B,MAAhBP,EAAKO,QACAtK,KAAK8J,iCAAeC,IAAMO,SAAS,KAErCtK,KAAK8J,EAAUC,KA8B5B,SAAgBH,GACZvE,GAOF,MAAMkF,GAEET,EACAC,KAGF,MAAMpF,EAAWD,EAAcoF,GAI/B,OAFAzE,EAASV,EAAUoF,GAEZpF,EAASE,QAMtB,OAFAqD,OAAOC,eAAeoC,EAAYZ,GAAWvB,WAEtCmC,ECvNT,MAIMC,GAA8C,CAClDC,YAAatK,GAQf,MAAauK,GAYXlM,YAAYC,GACVuB,KAAK2K,QAAUlM,EAiBjBD,GAAoBoM,GAClB,OAAOhB,GAAgB,CAACE,EAAUC,KAGhC,MAAMc,EAA6B9F,GAAS+E,EAAS7E,QAAQuF,GAAiBzF,GAE9E/E,KAAK2K,QAAQG,iBAAiBF,EAAMC,EAAad,GACjDD,EAASjF,OAAOb,QAAQ,IAAMhE,KAAK2K,QAAQI,oBAAoBH,EAAMC,MAczErM,SAASuG,GACP,OAAO/E,KAAK2K,QAAQK,cAAcjG,WCrDtC,MAAakG,WAAsC3F,EAAnD9G,kCAOWwB,QAAKoH,GAAazC,GAAYjB,MAAM0C,GAAGzB,IAEvC3E,SAAgCA,KAAKoG,ICLhD,SAAgB8E,GACZC,GAGF,MAAMC,EAAOlD,OAAOkD,KAAKD,GAEzB,OAAKC,EAAKtL,OAIHgJ,IAEP,SACInE,GAGF,MAAM0G,EAAW,IAAI/F,EACfT,EAASwG,EAASjF,GAAGzB,GAC3B,IAAIc,EAAmBtF,EACvB,MAAMjB,EAAsD,GAE5DkM,EAAK7E,SAML,SAAkB+E,GAChBzG,EAAOmC,MAAMmE,EAAQG,GAAK1H,GAAoB,IAAImB,KAChD7F,EAAOoM,GAAOvG,EACdU,MACCuB,MAAMnC,OARNA,EAAOP,QACVmB,EAAO,IAAM4F,EAAS5F,KAAKvG,OAW/B,WAEE,MAAMA,EAAsD,GAM5D,OAJAkM,EAAK7E,QAAQ+E,GACT3C,GAAcwC,EAAQG,IACjBlG,KAAK,IAAIL,IAAU7F,EAAOoM,GAAkBvG,IAE9C,CAAC7F,MAjCyCyH,QAH1C8C,GCPX,SAAgB8B,MAA8BJ,GAC5C,OAAKA,EAAQrL,OAINgJ,IAEP,SAA0BnE,GAExB,MAAM0G,EAAW,IAAI/F,EACfT,EAASwG,EAASjF,GAAGzB,GAC3B,IAAIc,EAAmBtF,EACvB,MAAMjB,EAAc,GAEpBiM,EAAQ5E,SAMR,SAAkB7E,EAAwB8J,GACxC3G,EAAOmC,MAAMtF,EAAOkC,GAAoB,IAAImB,KAC1C7F,EAAOsM,GAASzG,EAChBU,MACCuB,MAAMnC,OARNA,EAAOP,QACVmB,EAAO,IAAM4F,EAAS5F,QAAQvG,OAWlC,WAEE,MAAMA,EAAc,GAMpB,OAJAiM,EAAQ5E,QAAQ7E,GACZiH,GAAcjH,GACT0D,KAAK,IAAIL,IAAU7F,EAAO4G,KAAKf,KAEjC7F,KA/B0CyH,QAH1C8C,GCFX,SAAgBgC,MAA0BC,GACxC,OAAKA,EAAU5L,OAIRsH,GAAazC,IAElB,MAAME,OAAEA,GAAWF,EACnB,IAAIgH,EAAWD,EAAU5L,OACzB,MAAM8L,EAAkB3H,MACf0H,GACL9G,EAAOX,IAAID,IAGTgB,EAAU,CAACD,KAAsCD,KACrDJ,EAASM,QAAQD,KAAYD,IAG/B2G,EAAUnF,QACN8B,GAAYX,GAAWW,EAAXX,CAAqB,CAC/B7C,OAAQV,EAAYyH,GAAgB5E,MAAMnC,GAC1CI,QAAAA,OAGL0B,QAtBM4B,YCyBKsD,GAAUC,GACxB,OAAOC,MAAMC,QAAQF,GAAQA,EAAO,CAACA,MJvB3B5G,EKZZ,MAAM+G,GAKJzN,YAA6B0N,GAAAlM,WAAAkM,EAHpBlM,aAAU,IAAIiL,GACNjL,aAAU,IAAImM,IAG7BnM,KAAKoM,QAAQhG,GAAG,CAAC0F,EAAMO,EAAUC,KAG/B,MAAMhB,GAFNQ,EAAOD,GAAUC,IAEA,GACXS,EAASvM,KAAKwM,QAAQ9M,IAAI4L,GAE5BiB,GACFA,EAAOH,QAAQ3G,KAAKqG,EAAKW,MAAM,GAAIJ,EAAUC,KAKnD9N,GAAGmG,GAED,MAAM+H,EAAQ1M,KACR6E,EAAS7E,KAAKoM,QAAQhG,GAAGzB,GAE/B,OAAOR,EAAYF,IACjBY,EAAOX,IAAID,GACXyI,EAAMC,iBACL3F,MAAMnC,GASXrG,KAAK8M,EAAkBsB,GAErB,MAAMC,EAAQ7M,KAAKwM,QAAQ9M,IAAI4L,GAE/B,GAAIuB,GAASD,EACX,OAAOC,EAGT,MAAMC,EAAU,IAAIb,GAAU,IAAMjM,KAAK+M,QAAQzB,IAIjD,OAFAtL,KAAKwM,QAAQQ,IAAI1B,EAAKwB,GAEfA,EAGTtO,KAAKyF,GACH,IAAK,MAAMsI,KAAUvM,KAAKwM,QAAQS,SAChCV,EAAOW,KAAKjJ,GAEdjE,KAAKoM,QAAQc,KAAKjJ,GAGZzF,QAAQ8M,GACdtL,KAAKwM,QAAQlG,OAAOgF,GACpBtL,KAAK2M,eAGCnO,gBACDwB,KAAKwM,QAAQrG,MAAQnG,KAAKoM,QAAQjG,MAAQ,GAC7CnG,KAAKkM,SAMX,MAAMiB,GAAN3O,cAEmBwB,WAAQ,IAAIiM,GAAU9L,GAEvC3B,GAAGsN,EAA4BnH,GAC7B,OAAO3E,KAAKoN,OAAOtB,GAAM1F,GAAGzB,GAG9BnG,KAAQsN,EAA4BO,EAAaC,GAC/CtM,KAAKqN,MAAMjB,QAAQ3G,KAAKqG,EAAMO,EAAUC,GAG1C9N,KAAKsN,EAA4B7H,GAE/B,MAAMyI,EAAQ1M,KAAKoN,OAAOtB,GAAM,GAE5BY,GACFA,EAAMQ,KAAKjJ,GAQPzF,OAAOsN,EAA4Bc,GAEzC,IAAIF,EAAQ1M,KAAKqN,MAEjB,IAAK,MAAM/B,KAAOQ,EAAM,CAEtB,MAAMS,EAASG,EAAMY,KAAKhC,EAAKsB,GAE/B,IAAKL,EACH,OAGFG,EAAQH,EAGV,OAAOG,GAKX,MAAMa,GAcJ/O,YAA6BgP,EAAsCC,GAAtCzN,eAAAwN,EAAsCxN,WAAAyN,EAZ1DzN,aAKQ8L,EAAiBO,EAAaC,KAC7CtM,KAAKwN,UAAU/H,KAAK,IAAIzF,KAAKyN,SAAU5B,GAAUC,IAAQO,EAAUC,IAG5DtM,cACLoH,GAAiCzC,GAAY3E,KAAKwN,UAAUpH,GAAGpG,KAAKyN,MAAO9I,IAM/E+I,eACE,OAAO1N,KAGTkF,IAAKA,KACH,OAAOlF,KAAK2N,SAGdnP,MAAMsN,GAEJ,OADAA,EAAOD,GAAUC,IACPhM,OAGH,IAAIyN,GAAgBvN,KAAKwN,UAAW,IAAIxN,KAAKyN,SAAU3B,IAFrD9L,KAKXxB,KAAKyF,GACHjE,KAAKwN,UAAUN,KAAKlN,KAAKyN,MAAOxJ,IAepC,MAAa2J,GAAbpP,cAKWwB,cAA4B,IAAIuN,GAAgB,IAAIJ,GAAY,IAOzEQ,eACE,OAAO3N,KAAK0N,SAASC,SAGvBzI,IAAKA,KACH,OAAOlF,KAAK2N,SAcdE,aAME,OAAO7N,KAAK0N,SAASG,OAUvBrP,MAAMsN,GAEJ,MAAMgC,EAAa9N,KAAK0N,SAASK,MAAMjC,GAEvC,OAAOgC,IAAe9N,KAAK0N,SAAW1N,KAAO8N,EAU/CtP,KAAKyF,GACHjE,KAAK0N,SAASR,KAAKjJ,ICxNvB,MAAsB+J,GAAtBxP,cAKUwB,SAAMyE,IAcLzE,UAAwB8I,GAC7BnE,IAAY3E,OAAAA,KAAKoG,GA4Hd,CACLvB,QAHAoJ,EA1HsCtJ,GA6HhBE,OACtBrG,QAAQwG,EAASqH,GACf4B,EAAchJ,QACV,CACEzG,YAAYiI,GACVzB,EAAQyF,YAAYyD,GAAkBzH,EAAkByH,MAG5D7B,MAZV,IACI4B,GAzHE,IAAM,CAACjO,KAAKyC,KAGhByC,IAAKA,KACH,OAAOlF,KAAKoG,GAGdxC,IAAKA,KACH,OAAO5D,KAAKmO,KA4Cd3P,GACI6J,EACAhB,GAGF,MAAM+G,EAAOpO,KAIb,GAFAA,KAAKqO,SAEAhH,EAKE,CAEL,MAAMiH,EAAYjG,EAElBrI,KAAKuO,IAAM7G,GAAW4G,GAAW1G,QAAQ,IAAI7C,KAE3C,MAAMuE,EAASjC,KAAWtC,GAE1B,GAAIuE,EACF,OAAOkF,EAAiBlF,SAdhB,CAEZ,MAAMA,EAASjB,EAEfrI,KAAKuO,IAAMC,EAAiBlF,GAkB9B,OAFAtJ,KAAKuO,IAAIvK,QAAQ,IAAMhE,KAAKuO,IAAM9J,KAE3BzE,KAEP,SAASwO,EAAiBlF,GAIxB,OAFkBzF,EAAcyF,GAAUA,EAAO1F,GAAsB0F,EAAOpE,IAE7DxG,GAAS0P,EAAK3L,GAAK/D,IAaxCF,OAAOyF,GAEL,OADAjE,KAAKuO,IAAIrK,IAAID,GACNjE,MCjJX,MAIMyO,WAAwBT,GAI5BxP,YAAoBkQ,GAClBhL,QADkB1D,SAAA0O,EAFH1O,SAAM,IAAIiL,GAM3B7E,SACE,OAAOpG,KAAK2O,IAAIvI,GAGlB3D,SACE,OAAOzC,KAAK0O,IAGdjM,OAAO/D,GAEL,MAAM4N,EAAWtM,KAAK0O,IAElBpC,IAAa5N,IACfsB,KAAK0O,IAAMhQ,EACXsB,KAAK2O,IAAIlJ,KAAK/G,EAAO4N,IAIzB9N,KAAKyF,GAEH,OADAjE,KAAK2O,IAAIzB,KAAKjJ,GACPjE,MAwBX,SAAgB4O,GAAcC,GAC5B,OAAO,IAAIJ,GAAgBI,SClDhBC,GAAmC1Q,OAAO,qBAcjC2Q,GAqBpBvQ,YAAsB4E,GACpBpD,KAAKoD,KAAOA,EAQd0L,IAAKA,MACH,OAAO9O,KAaTxB,WACE,MAAO,cAAcwB,KAAKoD,eA2ER4L,WAAkCD,GAOtDvQ,YAAY8M,GACV5H,MAAM,GAAG4H,EAAIlI,aAMf6L,cACE,OAAOjP,KAYTxB,KAAgCuL,GAE9B,MAAMmF,OAAEA,EAAMC,KAAEA,GAASpF,EAEzB,OAAOmF,EAAOE,QAAQD,GAAQpF,EAAKsF,UAAU,IAAMF,GAAQA,GCvK/D,MAAaG,WAAwB5F,MAanClL,YAAY8M,EAAgCiE,EAAkB,8BAA8BjE,KAC1F5H,MAAM6L,GACNvP,KAAKsL,IAAMA,GCiOf,SAAgBkE,GACZC,GAEF,GAkEF,SACIA,GAEF,MAAO,OAAQA,EArEXC,CAAWD,GAAO,CACpB,IAAKE,GAA+BF,GAClC,OAAOA,EAGT,MAAMG,EAAEA,EAACC,GAAEA,EAAIC,KAAMC,GAASN,EAE9B,MAAO,CACLG,EAAAA,EACAC,GAAe7K,GACN6K,KAAME,EAAKC,IAAIC,GAAOjL,EAAQtF,IAAIuQ,MAI/C,GA2FF,SACIR,GAEF,MAAO,OAAQA,EA9FXS,CAAsBT,GAAO,CAE/B,MAAMG,EAAEA,EAAGjR,GAAID,GAAU+Q,EAEzB,MAAO,CACLG,EAAAA,EACAC,GAAIxP,EAAc3B,IAGtB,GA2FF,SACI+Q,GAEF,MAAO,QAASA,EA9FZU,CAASV,GAAO,CAElB,MAAMG,EAAEA,EAACQ,IAAEA,GAAQX,EAEnB,MAAO,CACLG,EAAAA,EACAC,GAAGQ,GACMA,EAAI3Q,IAAI0Q,IAIrB,GAyCF,SACIX,GAEF,MAAO,OAAQA,EA5CXa,CAAiCb,GAAO,CAI1C,GA8CJ,SACIA,GAEF,QAAS,MAAOA,GApDVc,CAAmCd,KACrCA,EAyDN,SACIA,GAEF,OAAOvH,+BACFuH,IACHG,EAAGH,EAAKe,KA9DCC,CAAahB,KAEjBE,GAA+BF,GAAO,CAEzC,MAAQe,GAAIE,GAASjB,EAErB,MAAO,CACLG,EAAGH,EAAKG,EACRC,GAAGQ,GACM,IAAIK,EAAKL,IAKtB,MAAQG,GAAIG,EAASb,KAAMC,GAASN,EAEpC,MAAO,CACLG,EAAGH,EAAKG,EACRC,GAAe7K,GACN,IAAI2L,KAAWZ,EAAKC,IAAIC,GAAOjL,EAAQtF,IAAIuQ,MAKxD,MAAM,IAAIW,UAAU,sCAAsCnB,KA6E5D,SAASE,GACLF,GAEF,MAAO,SAAUA,EC7XnB,MAAsBoB,ICgBtB,MAAaC,GAmBXtS,YAAYqQ,GAbK7O,YAAS,IAAImM,IAe1BnM,KAAK+Q,SADQ,MAAXlC,EACc1O,EACY,mBAAZ0O,EACAA,EAEAI,GAAWJ,EAAQnP,IAAIuP,GAc3CzQ,QAAuCiR,GAErC,MAAQG,GAAKpR,CAACsQ,KAAqBG,QAAEA,IAAWY,GAAEA,GAAOL,GAAiBC,IACnEP,GAAUlP,KAAKgR,SAAoB/B,GAE1C,OAAOC,EAAO+B,QAAQpB,GAMhBrR,SAAoByQ,GAE1B,MAAMpC,EAA6C7M,KAAKkR,OAAOxR,IAAIuP,GAEnE,GAAIpC,EACF,OAAOA,EAGT,MAAMqC,EAAwCD,EAAQC,SAEhDiC,EAAmC,CAACjC,EADFlK,GAAWkK,EAAOC,KAAKnK,EAAShF,KAAK+Q,SAAS9B,EAASjK,KAK/F,OAFAhF,KAAKkR,OAAOlE,IAAIiC,EAASkC,GAElBA,EAWT3S,KAAgBwG,EAAcsG,GAE5B,OAAS8F,GAAWpR,KAAKgR,SAAS1F,GAElC,OAAO8F,EAAQpM,GAWjBxG,OAAOwG,EAAcqM,GAEnB,MAAMpE,EAASjN,KAAKsR,UAAUD,GAE9B,OAAmB/F,GACf2B,EAAOvN,IAAIO,KAA6C+E,EAASsG,GAUvE9M,UAAU6S,GAAQ,GAChB,IAAKA,GAASrR,KAAKuR,iBACjB,OAAOvR,KAAKuR,iBAGd,MAAMtE,EAAS,IAAId,IACbqF,EAAWxR,KAEjB,MAAMyR,UAAeZ,GAEnBrS,KAEMA,CAACsQ,IAAqBxD,GACxBvB,GAGF,MACM2H,EAA4BzE,EAAOvN,IAAI4L,GAE7C,GAAc,MAAVoG,EACF,OAAOA,EAGT,MAAOC,EAAaC,GAiBxB,SACI5M,EACAsG,EACAvB,GAGF,MAAOmF,EAAQC,GAmCjB,SACInK,EACAsG,GAGF,MAAM2D,QAAEA,GAAY3D,GACb4D,EAAQkC,GAAWI,EAASR,SAAS/B,GAE5C,GAAIA,IAAY3D,EAGd,MAAO,CAAC4D,EAAQlK,EAAQtF,IAAIuP,IAG9B,MAAO,CAACC,EAAQkC,EAAQpM,IAjDD6M,CAAoB7M,EAASsG,GACpD,IAAIsG,GAAc,EAElB,MAAME,EAEF,CACF9M,QAAAA,EACAkK,OAAAA,EACAC,KAAAA,EACAE,UAAYtF,GAAQ,OAAQA,EACtB,KACA6H,GAAc,EACP7H,EAAKgI,IACVC,IAEF,MAAMC,EAAeD,IAErB,GAAoB,MAAhBC,EACF,MAAM,IAAI3C,GAAgBhE,GAG5B,OAAO2G,IAIXlI,GAAQ,OAAQA,IAClB+H,EAAUC,GAAKhI,EAAKgI,IAGtB,MAAO,CACLzG,EAAI4G,KAAKJ,GACTF,GAtDmCO,CAPnBnS,KAOsCsL,EAAKvB,GAM3D,OAJIsH,IAAUO,GACZ3E,EAAOD,IAAI1B,EAAKqG,GAGXA,GAKX,OAAKN,EAIE,IAAII,EAHFzR,KAAKuR,iBAAmB,IAAIE,EAuEvCjT,OAAO4T,GACL,OAAO,IAAItB,GAAgB,CAAYxF,EAAgCtG,KAErE,MAAOkK,EAAQkC,GAAWpR,KAAKgR,SAAS1F,GAExC,OAAO4D,EAAOmD,QAAQjB,EAAQpM,GAAUoN,EAAMjD,KAAKnK,EAASsG,GAAMtG,MCxNxE,MAAMsN,GAAN9T,cAGmBwB,gBAAkF4O,GAAW,IAE9GpQ,QAAQ+T,GAEN,OADAvS,KAAKwS,WAAW/P,GAAK,IAAIzC,KAAKwS,WAAW/P,GAAI8P,GACtC,KAEL,MAAME,EAAYzS,KAAKwS,WAAW/P,GAC5BoK,EAAQ4F,EAAUC,QAAQH,GAE5B1F,GAAS,IACX7M,KAAKwS,WAAW/P,GAAKgQ,EAAUhG,MAAM,EAAGI,GAAO8F,OAAOF,EAAUhG,MAAMI,EAAQ,MAKpFrO,KAAKwG,EAAc6J,EAA6BrF,MAC9C,OAAOxJ,KAAKqS,QAAQxD,EAqBxB,SACI7J,EACA4N,GAEF,OAAOA,EAAiBzE,KAAKtF,KAAKgK,IAC9BJ,GAAcA,EAAU3S,OAAsByL,MACvCxI,EACCA,EACIY,EAAU8O,GACVK,GAAQA,EAAK9N,IAEjB+N,KAENlK,KAAKnG,KACHsQ,IAT6BxJ,MA1BNyJ,CAAajO,EAAShF,KAAKwS,aAG1DhU,UACE,OAAO,EAGTA,QAAQ0U,EAA0BC,GAChC,OAAO5H,GACH2H,EACAC,GACFtK,KAAKnG,KACHsQ,KA8BR,SAASD,GAAmBK,GAC1B,OAAc,MAAPA,EAAc5J,KAMvB,SAA4B4J,GAC1B,OAAuB,iBAARA,GAAmC,mBAARA,IAAuBvP,EAAcuP,GAP7CC,CAAcD,GAAOzK,GAAcyK,GAAO5J,GAAS4J,GAavF,SAASJ,MAAkC7H,GACzC,OAAO7K,KACAuC,EAAUc,EAAUwH,GAAUjL,IAOvC,MAAMoT,WAA8BtE,GAElCxQ,SACE,OAAO,IAAI8T,IAoBf,MAAMiB,WACMxE,GAMVvQ,YACqBgV,EACRtB,GAIXxO,MAAM8P,EAAKpQ,KAAO,OALCpD,UAAAwT,EACRxT,UAAAkS,EANbjD,cACE,OAAOjP,KAAKwT,KAAKvE,SAwBrB,MAAsBwE,WACV1E,GAoBVvQ,YAAY4E,EAAc6L,GACxBvL,MAAMN,GACNpD,KAAKiP,QAAUA,GAAW,IAAIqE,GAAiBtT,MAUvCxB,YACN0T,GAIF,OAAO,IAAIqB,GAAkBvT,KAAMkS,ICxKvC,MAAawB,WACDD,GAmBVjV,YACI4E,GACA6L,QACEA,EAAOI,UACPA,EAAYlP,GAMV,IAENuD,MAAMN,EAAM6L,GACZjP,KAAKqP,UAAY,CAACrK,EAASsG,IAAQ+D,EAAUrK,EAASsG,UAAiB,MAAM,IAAIgE,GAAgBtP,QACjGA,KAAK2T,MAAQ3T,KAAK4T,YACd7J,GAAQA,EAAKoF,KAAKtG,KAAKgK,IAAI,IAAIrT,KAC7B,GAAIA,EAAIM,OACN,OAAO0J,GAAShK,EAAIA,EAAIM,OAAS,IAGnC,MAAMkS,EAAkB,IAAMxI,GAA+CxJ,KAAKqP,UAC9EtF,EAAK/E,QACLhF,OAGJ,OAAO+J,EAAKsF,UAAU2C,IAAqBA,OAKnDxT,KACIuL,GAOF,IAAI8J,EAOJ,OALA9J,EAAK/E,QAAQtF,IACTM,KAAK2T,MACL,OAAQ5J,EAAO,CAAEgI,GAAe,MAAXhI,EAAKgI,GAAavI,GAASO,EAAKgI,IAAMhI,EAAKgI,SAAOxR,EAF3EwJ,CAGG+J,GAAMD,EAAYC,GAEd,IAAIrU,IAASoU,KAAapU,ICrFrC,MAAMsU,GAANvV,cAEmBwB,gBAA+C,GAEhExB,QAAQ+T,GAEN,OADAvS,KAAKwS,WAAW1M,KAAKyM,GACd,KAEL,MAAM1F,EAAQ7M,KAAKwS,WAAWE,QAAQH,GAElC1F,GAAS,GACX7M,KAAKwS,WAAWwB,OAAOnH,EAAO,IAKpCrO,KAAKwG,EAAc6J,EAA0B5L,EAAUI,K5BahDH,I4BZL,OAAOD,EAAUI,KAAK,CACpBwL,EACAoF,GAAajP,EAAShF,KAAKwS,cAC1B0B,QAAQhU,GAGb1B,QAAQ2Q,GACN,QhCNO/N,EgCMS+N,GhCNahN,OAAO+K,KgCStC1O,QAAQ0U,EAAuBC,GAC7B,OAAOlQ,EAAUI,KAAK,CAAC6P,EAAOC,IAASe,QAAQhU,IAKnD,MAAMiU,WAA2BnF,GAE/BxQ,SACE,OAAO,IAAIuV,IAef,MAAsBK,WAA6CrF,GAUjEvQ,YAAY4E,EAAc6L,GACxBvL,MAAMN,GACNpD,KAAKiP,QAAUA,GAAW,IAAIkF,GAAcnU,OAmBhD,MAAaqU,WACDD,GAgBV5V,YACI4E,GACA6L,QACEA,EAAOI,UACPA,EAAYlP,GAIV,IAENuD,MAAMN,EAAM6L,GACZjP,KAAKqP,UAAYA,EAGnB7Q,KACIuL,GAGF,MAAMrL,EhCrDV,SAA2ByC,GACzB,GAAIF,EAAYE,GACd,OAAOA,EAASA,EAASrB,OAAS,GAEpC,GAAIoB,EAAcC,GAChB,OAAOe,EAASf,EAASI,WAG3B,IAAI6I,EAEJ,IAAK,MAAMnI,KAAWd,EACpBiJ,EAAOnI,EAGT,OAAOmI,EgCuCSkK,CAAQvK,EAAKoF,MAE3B,OAAa,MAATzQ,EACKA,EAGFqL,EAAKsF,UAAU,IAAMrP,KAAKqP,UAAUtF,EAAK/E,QAAShF,QAuF7D,SAASiU,GACLjP,EACAyN,GAEF,OAAOxP,EAAUI,KAAKM,EAAU8O,EAAUzC,IAA2BuC,GAAY,CAACA,MAC7EvC,IAAItD,IACH,GAAIA,EAAM5M,OAAS,EACjB,OAAO4M,EAAM,GAGf,MAAMhL,EAASgL,EAAM,GAAG1H,GAIxB,OAFA0H,EAAM5G,KAAKpE,GAEJA,IAER6S,OAAYnU,GC1OnB,MAEMoU,WCMN,MAmBEhW,KAAK4E,EAAqBqR,GACxB,GAAoB,iBAATrR,EACT,OAAOA,EAGT,MAAOsR,EAAOC,GAAMvR,EAEpB,OAAOuR,EAAGvR,KAAKqR,EAAQE,GAAKD,EAAO1U,QD9BrCxB,WAAW4E,EAAcwR,GACvB,MAAO,GAAGA,KAASxR,KAYvB,MAAayR,OAA6CL,GAS7CM,OAA0CN,GElBvD,MAAaO,GA6BXvW,YAAYwW,KAAgBC,GAC1BjV,KAAKgV,IAAMA,EACXhV,KAAKiV,QAAUA,EAdjBL,YACE,OAAO5U,KAAKiV,QAAQ,IAAM,KA2B5BzW,KAAKoW,EAAexR,EAAc8R,EAAiBL,IACjD,OAAOK,EAAOC,WAAW/R,EAAMwR,EAAO5U,OCX1C,SAAgBoV,GAAgB1W,GAC9B,MAAwB,iBAAVA,GAjBhB,SAAmCA,GACjC,OAAOqN,MAAMC,QAAQtN,IACG,IAAjBA,EAAMoB,QACc,iBAAbpB,EAAM,IACbA,EAAM,aAAcqW,GAaSM,CAAmB3W,GA2DzD,SAAgB4W,GAAapC,EAAsBC,GACjD,GAAqB,iBAAVD,EACT,MAAsB,iBAAXC,EACFoC,GAAerC,EAAOC,GAE1BA,EAAO,GAAG6B,KAGP,EAFCO,GAAerC,EAAOC,EAAO,IAKxC,MAAOqC,GAAaR,IAAKS,IAAcvC,EAEvC,MAAsB,iBAAXC,EACJsC,EAGE,EAFEF,GAAeC,EAAWrC,GAK9BoC,GAAeE,EAAUtC,EAAO,GAAG6B,MAAQO,GAAeC,EAAWrC,EAAO,IAGrF,SAASoC,GAAerC,EAAeC,GACrC,OAAOD,EAAQC,GAAU,EAAID,EAAQC,EAAS,EAAI,ECxGpD,SAAgBuC,KAEd,MAAMC,EAAc,IAAIxJ,IAClByJ,EAAgB,IAAIzJ,IAE1B,OAAO,SAAiBwI,GAEtB,MAAM9H,EAAQ8I,EAAYjW,IAAIiV,EAAGK,KAEjC,GAAInI,EACF,OAAOA,EAGT,MAAMgJ,EAAgBlB,EAAGC,MACzB,IAAIkB,EAAkB,EAEtB,IAAK,MAAMC,IAAa,CAACF,KAAkBlB,EAAGM,SAAU,CAEtD,MAAMe,EAAMJ,EAAclW,IAAIqW,GAE9B,IAAKC,EAGH,OAFAL,EAAY3I,IAAI2H,EAAGK,IAAKe,GACxBH,EAAc5I,IAAI+I,EAAW,GACtBA,EAEJD,IAEHA,EAAkBE,GAItB,MAAMC,EAAYJ,KAAmBC,EAKrC,OAHAH,EAAY3I,IAAI2H,EAAGK,IAAKiB,GACxBL,EAAc5I,IAAI6I,EAAeC,GAE1BG,SC+BEC,GAAuB,CAOlC1X,GAAe2X,EAAiC,IAE9C,IAAIC,EAEJ,MAAO,CACLC,WACE,OAAOF,EAAQE,MAEjBC,aACE,OAAOF,IAAQA,EAAMD,EAAQG,QAAWH,EAAQE,QAqB7BA,EArBgDF,EAAQE,MAuB3DE,eAAiBF,GAEvBG,aAzB2EF,YAqBlED,GAnBrB7X,SAASiY,GACHN,GAAWA,EAAQO,MACrBP,EAAQO,SAASD,GAEjBE,QAAQD,SAASD,OC/G3B,MAiEaG,GAAuB,CAYlCpY,IAEIqY,SACEA,EAAQC,QACRA,EAAU,WAOd,MAAMC,EAA6B,GAEnC,MAAO,CACLF,SAAAA,EACArY,IAAIwY,GACFD,EAAQjR,KAAKkR,IAEfC,KAAI,IACKF,EAAQ/Q,QAEjBxH,QAEE,MAAM2D,EAAOyU,GAAqB/G,GAAG,CAAEgH,SAAAA,EAAUC,QAAAA,IAIjD,OAFAA,EAAQ3U,GAEDA,MAUT+U,GAA2B9Y,OAAO,sBAKxC,MAAM+Y,GAWJ3Y,YAAqC4Y,EAAyBC,GAAzBrX,OAAAoX,EACnCpX,KAAK6W,SAAW7W,KAAKsX,WACrBtX,KAAKqX,IAAMA,GAAO,CAACrX,MAPrBxB,UAAU+Y,EAA6BF,GACrC,OAAQE,EAAcL,MACbK,EAAcL,IAA4B,IAAIC,GAAiBI,EAAOF,IAQjF7Y,IAAIwY,GACFhX,KAAKoX,EAAE/Q,IAAI2Q,GAGLxY,WAAWgZ,GACjBxX,KAAK6W,SAAW,OAEhB,MAAMY,EAAsC,CAC1CD,aACE,OAAOA,GAETE,SAAUC,GAAa3X,KAAKqG,IAAIsR,IAGlC3X,KAAKoX,EAAEP,SAAS,KAEd,MAAM1U,EAAOnC,KAAK4X,QAElBzV,EAAK0V,UACL7X,KAAK8X,KAAKL,GACVtV,EAAK4V,WAIDvZ,KAAKiZ,GACX,OAAU,CAER,MAAMT,EAAShX,KAAKoX,EAAEH,OAEtB,IAAKD,EACH,MAEFA,EAAOS,IAIHjZ,QACN,OAAOwB,KAAKqX,IAAI,GAAKF,GAAiBtH,GAAG7P,KAAKoX,EAAEQ,QAAS5X,KAAKqX,KAGxD7Y,UACNwB,KAAK6W,SAAWW,IACdxX,KAAKgY,UAAYR,EACjBxX,KAAK6W,SAAW,QAIZrY,SACFwB,KAAKgY,UACPhY,KAAKsX,WAAWtX,KAAKgY,WAErBhY,KAAK6W,SAAW7W,KAAKsX,YAa3B,SAAgBW,GACZ9B,GAEF,OAAO+B,IAEL,MAAMV,EAAStB,GAAqBrG,GAAGqI,GACjCC,EAAWhB,GAAiBtH,GAAGsG,EAAQiC,SAASZ,IAASH,IAC/D,IAAIgB,EAAqD,GAEzD,OAAOrB,IAEL,MAAOsB,GAAaD,GACbE,GAAaJ,EAEpB,GAAIG,IAAcC,EAChBF,EAAS,GAAKrB,MACT,CAEL,MAAMwB,EAAeH,EAAW,CAACE,EAAWvB,GAE5CuB,EAAUlS,IAAKoR,IACb,IACEe,EAAa,GAAG,CACdhB,aACE,OAAOA,GAEThZ,SAASmZ,GACPF,EAAUC,SAASC,MAGvB,MAAOc,GACPjB,EAAOd,MAAM+B,MAKnBF,EAAU1B,SAASW,KCrOzB,MAAMkB,OAA2CC,QCwBjD,IAAIC,GDXoEX,GAAsB,CAC5FzZ,UAAS8X,OAAEA,IAET,MAAMuC,EAAWH,GAAsBhZ,IAAI4W,GAE3C,GAAIuC,EACF,OAAOA,EAGT,MAAMT,EAAWxB,GAAqB/G,GAAG,CACvCgH,SAAUiC,GAAQxC,EAAOyC,sBAAsBD,GAC/ChC,QAASkC,GAAeN,GAAsB1L,IAAIsJ,EAAQ0C,KAK5D,OAFAN,GAAsB1L,IAAIsJ,EAAQ8B,GAE3BA,KCoBX,SAAgBa,GAAkB9C,GAChC,OAAOyC,GAAuBzC,yUC1ChC,SAAgB+C,IACZC,EACEA,EAACC,EACDA,EAACC,EACDA,EAACC,EACDA,EAACC,EACDA,EAAI,GAAEC,EACNA,EAAI,GAAEC,GACNA,EAAK,KAGT,MAAO,CACLN,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,GAAAA,GC/BJ,SAAgBC,IAASF,EAAEA,EAACC,GAAEA,GAAgBE,GAE5C,MAAMrO,EAAMqO,EAAMP,GAAKO,EAAML,EACvB1Z,EAAO4Z,EAAElO,KAEV1L,IAASA,EAAKwZ,GAAKO,EAAMP,KAC5BI,EAAElO,GAAOqO,GAEXF,EAAG3T,KAAK6T,GCPV,SAAgBC,GAAWpC,GACzB,OAAOqC,IAEL,MAAMC,EAAID,EAAME,EAAEF,EAAM/X,GAIxB,OAFA+X,EAAMG,EAAIxC,EAAOyC,YAAYH,GAEtBA,GCVX,MAAMI,GAAc,qHAKpB,SAAgBC,GAAcN,EAAoBO,GAGhD,OAFAP,EAAME,EAAIF,EAAME,EAAEM,UAAUR,EAAM/X,GAClC+X,EAAM/X,EAAI,IACN+X,EAAME,EAAEO,MAAMJ,MAChBE,EAAIP,EAAME,EAAEM,UAAUR,EAAM/X,EAAG+X,EAAM/X,GAAK,MACnC,GCVJ,MAAMyY,GAAY,KAAM,ECqB/B,SAAgBC,GACZhD,GACAiD,MACEA,GAAQ,EAAIC,OACZA,GAAS,EAAIC,MACbA,GAAQ,EAAIxY,KACZA,EAAOyX,GAAWpC,IACA,IAGtB,MAAMoD,EC3BR,SACIpD,GAEF,MAAO,CAACqC,EAAOO,KAEb,IAAIS,EAAW,GAGf,MADEhB,EAAM/X,EACD+X,EAAM/X,EAAI+X,EAAME,EAAEja,SAAU+Z,EAAM/X,EAAG,CAE1C,MAAMgY,EAAID,EAAME,EAAEF,EAAM/X,GAExB,GAAU,OAANgY,EAAY,CAEd,MAAM3X,EAAO0X,EAAME,IAAIF,EAAM/X,GAG3B+Y,GADE1Y,GAGU2X,MAET,CAAA,SAAItC,EAAOyC,YAAYH,GAG5B,QAFED,EAAM/X,OACRsY,EAAIS,GAGJA,GAAYf,GAIhBM,EAAIS,IDHoBC,CAAmBtD,GACvCuD,EE5BR,SACIvD,GAEF,MAAO,CAACqC,EAAOO,KACZ,YAAM5C,EAAOyC,YAAYJ,EAAME,EAAEF,EAAM/X,KACrC,OAAO,EAGT,IAAI5C,EAAS,GAGb,MADE2a,EAAM/X,EACD+X,EAAM/X,EAAI+X,EAAME,EAAEja,QAAQ,CAE/B,MAAMga,EAAID,EAAME,EAAEF,EAAM/X,KAExB,UAAI0V,EAAOyC,YAAYH,GACrB,MAEF5a,GAAU4a,EAKZ,OAFAM,EAAIlb,IAEG,GFKiB8b,CAAoBxD,GACzCyD,EAAaN,EAAQH,GAAWhD,EAAQ,CAAErV,KAAAA,EAAMuY,QAAQ,EAAOD,OAAO,EAAOE,OAAO,IAAWJ,GAErG,MAAO,CAACV,EAAOO,KAEb,IAEIc,EACAxc,EAgFAgC,EAnFA0C,EAAO,GACPwH,EAAqB,MAIzB,KAAOiP,EAAM/X,EAAI+X,EAAME,EAAEja,QAAQ,CAE/B,MAAMga,EAAI3X,EAAK0X,GAEf,GAAIA,EAAMG,EAAG,CACX,MAAIH,EAAMG,EACR,MAEF,GAAa,MAATtb,EAAe,CACjB,MAAImb,EAAMG,EAA8B,CACtCtb,EAAQ0E,EAAO,GAAK0W,IAClBD,EAAM/X,EACR,SAEF,SAAI+X,EAAMG,EAAyB,EAC7BU,GAAWtX,GACbwX,EAAkBf,EAAOP,IACnBlW,GACFwH,EAAO,gBACPsQ,EAAM9X,GAENwH,EAAO,gBAETxH,EAAO,GACP1E,EAAQ4a,IAGZ,MAEF,IAAKlW,GAAQ2X,EAAmBlB,EAAOP,IACrC1O,EAAO,yBACPlM,EAAQ4a,IAER,MAEF5a,EAAQ0E,EACRA,EAAO,OACF,CAAA,SAAIyW,EAAMG,EAAyB,EACpCU,GAAWhc,GACbkc,EAAkBf,EAAOP,IACnB5a,GACFkM,EAAO,gBACPsQ,EAAMxc,GAENkM,EAAO,gBAETlM,EAAQ4a,IAGZ,MACK,IAAK5a,GAASqc,EAAmBlB,EAAOP,IAC7C1O,EAAO,yBACPlM,EAAQ4a,IAER,OAIJ,GAAa,MAAT5a,EAAe,CACjB,IAAK0E,GAAQ+W,GAAcN,EAAOP,GAAK5a,EAAQ4a,GAAI,CACjD1O,EAAO,YACP,MAEE6P,EACFrX,GAAQ0W,EAERpb,EAAQob,MAEL,CAAA,IAAKpb,GAASyb,GAAcN,EAAOP,GAAK5a,EAAQ4a,GAAI,CACzD1O,EAAO,YACP,MAEAlM,GAASob,IAGTD,EAAM/X,EAKV,GAAa,MAATpD,EAAe,CACjB,IAAK0E,EACH,OAAO,EAET1C,EAAOwY,GAAS,CAAEC,EAAGvO,EAAM0O,EAAGlW,SAE9B1C,EAAOwY,GAAS,CAAEC,EAAGvO,EAAMwO,EAAGhW,QAAQ7C,EAAW8Y,EAAG6B,EAAK5B,EAAG5a,IAI9D,KAAOuc,EAAWpB,EAAOsB,GAAaza,EAAK6Y,EAAEzT,KAAKqV,MAKlD,OAFAf,EAAI1Z,IAEG,GGrIX,SAAgB0a,GAAc5D,GAC5B,OAAOqC,IAEL,IAAIC,EAAID,EAAME,EAAEF,EAAM/X,GAEtB,MAAU,OAANgY,GACFD,EAAMG,EAAIxC,EAAOyC,YAAYH,GACtBA,MAGPD,EAAM/X,EACJ+X,EAAM/X,EAAI+X,EAAME,EAAEja,QACpBga,EAAID,EAAME,EAAEF,EAAM/X,GAClB+X,EAAMG,EAAIxC,EAAOyC,YAAYH,QAE7BD,EAAMG,IAGDF,IClBX,SAAgBuB,GAAa7D,GAC3B,OAAOqC,IAEL,MAAMyB,EAAQzB,EAAM/X,EAEpB,EAAG,CAED,MAAMgY,EAAID,EAAME,EAAEF,EAAM/X,GAExB,OAAM0V,EAAOyC,YAAYH,IACvB,MAEFD,EAAM/X,UACC+X,EAAM/X,EAAI+X,EAAME,EAAEja,QAE3B,OAAO+Z,EAAM/X,IAAMwZ,GCZvB,SAAgBC,GACZ/D,EACAzN,EAAuB,IAGzB,MAAMyR,EAAaH,GAAa7D,GAC1BiE,EAAYjB,GAAWhD,iCAAazN,IAAM2Q,QAAQ,KAExD,MAAO,CAACb,EAAOO,SACP5C,EAAOyC,YAAYJ,EAAME,EAAEF,EAAM/X,SAIrC+X,EAAM/X,EACR0Z,EAAW3B,GAEJ4B,EAAU5B,EAAOO,ICR5B,MAAasB,GAAgC,CAC3CC,IAAK,EACLC,KAAM,EACNC,IAAK,EACLC,IAAK,EACLC,IAAK,MACLC,KAAM,GACNC,IAAK,OACLC,IAAK,OACLC,IAAK,GACLC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,OAMF,SAAgBC,IACZC,QACEA,GAGE,IAEN,MAAMC,EAA+BD,iCAAerB,IAAmBqB,GAAYrB,GAEnF,MAAO,CACLzB,YAAYH,GACHkD,EAAclD,KACbA,GAAK,MAAYA,GAAK,KAAa,SAANA,QAQpC,MAAMmD,GAAoCH,KAKpCI,GAAoCJ,GAAkB,CACjEC,QAAS,CACPR,IAAK,GACLH,IAAK,OACLC,IAAK,GACLV,IAAK,EACLC,KAAM,EACNO,MACAN,SCIJ,SAAgBsB,GAAc3F,SAE5B,MAAM4F,EAAe5F,EAASsF,GAAkBtF,GAAUyF,GACpDI,EC3ER,SAAkC7F,GAEhC,MAAMgE,EAAaH,GAAa7D,GAEhC,OAAOqC,QACDrC,EAAOyC,YAAYJ,EAAME,EAAEF,EAAM/X,OACnC+X,EAAM/X,IACN0Z,EAAW3B,IACJ,GDmEcyD,CAAkBF,GACrCG,EAAahC,GAAY6B,GACzB3B,EAAYjB,GAAW4C,GACvBI,aAAehG,wBAAQiG,UExE/B,SAA8BjG,GAE5B,MAAMgE,EAAaH,GAAa7D,GAC1BkG,EAAoC,CACxCvb,KAAMiZ,GAAc5D,IAEhBiE,EAAYjB,GAAWhD,EAAQkG,GAC/BH,EAAahC,GAAY/D,EAAQkG,GAEvC,MAAO,CAAC7D,EAAOO,KACb,YAAM5C,EAAOyC,YAAYJ,EAAME,EAAEF,EAAM/X,KACrC,OAAO,EAKT,IAAI5C,EAGJ,MALE2a,EAAM/X,EAMJ0Z,EAAW3B,IACR0D,EACC1D,EACAF,IACOza,IACHA,EAASga,GAAS,CAAEC,EAAG,MAAOG,EAAG,MAEnCI,GAASxa,EAAQya,MAGpB8B,EAAU5B,EAAOnZ,GAAQxB,EAASwB,KAMzC,QAHEmZ,EAAM/X,EACRsY,EAAIlb,GAAUga,GAAS,CAAEC,EAAG,MAAOG,EAAG,OAE/B,GFoC+BqE,CAAcT,IAAuB3C,GAE7E,OAAOqD,IAEL,MAAM1e,EAAqB,GACrB2a,EAAqB,CAAE/X,EAAG,EAAGiY,EAAG6D,GAGtC,KAKS/D,EAAM/X,EAAI+X,EAAME,EAAEja,SACrBud,EAAiBxD,IACd0D,EACC1D,EACAF,IACOza,EAAOY,QACVZ,EAAO4G,KAAKoT,GAAS,CAAEC,EAAG,MAAOG,EAAG,MAEtCI,GAASxa,EAAOA,EAAOY,OAAS,GAAI6Z,MAGvC6D,EAAa3D,EAAOnZ,GAAQxB,EAAO4G,KAAKpF,KACxC+a,EAAU5B,EAAOnZ,GAAQxB,EAAO4G,KAAKpF,OAf9C,OAAOxB,SGxEE2e,GACKV,KCTlB,SAAgBW,GAAUC,GACxB,IAAKA,EACH,MAAO,KAGT,IAAIC,EACAC,GAAQ,EAEZ,IAAK,IAAInc,EAAI,EAAGA,EAAIic,EAAOje,SAAUgC,EAAG,CAEtC,MAAMgY,EAAIiE,EAAOjc,GACXoc,EAAYjB,GAAoBhD,YAAYH,GAE9CoE,MACEA,IACGF,IACHA,EAAUD,EAAO1D,UAAU,EAAGvY,IAEhCkc,GAAW,KAAOlE,GAEpBmE,GAAQ,GACCD,IACTA,GAAWlE,GAIf,OAAOmE,EAAQ,IAAID,GAAWD,KAAYA,ECvC5C,SAAgBI,GAAmBzf,GACjC,OAAOqN,MAAMC,QAAQtN,GAgBvB,SAAgB0f,GAAmBvc,GACjC,QAASA,EAAM/B,OCVjB,SAAgBue,GACZ3d,GAEF,MAAgB,MAATA,GAAyB,MAATA,GAAyB,MAATA,EAuBzC,SAAgB4d,GAAsBC,GACpC,IAAKJ,GAAgBI,GACnB,MAAO,CAACC,GAAaD,IAGvB,MAAME,EAAmC,GACzC,IAAIC,EAEJ,IAAK,MAAMhe,KAAQ6d,EAAU,CAE3B,MAAMI,EAAiBD,EAOvB,IAAIE,EAEJ,GAPIF,IACFD,EAAW3Y,KAAK4Y,GAChBA,OAAane,GAKX8d,GAAa3d,GAAO,CAEtB,GADAge,EAAahe,GACRie,EACH,SAEFC,EAAO,QAEPA,EAAOJ,GAAa9d,GAGtB+d,EAAW3Y,KAAK8Y,GAMlB,OAJIF,GACFD,EAAW3Y,KAAK4Y,EAAY,IAGvBD,EAGT,SAASD,GAAalT,GACpB,MAAmB,iBAARA,EACJA,EAGE,CAAEyO,EAAGzO,GAFH,GAIJuT,GAA0BvT,GAMnC,SAAgBuT,GAA0BD,GAExC,MAAMjK,EAAKiK,EAAKjK,SAAMpU,EAChBuB,EAAI8c,EAAK9c,QAAKvB,EACduZ,EAcR,SACIgF,GAEF,IAAKA,EACH,OAEF,GAAI1J,GAAgB0J,GAClB,MAAO,CAACA,GAGV,MAAM5f,EAAS4f,EAAQvK,OAAOuF,KAAOA,GAErC,OAAOsE,GAAgBlf,GAAUA,EAAO6f,KAAKzJ,SAAgB/U,EA1BnDye,CAAiBJ,EAAK9E,GAC1BmF,EA4BR,SACIC,GAEF,IAAKA,EACH,OAEF,GAUF,SACIA,GAEF,MAA0B,iBAAZA,EAAK,GAbCC,CAAoBD,GAAO,CAE7C,MAAMhgB,EAASggB,EAAKlP,IAAIoP,IAExB,OAAOhB,GAAgBlf,GAAUA,OAASqB,EAG5C,MAAO,CAAC6e,GAAqBF,IAzCnBG,CAAsBT,EAAKK,GAErC,MAAO,CACLtK,GAAAA,EACA8D,GAAe,MAAXmG,EAAKnG,IAAc9D,IAAO7S,IAAMgY,GAAKmF,GAAKK,GAAoBL,EAAE,MAAQL,EAAKnG,QAAKlY,EACtFuB,EAAAA,EACAgY,EAAAA,EACAmF,EAAAA,EACAlF,EAAG6E,EAAK7E,QAAKxZ,EACb4Y,EAAGoG,GAAoBX,EAAKzF,IAyChC,SAASiG,GAAqBI,GAC5B,IAAKF,GAAoBE,GACvB,OAAOA,EAET,GAAIA,EAAI1f,OAAS,EACf,OAAO0f,EAGT,MAAOC,EAAQrc,KAASsc,GAAUF,EAElC,OAwBOrB,GAxB0CuB,EAwBpB,IAvBpB,CAACD,EAAQrc,KAASsc,EAAO1P,IAAIsO,KAG/B,CAACmB,EAAQrc,EAAMkb,GAAsBoB,IAa9C,SAAgBJ,GAAoBE,GAClC,OAAOA,EAAI1f,OAAS,IAAiB,MAAX0f,EAAI,IAAyB,OAAXA,EAAI,IASlD,SAASD,GACLI,GAEF,GAAKA,EAUL,OAAOvB,GAHLuB,EAHGxB,GAAgBwB,GAGN,IAAI,IAAIpa,IAAI1C,EAAU8c,EAAYC,MAAmBb,OAFrD,IAAIa,GAAgBD,KAKEA,OAAapf,EAGpD,MAAMsf,GAA4B,IAAIta,IAEtC,SAASqa,GAAgBE,GACvB,IAAKA,EACH,OAAOD,GAGT,MAAME,EAAQD,EAAUpN,QAAQ,KAC1BtP,EAAO2c,EAAQ,EAAID,EAAYA,EAAUzF,UAAU,EAAG0F,GACtDC,EAAU,IAAIza,IACpB,IAAI0a,EAEJ,IAAK,MAAMrB,KAAQxb,EAAK8c,MAAM,KACxBD,EACFA,GAAe,IAAMrB,EAErBqB,EAAcrB,EAEhBoB,EAAQ3Z,IAAI4Z,GAMd,OAJIF,GAAS,GACXC,EAAQ3Z,IAAIyZ,GAGPE,EC9GT,SAASG,GAAarB,EAA+CsB,GACnE,OAAOtB,GAAWsB,EAAMjd,MAAMkd,GAAUvB,EAAQwB,KAAKC,GzB9BvD,SAA2BrN,EAAsBC,GAC/C,GAAqB,iBAAVD,EACT,MAAyB,iBAAXC,EAAsBD,IAAUC,GAAUA,EAAO,GAAG6B,KAAO7B,EAAO,KAAOD,EAGzF,MAAOsC,GAAaR,IAAKS,IAAcvC,EAEvC,MAAsB,iBAAXC,GACDsC,GAAYD,IAAcrC,EAG7BqC,IAAcrC,EAAO,IAAMsC,IAAatC,EAAO,GAAG6B,IyBmBMwL,CAAWH,EAAQE,KChGpF,MAAsBE,GAyCpB7c,IAAKA,KACH,OAAO5D,KAAKmO,KAwBd3P,IAAIkiB,GACF,OAAO1gB,KAAK2gB,MAAMta,IAAI,GAAIqa,GAU5BliB,QACE,OAAOwB,KAAKgN,OAqBhB,MAAsB4T,GASpBhd,IAAKA,KACH,OAAO5D,KAAKmO,KAcdjJ,IAAKA,KACH,OAAOlF,KAAK2N,UCjIhB,MAAakT,WAAcD,GAMzBpiB,YAAYsiB,EAAiBC,GAG3B,IAAIC,EACAC,EAUAC,EAbJxd,QAKIqd,GACFC,EAAY,IAAMre,EAASme,EAAMC,GACjCE,EAAcN,GAASA,EAAMpM,OAAOwM,KAEpCC,EAAY,IAAMF,EAClBG,EAAc/gB,GAKhBF,KAAK2N,SAAWvG,GAAoCzC,IAElD,MAAMgc,EAAQO,IAAYA,EAAU,IAAI3b,IAAIyb,MAE5CtZ,GAAWoZ,EAAXpZ,CAAiB,CACf7C,OAAQF,EAASE,OAAOb,QAAQ,IAAMkd,OAAU3gB,GAChD/B,QAAQwG,EAASmc,EAAOC,GACtBD,EAAQF,EAAYE,KACpBC,EAAUH,EAAYG,IACVthB,QAAUqhB,EAAMrhB,UAC1BshB,EAAQ7a,QAAQ8a,GAAQV,EAAMra,OAAO+a,IACrCF,EAAM5a,QAAQ8a,GAAQV,EAAMta,IAAIgb,IAChC1c,EAASM,QAAQD,EAASmc,EAAOC,SAItCza,QAEH3G,KAAKmO,KAAOxF,GAAuB3I,KAAK2N,SAASjL,KAAKrC,EAAcL,OxE3BxE,YAA4DiN,GAC1D,MAAO,IAAMA,EwE0BiEqU,CAAethB,OAE3FA,KAAK5B,OAAOkB,UAAY,KACtB,OAAI4hB,EAEKA,EAAQjU,UjE9BQ9L,EiEkCN6f,IjEjChB,kBAAsB7f,EAAtB,IADT,IAA+BA,GiEuC7B3C,KAAK4hB,GACH,OAQJ,SAA0BU,EAAoBV,GAE5C,MAAMhJ,EFRR,SAA0BgJ,GACxB,OAAOvB,GAA0BuB,GEOvBmB,CAAUnB,GAEpB,OAAO,IAAIS,GAAMC,EAAMO,GFGzB,SACI9C,EACA6B,GAEF,IAAK7B,EAASze,OACZ,OAAO,EAGT,MAAM8e,EAAOL,EAASA,EAASze,OAAS,GAExC,QAAIsgB,EAAMzL,IAAMiK,EAAKjK,KAAOyL,EAAMzL,QAG9ByL,EAAM3H,GAAKmG,EAAKnG,IAAM2H,EAAM3H,OAG5B2H,EAAMte,GAAK8c,EAAK9c,IAAMse,EAAMte,OAG5Bse,EAAMtG,IAAMqG,GAAavB,EAAK9E,EAAGsG,EAAMtG,OAIvCsG,EAAMjH,IAAMgH,GAAavB,EAAKzF,EAAGiH,EAAMjH,OE1BZqI,CAAoBH,EAAK9C,SAAUnH,IAZzDqK,CAAUzhB,KAAMogB,ICL3B,MAAMsB,GACY,IAAIb,GAAM,CAC1BriB,CAAC0G,GAAkBqD,GACnB/J,CAACJ,OAAOkB,UAAS,IACR,GAAGlB,OAAOkB,cAYrB,SAAgBqiB,MAAaxW,GAC3B,OAAOA,EAAQrL,OA6BjB,SAAqBqL,GACnB,GAAuB,IAAnBA,EAAQrL,OAAc,CAExB,MAAM4B,EAASyJ,EAAQ,GAEvB,OAAOzJ,aAAkBkf,GAAelf,EAAS,IAAImf,GAAMnf,GAE7D,OAAO,IAAImf,GAAM,CACfriB,EAAGJ,OAAOkB,YACR,IAAK,MAAMqhB,KAASxV,QACXwV,GAGXzb,IAAKA,KACH,OAAOkC,GAAoCzC,IACzCwG,EAAQ5E,QAAQ7E,GAAUgG,GAAWhG,EAAXgG,CAAmB,CAC3C7C,OAAQV,IAAc6C,MAAMrC,EAASE,QACrCrG,QAAQwG,EAASmc,EAAOC,GACtBzc,EAASM,QAAQD,EAASmc,EAAOC,SAGpCza,WAlDiBib,CAAYzW,EAAQ6E,IAAI6R,KAAoBH,GAGtE,SAASG,GAAgBngB,GACvB,MAAyB,mBAAXA,EAmDhB,SAAmBA,GAEjB,IAAIogB,EAEJ,MAAO,CACLtjB,CAACJ,OAAOkB,UAAS,IACRqhB,IAAQviB,OAAOkB,YAExB4F,IAAKA,KACH,OAAOyb,IAAQzb,KAInB,SAASyb,IACP,OAAOmB,IAAWA,EAASC,GAAargB,OAjEJsgB,CAAUtgB,GAAUqgB,GAAargB,GA+FzE,SAASqgB,GAAargB,GACpB,OAAOA,aAAkB+e,GAAW/e,EAAOif,MAAMvS,KAAOjJ,EAAczD,GAAUA,EAGlF,SAAoBA,GAElB,MAAMwf,EAAU,IAAI3b,IACd0C,EAAUb,GAAoCzC,IAElD,IAAIsd,EAAexd,IACnB,MAAMI,OAAEA,GAAWF,EAEnBE,EAAOb,QAAQC,IACbge,EAAa/d,IAAID,GACjBid,EAAQgB,UAGVxgB,EAAOygB,KAAKC,IACV,IAAKvd,EAAOP,MAAO,CAEjB,MAAMqc,EAAQyB,aAAsB3B,GAAW2B,EAAWzB,MAAQyB,GAuB1E,SACIzB,EACAO,EACAvc,GAGF,MAAMkU,EAAuB,GAM7B,GAJA9W,EAAQ4e,EAAOU,IACbxI,EAAS/S,KAAKub,GACdH,EAAQ7a,IAAIgb,KAEVxI,EAAS/Y,OAAQ,CAEnB,MAAMmH,EAAa,IAAI3B,EAEvB2B,EAAWb,GAAGzB,GACdsC,EAAWxB,KAAKoT,EAAU,KAtCtBwJ,CAAoB1B,EAAOO,EAASvc,GAEpCsd,EAAeva,GAAWiZ,EAAXjZ,CAAkB,CAC/BlJ,QAAQwG,EAASmc,EAAOC,GACtBA,EAAQ7a,QAAQ8a,GAAQH,EAAQ5a,OAAO+a,IACvCF,EAAM5a,QAAQ8a,GAAQH,EAAQ7a,IAAIgb,IAClC1c,EAASM,QAAQD,EAASmc,EAAOC,MAElCpa,MAAMnC,QAGZ8B,QAEH,MAAO,CACLnI,CAAC0G,GAAkB+C,EACnBzJ,CAACJ,OAAOkB,UAAS,IACR4hB,EAAQjU,UArCsEqV,CAAW5gB"}