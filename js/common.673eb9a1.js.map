{"version":3,"file":"common.673eb9a1.js","sources":["../../src/common/articles/feed-service.ts","../../src/common/api/api-root-url.ts","../../src/common/auth/auth-service.key.impl.ts","../../src/common/api/api-fetch.ts","../../src/common/api/api-submitter.ts","../../src/common/articles/feed-service.impl.ts","../../src/common/articles/feed-support.feature.ts","../../src/common/auth/auth-service.ts","../../src/common/auth/auth-service.impl.ts","../../src/common/auth/auth-support.feature.ts","../../src/common/input/api-error-generator.ts","../../src/common/input/bootstrap-css-error.ts","../../src/common/conduit.ns.ts","../../src/common/input/api-errors.component.ts","../../src/common/input/in-error.component.ts","../../src/common/input/conduit-input-support.feature.ts","../../src/common/input/fill-conduit-form.decorator.ts","../../src/common/input/handle-conduit-submit-button.decorator.ts","../../src/common/input/use-conduit-input.decorator.ts","../../src/common/layout/main.component.ts","../../src/common/layout/navbar.component.ts","../../src/common/layout/container.component.ts","../../src/common/layout/footer.component.ts","../../src/common/layout/conduit-layout-support.feature.ts","../../src/common/conduit.feature.ts","../../src/common/util/escape-html.ts","../../src/common/util/hash-url.ts","../../src/common/index.ts"],"sourcesContent":["import { ContextRef, SingleContextKey } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { ApiResponse } from '../api';\nimport { Article } from './article';\n\nexport interface FeedRequest {\n  readonly tag?: string;\n  readonly author?: string;\n  readonly favorited?: string;\n  readonly limit?: number;\n  readonly offset?: number;\n}\n\nconst feedRequestKeys: readonly (keyof FeedRequest)[] = ['tag', 'author', 'favorited', 'limit', 'offset'];\n\nexport function feedRequestsEqual(first: FeedRequest, second: FeedRequest): boolean {\n  return feedRequestKeys.every(key => first[key] === second[key]);\n}\n\nexport interface ArticleList {\n  readonly articleCount: number;\n  readonly articles: readonly Article[];\n}\n\nexport interface FeedService {\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]>;\n\n  feed(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]>;\n\n  article(slug: string): OnEvent<[ApiResponse<Article>]>;\n\n}\n\nexport const FeedService: ContextRef<FeedService> = new SingleContextKey<FeedService>('feed-service');\n","import { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\n\nexport type ApiRootURL = URL;\n\nexport const ApiRootURL: SingleContextUpRef<ApiRootURL> = new SingleContextUpKey<ApiRootURL>(\n    'api-root-url',\n    {\n      byDefault: () => new URL('https://conduit.productionready.io/api/'),\n    },\n);\n","import { SingleContextKey } from 'context-values';\nimport { AuthService } from './auth-service';\n\nexport const AuthService__key = new SingleContextKey<AuthService>('auth-service');\n","import { HttpFetch } from '@wesib/generic';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { AfterEvent, nextOnEvent, onAsync, OnEvent, OnEventCallChain } from 'fun-events';\nimport { AuthService__key } from '../auth/auth-service.key.impl';\nimport { ApiRootURL } from './api-root-url';\n\n/**\n * Request to some API endpoint.\n *\n * @typeparam T  Response type.\n */\nexport interface ApiRequest<T> {\n\n  /**\n   * API endpoint path __relative__ to {@link ApiRootURL API root URL}.\n   *\n   * Do not start it with `/` as this would make it absolute.\n   */\n  readonly path: string;\n\n  /**\n   * Wrapper field containing response object, or a function extracting it.\n   */\n  readonly respondAs: string | ((this: void, json: any) => T);\n\n  /**\n   * Additional HTTP request options.\n   */\n  readonly init?: RequestInit;\n\n  /**\n   * Whether to send authentication token.\n   *\n   * - `true` to always send it,\n   * - `false` to never send it,\n   * - `undefined` (the default) - to send it only if {@link AuthService.user current user} is authenticated.\n   */\n  readonly auth?: boolean;\n\n}\n\nexport type ApiResponse<T> =\n    | ApiResponse.Ok<T>\n    | ApiResponse.Failure;\n\nexport namespace ApiResponse {\n\n  export interface Ok<T = any> {\n    readonly ok: true;\n    readonly response: Response;\n    readonly body: T;\n  }\n\n  export interface Failure {\n    readonly ok: false;\n    readonly response?: Response;\n    readonly errors: Errors;\n  }\n\n  export type Errors = {\n    readonly [field in string]: readonly string[];\n  };\n\n}\n\nexport type ApiFetch = <T>(this: void, request: ApiRequest<T>) => OnEvent<[ApiResponse<T>]>;\n\nexport const ApiFetch: ContextUpRef<ApiFetch, ApiFetch> = (\n    new FnContextKey<[ApiRequest<any>], OnEvent<[ApiResponse<any>]>>(\n        'api-fetch',\n        {\n          byDefault: bootstrapDefault(newApiFetch),\n        },\n    ));\n\ntype RequestOrFailure =\n    | { request: Request }\n    | { request?: undefined; failure: ApiResponse.Failure };\ntype ResponseOrFailure =\n    | { response: Response }\n    | { response?: undefined; failure: ApiResponse.Failure };\ntype ResponseBodyOrFailure =\n    | [{ response: Response }, any]\n    | [{ response?: undefined; failure: ApiResponse.Failure }];\n\nfunction newApiFetch(context: BootstrapContext): ApiFetch {\n\n  const httpFetch = context.get(HttpFetch);\n  const apiRootURL = context.get(ApiRootURL);\n\n  return request => {\n\n    const { path, init, auth } = request;\n    const onResponse: OnEvent<[ResponseOrFailure]> = apiRootURL.thru_(\n        baseURL => new URL(path, baseURL),\n        url => buildApiRequest(url, init),\n    ).thru_(\n        (request: Request): NextCall<OnEventCallChain, [RequestOrFailure]> => auth === false\n            ? nextArgs({ request })\n            : nextOnEvent(authenticateApiRequest(context, request, auth)),\n        (requestOrFailure): NextCall<OnEventCallChain, [ResponseOrFailure]> => requestOrFailure.request\n            ? nextOnEvent(httpFetch(requestOrFailure.request).thru_(response => ({ response })))\n            : nextArgs({ failure: requestOrFailure.failure }),\n    );\n\n    return onAsync(onResponse.thru_(parseApiResponse)).thru_(\n        ([responseOrFailure, json]) => handleApiResponse(request, responseOrFailure, json),\n    );\n  };\n}\n\nfunction buildApiRequest(url: URL, init: RequestInit = {}): Request {\n\n  const request = new Request(url.href, { mode: 'cors', ...init });\n  const { headers } = request;\n\n  headers.set('X-Requested-With', 'XMLHttpRequest');\n\n  return request;\n}\n\nfunction authenticateApiRequest(\n    context: BootstrapContext,\n    request: Request,\n    auth?: true,\n): AfterEvent<[RequestOrFailure]> {\n  // Access by key to avoid circular dependencies during the build\n  return context.get(AuthService__key).user.keep.thru_(\n      (user?, failure?) => {\n        if (user) {\n          request.headers.set('Authorization', `Token ${user.token}`);\n          return { request };\n        }\n        if (!auth) {\n          return { request };\n        }\n        if (!failure) {\n          failure = {\n            ok: false,\n            errors: {\n              api: ['Not authenticated'],\n            },\n          };\n        }\n        return { failure };\n      },\n  );\n}\n\nfunction parseApiResponse(\n    responseOfFailure: ResponseOrFailure,\n): ResponseBodyOrFailure | Promise<ResponseBodyOrFailure> {\n  return responseOfFailure.response\n      ? Promise.all([responseOfFailure, responseOfFailure.response.json()])\n          .catch(error => [{\n            failure: {\n              ok: false,\n              response: responseOfFailure.response,\n              errors: {\n                api: [`Failed to parse response: ${error}`],\n              },\n            },\n          }])\n      : [responseOfFailure];\n}\n\nfunction handleApiResponse<T>(\n    { respondAs }: ApiRequest<T>,\n    responseOfFailure: ResponseOrFailure,\n    json?: any,\n): ApiResponse<T> {\n  if (!responseOfFailure.response) {\n    return responseOfFailure.failure;\n  }\n\n  const { response } = responseOfFailure;\n\n  if (response.ok) {\n    return {\n      ok: true,\n      response,\n      body: typeof respondAs === 'function' ? respondAs(json) : json[respondAs],\n    };\n  }\n\n  return {\n    ok: false,\n    response,\n    errors: json.errors || {\n      http: [\n        response.statusText\n            ? `${response.status}: ${response.statusText}`\n            : `ERROR ${response.status}`,\n      ],\n    },\n  };\n}\n","import { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { OnEvent } from 'fun-events';\nimport { InSubmit, InSubmitError } from 'input-aspects';\nimport { ApiFetch, ApiRequest, ApiResponse } from './api-fetch';\n\nexport type ApiSubmitter =\n    <Value = any, Result = any>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result>;\n\nexport const ApiSubmitter: ContextUpRef<ApiSubmitter, ApiSubmitter> = (\n    new FnContextKey<[ApiRequest<any>], InSubmit.Submitter<any, any>>(\n        'api-submitter',\n        {\n          byDefault: bootstrapDefault(newApiSubmitter),\n        },\n    ));\n\nfunction newApiSubmitter(\n    context: BootstrapContext,\n): <Value, Result>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result> {\n\n  const apiFetch: ApiFetch = context.get(ApiFetch);\n\n  return <Value, Result>(request: ApiRequest<Result>) => {\n\n    const { init = {} } = request;\n    const { method = 'POST', headers = {} } = init;\n\n    return (body: Value) => {\n\n      const apiRequest: ApiRequest<Result> = {\n        ...request,\n        init: {\n          ...init,\n          method,\n          body: JSON.stringify(body),\n          headers: {\n            ...headers,\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n          },\n        },\n      };\n\n      return apiSubmit(apiFetch(apiRequest));\n    };\n  };\n}\n\nexport function apiSubmit<Result>(onFetch: OnEvent<[ApiResponse<Result>]>): Promise<Result> {\n  return new Promise((resolve, reject) => {\n    onFetch.once(\n        (response: ApiResponse<Result>) => {\n          if (response.ok) {\n            resolve(response.body);\n          } else {\n            reject(new InSubmitError({ submit: 'api', api: response.errors }));\n          }\n        },\n    ).whenOff(\n        reason => {\n          reject(\n              reason instanceof InSubmitError\n                  ? reason\n                  : new InSubmitError({ submit: 'cancel', cancel: reason }),\n          );\n        },\n    );\n  });\n}\n","import { BootstrapContext } from '@wesib/wesib';\nimport { overEntries, thruIt } from 'a-iterable';\nimport { asis, nextArg, nextSkip } from 'call-thru';\nimport { OnEvent } from 'fun-events';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { Article } from './article';\nimport { ArticleList, FeedRequest, FeedService } from './feed-service';\n\nexport class FeedService$ implements FeedService {\n\n  private readonly _apiFetch: ApiFetch;\n\n  constructor(context: BootstrapContext) {\n    this._apiFetch = context.get(ApiFetch);\n  }\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]> {\n    return this._articles('articles', request);\n  }\n\n  feed(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]> {\n    return this._articles('articles/feed', request, true);\n  }\n\n  article(slug: string): OnEvent<[ApiResponse<Article>]> {\n\n    const apiRequest: ApiRequest<Article> = {\n      path: `articles/${encodeURIComponent(slug)}`,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      respondAs: 'article',\n    };\n\n    return this._apiFetch(apiRequest);\n  }\n\n  private _articles(\n      path: string,\n      request: FeedRequest,\n      auth?: boolean,\n  ): OnEvent<[ApiResponse<ArticleList>]> {\n\n    const params: [string, string][] = Array.from(thruIt(\n        overEntries(request),\n        ([key, value]) => value\n            ? nextArg<[string, string]>([key, String(value)])\n            : nextSkip,\n    ));\n\n    if (params.length) {\n      path = `${path}?${new URLSearchParams(params)}`;\n    }\n\n    const apiRequest: ApiRequest<ArticleList> = {\n      path,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      auth,\n      respondAs: asis,\n    };\n\n    return this._apiFetch(apiRequest);\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedService } from './feed-service';\nimport { FeedService$ } from './feed-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: FeedService, as: FeedService$ });\n  },\n})\nexport class FeedSupport {\n}\n","import { ContextKey, ContextKey__symbol } from 'context-values';\nimport { AfterEvent, OnEvent } from 'fun-events';\nimport { ApiResponse } from '../api';\nimport { AuthService__key } from './auth-service.key.impl';\nimport { AuthUser } from './auth-user';\n\nexport type AuthUserOrFailure = [] | [AuthUser] | [undefined, ApiResponse.Failure];\n\nexport interface LoginRequest {\n  readonly email: string;\n  readonly password: string;\n}\n\nexport interface RegisterRequest {\n  readonly username: string;\n  readonly email: string;\n  readonly password: string;\n}\n\nexport abstract class AuthService {\n\n  static get [ContextKey__symbol](): ContextKey<AuthService> {\n    return AuthService__key;\n  }\n\n  abstract readonly user: AfterEvent<AuthUserOrFailure>;\n\n  abstract login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract logout(): void;\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { nextArgs, NextCall, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  eventSupply,\n  nextOnEvent,\n  OnEvent,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { AuthService, AuthUserOrFailure, LoginRequest, RegisterRequest } from './auth-service';\nimport { AuthUser } from './auth-user';\n\nconst authTokenKey = 'wesib-conduit:auth';\ntype Authentication = AuthUser | string | null;\n\nexport class AuthService$ extends AuthService {\n\n  readonly user: AfterEvent<AuthUserOrFailure>;\n  private readonly _auth: ValueTracker<Authentication>;\n\n  constructor(private readonly _context: BootstrapContext) {\n    super();\n\n    const storage = _context.get(BootstrapWindow).localStorage;\n\n    this._auth = trackValue(storage.getItem(authTokenKey));\n    this._auth.on(updateAuthToken);\n    this.user = this._auth.read.keep.thru(authUser);\n\n    function updateAuthToken(newAuth: Authentication): void {\n      if (!newAuth) {\n        storage.removeItem(authTokenKey);\n      } else {\n        storage.setItem(authTokenKey, typeof newAuth === 'string' ? newAuth : newAuth.token);\n      }\n    }\n\n    function authUser(auth: Authentication): NextCall<OnEventCallChain, AuthUserOrFailure> {\n      if (!auth) {\n        return nextArgs();\n      }\n      if (typeof auth === 'string') {\n        return nextOnEvent(fetchCurrentUser(auth));\n      }\n      return nextArgs(auth);\n    }\n\n    function fetchCurrentUser(token: string): AfterEvent<AuthUserOrFailure> {\n\n      const apiFetch: ApiFetch = _context.get(ApiFetch);\n      const apiRequest: ApiRequest<AuthUser> = {\n        path: 'user',\n        init: {\n          headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            Authorization: `Token ${token}`,\n          },\n        },\n        respondAs: 'user',\n        auth: false,\n      };\n\n      return afterEventBy<AuthUserOrFailure>(\n          receiver => {\n            apiFetch(apiRequest).thru_(\n                (response: ApiResponse<AuthUser>): NextCall<OnEventCallChain, AuthUserOrFailure> => {\n                  if (response.ok) {\n                    return nextArgs(response.body);\n                  }\n                  return nextArgs(undefined, response);\n                },\n            )({\n              supply: eventSupply().needs(receiver.supply), // Do not abort after user received\n              receive(ctx, ...event) {\n                receiver.receive(ctx, ...event);\n              },\n            });\n          },\n          valuesProvider(),\n      );\n    }\n  }\n\n  login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users/login', request);\n  }\n\n  register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users', request);\n  }\n\n  logout(): void {\n    this._auth.it = null;\n  }\n\n  private _request(path: string, request: LoginRequest | RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n\n    const apiFetch: ApiFetch = this._context.get(ApiFetch);\n    const apiRequest: ApiRequest<AuthUser> = {\n      path,\n      init: {\n        method: 'POST',\n        body: JSON.stringify({ user: request }),\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json',\n        },\n      },\n      respondAs: 'user',\n      auth: false,\n    };\n\n    return apiFetch(apiRequest).thru_(\n        response => {\n          if (response.ok) {\n            this._auth.it = response.body;\n          } else {\n            this._auth.it = null;\n          }\n          return response;\n        },\n    );\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { AuthService } from './auth-service';\nimport { AuthService$ } from './auth-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: AuthService, as: AuthService$ });\n  },\n})\nexport class AuthSupport {\n}\n","import { bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { AIterable, overEntries } from 'a-iterable';\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { ApiResponse } from '../api';\n\nexport type ApiErrorGenerator = (this: void, errors: ApiResponse.Errors) => Element | undefined;\n\nexport const ApiErrorGenerator: FnContextRef<[ApiResponse.Errors], Element | undefined> = (\n    new FnContextKey<[ApiResponse.Errors], Element | undefined>(\n        'api-error-generator',\n        {\n          byDefault: bootstrapDefault(context => {\n\n            const document = context.get(BootstrapWindow).document;\n\n            return errors => {\n\n              let list: Element | undefined;\n\n              AIterable.from(overEntries(errors)).forEach(\n                  ([key, messages]) => {\n                    if (!list) {\n                      list = document.createElement('ul');\n                      list.classList.add('error-messages');\n                    }\n\n                    const ul = list;\n\n                    messages.forEach(message => {\n\n                      const li = document.createElement('li');\n\n                      li.innerText = `${key} ${message}`;\n                      ul.appendChild(li);\n                    });\n                  },\n              );\n\n              return list;\n            };\n          }),\n        },\n    ));\n","import { nextArgs } from 'call-thru';\nimport { afterAll, nextAfterEvent } from 'fun-events';\nimport { InCssClasses, inCssError, InStatus, InValidation } from 'input-aspects';\n\nexport function bootstrapCssError(\n    {\n      mark = 'is-invalid',\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n  return control => {\n\n    const cssClasses = control.aspect(InCssClasses);\n\n    return afterAll({\n      status: control.aspect(InStatus),\n      validity: control.aspect(InValidation),\n    }).keep.thru(\n        ({\n          status: [{ touched, hasFocus }],\n          validity: [validity],\n        }) => {\n\n          const incomplete = validity.has('incomplete') || validity.has('missing');\n\n          return touched && !(hasFocus && incomplete)\n              ? nextAfterEvent(cssClasses.specs(inCssError({ mark, when })))\n              : nextArgs();\n        },\n    );\n  };\n}\n","import { NamespaceDef } from 'namespace-aliaser';\n\nexport const Conduit__NS: NamespaceDef = new NamespaceDef(\n    'https://wesib.github.io/realworld-app/ns/',\n    'conduit',\n);\n","import { HierarchyContext } from '@wesib/generic';\nimport { InputToForm } from '@wesib/generic/input';\nimport { Component, ComponentContext, ElementRender, Render } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InValidation } from 'input-aspects';\nimport { ApiResponse } from '../api';\nimport { Conduit__NS } from '../conduit.ns';\nimport { ApiErrorGenerator } from './api-error-generator';\n\nconst noApiErrors: ApiResponse.Errors = {};\n\n@Component(['api-errors', Conduit__NS])\nexport class ApiErrorsComponent {\n\n  private _errors: ApiResponse.Errors = noApiErrors;\n\n  constructor(private readonly _context: ComponentContext) {\n    _context.get(HierarchyContext)\n        .get(InputToForm)\n        .thru_(\n            ({ control }): NextCall<OnEventCallChain, [ApiResponse.Errors]> => {\n              if (!control) {\n                return nextArgs(noApiErrors);\n              }\n              return nextAfterEvent(\n                  control.aspect(InValidation).read.keep.thru_(\n                      validity => validity.messages('api').reduce(\n                          (prev, message) => ({\n                            ...prev,\n                            ...message.api,\n                          }),\n                          noApiErrors,\n                      ),\n                  ),\n              );\n            },\n        )(errors => this.errors = errors);\n  }\n\n  get errors(): ApiResponse.Errors {\n    return this._errors;\n  }\n\n  set errors(value: ApiResponse.Errors) {\n\n    const old = this._errors;\n\n    if (old === value) {\n      return;\n    }\n    this._errors = value;\n    this._context.updateState('errors', value, old);\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const { contentRoot } = this._context;\n    let list: Element | undefined;\n\n    return () => {\n      if (list) {\n        list.remove();\n        list = undefined;\n      }\n      list = this._context.get(ApiErrorGenerator)(this.errors);\n      if (list) {\n        contentRoot.append(list);\n      }\n    };\n  }\n\n}\n","import { ConvertInput } from '@wesib/generic/input';\nimport { Attributes, Component, trackAttribute } from '@wesib/wesib';\nimport { AfterEvent } from 'fun-events';\nimport { InCssClasses, inCssInfo, InStyledElement } from 'input-aspects';\nimport { Conduit__NS } from '../conduit.ns';\nimport { bootstrapCssError } from './bootstrap-css-error';\n\n@Component(\n    ['in-error', Conduit__NS],\n    Attributes('code'),\n    ConvertInput(\n        ({ control: { control }, aspects, context }) => {\n\n          const codes: AfterEvent<[string[]]> = trackAttribute(context, 'code')\n              .read.keep.thru_(\n                  code => code ? code.trim().split(/\\s+/) : [],\n              );\n\n          return codes.keep.thru(\n              when => control.convert(\n                  InStyledElement.to(context.element),\n                  aspects,\n              ).setup(\n                  InCssClasses,\n                  cssClasses => {\n                    cssClasses.add(inCssInfo());\n                    cssClasses.add(bootstrapCssError({ when }));\n                  },\n              ),\n          );\n        },\n    ),\n)\nexport class InErrorComponent {}\n","import { Feature } from '@wesib/wesib';\nimport { ApiErrorsComponent } from './api-errors.component';\nimport { InErrorComponent } from './in-error.component';\n\n@Feature({\n  needs: [\n    ApiErrorsComponent,\n    InErrorComponent,\n  ],\n})\nexport class ConduitInputSupport {\n}\n","import { FillInputForm, FillInputFormDef } from '@wesib/generic/input';\nimport { Class, Component, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { InCssClasses, inCssInfo, inFormElement, inGroup, InGroup, InMode, inModeByValidity } from 'input-aspects';\nimport { HandleConduitSubmitButton, HandleConduitSubmitButtonDef } from './handle-conduit-submit-button.decorator';\n\nexport function FillConduitForm<Model extends object = any, T extends ComponentClass = Class>(\n    {\n        emptyModel = {} as Model,\n        form = {\n          makeForm({ node, aspects }) {\n\n            const group: InGroup<Model> = inGroup<Model>(emptyModel)\n                .setup(InCssClasses, classes => classes.add(inCssInfo()))\n                .setup(InMode, mode => mode.derive(inModeByValidity()));\n            const form = inFormElement(node.element, { form: group, aspects })\n                .setup(InCssClasses, classes => classes.add(group.aspect(InCssClasses)));\n\n            return [group, form];\n          },\n        },\n        button,\n    }: FillConduitFormDef<Model> = {},\n): ComponentDecorator<T> {\n  return Component(\n      FillInputForm(form),\n      HandleConduitSubmitButton(button),\n  );\n}\n\nexport interface FillConduitFormDef<Model extends object> {\n  readonly emptyModel?: Model;\n  readonly form?: FillInputFormDef;\n  readonly button?: HandleConduitSubmitButtonDef;\n}\n","import { ComponentNode, ComponentTreeSupport, ElementPickMode, HierarchyContext } from '@wesib/generic';\nimport { DefaultInAspects, InputToForm } from '@wesib/generic/input';\nimport { Class, Component, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { afterAll } from 'fun-events';\nimport { inSubmitButton } from 'input-aspects';\n\nexport function HandleConduitSubmitButton<T extends ComponentClass = Class>(\n    {\n      select = 'button',\n      pick = { deep: true, all: true },\n    }: HandleConduitSubmitButtonDef = {},\n): ComponentDecorator<T> {\n  return Component({\n    feature: {\n      needs: ComponentTreeSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n        const hierarchy = context.get(HierarchyContext);\n\n        context.whenOn(supply => {\n          afterAll({\n            form: hierarchy.get(InputToForm),\n            button: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).tillOff(supply).consume(\n              ({\n                form: [{ control: form }],\n                button: [button],\n                aspects: [aspects],\n              }) => form && button && inSubmitButton(button.element, { form, aspects }),\n          );\n        });\n      });\n    },\n  });\n}\n\nexport interface HandleConduitSubmitButtonDef {\n  readonly select?: string;\n  readonly pick?: ElementPickMode;\n}\n","import { HierarchyContext } from '@wesib/generic';\nimport { InputToForm, UseInputElement, UseInputElementDef } from '@wesib/generic/input';\nimport { Class, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { afterSupplied, EventSupply, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InCssClasses, inCssInfo, InMode } from 'input-aspects';\nimport { bootstrapCssError } from './bootstrap-css-error';\n\nexport function UseConduitInput<T extends ComponentClass = Class>(\n    def: UseInputElementDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return UseInputElement({\n    ...def,\n    makeControl(opts) {\n      return opts.context.get(HierarchyContext).get(InputToForm).keep.thru_(\n          ({ form }) => {\n\n            const ctrl = def.makeControl(opts);\n\n            if (!ctrl) {\n              return nextArgs();\n            }\n            if (ctrl instanceof InControl) {\n              return augmentControl(ctrl);\n            }\n\n            return nextAfterEvent(afterSupplied(ctrl).keep.thru_(\n                (control, supply): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n                  if (!control) {\n                    return nextArgs();\n                  }\n\n                  augmentControl(control);\n\n                  return supply ? nextArgs(control, supply) : nextArgs(control);\n                },\n            ));\n\n            function augmentControl(control: InControl<any>): InControl<any> {\n              if (form) {\n                control.aspect(InMode).derive(form.aspect(InMode));\n              }\n\n              const classes = control.aspect(InCssClasses);\n\n              classes.add(inCssInfo());\n              classes.add(bootstrapCssError());\n\n              return control;\n            }\n          },\n      );\n    },\n  });\n}\n","import { IncludePage } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['main', Conduit__NS],\n    IncludePage({\n      onResponse({ response, range }) {\n        if (!response.ok) {\n          range.deleteContents();\n          if (response.ok == null) {\n            range.insertNode(document.createTextNode('Loading...'));\n          } else {\n            range.insertNode(document.createTextNode(`Error. ${response.error}`));\n          }\n        }\n      },\n    }),\n)\nexport class MainComponent {}\n","import { ActivateNavLink, HandleNavLinks } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['navbar', Conduit__NS],\n    HandleNavLinks(),\n    ActivateNavLink({ active: 'active' }),\n)\nexport class NavbarComponent {\n}\n","import { Component, ComponentContext, DefaultNamespaceAliaser, ElementRender, Render } from '@wesib/wesib';\nimport { css__naming, QualifiedName } from 'namespace-aliaser';\nimport { AuthService, AuthUser } from '../auth';\nimport { Conduit__NS } from '../conduit.ns';\nimport { MainComponent } from './main.component';\nimport { NavbarComponent } from './navbar.component';\n\nconst authenticatedClassQName: QualifiedName = ['authenticated', Conduit__NS];\nconst notAuthenticatedClassQName: QualifiedName = ['not-authenticated', Conduit__NS];\n\n@Component({\n  name: ['container', Conduit__NS],\n  feature: {\n    needs: [MainComponent, NavbarComponent],\n  },\n})\nexport class ContainerComponent {\n\n  private _user?: AuthUser;\n\n  constructor(private readonly _context: ComponentContext) {\n    _context.whenOn(connectSupply => {\n      _context.get(AuthService).user.tillOff(connectSupply)((user?, _failure?) => {\n        this.user = user;\n      });\n    });\n  }\n\n  get user(): AuthUser | undefined {\n    return this._user;\n  }\n\n  set user(value: AuthUser | undefined) {\n\n    const oldValue = this._user;\n\n    this._user = value;\n    this._context.updateState('user', value, oldValue);\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const nsAlis = this._context.get(DefaultNamespaceAliaser);\n    const authenticatedClass = css__naming.name(authenticatedClassQName, nsAlis);\n    const notAuthenticatedClass = css__naming.name(notAuthenticatedClassQName, nsAlis);\n    const { classList }: Element = this._context.element;\n\n    return () => {\n      if (this.user) {\n        classList.remove(notAuthenticatedClass);\n        classList.add(authenticatedClass);\n      } else {\n        classList.remove(authenticatedClass);\n        classList.add(notAuthenticatedClass);\n      }\n    };\n  }\n\n}\n","import { HandleNavLinks } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['footer', Conduit__NS],\n    HandleNavLinks(),\n)\nexport class FooterComponent {\n}\n","import { Feature } from '@wesib/wesib';\nimport { ContainerComponent } from './container.component';\nimport { FooterComponent } from './footer.component';\n\n@Feature({\n  needs: [\n    ContainerComponent,\n    FooterComponent,\n  ],\n})\nexport class ConduitLayoutSupport {\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedSupport } from './articles';\nimport { AuthSupport } from './auth';\nimport { ConduitInputSupport } from './input';\nimport { ConduitLayoutSupport } from './layout';\n\n@Feature({\n  needs: [\n    AuthSupport,\n    ConduitInputSupport,\n    ConduitLayoutSupport,\n    FeedSupport,\n  ],\n})\nexport class ConduitFeature {\n}\n","const htmlUnsafe: { [key: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n};\n\nfunction replaceHtmlUnsafe(tag: string): string {\n  return htmlUnsafe[tag] || tag;\n}\n\nexport function escapeHtml(str: string | null | undefined): string {\n  return str ? str.replace(/[&<>]/g, replaceHtmlUnsafe) : '';\n}\n","export function hashURL(url: URL): URL {\n\n  const base = new URL('/', url.href);\n\n  return new URL(url.hash.substring(1), base);\n}\n\nexport function setHashURL(url: URL, hashURL: URL): URL {\n\n  const hashBaseLen = new URL('/', hashURL).href.length;\n  const result = new URL(url.href);\n\n  result.hash = hashURL.href.substring(hashBaseLen);\n\n  return result;\n}\n","import { bootstrapComponents } from '@wesib/wesib';\nimport { ConduitFeature } from './conduit.feature';\n\nexport * from './api';\nexport * from './articles';\nexport * from './auth';\nexport * from './conduit.feature';\nexport * from './conduit.ns';\nexport * from './input';\nexport * from './users';\nexport * from './util';\n\nexport const conduitContext = bootstrapComponents(ConduitFeature);\n"],"names":["feedRequestKeys","feedRequestsEqual","first","second","every","key","FeedService","SingleContextKey","ApiRootURL","SingleContextUpKey","byDefault","URL","AuthService__key","ApiFetch","FnContextKey","bootstrapDefault","context","httpFetch","get","HttpFetch","apiRootURL","request","path","init","auth","onResponse","thru_","baseURL","url","Request","href","mode","headers","set","buildApiRequest","nextArgs","nextOnEvent","user","keep","failure","token","ok","errors","api","authenticateApiRequest","requestOrFailure","response","onAsync","parseApiResponse","responseOrFailure","json","respondAs","responseOfFailure","body","http","statusText","status","handleApiResponse","Promise","all","catch","error","apiFetch","method","apiRequest","JSON","stringify","Accept","Content-Type","apiSubmit","onFetch","resolve","reject","once","InSubmitError","submit","whenOff","reason","cancel","FeedService$","[object Object]","this","_apiFetch","_articles","slug","encodeURIComponent","params","Array","from","thruIt","overEntries","value","nextArg","String","nextSkip","length","URLSearchParams","asis","FeedSupport","Feature","setup","provide","a","as","AuthService","ContextKey__symbol","AuthService$","_context","super","storage","BootstrapWindow","localStorage","_auth","trackValue","getItem","on","newAuth","setItem","removeItem","read","thru","Authorization","afterEventBy","receiver","undefined","supply","eventSupply","needs","ctx","event","receive","valuesProvider","fetchCurrentUser","_request","it","AuthSupport","ApiErrorGenerator","document","list","AIterable","forEach","messages","createElement","classList","add","ul","message","li","innerText","appendChild","bootstrapCssError","mark","when","control","cssClasses","aspect","InCssClasses","afterAll","InStatus","validity","InValidation","touched","hasFocus","incomplete","has","nextAfterEvent","specs","inCssError","Conduit__NS","NamespaceDef","noApiErrors","ApiErrorsComponent","HierarchyContext","InputToForm","reduce","prev","_errors","old","updateState","contentRoot","remove","append","__decorate","Render","Component","InErrorComponent","Attributes","ConvertInput","aspects","trackAttribute","code","trim","split","convert","InStyledElement","to","element","inCssInfo","ConduitInputSupport","FillConduitForm","emptyModel","form","node","group","inGroup","classes","InMode","derive","inModeByValidity","inFormElement","button","FillInputForm","select","pick","deep","feature","ComponentTreeSupport","defContext","whenComponent","componentNode","ComponentNode","hierarchy","whenOn","DefaultInAspects","tillOff","consume","inSubmitButton","HandleConduitSubmitButton","UseConduitInput","def","UseInputElement","makeControl","opts","ctrl","InControl","augmentControl","afterSupplied","MainComponent","IncludePage","range","deleteContents","insertNode","createTextNode","NavbarComponent","HandleNavLinks","ActivateNavLink","active","authenticatedClassQName","notAuthenticatedClassQName","ContainerComponent","connectSupply","_failure","_user","oldValue","nsAlis","DefaultNamespaceAliaser","authenticatedClass","css__naming","name","notAuthenticatedClass","FooterComponent","ConduitLayoutSupport","ConduitFeature","htmlUnsafe","&","<",">","replaceHtmlUnsafe","tag","escapeHtml","str","replace","hashURL","base","hash","substring","setHashURL","hashBaseLen","result","conduitContext","bootstrapComponents"],"mappings":"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"}