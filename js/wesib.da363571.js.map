{"version":3,"file":"wesib.da363571.js","sources":["../../node_modules/@wesib/wesib/src/boot/bootstrap-context.key.impl.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap-context.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap-default.ts","../../node_modules/@wesib/wesib/src/component/definition/component-factory.ts","../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-window.ts","../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-root.ts","../../node_modules/@wesib/wesib/src/boot/globals/default-namespace-aliaser.ts","../../node_modules/@wesib/wesib/src/boot/globals/default-render-scheduler.ts","../../node_modules/@wesib/wesib/src/common/types.impl.ts","../../node_modules/@wesib/wesib/src/common/array-set.ts","../../node_modules/@wesib/wesib/src/common/classes.ts","../../node_modules/@wesib/wesib/src/common/functions.ts","../../node_modules/@wesib/wesib/src/common/is-element.ts","../../node_modules/@wesib/wesib/src/common/meta-accessor.ts","../../node_modules/@wesib/wesib/src/common/promises.ts","../../node_modules/@wesib/wesib/src/feature/feature-def.ts","../../node_modules/@wesib/wesib/src/feature/feature.decorator.ts","../../node_modules/@wesib/wesib/src/feature/feature-context.ts","../../node_modules/@wesib/wesib/src/feature/feature-needs-error.ts","../../node_modules/@wesib/wesib/src/component/component-def.ts","../../node_modules/@wesib/wesib/src/component/component.decorator.ts","../../node_modules/@wesib/wesib/src/component/component-context.key.impl.ts","../../node_modules/@wesib/wesib/src/component/component-event.key.impl.ts","../../node_modules/@wesib/wesib/src/component/content-root.ts","../../node_modules/@wesib/wesib/src/component/state-updater.ts","../../node_modules/@wesib/wesib/src/component/component-context.ts","../../node_modules/@wesib/wesib/src/component/component-event.ts","../../node_modules/@wesib/wesib/src/boot/globals/element-adapter.ts","../../node_modules/@wesib/wesib/src/boot/globals/element-observer.ts","../../node_modules/@wesib/wesib/src/boot/impl/component-factory.symbol.impl.ts","../../node_modules/@wesib/wesib/src/component/definition/custom-elements.ts","../../node_modules/@wesib/wesib/src/component/definition/definition.context.key.impl.ts","../../node_modules/@wesib/wesib/src/component/definition/element-def.ts","../../node_modules/@wesib/wesib/src/component/definition/definition-context.ts","../../node_modules/@wesib/wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/component-context-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/definition-context-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/post-def-setup.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/when-component.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/element-builder.impl.ts","../../node_modules/@wesib/wesib/src/component/component-mount.ts","../../node_modules/@wesib/wesib/src/boot/impl/unloader.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/component-registry.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-loader.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-request.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-requester.impl.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap/bootstrap-components.ts","../../node_modules/@wesib/wesib/src/feature/feature-ref.ts","../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-path.ts","../../node_modules/@wesib/wesib/src/feature/state/component-state.ts","../../node_modules/@wesib/wesib/src/feature/state/state-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/render/element-render.ts","../../node_modules/@wesib/wesib/src/feature/render/render.decorator.ts","../../node_modules/@wesib/wesib/src/wesib.ns.ts","../../node_modules/@wesib/generic/src/fetch/fetch-agent-key.impl.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch-agent.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch.impl.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch.ts","../../node_modules/@wesib/generic/src/hierarchy/hierarchy-updates.impl.ts","../../node_modules/@wesib/generic/src/hierarchy/hierarchy-context.ts","../../node_modules/@wesib/generic/src/hierarchy/hierarchy-registry.impl.ts","../../node_modules/@wesib/generic/src/tree/element-node.ts","../../node_modules/@wesib/generic/src/tree/element-node-list.ts","../../node_modules/@wesib/generic/src/tree/element-node-list.impl.ts","../../node_modules/@wesib/generic/src/tree/node-attributes.impl.ts","../../node_modules/@wesib/generic/src/tree/node-properties.impl.ts","../../node_modules/@wesib/generic/src/tree/element-node.impl.ts","../../node_modules/@wesib/generic/src/tree/component-tree-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/navigation.ts","../../node_modules/@wesib/generic/src/navigation/page-param.ts","../../node_modules/@wesib/generic/src/navigation/page-param-context.ts","../../node_modules/@wesib/generic/src/navigation/nav-history.impl.ts","../../node_modules/@wesib/generic/src/navigation/navigation-agent.ts","../../node_modules/@wesib/generic/src/navigation/navigation.event.ts","../../node_modules/@wesib/generic/src/navigation/navigation.impl.ts","../../node_modules/@wesib/generic/src/navigation/navigation-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/activate-nav-link.decorator.ts","../../node_modules/@wesib/generic/src/navigation/handle-nav-links.decorator.ts","../../node_modules/@wesib/generic/src/util/import-node.ts","../../node_modules/@wesib/generic/src/navigation/page-load/caching-page-loader.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-requests.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-agent.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-url-modifier.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-loader.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-param.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-cache-buster.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-style-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-title-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/page-load/include-page.decorator.ts","../../node_modules/@wesib/generic/src/input/default-in-aspects.ts","../../node_modules/@wesib/generic/src/input/input-from-control.ts","../../node_modules/@wesib/generic/src/input/set-input-name.decorator.ts","../../node_modules/@wesib/generic/src/input/use-input-element.decorator.ts"],"sourcesContent":["import { SingleContextKey } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { Class } from '../common';\nimport { ComponentClass, ComponentFactory } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to [[FeatureDef.Options.init]] method so that the feature can configure itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * An `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[BootstrapContext]>;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentType  Component class constructor.\n   *\n   * @return A promise that is resolved to component factory when the given `componentType` is registered.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature  The feature to load.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class): FeatureRef;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @param provide  A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<Value, Key extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: Key) => Value | null | undefined,\n): ContextKeyDefault<Value, Key> {\n  return (context, key) => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext ? provide(bootstrapContext, key) : bootstrapContext.get(key);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Class } from '../../common';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { ElementDef } from './element-def';\n\n/**\n * @internal\n */\nconst ComponentFactory__key = (/*#__PURE__*/ new SingleContextKey<ComponentFactory>('component-factory'));\n\n/**\n * A factory of components of particular type.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentFactory<T extends object = any> {\n\n  /**\n   * A key of definition context value containing a component factory.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentFactory> {\n    return ComponentFactory__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  abstract readonly elementDef: ElementDef;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connected = true;\n\n    return mount;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = any;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of [[BootstrapWindow]].\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { NamespaceAliaser } from 'namespace-aliaser';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","import { FnContextKey, FnContextRef } from 'context-values';\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\n/**\n * A key of bootstrap, definition, or component context value containing [[DefaultRenderScheduler]] instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler:\n    FnContextRef<Parameters<DefaultRenderScheduler>, ReturnType<DefaultRenderScheduler>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<DefaultRenderScheduler>, ReturnType<DefaultRenderScheduler>>(\n        'default-render-scheduler',\n        {\n          byDefault: bootstrapDefault(\n              context => (options = {}) => newRenderSchedule({\n                ...options,\n                window: options.window || context.get(BootstrapWindow),\n              }),\n          ),\n        },\n    )\n);\n","/**\n * @internal\n */\nexport function isArray<T>(value: T | T[]): value is T[];\n\n/**\n * @internal\n */\nexport function isArray<T>(value: T | readonly T[]): value is readonly T[];\n\nexport function isArray<T>(value: T | readonly T[]): value is T[] {\n  return Array.isArray(value);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AIterable } from 'a-iterable';\nimport { isArray } from './types.impl';\n\n/**\n * @category Utility\n */\nexport class ArraySet<T> extends AIterable<T> {\n\n  readonly items: Set<T>;\n\n  constructor(value?: T | readonly T[]) {\n    super();\n    this.items = value == null ? new Set() : isArray(value) ? new Set(value) : new Set([value]);\n  }\n\n  get value(): T | T[] | undefined {\n    switch (this.items.size) {\n    case 0: return;\n    case 1: return this.items[Symbol.iterator]().next().value;\n    default: return [...this.items];\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.items[Symbol.iterator]();\n  }\n\n  add(...items: T[]): this {\n    items.forEach(item => this.items.add(item));\n    return this;\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  merge(items: readonly T[] | T | undefined): this {\n    if (items == null) {\n      return this;\n    }\n    if (isArray(items)) {\n      return this.add(...items);\n    }\n    return this.add(items);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Arbitrary class constructor.\n *\n * @category Utility\n * @typeparam T  A type of object.\n */\nexport interface Class<T extends object = any> extends Function {\n  new(...args: any[]): T;\n  prototype: T;\n}\n\n/**\n * Detects super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @category Utility\n * @param type  The class constructor to find super class of.\n * @param satisfying  The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  const prototype = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @category Utility\n * @typeparam P  Function parameter types as tuple.\n * @typeparam R  A type of function result.\n * @typeparam T  A type if `this` object expected by function.\n * @param first  The first function to call.\n * @param second  The second function to call.\n * @param merge  Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<P extends any[], R, T>(\n    first: (this: T, ...args: P) => R,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: (this: T, ...args: P) => R,\n    merge?: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge?: (first: R, second: R) => R,\n): ((this: T, ...args: P) => R) | undefined;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R = (_f, s) => s,\n): ((this: T, ...args: P) => R) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: T, ...args: P): R {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node  A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { flatMapIt, mapIt } from 'a-iterable';\nimport { asis } from 'call-thru';\nimport { Class, superClassOf } from './classes';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<M, S = M> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): M | undefined {\n    // eslint-disable-next-line no-prototype-builtins\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] : undefined;\n  }\n\n  of(type: Class): M | undefined {\n\n    const ownDef: M | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<C extends Class>(type: C, sources: Iterable<S>): C {\n\n    const prevMeta = this.own(type);\n    const updates = mapIt(sources, source => this.meta(source, type));\n    const newMeta: M = this.merge(prevMeta ? flatMapIt([[prevMeta], updates], asis) : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: Iterable<M>): M;\n\n  protected abstract meta(source: S, type: Class): M;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * @category Utility\n */\nexport class PromiseResolver<T = void> {\n\n  readonly promise: Promise<T>;\n  private _resolve!: (value: T) => void;\n  private _reject!: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  resolve(value: T): void {\n    this._resolve(value);\n  }\n\n  reject(error: any): void {\n    this._reject(error);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from 'a-iterable';\nimport { BootstrapSetup } from '../boot';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup  Bootstrap setup.\n     */\n    setup?(setup: BootstrapSetup): void;\n\n    /**\n     * Bootstraps this feature by calling the given bootstrap context constructed.\n     *\n     * @param context  Feature initialization context.\n     */\n    init?(context: FeatureContext): void;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType  A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: Iterable<FeatureDef.Options>): FeatureDef.Options {\n    return itsReduction<FeatureDef.Options, FeatureDef.Options>(\n        defs,\n        (prev, def) => ({\n          needs: new ArraySet(prev.needs).merge(def.needs).value,\n          has: new ArraySet(prev.has).merge(def.has).value,\n          setup: mergeFunctions<[BootstrapSetup], void, Class>(prev.setup, def.setup),\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType  Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType  Target feature class constructor.\n   * @param def  A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs  Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs  Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return itsReduction<FeatureDef, FeatureDef.Factory>(\n        defs,\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeparam T  Feature type.\n   * @param featureType  Feature class constructor.\n   * @param defs  Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(this: void, featureType: T, ...defs: readonly FeatureDef[]): T {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to [[bootstrapComponents]] function or referenced by other features.\n *\n * This is an alternative to direct call to [[FeatureDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated feature class.\n * @param defs  Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, ...defs);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, ComponentFactory, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext extends BootstrapContext implements BootstrapSetup {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  abstract readonly whenReady: OnEvent<[FeatureContext]>;\n\n  abstract readonly onDefinition: OnEvent<[DefinitionContext]>;\n\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a [[BootstrapSetup.provide]] method can be used.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class): FeatureRef {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.Options.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.Options.has provides} another one.\n *\n * @category Core\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n *\n * @category Core\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs  Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: ' + needs.reduce(\n        (\n            prev,\n            [feature, reason, need],\n        ) => (prev ? prev : feature.name) + ` ${reason} ${need.name}`,\n        '',\n        ),\n    );\n    this.needs = needs;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from 'a-iterable';\nimport { isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup  Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param context  Component definition context.\n     */\n    define?(context: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType  A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: Iterable<ComponentDef.Options<T>>): ComponentDef.Options<T> {\n    return itsReduction<ComponentDef.Options<T>, ComponentDef.Options<T>>(\n        defs,\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as any)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as any)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType  Target component class constructor.\n   * @param source  A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return itsReduction<ComponentDef<T>, ComponentDef.Factory<T>>(\n        defs,\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under [[ComponentDef__symbol]] key.\n   *\n   * Each component can be passed directly to [[bootstrapComponents]] function or added as a requirement\n   * of another feature.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   * @param defs  Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      this: void,\n      componentType: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by [[Component]] function.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n */\nexport type ComponentDecorator<T extends ComponentClass = any> =\n    & ((this: void, type: T) => T | void)\n    & ComponentDef<InstanceType<T>>;\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with [[FeatureContext.define]] method or used as a feature, e.g. passed to\n * [[bootstrapComponents]] function, or added to [[FeatureDef.Options.needs]] property of another feature.\n *\n * This is an alternative to direct call to [[ComponentDef.Options.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n * @param defs  Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<T>>[]\n): ComponentDecorator<T> {\n\n  const decorator = ((type: T) => ComponentDef.define(type, ...defs)) as ComponentDecorator<T>;\n  const def = decorator as ComponentDef.Factory<InstanceType<T>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from 'context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { SingleContextKey } from 'context-values';\nimport { DomEventDispatcher, OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault() {\n        return {\n          dispatch(context: ComponentContext, event: Event): boolean {\n            return context.element.dispatchEvent(event);\n          },\n          on<E extends Event>(context: ComponentContext, type: string): OnDomEvent<E> {\n\n            const dispatcher = new DomEventDispatcher(context.element);\n\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * @category Core\n */\nexport type ContentRoot = ParentNode;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { FnContextKey, FnContextRef } from 'context-values';\nimport { StatePath } from 'fun-events';\n\n/**\n * Component state updater function.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeparam V  Updated value type\n * @param path  Updated state node path.\n * @param newValue  New value.\n * @param oldValue  Replaced value.\n */\n    <V>(this: void, path: StatePath, newValue: V, oldValue: V) => void;\n\n/**\n * A key of component context value containing a component state updates receiver function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Note that this value is not provided, unless the `StateSupport` feature is enabled.\n *\n * @category Core\n */\nexport const StateUpdater: FnContextRef<Parameters<StateUpdater>> = (/*#__PURE__*/ new FnContextKey(\n    'state-updater',\n    {\n      byDefault: valueProvider(noop),\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { EventSupply, OnEvent, StatePath } from 'fun-events';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { BootstrapContext__key } from '../boot/bootstrap-context.key.impl';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perComponent]] and [[DefinitionSetup.perComponent]] methods.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A [[whenReady]] callback could\n   * be utilized to work this around.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is defined when component is mounted to arbitrary element by [[ComponentFactory.mountTo]]. Ot is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the custom element is connected.\n   *\n   * This becomes `true` right before [[whenOn]] event is sent, and becomes `false` right before [[whenOff]] event is\n   * sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An `OnEvent` sender of custom element connection events.\n   *\n   * The registered receivers are called when custom element is connected, i.e. its `connectedCallback()` method is\n   * called. If component is connected already the receiver is called immediately.\n   *\n   * Sends a connection supply that is cut off once custom element is disconnected.\n   */\n  abstract readonly whenOn: OnEvent<[EventSupply]>;\n\n  /**\n   * An `OnEvent` sender of custom element disconnection events.\n   *\n   * The registered receivers are called when custom element is disconnected, i.e. its `disconnectedCallback()` method\n   * is called. If component is ready but disconnected, the receiver is called immediately.\n   */\n  abstract readonly whenOff: OnEvent<[]>;\n\n  /**\n   * An `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component destruction reason event.\n   *\n   * The registered receiver is notified when [[destroy]] method is called. If the component is destroyed already\n   * the receiver is notified immediately.\n   */\n  abstract readonly whenDestroyed: OnEvent<[any]>;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * Note that state update has no effect unless [[StateSupport]] feature is enabled or [[StateUpdater]] context value\n   * is provided by other means.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  readonly updateState: StateUpdater = updateComponentState.bind(this);\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element  Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under [[ComponentContext__symbol]] key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = element[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${element}`);\n    }\n\n    return context;\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): ContentRoot {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Returns a `super` property value inherited from custom element parent.\n   *\n   * @param key  Target property key.\n   */\n  abstract elementSuper(key: PropertyKey): any;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return this.get(ComponentEventDispatcher__key).on(this, type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event  An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(BootstrapContext__key).get(ComponentEventDispatcher__key).dispatch(this, event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   *\n   * @param reason  Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n\n/**\n * @internal\n */\nfunction updateComponentState<V>(this: ComponentContext<any>, key: StatePath, newValue: V, oldValue: V): void {\n  this.get(StateUpdater)(key, newValue, oldValue);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextRef } from 'context-values';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using [[ComponentEventDispatcher]] available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param context  Target component context.\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(context: ComponentContext, event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @param context  Target component context.\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(context: ComponentContext, type: string): OnDomEvent<E>;\n\n}\n\n/**\n * A key of bootstrap context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { AfterEvent, afterThe, EventKeeper } from 'fun-events';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element  Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ElementAdapter>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.dig((...adapters) => {\n\n          const combined: ElementAdapter = adapters.reduce(\n              (prev, adapter) => element => prev(element) || adapter(element),\n              defaultElementAdapter,\n          );\n\n          const defaultProvider = (): AfterEvent<[ElementAdapter]> => afterThe(defaultElementAdapter);\n\n          return combined !== defaultElementAdapter\n              ? afterThe(combined)\n              : opts.byDefault(defaultProvider) || defaultProvider();\n        }),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter,\n          AfterEvent<ElementAdapter[]>>,\n  ): ElementAdapter {\n\n    let delegated: ElementAdapter;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(adapter => delegated = adapter);\n\n    return element => delegated(element);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: any): ComponentContext {\n  return element[ComponentContext__symbol];\n}\n\n/**\n * A key of bootstrap context value containing combined [[ElementAdapter]] instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = (/*#__PURE__*/ new ElementAdapterKey());\n","/**\n * @packageDocumentation\n * @module wesib/wesib\n */\nimport { filterIt, itsEach, overArray } from 'a-iterable';\nimport { FnContextKey } from 'context-values';\nimport { isElement } from '../../common';\nimport { ComponentContext__symbol, ComponentMount } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * [[disconnect]].\n   *\n   * @param target  A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options  An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new [[ElementObserver]] instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node)?.checkConnected(),\n                );\n                itsEach(\n                    filterIt(\n                        overArray(mutation.addedNodes),\n                        isElement,\n                    ),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: any): ComponentMount | undefined {\n  return node[ComponentContext__symbol]?.mount;\n}\n","import { ComponentClass, ComponentFactory } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const ComponentFactory__symbol = (/*#__PURE__*/ Symbol('component-factory'));\n\n/**\n * @internal\n */\nexport function componentFactoryOf<T extends object>(componentType: ComponentClass<T>): ComponentFactory<T> {\n\n  const factory = (componentType as any)[ComponentFactory__symbol];\n\n  if (!factory) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n\n  return factory;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, SingleContextKey } from 'context-values';\nimport { html__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { componentFactoryOf } from '../../boot/impl/component-factory.symbol.impl';\nimport { Class, PromiseResolver } from '../../common';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: createCustomElements,\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName  A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType  A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName  Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(values: ContextValues): CustomElements {\n\n  const customElements: CustomElementRegistry = values.get(BootstrapWindow).customElements;\n  const nsAlias = values.get(DefaultNamespaceAliaser);\n\n  class WindowCustomElements extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name, extend } = factory.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name } = factory.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise;\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new WindowCustomElements();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: ComponentClass): PromiseResolver<void> {\n  return (componentType as any)[ComponentResolver__symbol]\n      || ((componentType as any)[ComponentResolver__symbol] = new PromiseResolver());\n}\n","import { SingleContextKey } from 'context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class } from '../../common';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../component-context';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perDefinition]] and [[DefinitionSetup.perDefinition]] methods. All [[BootstrapContext]] values\n * are available too.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * An `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenOn connected}. This is to prevent resource leaking\n   * on disconnected components that may be never used again.\n   */\n  abstract readonly whenComponent: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeparam Deps  A type of dependencies.\n   * @typeparam Src  The type of context value sources.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Component context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void;\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, ContextValues, SingleContextKey } from 'context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst ComponentContextRegistry__key = new SingleContextKey<ComponentContextRegistry>(\n    'component-context-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n);\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentContextRegistry> {\n    return ComponentContextRegistry__key;\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst DefinitionContextRegistry__key = new SingleContextKey<DefinitionContextRegistry>(\n    'definition-context-registry',\n    {\n      byDefault: bootstrapDefault(context => new DefinitionContextRegistry(context)),\n    },\n);\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n\n  static get [ContextKey__symbol](): ContextKey<DefinitionContextRegistry> {\n    return DefinitionContextRegistry__key;\n  }\n\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { EventEmitter, onAny, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { superClassOf } from '../../common';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\nimport { Unloader } from './unloader.impl';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    unloader: Unloader,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on({\n      supply: receiver.supply.needs(unloader.supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady.tillOff(unloader.supply);\n        const whenComponent = setup.whenComponent.tillOff(unloader.supply);\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return unloader.add(() => setup.perDefinition(spec));\n          },\n          perComponent(spec) {\n            return unloader.add(() => setup.perComponent(spec));\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: ComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return (componentType as any)[PostDefSetup__symbol];\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read.thru(setup => setup ? nextArgs(setup) : nextSkip());\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","import { AfterEvent, EventEmitter, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read.keep.thru_(\n        rev => (context, notifiedRev) => {\n          created.send(context, notifiedRev);\n          return rev;\n        },\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { nextArgs, nextSkip, noop } from 'call-thru';\nimport { ContextRegistry, ContextValues, ContextValueSpec, SingleContextKey, SingleContextRef } from 'context-values';\nimport { EventEmitter, eventSupply, EventSupply, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { Class } from '../../common';\nimport {\n  ComponentContext as ComponentContext_,\n  ComponentContext__symbol,\n  ComponentDef,\n  ComponentEvent,\n  ComponentMount as ComponentMount_,\n} from '../../component';\nimport {\n  ComponentClass,\n  ComponentFactory as ComponentFactory_,\n  DefinitionContext as DefinitionContext_,\n  DefinitionSetup,\n  ElementDef,\n} from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ComponentContextRegistry } from './component-context-registry.impl';\nimport { DefinitionContextRegistry } from './definition-context-registry.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext_]>;\n  readonly components: EventEmitter<[ComponentContext_]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): ComponentFactory_<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Off,\n  On,\n}\n\nconst ComponentStatus__symbol = (/*#__PURE__*/ Symbol('component-status'));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n\n  const definitionContextRegistry$global = bsContext.get(DefinitionContextRegistry);\n  const componentContextRegistry$global = bsContext.get(ComponentContextRegistry);\n  const definitions = new EventEmitter<[DefinitionContext_]>();\n  const components = new EventEmitter<[ComponentContext_]>();\n\n  return {\n    definitions,\n    components,\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const def = ComponentDef.of(componentType);\n      const whenComponent = new WhenComponent<T>();\n      let componentContextRegistry$perType!: ComponentContextRegistry;\n      const ready = trackValue(false);\n      const whenReady: OnEvent<[]> = ready.read.thru(cls => cls ? nextArgs() : nextSkip());\n      // eslint-disable-next-line prefer-const\n      let definitionContext: DefinitionContext;\n\n      function createComponentContextRegistry(): ContextRegistry<ComponentContext_<T>> {\n        return componentContextRegistry$global.append(componentContextRegistry$perType);\n      }\n\n      class ComponentFactory extends ComponentFactory_ < T > {\n\n        get componentType(): ComponentClass<T> {\n          return definitionContext.componentType;\n        }\n\n        get elementType(): Class {\n          return definitionContext.elementType;\n        }\n\n        get elementDef(): ElementDef {\n          return definitionContext.elementDef;\n        }\n\n        mountTo(element: any): ComponentMount_<T> {\n          if (element[ComponentContext__symbol]) {\n            throw new Error(`Element ${element} already bound to component`);\n          }\n\n          const mount = createComponent({\n            definitionContext,\n            whenComponent,\n            registry: createComponentContextRegistry(),\n            element,\n            elementSuper(key) {\n              return element[key];\n            },\n            createMount(context: ComponentContext_<T>) {\n\n              class ComponentMount extends ComponentMount_<T> {\n\n                get context(): ComponentContext_<T> {\n                  return context;\n                }\n\n                get connected(): boolean {\n                  return elementStatus(element).it === ComponentStatus.On;\n                }\n\n                set connected(value: boolean) {\n                  elementStatus(element).it = value ? ComponentStatus.On : ComponentStatus.Off;\n                }\n\n                checkConnected(): boolean {\n\n                  const el: Element = element;\n                  const doc = el.ownerDocument;\n\n                  return this.connected = doc != null && doc.contains(el);\n                }\n\n              }\n\n              return new ComponentMount();\n            },\n          }).mount as ComponentMount_<T>;\n\n          mount.checkConnected();\n          componentCreated(mount.context);\n\n          return mount;\n        }\n\n      }\n\n      const componentFactory = new ComponentFactory();\n\n      class DefinitionContext extends DefinitionContext_<T> {\n\n        readonly get: ContextValues['get'];\n        readonly whenReady: OnEvent<[this]>;\n\n        get componentType(): ComponentClass<T> {\n          return componentType;\n        }\n\n        get whenComponent(): OnEvent<[ComponentContext_<T>]> {\n          return whenComponent.onCreated;\n        }\n\n        get elementType(): Class {\n          throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n        }\n\n        constructor() {\n          super();\n\n          const context = this;\n\n          this.whenReady = whenReady.thru_(() => this).once;\n\n          const definitionContextRegistry = new DefinitionContextRegistry(\n              definitionContextRegistry$global.seedIn(this),\n          );\n\n          definitionContextRegistry.provide({ a: DefinitionContext_, is: this });\n          definitionContextRegistry.provide({ a: ComponentFactory_, is: componentFactory });\n          this.get = definitionContextRegistry.newValues().get;\n          componentContextRegistry$perType = new ComponentContextRegistry(definitionContextRegistry.seedIn(this));\n\n          const definitionSetup: DefinitionSetup<T> = {\n            get componentType() {\n              return componentType;\n            },\n            get whenReady() {\n              return context.whenReady;\n            },\n            get whenComponent() {\n              return context.whenComponent;\n            },\n            perDefinition(spec) {\n              return definitionContextRegistry.provide(spec);\n            },\n            perComponent(spec) {\n              return componentContextRegistry$perType.provide(spec);\n            },\n          };\n\n          def.setup?.(definitionSetup);\n          postDefSetup(componentType).setup(definitionSetup);\n        }\n\n        perComponent<Deps extends any[], Src, Seed>(\n            spec: ContextValueSpec<ComponentContext_<T>, any, Deps, Src, Seed>,\n        ): () => void {\n          return componentContextRegistry$perType.provide(spec);\n        }\n\n      }\n\n      definitionContext = new DefinitionContext();\n\n      def.define?.(definitionContext);\n      definitions.send(definitionContext);\n\n      const elementType = createElementType(\n          definitionContext,\n          whenComponent,\n          createComponentContextRegistry(),\n      );\n\n      Object.defineProperty(definitionContext, 'elementType', {\n        configurable: true,\n        enumerable: true,\n        value: elementType,\n      });\n\n      ready.it = true;\n\n      return componentFactory;\n    },\n  };\n\n  function createElementType<T extends object>(\n      definitionContext: DefinitionContext_<T>,\n      whenComponent: WhenComponent<T>,\n      componentContextRegistry: ComponentContextRegistry,\n  ): Class {\n\n    const elementDef = definitionContext.get(ElementDef);\n\n    class Element extends elementDef.extend.type {\n\n      // Component context reference\n      [ComponentContext__symbol]: ComponentContext_<T>;\n\n      constructor() {\n        super();\n\n        const context = createComponent({\n          definitionContext,\n          whenComponent,\n          registry: componentContextRegistry,\n          element: this,\n          createMount: noop,\n          elementSuper: key => super[key],\n        });\n\n        componentCreated(context);\n      }\n\n      connectedCallback(): void {\n        elementStatus(this).it = ComponentStatus.On;\n      }\n\n      disconnectedCallback(): void {\n        elementStatus(this).it = ComponentStatus.Off;\n      }\n\n    }\n\n    return Element;\n  }\n\n  function createComponent<T extends object>(\n      {\n        definitionContext,\n        whenComponent,\n        registry,\n        element,\n        createMount,\n        elementSuper,\n      }: {\n        definitionContext: DefinitionContext_<T>;\n        whenComponent: WhenComponent<T>;\n        registry: ComponentContextRegistry;\n        element: any;\n        elementSuper(name: PropertyKey): any;\n        createMount(context: ComponentContext_<T>): ComponentMount_<T> | undefined;\n      },\n  ): ComponentContext_<T> {\n\n    const status = trackValue<ComponentStatus>(ComponentStatus.Building);\n    const destructionReason = trackValue<[any] | undefined>();\n\n    status.on(noop).whenOff(reason => destructionReason.it = [reason]);\n\n    const destroyed: OnEvent<[any]> = destructionReason.read.thru(reason => reason ? nextArgs(reason[0]) : nextSkip());\n    const whenDestroyed: OnEvent<[any]> = destroyed.once;\n\n    const whenOff: OnEvent<[]> = status.read.thru_(sts => sts === ComponentStatus.Off ? nextArgs() : nextSkip());\n    const whenOn: OnEvent<[EventSupply]> = status.read.thru_(\n        sts => {\n          if (sts !== ComponentStatus.On) {\n            return nextSkip();\n          }\n\n          const offSupply = eventSupply();\n\n          whenOff.once(() => offSupply.off());\n\n          return nextArgs(offSupply);\n        },\n    );\n\n    let mount: ComponentMount_<T> | undefined;\n    const values = registry.newValues();\n\n    class ComponentContext extends ComponentContext_<T> {\n\n      readonly get = values.get;\n      readonly elementSuper = elementSuper;\n      readonly whenReady: OnEvent<[this]>;\n\n      constructor() {\n        super();\n\n        const whenReady: OnEvent<[this]> = status.read.thru(sts => sts ? nextArgs(this) : nextSkip());\n\n        this.whenReady = whenReady.once;\n      }\n\n      get componentType(): ComponentClass<T> {\n        return definitionContext.componentType;\n      }\n\n      get element(): any {\n        return element;\n      }\n\n      get component(): T {\n        throw new Error('The component is not constructed yet. Consider to use a `whenReady()` callback');\n      }\n\n      get mount(): ComponentMount_<T> | undefined {\n        return mount || (mount = createMount(this));\n      }\n\n      get connected(): boolean {\n        return status.it === ComponentStatus.On;\n      }\n\n      get whenOn(): OnEvent<[EventSupply]> {\n        return whenOn;\n      }\n\n      get whenOff(): OnEvent<[]> {\n        return whenOff;\n      }\n\n      get whenDestroyed(): OnEvent<[any]> {\n        return whenDestroyed;\n      }\n\n      destroy(reason?: any): void {\n        status.done(reason);\n      }\n\n    }\n\n    const context = new ComponentContext();\n    let lastRev = 0;\n\n    context.whenDestroyed(() => removeElement(context));\n    registry.provide({ a: ComponentContext_, is: context });\n\n    augmentElement();\n\n    whenComponent.readNotifier.once(notifier => lastRev = notifier(context, lastRev));\n    context.whenOn(supply => {\n      whenComponent.readNotifier({\n        supply,\n        receive(_, notifier) {\n          lastRev = notifier(context, lastRev);\n        },\n      });\n    });\n    components.send(context);\n\n    const component = newComponent(definitionContext.componentType, context);\n\n    Object.defineProperty(context, 'component', {\n      configurable: true,\n      enumerable: true,\n      value: component,\n    });\n\n    status.it = ComponentStatus.Ready;\n\n    return context;\n\n    function augmentElement(): void {\n      Object.defineProperty(element, ComponentContext__symbol, { value: context });\n      Object.defineProperty(element, ComponentStatus__symbol, { writable: true, value: status });\n    }\n  }\n\n}\n\n/**\n * Creates new component of the given type.\n *\n * It makes component context available under `[ComponentContext__symbol]` key in constructed component.\n * The component context is also available inside component constructor by temporarily assigning it to component\n * prototype.\n *\n * @typeparam T  A type of component.\n * @param type  Component class constructor.\n * @param context  Target component context.\n */\nfunction newComponent<T extends object>(type: ComponentClass<T>, context: ComponentContext_<T>): T {\n\n  const proto = type.prototype as any;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    Object.defineProperty(component, ComponentContext__symbol, { value: context });\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nfunction elementStatus(element: any): ValueTracker<ComponentStatus> {\n  return element[ComponentStatus__symbol];\n}\n\nfunction componentCreated(context: ComponentContext_): void {\n  context.whenOn.once(\n      () => context.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n  );\n}\n\nfunction removeElement(context: ComponentContext_): void {\n\n  const { element, mount } = context;\n\n  if (mount) {\n    mount.connected = false; // Disconnect mounted element\n  }\n\n  const parentNode: Element = element.parentElement;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by [[ComponentFactory.mountTo]] method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating [[ComponentMount.connected]] property. E.g. by calling a\n * [[ComponentMount.checkConnected]] method. An [[ElementObserver]] and [[AutoConnectSupport]] feature could be used to\n * do it automatically.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * Updating this property triggers appropriate listeners registered in [[ComponentContext]].\n   *\n   * The initial state is set by [[checkConnected]] method.\n   */\n  abstract connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element;\n  }\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { itsEach, overArray } from 'a-iterable';\nimport { noop, valueProvider } from 'call-thru';\nimport { EventSupply, eventSupply } from 'fun-events';\n\n/**\n * @internal\n */\nexport interface Unloader {\n  readonly supply: EventSupply;\n  add(adder: () => () => void): () => void;\n}\n\nconst doNotAdd = valueProvider(noop);\n\n/**\n * @internal\n */\nexport function newUnloader(): Unloader {\n\n  const unloads: (() => void)[] = [];\n  let add = (adder: () => () => void): () => void => {\n\n    const unload = adder();\n\n    unloads.push(unload);\n\n    return unload;\n  };\n  const supply = eventSupply(() => {\n    add = doNotAdd;\n    itsEach(\n        overArray(unloads).reverse(),\n        unload => unload(),\n    );\n    unloads.length = 0;\n  });\n\n  return {\n    supply,\n    add(adder) {\n      return add(adder);\n    },\n  };\n}\n","import { ElementBuilder } from '../../boot/impl';\nimport { ComponentFactory__symbol } from '../../boot/impl/component-factory.symbol.impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._definitionQueue.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const factory = elementBuilder.buildElement(componentType);\n\n      (componentType as any)[ComponentFactory__symbol] = factory;\n\n      this.customElements.define(componentType, factory.elementType);\n    });\n  }\n\n}\n","import { filterIt, mapIt } from 'a-iterable';\nimport { isPresent, NextArgs, nextArgs, NextSkip, nextSkip } from 'call-thru';\nimport { ContextRegistry, ContextUpKey, ContextValueOpts, ContextValues, ContextValueSpec } from 'context-values';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  EventKeeper,\n  EventSupply,\n  OnEvent,\n  trackValue,\n} from 'fun-events';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ComponentContextRegistry,\n  DefinitionContextRegistry,\n  ElementBuilder,\n  newUnloader,\n  onPostDefSetup,\n} from '../../boot/impl';\nimport { ArraySet, Class } from '../../common';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = (/*#__PURE__*/ Symbol('feature-key'));\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n    // eslint-disable-next-line no-prototype-builtins\n    return feature.hasOwnProperty(FeatureKey__symbol)\n        ? (feature as any)[FeatureKey__symbol]\n        : ((feature as any)[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): AfterEvent<[FeatureLoader?]> | null | undefined {\n    return loadFeature(\n        opts.context.get(BootstrapContext),\n        opts.seed.keep.thru(preferredFeatureClause),\n    );\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n      case 'is':\n        required = true;\n        if (!preferred) {\n          preferred = clause;\n        }\n        break;\n      case 'has':\n        preferred = clause;\n        break;\n      case 'needs':\n        required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: OnEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).dig_(({ clause: [clause], deps }) => {\n      if (!clause) {\n        return afterThe();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return source; // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return source = bsContext.get(FeatureKey.of(origin)).thru_(\n            loader => {\n              loader!.to(stageId);\n              stageId = loader!.stage;\n              return loader;\n            },\n        );\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).share(); // Can be accessed again when reused\n    })(receiver);\n  }).keep.thru(\n      preventDuplicateLoader(),\n  );\n}\n\nfunction preventDuplicateLoader():\n    <NextReturn>(\n        loader?: FeatureLoader,\n    ) => NextArgs<[FeatureLoader?], NextReturn> | NextSkip<[FeatureLoader?], NextReturn> {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return <NextReturn>(loader?: FeatureLoader) => {\n    if (lastLoader === loader) {\n      return nextSkip();\n    }\n    lastLoader = loader;\n\n    if (!loader) {\n      return nextArgs<[FeatureLoader?], NextReturn>();\n    }\n\n    return nextArgs<[FeatureLoader?], NextReturn>(loader);\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.keep.dig_(clause => {\n    if (!clause) {\n      return afterThe();\n    }\n\n    const [{ def }] = clause;\n    const needs = new ArraySet(def.needs);\n\n    if (!needs.size) {\n      return afterThe();\n    }\n\n    return afterEach(...needs.map(dep => bsContext.get(FeatureKey.of(dep))))\n        .keep.thru_(presentFeatureDeps);\n  });\n}\n\nfunction presentFeatureDeps<NextReturn>(...deps: [FeatureLoader?][]): NextArgs<FeatureLoader[], NextReturn> {\n  return nextArgs<FeatureLoader[], NextReturn>(\n      ...filterIt<FeatureLoader | undefined, FeatureLoader>(\n          mapIt(deps, dep => dep[0]),\n          isPresent,\n      ),\n  );\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    delete this._stage; // Unloaded feature should never be accessed again.\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  idle(): Promise<this> {\n    return Promise.resolve(this);\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after(): 'idle' {\n    return 'idle';\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def } } = this.loader;\n    const [context, supply] = newFeatureContext(bsContext, this.loader);\n\n    def.setup?.(context);\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        () => Promise.resolve(supply.off()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after(): 'setup' {\n    return 'setup';\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { def } } = this.loader;\n\n    def.init?.(this._context);\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after(): 'init' {\n    return 'init';\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  init(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n}\n\nfunction newFeatureContext(\n    bsContext: BootstrapContext,\n    loader: FeatureLoader,\n): [FeatureContext, EventSupply] {\n\n  const unloader = newUnloader();\n  let componentRegistry: ComponentRegistry;\n  const definitionContextRegistry = bsContext.get(DefinitionContextRegistry);\n  const componentContextRegistry = bsContext.get(ComponentContextRegistry);\n  const registry = new ContextRegistry<FeatureContext>(bsContext);\n  const elementBuilder = bsContext.get(ElementBuilder);\n  const onDefinition = elementBuilder.definitions.on.tillOff(unloader.supply);\n  const onComponent = elementBuilder.components.on.tillOff(unloader.supply);\n\n  class Context extends FeatureContext {\n\n    readonly get = registry.newValues().get;\n    readonly whenReady: OnEvent<[FeatureContext]>;\n\n    constructor() {\n      super();\n\n      const whenReady: OnEvent<[FeatureContext]> = afterAll({\n        st: loader.state,\n        bs: trackValue<BootstrapContext>().by(bsContext.whenReady),\n      }).thru(\n          ({ st: [ready], bs: [bs] }) => bs && ready ? nextArgs(this) : nextSkip(),\n      );\n\n      this.whenReady = whenReady.once;\n      registry.provide({ a: FeatureContext, is: this });\n      componentRegistry = new ComponentRegistry(this);\n    }\n\n    get feature(): Class {\n      return loader.request.feature;\n    }\n\n    get onDefinition(): OnEvent<[DefinitionContext]> {\n      return onDefinition;\n    }\n\n    get onComponent(): OnEvent<[ComponentContext]> {\n      return onComponent;\n    }\n\n    provide<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => bsContext.get(BootstrapContextRegistry).provide(spec));\n    }\n\n    perDefinition<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => definitionContextRegistry.provide(spec));\n    }\n\n    perComponent<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => componentContextRegistry.provide(spec));\n    }\n\n    setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n      return onPostDefSetup(componentType, unloader);\n    }\n\n    define<T extends object>(componentType: ComponentClass<T>): void {\n      componentRegistry.define(componentType);\n    }\n\n  }\n\n  return [new Context(), unloader.supply];\n}\n","import { ArraySet, Class, mergeFunctions } from '../../common';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest {\n\n  readonly def: FeatureDef.Options;\n  private _uses = 0;\n\n  constructor(\n      private readonly _requester: FeatureRequester,\n      readonly feature: Class,\n      private _revoke: () => void,\n  ) {\n    this.def = featureDef(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    this._revokeBy(registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }));\n\n    new ArraySet(this.def.has).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n    });\n\n    new ArraySet(this.def.needs).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n    });\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(([{ feature }, reason, need]) => [feature, reason, need]));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse(): void {\n    if (!--this._uses) {\n      this._revoke();\n    }\n  }\n\n  private _revokeBy(revoke: () => void): void {\n    this._revoke = mergeFunctions(revoke, this._revoke);\n  }\n\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapContextRegistry } from '../../boot/impl';\nimport { Class } from '../../common';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = (/*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapContextRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapContextRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature, () => this._map.delete(feature));\n\n    this._map.set(feature, request);\n\n    return request.request(clauses);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip } from 'call-thru';\nimport { AfterEvent, afterEventBy, OnEvent, trackValue } from 'fun-events';\nimport { newNamespaceAliaser } from 'namespace-aliaser';\nimport { Class } from '../../common';\nimport { ComponentClass, ComponentFactory, CustomElements } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { componentFactoryOf } from '../impl/component-factory.symbol.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features  Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature))(loader => {\n    loader!.init().then(complete);\n  });\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class Context extends BootstrapContext {\n\n    readonly get = values.get;\n    readonly whenReady: OnEvent<[BootstrapContext]>;\n\n    constructor() {\n      super();\n\n      const whenReady: OnEvent<[BootstrapContext]> = stage.read.thru(\n          s => s ? nextArgs(this) : nextSkip(),\n      );\n\n      this.whenReady = whenReady.once;\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    async whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n      await new Promise(resolve => this.whenReady(resolve));\n      await this.get(CustomElements).whenDefined(componentType);\n      return componentFactoryOf(componentType);\n    }\n\n    load(feature: Class<any>): FeatureRef {\n\n      interface FeatureInfo {\n        status: FeatureStatus;\n        down?: Promise<void>;\n      }\n\n      const status = afterEventBy<[FeatureInfo]>(receiver => {\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<FeatureInfo>({\n          status: {\n            feature,\n            ready: false,\n          },\n        });\n\n        this.get(FeatureKey.of(feature))({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              status: {\n                feature: loader.request.feature,\n                ready: loader.ready,\n              },\n              down: loader.down,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  status: {\n                    feature: loader.request.feature,\n                    ready: true,\n                  },\n                  down: loader.down,\n                };\n              });\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).share();\n\n      let whenDown: Promise<void>;\n      const supply = status(({ down }) => {\n        whenDown = down!;\n      });\n      const read: AfterEvent<[FeatureStatus]> = status.keep.thru(\n          info => info.status,\n      ).tillOff(supply);\n\n      class Ref extends FeatureRef {\n\n        get read(): AfterEvent<[FeatureStatus]> {\n          return read;\n        }\n\n        get down(): Promise<void> {\n          return whenDown;\n        }\n\n        dismiss(reason?: any): Promise<void> {\n          supply.off(reason);\n          return whenDown;\n        }\n\n      }\n\n      return new Ref();\n    }\n\n  }\n\n  const bootstrapContext = new Context();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module wesib/wesib\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper } from 'fun-events';\nimport { FeatureStatus } from './feature-status';\n\n/**\n * Dynamically loaded feature reference.\n *\n * It is returned from [[BootstrapContext.load]] and can be used to read feature load status and unload it.\n *\n * Implements an `EventKeeper` interface by sending a feature load status updates.\n *\n * @category Core\n */\nexport abstract class FeatureRef implements EventKeeper<[FeatureStatus]> {\n\n  /**\n   * An `AfterEvent` sender of feature load status updates.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[FeatureStatus]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[FeatureStatus]> {\n    return this.read;\n  }\n\n  /**\n   * A promise resolved when feature is unloaded.\n   *\n   * This happens after all feature references dismissed.\n   */\n  abstract readonly down: Promise<void>;\n\n  /**\n   * Dismisses feature reference.\n   *\n   * When all feature references dismissed, then unloads the feature. This removes everything set up by the\n   * feature via [[BootstrapSetup]] and [[DefinitionSetup]].\n   *\n   * @param reason  Arbitrary reason of feature reference dismiss. This will be reported by load status supplies\n   * as their cut off reason.\n   *\n   * @returns A promise resolved when feature is unloaded. This happens only after all feature references dismissed.\n   */\n  abstract dismiss(reason?: any): Promise<void>;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n */\nexport type DomPropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath__rootKeys, K];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): DomPropertyPath<K> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface DomPropertyPath__rootKeys {\n  [DomPropertyPath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { StateTracker } from 'fun-events';\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new SingleContextKey<ComponentState>('component-state'));\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, StateUpdater } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ComponentState } from './component-state';\n\n/**\n * @internal\n */\nconst StateSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentState,\n      by(context: ComponentContext) {\n\n        const state = new ComponentState();\n\n        context.whenDestroyed(reason => state.done(reason));\n\n        return state;\n      },\n    });\n    setup.perComponent({\n      a: StateUpdater,\n      by(state: ComponentState) {\n        return state.update;\n      },\n      with: [ComponentState],\n    });\n  },\n};\n\n/**\n * Component state support feature.\n *\n * When enabled, it registers the following component context values:\n *\n * - [[StateUpdater]] that allows to update the component state, and\n * - [[ComponentState]] that allows to track component state changes.\n *\n * Other features would use this to notify when the state changes. E.g. [[DomPropertiesSupport]]\n * and [[AttributesSupport]] features issue state updates when needed.\n *\n * @category Feature\n */\nexport class StateSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StateSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { RenderDef } from './render-def';\n\n/**\n * Component element render function interface.\n *\n * It has no arguments. It may return either nothing, or a function. In the latter case the returned function will be\n * called immediately to render the element. It may, in turn, return a render function, and so on.\n *\n * @category Feature\n */\nexport type ElementRender =\n/**\n * @returns Either delegated render, or nothing.\n */\n    (this: void) => void | ElementRender;\n\n/**\n * @category Feature\n */\nexport const ElementRender = {\n\n  /**\n   * Enables component element rendering.\n   *\n   * The `render` call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n   *\n   * @param context  Target component context.\n   * @param render  Element render function.\n   * @param def  Optional element render definition.\n   */\n  render(\n      this: void,\n      context: ComponentContext,\n      render: ElementRender,\n      def: RenderDef = {},\n  ): void {\n\n    const { offline, path = [] } = def;\n    const stateTracker = context.get(ComponentState).track(path);\n    const schedule = context.get(DefaultRenderScheduler)();\n\n    let rendered = false;\n    const stateSupply = stateTracker.onUpdate(() => {\n      if (offline || context.connected) {\n        scheduleRender();\n      } else {\n        rendered = false;\n      }\n    });\n\n    if (offline) {\n      scheduleRender();\n    } else {\n      context.whenOn(() => {\n        if (!rendered) {\n          scheduleRender();\n        }\n      }).whenOff(reason => {\n        stateSupply.off(reason);\n        rendered = true;\n      });\n    }\n\n    function scheduleRender(): void {\n      rendered = true;\n      schedule(renderElement);\n    }\n\n    function renderElement(): void {\n      for (;;) {\n\n        const newRender = render();\n\n        if (newRender === render || typeof newRender !== 'function') {\n          break;\n        }\n\n        render = newRender;\n      }\n    }\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { TypedPropertyDecorator } from '../../common';\nimport { ComponentDef } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StateSupport } from '../state';\nimport { ElementRender } from './element-render';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * This decorator automatically enables [[StateSupport]] feature.\n *\n * Utilizes [[ElementRender.render]] function to define rendering.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(def?: RenderDef): TypedPropertyDecorator<T> {\n  return (target: InstanceType<T>, propertyKey: string | symbol) => {\n\n    const componentType = target.constructor as T;\n\n    ComponentDef.define(\n        componentType,\n        {\n          feature: {\n            needs: StateSupport,\n          },\n          define(defContext) {\n            defContext.whenComponent(componentContext => {\n              componentContext.whenReady(() => {\n\n                const component = componentContext.component as any;\n                const render: () => any = component[propertyKey].bind(component);\n\n                ElementRender.render(componentContext, render, def);\n              });\n            });\n          },\n        },\n    );\n  };\n}\n","import { NamespaceDef } from 'namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n","import { ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { AfterEvent, afterThe, EventKeeper, EventSender, OnEvent, onSupplied } from 'fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<Res>,\n    request: Request,\n) => EventSender<Res>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n) => OnEvent<Res>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<Res extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>\n    implements ContextUpRef<CombinedFetchAgent<Res>, FetchAgent<Res>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keep.dig(\n            (...agents) => {\n              if (agents.length) {\n                return afterThe(combineFetchAgents(agents));\n              }\n\n              const defaultProvider = (): AfterEvent<[CombinedFetchAgent<Res>]> => afterThe(defaultFetchAgent);\n\n              return opts.byDefault(defaultProvider) || defaultProvider();\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          CombinedFetchAgent<Res>,\n          EventKeeper<FetchAgent<Res>[]> | FetchAgent<Res>,\n          AfterEvent<FetchAgent<Res>[]>>,\n  ): CombinedFetchAgent<Res> {\n\n    let delegated!: CombinedFetchAgent<Res>;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(agent => delegated = agent);\n\n    return (next, request) => delegated(next, request);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<Res extends any[]>(\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n): OnEvent<Res> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<Res extends any[]>(agents: FetchAgent<Res>[]): CombinedFetchAgent<Res> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<Res> = (agentIdx, agentRequest) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter [[HttpFetch]] processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by [[HttpFetch]].\n */\nexport type HttpFetchAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * [[HttpFetch]] call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under [[HttpFetchAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of response object(s) receivers. It is returned as a result of [[HttpFetch]] call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an [[HttpFetchAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { EventEmitter, EventSupply, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: EventSupply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new (window as any).AbortController();\n        const { signal } = abortController;\n\n        supply = eventSupply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal).on('abort').once(() => abortController.abort());\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { FnContextKey, FnContextRef } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of [[HttpFetch]] is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input  The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init  Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an [[HttpFetch]] instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import {\n  BootstrapContext,\n  BootstrapRoot,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n} from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\n\n/**\n * @internal\n */\nexport type HierarchyRoot = ValueTracker<ComponentContext | undefined>;\n\n/**\n * @internal\n */\nexport const HierarchyRoot = (/*#__PURE__*/ new SingleContextKey<HierarchyRoot>(\n    'hierarchy-root',\n    {\n      byDefault: bsContext => {\n\n        const root: Element = bsContext.get(BootstrapRoot);\n\n        new DomEventDispatcher(root).on<ComponentEvent>('wesib:component')(\n            ({ context }: ComponentEvent) => context.get(HierarchyUpdates).issue(),\n        );\n\n        return trackValue();\n      },\n    },\n));\n\nconst HierarchyUpdates__key = (/*#__PURE__*/ new SingleContextKey<HierarchyUpdates>(\n    'hierarchy-updates',\n    {\n      byDefault: context => new HierarchyUpdates(context.get(ComponentContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class HierarchyUpdates {\n\n  static get [ContextKey__symbol](): ContextKey<HierarchyUpdates> {\n    return HierarchyUpdates__key;\n  }\n\n  readonly on: OnEvent<[ComponentContext]>;\n  readonly send: (this: void) => void;\n  readonly issue: () => void;\n\n  constructor(context: ComponentContext) {\n\n    const updates = new EventEmitter<[ComponentContext]>();\n    const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n\n    this.on = updates.on;\n    this.send = () => updates.send(context);\n    this.issue = () => {\n\n      const parent = findParentContext(context);\n\n      if (parent) {\n        parent[0].get(HierarchyUpdates).send();\n      } else {\n        hierarchyRoot.it = context;\n      }\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport function findParentContext(of: ComponentContext): [ComponentContext, boolean] | undefined {\n\n  const root = of.get(BootstrapContext).get(BootstrapRoot);\n  let element: Node = of.element;\n  let immediate = true;\n\n  if (element === root) {\n    return;\n  }\n  for (;;) {\n\n    const parent = element.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    const ctx: ComponentContext = (parent as any)[ComponentContext__symbol];\n\n    if (ctx) {\n      return [ctx, immediate];\n    }\n    if (parent === root) {\n      return;\n    }\n\n    immediate = false;\n    element = parent;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext } from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { AfterEvent, afterEventBy, EventKeeper, eventSupply, trackValue } from 'fun-events';\nimport { newHierarchyRegistry } from './hierarchy-registry.impl';\nimport { findParentContext, HierarchyRoot, HierarchyUpdates } from './hierarchy-updates.impl';\n\n/**\n * @internal\n */\nconst HierarchyContext__key = (/*#__PURE__*/ new SingleContextKey<HierarchyContext>(\n    'hierarchy-context',\n    {\n      byDefault: context => newHierarchyContext(context.get(ComponentContext)),\n    },\n));\n\n/**\n * Component's hierarchy context.\n *\n * Passes provided values to hierarchy contexts of nested components.\n *\n * Available as component context value.\n *\n * @typeparam T  A type of component.\n */\nexport abstract class HierarchyContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of component context value containing its hierarchy context instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<HierarchyContext> {\n    return HierarchyContext__key;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * An `AfterEvent` keeper of enclosing component's hierarchy context.\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   */\n  abstract readonly up: AfterEvent<[HierarchyContext?]>;\n\n  /**\n   * Provides hierarchy context value.\n   *\n   * The provided value will be available in context itself, as well as in all nested hierarchy contexts.\n   *\n   * Note that the provided value key has to `ContextUpKey`.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src | EventKeeper<Src[]>, Seed>,\n  ): () => void;\n\n}\n\n/**\n * @internal\n */\nfunction newHierarchyContext<T extends object>(context: ComponentContext<T>): HierarchyContext<T> {\n\n  const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n  const up = afterEventBy<[HierarchyContext?]>(\n      receiver => {\n\n        const parentHierarchy = trackValue<HierarchyContext>();\n        const rootSupply = eventSupply().needs(receiver.supply);\n        const parentSupply = eventSupply().needs(receiver.supply);\n        const updateParent = (): void => {\n\n          const parent = findParentContext(context);\n\n          if (parent) {\n\n            const [parentCtx, immediate] = parent;\n\n            parentHierarchy.it = parentCtx.get(HierarchyContext);\n            rootSupply.off();\n            if (immediate) {\n              parentSupply.off();\n            }\n          } else {\n            parentHierarchy.it = undefined;\n          }\n        };\n\n        hierarchyRoot.read({\n          supply: rootSupply,\n          receive: () => context.connected && updateParent(),\n        });\n        parentHierarchy.read.consume(\n            newParent => newParent && newParent.context.get(HierarchyUpdates).on(updateParent),\n        ).needs(parentSupply);\n        parentHierarchy.read(receiver);\n        context.whenOn({\n          supply: receiver.supply,\n          receive: (_, onSupply) => {\n            updateParent();\n            onSupply.whenOff(\n                () => {\n                  Promise.resolve().then(\n                      () => context.connected || (parentHierarchy.it = undefined),\n                  );\n                },\n            );\n          },\n        });\n      },\n  ).share();\n  const registry = newHierarchyRegistry<T>(up);\n  const values = registry.newValues();\n\n  class HierarchyCtx extends HierarchyContext<T> {\n\n    readonly get = values.get;\n\n    get context(): ComponentContext<T> {\n      return context;\n    }\n\n    get up(): AfterEvent<[HierarchyContext?]> {\n      return up;\n    }\n\n    provide<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src | EventKeeper<Src[]>, Seed>,\n    ): () => void {\n      return registry.provide(spec);\n    }\n\n  }\n\n  return new HierarchyCtx();\n}\n","import { ContextRegistry } from 'context-values';\nimport { AfterEvent, afterThe } from 'fun-events';\nimport { HierarchyContext } from './hierarchy-context';\n\n/**\n * @internal\n */\nexport function newHierarchyRegistry<T extends object>(\n    up: AfterEvent<[HierarchyContext?]>,\n): ContextRegistry<HierarchyContext<T>> {\n  return new ContextRegistry(\n      key => up.keep.dig(\n          upper => ((upper ? upper.get(key) : afterThe()) as any),\n      ) as any,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested components.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType  Nested component type with custom element name.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode  A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * @param name  Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null, string>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @param key  Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<V>(key: PropertyKey): ValueTracker<V>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>('component-node')\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { AIterable, ArrayLikeIterable } from 'a-iterable';\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n */\nexport abstract class ElementNodeList<N extends ElementNode = ElementNode>\n    extends AIterable<N>\n    implements EventSender<[N[], N[]]>, EventKeeper<[ElementNodeList<N>]> {\n\n  /**\n   * An `OnEvent` sender of list changes. Sends arrays of added and removed nodes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[N[], N[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[N[], N[]]> {\n    return this.onUpdate;\n  }\n\n  /**\n   * An `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[ElementNodeList<N>]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[ElementNodeList<N>]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of node list changes.\n   *\n   * Sends an iterables of added and removed nodes. Sends current nodes immediately upon receiver registration.\n   */\n  abstract readonly track: AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>;\n\n  /**\n   * An `AfterEvent` keeper of the first node in this list.\n   */\n  abstract readonly first: AfterEvent<[N?]>;\n\n}\n","import {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport { AIterable, ArrayLikeIterable, filterIt, itsEach, itsFirst, itsIterator, mapIt, overArray } from 'a-iterable';\nimport { isPresent, nextArgs } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterSupplied, EventEmitter, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { html__naming } from 'namespace-aliaser';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList as ElementNodeList_ } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<N extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => N | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList_<N> {\n\n  const updates = new EventEmitter<[N[], N[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let iterable: Iterable<N> | undefined;\n  let selector: string | undefined;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      iterable = undefined;\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = Array.from(\n                filterIt<N | undefined, N>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    });\n  }\n\n  const observer = bsContext.get(ElementObserver)(update);\n  let nodeList: ElementNodeList;\n\n  const onUpdate = onEventBy<[N[], N[]]>(receiver => {\n\n    const firstReceiver = !updates.size;\n    const supply = updates.on(receiver);\n\n    if (firstReceiver) {\n      refresh();\n      observer.observe(root, init);\n    }\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      if (!updates.size) {\n        observer.disconnect();\n      }\n    }).needs(supply);\n  });\n  const read = afterEventBy<[ElementNodeList]>(onUpdate.thru(() => nodeList), () => [nodeList]);\n  const onTrackUpdate: OnEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]> = onUpdate.thru(\n      (added, removed) => nextArgs(AIterable.of(added), AIterable.of(removed)),\n  );\n  const track = afterEventBy<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>(receiver => {\n\n    const initialEmitter = new EventEmitter<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>();\n\n    initialEmitter.on(receiver);\n    initialEmitter.send(nodeList, AIterable.of([]));\n\n    onTrackUpdate(receiver);\n  });\n  const first: AfterEvent<[N?]> = afterSupplied(read).keep.thru(itsFirst);\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as N;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  class ElementNodeList extends ElementNodeList_<N> {\n\n    get onUpdate(): OnEvent<[N[], N[]]> {\n      return onUpdate;\n    }\n\n    get read(): AfterEvent<[ElementNodeList]> {\n      return read;\n    }\n\n    get track(): AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]> {\n      return track;\n    }\n\n    get first(): AfterEvent<[N?]> {\n      return first;\n    }\n\n    [Symbol.iterator](): Iterator<N> {\n      return itsIterator(iterable || (iterable = filterIt<N | undefined, N>(\n          mapIt(\n              elements(),\n              element => nodeOf(element),\n          ),\n          isPresent,\n      )));\n    }\n\n  }\n\n  return nodeList = new ElementNodeList();\n\n  function elements(): Set<Element> {\n    return updates.size ? cache : refresh();\n  }\n\n  function refresh(): Set<Element> {\n    iterable = undefined;\n    return cache = select();\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n    return new Set(\n        filterIt(\n            overArray(root.children),\n            item => item.matches(sel),\n        ),\n    );\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: N[] = [];\n    const removed: N[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overArray(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overArray(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver, eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n  ValueTracker,\n} from 'fun-events';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer: typeof MutationObserver = (this._bs.get(BootstrapWindow) as any).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string, string | null]>): EventSupply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: eventSupply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: Array.from(self._emitters.keys()),\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string, string | null]> {\n\n    const emitter = new EventEmitter<[string, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null, string> {\n\n  private readonly _updates = new EventEmitter<[string, string | null]>();\n  readonly on: OnEvent<[string, string | null]>;\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n\n    let observeSupply = noEventSupply();\n\n    this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            _name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    });\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    this._observer.element.setAttribute(this._name, value as string);\n  }\n\n  done(reason?: any): this {\n    this._updates.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null, string> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\nimport { EventEmitter, eventSupply, noEventSupply, OnEvent, ValueTracker } from 'fun-events';\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n  private _supply = noEventSupply();\n\n  constructor(\n      private readonly _element: any,\n      private readonly _key: PropertyKey,\n  ) {\n    super();\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._updates.on;\n  }\n\n  bind(context: ComponentContext): void {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    this._supply = propertyState.onUpdate({\n      supply: eventSupply().whenOff(reason => this._updates.done(reason)),\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  done(reason?: any): this {\n    this._supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ValueTracker } from 'fun-events';\nimport { ComponentNode, ComponentTreeNode, ElementPickMode, ElementNode as ElementNode_ } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\nclass ElementNode implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    (element as any)[ElementNode__symbol] = this;\n\n    const context = (element as any)[ComponentContext__symbol] as ComponentContext<any> | undefined;\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return (this.element as any)[ComponentContext__symbol];\n  }\n\n  get parent(): ElementNode_ | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null, string> {\n    return this._attrs.get(name);\n  }\n\n  property<V>(key: PropertyKey): ValueTracker<V> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(bsContext: BootstrapContext, element: Element, optional?: boolean): ElementNode_ {\n\n  const existing: ElementNode_ = (element as any)[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode_>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext, FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { ComponentNode } from './element-node';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * @internal\n */\nconst ComponentTreeSupport__feature: FeatureDef = {\n  needs: StateSupport,\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentNode,\n      by(context: ComponentContext) {\n        return elementNodeOf(context.get(BootstrapContext), context.element) as ComponentNode;\n      },\n    });\n  },\n};\n\n/**\n * Component tree support feature.\n *\n * Provides a [[ComponentNode]] instance for each component.\n */\nexport class ComponentTreeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ComponentTreeSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { EnterPageEvent, LeavePageEvent, NavigationEvent, StayOnPageEvent } from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>('navigation'));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value when [[NavigationSupport]] feature is enabled.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` registrar of enter page event receivers.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` registrar of leave page event receivers.\n   *\n   * These receivers may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` registrar of stay on page event receivers.\n   *\n   * These receivers are informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` registrar of navigation events receivers.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  get [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` registrar of current page receivers.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta  Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target  Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target  Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url  An URL to replace the\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   * @param ref  A reference to page navigation parameter to apply.\n   * @param input  Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     * @param ref  A reference to page navigation parameter to apply.\n     * @param input  Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target  Either navigation target or URL to navigate to.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target  Either navigation target or URL to replace the latest history entry with.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to [[Navigation.open]] and [[Navigation.replace]] methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to [[LeavePageEvent]]). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeparam T  Parameter value type.\n * @typeparam I  Parameter input type.\n */\nexport abstract class PageParam<T, I> implements PageParam.Ref<T, I> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}.It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page  A page to assign navigation parameter to.\n   * @param input  Parameter input used to construct its initial value.\n   * @param context  Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: I, context: PageParamContext): PageParam.Handle<T, I>;\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeparam T  Parameter value type.\n   * @typaparam I  Parameter input type.\n   */\n  export interface Ref<T, I> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, I>;\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeparam T  Parameter value type.\n   * @typaparam I  Parameter input type.\n   */\n  export interface Handle<T, I> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input  Parameter input to use when updating its value.\n     */\n    put(input: I): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before [[LeavePageEvent]] is fired for each parameter handle of current page.\n     *\n     * @param to  A page to transfer parameter to.\n     * @param when  When the transfer happens. Either `pre-open`, `pre-replace`, `open`, or `return`. The latter is used\n     * when return to page generated by another app version. E.g. from the page that has been reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(to: Page, when: 'pre-open' | 'pre-replace' | 'enter' | 'return'): Handle<T, I> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page  Entered page.\n     * @param when  When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at  The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValues } from 'context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object' ? { data: state } : state[NAV_DATA_KEY];\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _context: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      url: target.url,\n      title: target.title,\n      data: target.data,\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get(ref) {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(ref[PageParam__symbol]);\n\n    return handle && handle.get();\n  }\n\n  put<T, I>(ref: PageParam.Ref<T, I>, input: I): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, I> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    const registry = new ContextRegistry<ParamContext>(this._context);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    const newHandle = param.create(this.page, input, new ParamContext());\n\n    this._params.set(param, newHandle);\n    if (this.page.current && newHandle.enter) {\n      newHandle.enter(this.page, 'init');\n    }\n\n    return newHandle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { AfterEvent, afterThe, EventKeeper } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n * @param when  When navigation occurred. Either `pre-open`, or `pre-replace`.\n * @param from  The page to leave.\n * @param to  Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => {\n\n          const { document } = opts.context.get(BootstrapWindow);\n\n          return opts.seed.keep.dig(\n              (...agents) => {\n                if (agents.length) {\n                  return afterThe(combinedAgent);\n                }\n\n                const defaultProvider = (): AfterEvent<[NavigationAgent.Combined]> => afterThe(defaultNavigationAgent);\n\n                return opts.byDefault(defaultProvider) || defaultProvider();\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get(ref) {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              },\n          );\n        },\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): NavigationAgent.Combined {\n\n    let delegated: NavigationAgent.Combined;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!(agent => delegated = agent);\n\n    return (next, when, from, to) => delegated(next, when, from, to);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under [[NavigationAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n   * one. Not calling this function effectively prevents navigation.\n   * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n   * @param when  When navigation occurred. Either `pre-open`, or `pre-replace`.\n   * @param from  The page to leave.\n   * @param to  Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an [[NavigationAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","import { BootstrapContext, BootstrapWindow, mergeFunctions } from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { AfterEvent, onAny, OnEvent, trackValue } from 'fun-events';\nimport { DomEventDispatcher, OnDomEvent } from 'fun-events/dom';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { Navigation as Navigation_ } from './navigation';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\nexport function createNavigation(context: BootstrapContext): Navigation_ {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n  const onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n  const onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n  const onEvent = onAny<[NavigationEvent]>(onEnter, onLeave, onStay);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  const readPage: AfterEvent<[Page]> = nav.read.keep.thru(entry => entry.page);\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  class Navigation extends Navigation_ {\n\n    get length(): number {\n      return history.length;\n    }\n\n    get onEnter(): OnDomEvent<EnterPageEvent> {\n      return onEnter;\n    }\n\n    get onLeave(): OnDomEvent<LeavePageEvent> {\n      return onLeave;\n    }\n\n    get onStay(): OnDomEvent<StayOnPageEvent> {\n      return onStay;\n    }\n\n    get on(): OnEvent<[NavigationEvent]> {\n      return onEvent;\n    }\n\n    get read(): AfterEvent<[Page]> {\n      return readPage;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation_.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation_.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation_.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation();\n\n  function withParam(applyParams: (page: Page) => void): Navigation_.Parameterized {\n    return {\n      with<TT, II>(ref: PageParam.Ref<TT, II>, input: II): Navigation_.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target: Navigation_.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target: Navigation_.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function urlTargetOf(target: Navigation_.Target | string | URL): Navigation_.URLTarget {\n    if (typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation_.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target: Navigation_.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const urlTarget = urlTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n\n        navHistory[when](toEntry, nav);\n\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = navHistory.newEntry(urlTarget);\n\n      fromEntry.transfer(toEntry, whenLeave);\n\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      applyParams(toEntry.page);\n      if (!dispatcher.dispatch(leavePage) || next !== promise) {\n        return stay(toEntry);\n      }\n\n      let finalTarget: Navigation_.URLTarget | undefined;\n\n      agent(t => finalTarget = t, whenLeave, leavePage.from, leavePage.to);\n\n      if (!finalTarget) {\n        return stay(toEntry); // Some agent didn't call `next()`.\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: urlTarget,\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { createNavigation } from './navigation.impl';\n\n/**\n * @internal\n */\nconst NavigationSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: Navigation, by: createNavigation });\n  },\n};\n\n/**\n * Browser navigation support feature.\n *\n * Makes [[Navigation]] available in bootstrap context.\n */\nexport class NavigationSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return NavigationSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  DefaultRenderScheduler,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { nextArgs, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  eventSupply,\n  EventSupply,\n} from 'fun-events';\nimport { css__naming, QualifiedName } from 'namespace-aliaser';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  readonly node?: ElementNode;\n  supply(): EventSupply | undefined;\n}\n\n/**\n * @internal\n */\nconst inactiveNavLink: ActiveNavLink = {\n  supply: noop,\n};\n\n/**\n * Creates component decorator that marks at most one of navigation links inside decorated component active.\n *\n * Enables [[ComponentTreeSupport]], and [[NavigationSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    feature: {\n      needs: [ComponentTreeSupport, NavigationSupport],\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenOn(connectSupply => {\n\n          let active: ActiveNavLink = inactiveNavLink;\n\n          navigation.read.consume(\n              page => componentNode.select(select, pick).read.keep.dig_(\n                  nodes => afterEach(\n                      ...nodes.map(node => weigh({ node, context, page })),\n                  ),\n              ).consume(\n                  (...weights: NavLinkWeight[]) => {\n\n                    const selected = selectActiveNavLink(weights);\n\n                    if (!selected) {\n                      active = inactiveNavLink;\n                    } else if (selected !== active.node) {\n                      active = activate({ node: selected, context, page });\n                    }\n\n                    return active.supply();\n                  },\n              ),\n          ).needs(connectSupply);\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked [[active]].\n *\n * @typeparam T  A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters is used\n   *    as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as `path[?query]`. The weight is calculated by applying steps 1 and 2 to hashes.\n   *\n   * @param node  Navigation link node to weigh.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active  Whether to make target link active (`true`), or inactive (`false`).\n   * @param node  Navigation link node to update activity state of.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLink(weights: NavLinkWeight[]): ElementNode | undefined {\n\n  let maxWeight = 0;\n  let active: ElementNode | undefined;\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = node;\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = afterSupplied(weight).keep.thru_(\n        weight => nextArgs(opts.node, weight),\n    );\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier({\n        supply: eventSupply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier(receiver);\n            }),\n        receive: receiver.receive.bind(receiver),\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const element: Element = node.element;\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument!.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n    if (navLinkSearchParamsWeight(linkURL, pageURL) < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n    return calcNavLinkWeight(navLinkHash2url(linkURL), navLinkHash2url(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkHash2url(url: URL): URL {\n\n  let { hash } = url;\n\n  hash = hash.substring(1); // Remove leading `#` symbol\n  if (hash[0] !== '/') {\n    hash = '/' + hash;\n  }\n\n  return new URL(hash, url);\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((_value, key) => {\n\n    const pageValues = new Set(pageParams.getAll(key));\n\n    if (weight >= 0) {\n      if (linkParams.getAll(key).every(linkValue => pageValues.has(linkValue))) {\n        weight += 1;\n      } else {\n        weight = -1;\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(DefaultRenderScheduler);\n  const { active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const element: Element = node.element;\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node;\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler({ node: element }));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: EventSupply | undefined;\n\n    return {\n      node: opts.node,\n      supply(): EventSupply {\n\n        const supply = lastSupply = eventSupply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ArraySet, Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link @Navigation navigation actions} instead of default ones.\n *\n * Enables [[NavigationSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks;\n  const events = new ArraySet(def.event || 'click');\n\n  return Component({\n    feature: {\n      needs: NavigationSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenOn(connectSupply => {\n\n          const navigation = context.get(Navigation);\n\n          events.forEach(eventType => {\n            context.on(eventType)(event => handle({\n              event,\n              context,\n              navigation,\n            })).needs(connectSupply);\n          });\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeparam T  A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action.\n   *\n   * @param event  An event to handle.\n   * @param navigation  Navigation service to use.\n   * @param context  Component context.\n   */\n  handle?(\n      {\n        event,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    {\n      event,\n      navigation,\n    }: {\n      event: Event;\n      navigation: Navigation;\n    },\n): void {\n\n  const target = event.target as HTMLAnchorElement;\n  const href = target.getAttribute('href');\n\n  if (href == null) {\n    return;\n  }\n\n  const base = new URL(target.ownerDocument!.baseURI);\n  const url = new URL(href, base);\n\n  if (url.origin !== base.origin) {\n    return; // External link\n  }\n\n  event.preventDefault();\n  navigation.open(href);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { isElement } from '@wesib/wesib';\nimport { itsEach, overArray } from 'a-iterable';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param before  The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: N, to: N) => void),\n    importContent: (this: void, from: N, to: N) => void = importNodeContent,\n): N {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & N);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from  The node which contents to import.\n * @param to  The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { eventSupply, EventSupply, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: EventSupply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = eventSupply().whenOff(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.whenOff(reason => {\n          trackSupply.off(reason);\n          tracker.done(reason);\n        });\n\n        tracked = {\n          on: tracker.read.thru_(\n              response => response ? nextArgs(response) : nextSkip(),\n          ),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on(receiver).needs(supply).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          });\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import { flatMapIt, itsEach, itsIterator } from 'a-iterable';\nimport { asis, noop } from 'call-thru';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n} from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const pageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam();\n\n/**\n * @internal\n */\nexport class PageLoadRequests implements Iterable<PageLoadReq> {\n\n  private readonly _map = new Map<EventSupply, PageLoadReq[]>();\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {}\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    for (const request of this) {\n      if (!request.fragment) {\n        return [];\n      }\n      result.push(request.fragment);\n    }\n\n    return result;\n  }\n\n  [Symbol.iterator](): Iterator<PageLoadReq> {\n    return itsIterator(flatMapIt(this._map.values(), asis));\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = eventSupply();\n    let loadSupply = noEventSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page) {\n\n        const transferred = self._transfer();\n\n        to.put(pageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = eventSupply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page)(response => emitter.send(response)).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                error,\n              });\n            }\n          }).needs(loadSupply);\n\n          return supply;\n        }).share();\n\n        itsEach(\n            self,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: eventSupply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, Array.from(list));\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.thru_(\n          response => response.ok\n              ? {\n                ...response,\n                fragment: (\n                    fragment.tag != null\n                    ? response.document.getElementsByTagName(fragment.tag)[0]\n                    : response.document.getElementById(fragment.id)\n                ) || undefined,\n              }\n              : response,\n      )\n      : onLoad;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under [[PageLoadAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of loaded document.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an [[PageLoadAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url  An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsReduction } from 'a-iterable';\nimport { SingleContextKey } from 'context-values';\nimport { afterThe, EventEmitter, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { hthvParse, hthvQuote } from 'http-header-value';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { pageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser: DOMParser = new (window as any).DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      fetchRequest = pageFragmentsRequest(page, fetchRequest);\n\n      const responseTextEmitter = new EventEmitter<[Response, string]>();\n      const onResponse: OnEvent<[PageLoadResponse]> = responseTextEmitter.on.thru_(\n          (response, text) => {\n            if (!response.ok) {\n              return {\n                ok: false as const,\n                page,\n                response,\n                error: response.status,\n              };\n            }\n            try {\n              return {\n                ok: true as const,\n                page,\n                response,\n                document: parsePageDocument(parser, url, response, text),\n              };\n            } catch (error) {\n              return {\n                ok: false as const,\n                page,\n                response,\n                error,\n              };\n            }\n          },\n      );\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const { supply } = receiver;\n\n        afterThe<[PageLoadResponse.Start]>({ page }).once({\n          supply: eventSupply().needs(supply),\n          receive(ctx, start) {\n            receiver.receive(ctx, start);\n          },\n        });\n\n        const responseSupply = httpFetch(fetchRequest)(response => {\n          onResponse(receiver);\n          response.text().then(\n              text => {\n                responseTextEmitter.send(response, text);\n                supply.needs(responseSupply);\n              },\n          ).catch(\n              e => supply.off(e),\n          );\n        });\n      });\n    }\n  };\n}\n\nfunction pageFragmentsRequest(page: Page, request: Request): Request {\n\n  const fragments = page.get(pageLoadRequestsParam)?.fragments;\n\n  if (!fragments || !fragments.length) {\n    return request;\n  }\n\n  return new Request(\n      request,\n      {\n        headers: {\n          'Accept-Fragment': itsReduction(\n              fragments,\n              (header, fragment) => (header ? header + ', ' : '') + (\n                  fragment.tag != null\n                      ? 'tag=' + hthvQuote(fragment.tag)\n                      : 'id=' + hthvQuote(fragment.id)\n              ),\n              '',\n          ),\n        },\n      },\n  );\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as SupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, pageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(pageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const pageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam());\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { AfterEvent, afterThe } from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request))\n              .thru_(\n                  response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  },\n              ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { filterIt, itsEach, mapIt, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, overArray(doc.scripts)),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, overArray(response.document.querySelectorAll('script'))),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      },\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: Iterable<HTMLScriptElement>,\n): Iterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterIt(\n          scripts,\n          script => !!script.src,\n      ),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach, itsFirst, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      },\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { NavigationSupport } from '../navigation-support.feature';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  needs: NavigationSupport,\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  BootstrapWindow,\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultRenderScheduler,\n} from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { pageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes [[pageLoadParam]] navigation parameter.\n *\n * Enables [[NavigationSupport]] and [[PageLoadSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n\n  return Component({\n    feature: {\n      needs: PageLoadSupport,\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(DefaultRenderScheduler)();\n        const navigation = context.get(Navigation);\n        const detectFragment = (): PageFragmentRequest => {\n\n          const { fragment } = def;\n\n          if (fragment) {\n            return fragment;\n          }\n\n          const { element: { id, tagName: tag } }: { element: Element } = context;\n\n          return id ? { id } : { tag };\n        };\n\n        context.whenOn(supply => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot as any);\n\n          navigation.read.once(page => {\n            page.put(\n                pageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply,\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n            if (response.ok) {\n              schedule(() => {\n                range.deleteContents();\n\n                const target = document.createDocumentFragment();\n                const { fragment } = response;\n\n                if (fragment) {\n                  importNodeContent(fragment, target);\n                  range.insertNode(target);\n                }\n\n                onResponse({ context, range, response });\n              });\n            } else {\n              schedule(() => onResponse({ context, range, response }));\n            }\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  fragment?: PageFragmentRequest;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse.ok each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context  Decorated component context.\n   * @param response  Page load response.\n   * @param range  Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { DefaultNamespaceAliaser, DefaultRenderScheduler } from '@wesib/wesib';\nimport { ContextKey__symbol, ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { afterAll, AfterEvent, EventKeeper } from 'fun-events';\nimport { InConverter, InNamespaceAliaser, InRenderScheduler, intoConvertedBy } from 'input-aspects';\n\n/**\n * Default input aspects.\n *\n * This is an `AfterEvent` keeper of aspect converter meant to be applied to controls.\n *\n * As a bare minimum it assigns the following aspects to converted controls:\n * - `InRenderScheduler` set to `DefaultRenderScheduler`,\n * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n *\n * More input aspect converters may be registered in context. They may override the default ones.\n */\nexport type DefaultInAspects = AfterEvent<[InConverter.Aspect<any, any>]>;\n\n/**\n * @internal\n */\nclass DefaultInAspectsKey\n    extends ContextUpKey<AfterEvent<[InConverter.Aspect<any, any>]>, InConverter.Aspect<any, any>> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor() {\n    super('default-in-aspects');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[InConverter.Aspect<any, any>]>,\n          EventKeeper<InConverter.Aspect<any, any>[]> | InConverter.Aspect<any, any>,\n          AfterEvent<InConverter.Aspect<any, any>[]>>,\n  ): AfterEvent<[InConverter.Aspect.Factory<any, any>]> {\n\n    const nsAlias = opts.context.get(DefaultNamespaceAliaser);\n\n    return afterAll({\n      scheduler: opts.context.get(DefaultRenderScheduler[ContextKey__symbol].upKey),\n      fns: opts.seed,\n    }).keep.thru(\n        ({\n            scheduler: [scheduler],\n            fns,\n        }) => intoConvertedBy(\n            ...fns,\n            InRenderScheduler.to(scheduler),\n            InNamespaceAliaser.to(nsAlias),\n        ),\n    );\n  }\n\n}\n\n/**\n * A key of bootstrap, definition, or component context containing default input aspects.\n */\nexport const DefaultInAspects: ContextUpRef<DefaultInAspects, InConverter.Aspect<any, any>> = (\n    /*#__PURE__*/ new DefaultInAspectsKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { SingleContextUpKey, SingleContextUpRef } from 'context-values';\nimport { eventSupply, EventSupply } from 'fun-events';\nimport { InControl, InSupply } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\n\n/**\n * A user input originated from control.\n *\n * It is meant to be present in root {@link HierarchyContext hierarchy context}. Nested components may access it from\n * their hierarchy contexts to participate in user input.\n *\n * An [[inputFromControl]] function can be used to initiate user input.\n */\nexport interface InputFromControl<Value = any> {\n\n  /**\n   * Root component context the input is initiated for.\n   */\n  readonly root: ComponentContext;\n\n  /**\n   * User input control.\n   */\n  readonly control: InControl<Value>;\n\n}\n\n/**\n * A user input originated from nowhere.\n */\nexport interface InputFromNowhere {\n  control?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a user input originated from control. Potentially\n * {@link InputFromNowhere absent}.\n */\nexport const InputFromControl: SingleContextUpRef<InputFromControl | InputFromNowhere> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputFromControl | InputFromNowhere>(\n        'input-receiver',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates user input from the given control for the given root component.\n *\n * Constructs an [[InputFromControl]] instance and makes it available in `root` component's hierarchy.\n *\n * @param root  Root component context to initiate user input for.\n * @param control  User input control.\n *\n * @returns User input supply. The user input would be stopped once this supply is cut off.\n */\nexport function inputFromControl<Value>(\n    root: ComponentContext,\n    control: InControl<Value>,\n): EventSupply {\n\n  const off = root.get(HierarchyContext).provide({\n    a: InputFromControl,\n    by: () => ({\n      root,\n      control,\n    }),\n  });\n\n  return eventSupply(off).needs(control.aspect(InSupply));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { valueProvider } from 'call-thru';\nimport { afterAll, afterThe, EventKeeper, eventSupply } from 'fun-events';\nimport { InGroup } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\nimport { InputFromControl, InputFromNowhere } from './input-from-control';\n\n/**\n * Creates component decorator that adds {@link InputFromControl input control} of decorated component to input control\n * group of enclosing one under the given name.\n *\n * @typeparam T  A type of decorated component class.\n * @param name  A name to assign to component. This could be either a string, or a function returning name as a string\n * or as its keeper.\n *\n * @returns New component decorator.\n */\nexport function SetInputName<T extends ComponentClass = Class>(\n    name: string | ((this: void, context: ComponentContext<InstanceType<T>>) => string | EventKeeper<[string?]>),\n): ComponentDecorator<T> {\n\n  const getName: (context: ComponentContext<InstanceType<T>>) => EventKeeper<[string?]> = typeof name === 'string'\n      ? valueProvider(afterThe(name))\n      : context => {\n        const result = name(context);\n        return typeof result === 'string' ? afterThe(result) : result;\n      };\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const hierarchy = context.get(HierarchyContext);\n\n        afterAll({\n          group: hierarchy.up.keep.dig_(\n              upper => upper ? upper.get(InputFromControl) : afterThe<[InputFromNowhere]>({}),\n          ).keep.thru_(\n              ({ control }) => control && control.aspect(InGroup),\n          ),\n          control: hierarchy.get(InputFromControl),\n          name: getName(context),\n        }).consume(\n            ({\n              group: [group],\n              control: [{ control }],\n              name: [name],\n            }) => {\n              if (name == null\n                  || !group\n                  || !control\n                  || group === control) {\n                return;\n              }\n\n              const supply = eventSupply(() => group.controls.remove(name));\n\n              group.controls.set(name, control);\n\n              return supply;\n            },\n        );\n      });\n    },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { afterAll, afterThe, EventKeeper, EventSupply } from 'fun-events';\nimport { InControl, InConverter, InSupply } from 'input-aspects';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that finds input element and uses it as an {@link InputFromControl origin of user\n * input}.\n *\n * Enables [[ComponentTreeSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Input element usage definition.\n *\n * @returns New component decorator.\n */\nexport function UseInputElement<T extends ComponentClass = Class>(\n    def: UseInputElementDef,\n): ComponentDecorator<T> {\n\n  const { select = 'input', pick = { deep: true, all: true } } = def;\n\n  return Component({\n    feature: {\n      needs: ComponentTreeSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n\n        context.whenOn(connectSupply => {\n          afterAll({\n            node: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).keep.dig(({\n            node: [node],\n            aspects: [aspects],\n          }) => {\n            if (!node) {\n              return afterThe();\n            }\n\n            const control = def.makeControl({ node, context, aspects });\n\n            if (!control) {\n              return afterThe();\n            }\n\n            return control instanceof InControl ? afterThe(control) : control;\n          }).consume(\n              (control?: InControl<any>, supply?: EventSupply) => {\n                if (!control) {\n                  return;\n                }\n\n                const usageSupply = inputFromControl(context, control);\n\n                (supply || control.aspect(InSupply)).needs(usageSupply);\n\n                return usageSupply;\n              },\n          ).needs(connectSupply);\n        });\n      });\n    },\n  });\n}\n\n/**\n * A definition of element to use as an {@link InputFromControl origin of user input}.\n *\n * This is passed to {@link UseInputElement @UseInputElement} decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface UseInputElementDef<T extends object = any> {\n\n  /**\n   * CSS selector of input element to use.\n   *\n   * `input` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Constructs input control for element node found by {@link UseInputElement @UseInputElement} decorator.\n   *\n   * The returned control keeper may send an event supply as a second parameter. This supply will be cut off\n   * when input from control become no longer needed. Otherwise the control's input supply (`InSupply`) will be cut\n   * off instead, and control will become unusable after that.\n   *\n   * @param node  Element node to construct input control for.\n   * @param context  Component context the `@UseInputElement` decorator is applied to.\n   * @param aspects  Default input aspect converter. This is a value of `DefaultInputAspect`.\n   *\n   * @returns Either input control, its keeper, or nothing.\n   */\n  makeControl(\n      {\n        node,\n        context,\n        aspects,\n      }: {\n        node: ElementNode;\n        context: ComponentContext<T>;\n        aspects: InConverter.Aspect<any, any>;\n      },\n  ): InControl<any> | EventKeeper<[InControl<any>?, EventSupply?]> | null | undefined;\n\n}\n"],"names":["BootstrapContext__key","SingleContextKey","BootstrapContext","ContextValues","ContextKey__symbol","bootstrapDefault","provide","context","key","bootstrapContext","get","ComponentFactory__key","ComponentFactory","[object Object]","element","mount","this","mountTo","connected","BootstrapWindow","byDefault","window","BootstrapRoot","ctx","document","body","DefaultNamespaceAliaser","DefaultRenderScheduler","FnContextKey","options","newRenderSchedule","isArray","value","Array","ArraySet","AIterable","super","items","Set","size","Symbol","iterator","next","forEach","item","add","superClassOf","type","satisfying","prototype","Object","getPrototypeOf","superType","constructor","mergeFunctions","first","second","merge","_f","s","args","apply","isElement","node","nodeType","Node","ELEMENT_NODE","MetaAccessor","symbol","hasOwnProperty","undefined","ownDef","own","superDef","of","sources","prevMeta","updates","mapIt","source","meta","newMeta","flatMapIt","asis","defineProperty","configurable","PromiseResolver","promise","Promise","resolve","reject","_resolve","_reject","error","FeatureDef__symbol","FeatureMeta","defs","itsReduction","prev","def","needs","has","setup","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","FeatureNeedsError","Error","reduce","reason","need","name","ComponentDef__symbol","ComponentMeta","isQualifiedName","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","dispatch","event","dispatchEvent","on","DomEventDispatcher","ContentRoot","StateUpdater","valueProvider","noop","ComponentContext__symbol","ComponentContext","updateComponentState","bind","TypeError","contentRoot","newValue","oldValue","ComponentEvent","Event","target","ElementAdapterKey","ContextUpKey","upKey","createUpKey","opts","seed","keep","dig","adapters","combined","adapter","defaultElementAdapter","defaultProvider","afterThe","delegated","or","ElementAdapter","ElementObserver","bsContext","DefaultElementObserver","MutationObserver","callback","mutations","mutation","itsEach","overArray","removedNodes","mountOf","checkConnected","filterIt","addedNodes","observe","childList","ComponentFactory__symbol","componentFactoryOf","factory","CustomElements__key","values","customElements","nsAlias","CustomElements","componentTypeOrName","elementType","html__naming","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","BootstrapContextRegistry__key","BootstrapContextRegistry","ContextRegistry","a","is","newValues","ComponentContextRegistry__key","ComponentContextRegistry","DefinitionContextRegistry__key","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","tracker","trackValue","emitter","EventEmitter","onSetup","read","thru","nextArgs","nextSkip","onAny","superPostDefSetup","send","result","it","WhenComponent","currentRev","created","onCreated","onEventBy","receiver","receiverRev","supply","receive","eventContext","componentContext","notifiedRev","recurrentReceiver","onRecurrent","recurrentContext","readNotifier","thru_","rev","ElementBuilder","definitionContextRegistry$global","componentContextRegistry$global","definitions","components","whenComponent","componentContextRegistry$perType","ready","whenReady","cls","definitionContext","createComponentContextRegistry","append","componentFactory","ComponentFactory_","createComponent","registry","elementSuper","createMount","component","elementStatus","el","doc","ownerDocument","contains","componentCreated","DefinitionContext_","once","definitionContextRegistry","seedIn","definitionSetup","perDefinition","spec","perComponent","componentContextRegistry","Element","createElementType","enumerable","status","destructionReason","whenOff","whenDestroyed","sts","whenOn","offSupply","eventSupply","off","ComponentContext_","done","lastRev","parentNode","parentElement","removeChild","removeElement","ComponentStatus__symbol","writable","notifier","_","proto","prevContext","newComponent","bubbles","doNotAdd","ComponentRegistry","_context","_definitionQueue","definition","push","buildElement","FeatureKey__symbol","FeatureKey","from","preferredFeatureClause","afterEventBy","origin","stageId","afterAll","clause","deps","loadFeatureDeps","dig_","request","loader","to","stage","ownLoader","FeatureLoader","ownSource","rcv","unload","share","lastLoader","preventDuplicateLoader","clauses","preferred","required","afterEach","map","dep","presentFeatureDeps","isPresent","down","_down","_stage","SetupFeatureStage","then","after","state","lastStage","id","prevStage","stop","FeatureStage","_stop","action","perDep","unloader","unloads","adder","reverse","length","newUnloader","componentRegistry","elementBuilder","onDefinition","tillOff","onComponent","st","bs","by","onPostDefSetup","newFeatureContext","InitFeatureStage","ActiveFeatureStage","FeatureRequest","_requester","_revoke","featureDef","requester","isClause","_revokeBy","unuse","_uses","revoke","FeatureRequester__key","FeatureRequester","Map","existing","_map","reuse","delete","set","bootstrapComponents","features","bootstrapContextRegistry","create","complete","newNamespaceAliaser","info","_ctx","ldr","whenDown","AfterEvent__symbol","initBootstrap","DomPropertyPath__root","ComponentState__key","ComponentState","StateTracker","StateSupport__feature","update","with","StateSupport","ElementRender","render","offline","path","stateTracker","track","schedule","rendered","stateSupply","onUpdate","scheduleRender","renderElement","newRender","Render","propertyKey","defContext","Wesib__NS","NamespaceDef","FetchAgentKey","agents","fetch","agentIdx","agentRequest","agent","onSupplied","nextRequest","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","HttpFetchAborted","HttpFetch","input","Request","responseEmitter","abortController","AbortController","signal","abort","response","customSignal","aborted","catch","HierarchyRoot","root","HierarchyUpdates","issue","HierarchyUpdates__key","hierarchyRoot","parent","findParentContext","immediate","HierarchyContext__key","up","parentHierarchy","rootSupply","parentSupply","updateParent","parentCtx","HierarchyContext","consume","newParent","onSupply","upper","newHierarchyRegistry","newHierarchyContext","ComponentNode","ElementNodeList","OnEvent__symbol","WATCH_DEEP","subtree","elementNodeList","selectorOrType","nodeOf","deep","iterable","selector","cache","selected","refresh","added","observer","removed","removeNode","addNode","nodeList","firstReceiver","disconnect","onTrackUpdate","initialEmitter","afterSupplied","itsFirst","addEventListener","ElementNodeList_","itsIterator","sel","querySelectorAll","children","matches","select","AttributesObserver","_bs","_observer","Observer","_update","self","_emitter","eventReceiver","_emitters","reconnect","takeRecords","attributes","attributeOldValue","attributeFilter","keys","attributeName","getAttribute","AttributeTracker","ValueTracker","_name","observeSupply","noEventSupply","_updates","setAttribute","NodeAttributes","_attrs","PropertyTracker","_element","_key","propertyState","_supply","_path","NodeProperties","_props","prop","ElementNode__symbol","ElementNode","_bind","elementNodeOf","mode","optional","selectNodes","ComponentTreeSupport__feature","ComponentTreeSupport","Navigation__key","Navigation","go","PageParam__symbol","PageParam","PageParamContext","NavHistory__key","NavHistory","extractNavData","data","_document","_location","location","_history","history","_uid","btoa","String","Math","random","entry","newEntry","url","URL","href","title","_entries","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","page","pushState","_enter","when","fromEntry","e","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_params","visited","_status","current","ref","put","handle","param","newHandle","entries","transferred","at","stay","clear","NavigationAgentKey","navigate","agentTo","nextURL","nextTitle","nextData","baseURI","defaultNavigationAgent","_when","_from","NavigationAgent","EnterPageEvent","cancelable","LeavePageEvent","StayOnPageEvent","createNavigation","dispatcher","navHistory","onEnter","onLeave","onStay","onEvent","nav","nextEntry","readPage","hashChange","Navigation_","delta","toURL","withParam","applyParams","open","replace","whenLeave","urlTarget","urlTargetOf","doNavigate","prepared","leavePage","finalTarget","t","prepare","NavigationSupport__feature","NavigationSupport","inactiveNavLink","ActivateNavLink","pick","activate","scheduler","active","defaultActiveNavLinkClass","activeClass","css__naming","NavLinkRenderSchedule__symbol","makeActive","classList","remove","assignClass","lastSupply","activateNavLink","weigh","defaultNavLinkWeight","weight","supplier","navLinkWeight","navigation","componentNode","connectSupply","nodes","weights","maxWeight","selectActiveNavLink","linkURL","calcNavLinkWeight","pageURL","linkDir","navLinkPath2dir","pageDir","hash","navLinkSearchParamsWeight","navLinkHash2url","searchParamWeight","startsWith","pathname","endsWith","substring","searchParams","linkParams","pageParams","_value","pageValues","getAll","every","linkValue","HandleNavLinks","defaultHandleNavLinks","events","eventType","base","preventDefault","importNode","beforeOrImport","importContent","importNodeContent","before","elementClone","createElement","tagName","toLowerCase","getAttributeNames","attr","insertBefore","nodeClone","childNodes","cachingPageLoader","pageUrl","sup","tracked","onLoad","trackSupply","resp","num","requested","PageLoadAbortError","pageLoadRequestsParam","_page","requests","PageLoadRequests","_navigation","_loader","fragments","fragment","pageSupply","loadSupply","_add","_transfer","responseReceiver","ok","tag","getElementsByTagName","getElementById","onFragment","req","list","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","Accept-Fragment","header","hthvQuote","pageFragmentsRequest","responseTextEmitter","onResponse","text","parsePageDocument","start","responseSupply","parseFromString","hthvParse","v","head","querySelector","newBase","appendChild","PageLoadParam","pageLoadParam","PageCacheBuster__key","PageCacheBuster","appRev","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","src","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","style","pageTitleAgent","textContent","PageLoadSupport__feature","buster","PageLoadSupport","IncludePage","detectFragment","range","createRange","selectNodeContents","deleteContents","createDocumentFragment","insertNode","handleResponse","DefaultInAspectsKey","fns","intoConvertedBy","InRenderScheduler","InNamespaceAliaser","DefaultInAspects","InputFromControl","SingleContextUpKey","inputFromControl","control","aspect","InSupply","SetInputName","getName","hierarchy","group","InGroup","controls","UseInputElement","aspects","makeControl","InControl","usageSupply"],"mappings":"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"}