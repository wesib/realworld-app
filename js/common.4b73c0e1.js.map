{"version":3,"file":"common.4b73c0e1.js","sources":["../../src/common/articles/article.ts","../../src/common/articles/feed-service.ts","../../src/common/api/api-root-url.ts","../../src/common/auth/auth-service.key.impl.ts","../../src/common/api/api-fetch.ts","../../src/common/api/api-submitter.ts","../../src/common/articles/feed-service.impl.ts","../../src/common/articles/feed-support.feature.ts","../../src/common/auth/auth-service.ts","../../src/common/auth/auth-service.impl.ts","../../src/common/auth/auth-support.feature.ts","../../src/common/input/bootstrap-css-error.ts","../../src/common/conduit.ns.ts","../../src/common/input/api-errors.component.ts","../../src/common/input/in-error.component.ts","../../src/common/input/conduit-input-support.feature.ts","../../src/common/input/fill-conduit-form.decorator.ts","../../src/common/input/handle-conduit-submit-button.decorator.ts","../../src/common/input/use-conduit-input.decorator.ts","../../src/common/layout/main.component.ts","../../src/common/layout/navbar.component.ts","../../src/common/layout/container.component.ts","../../src/common/layout/footer.component.ts","../../src/common/layout/conduit-layout-support.feature.ts","../../src/common/conduit.feature.ts","../../src/common/index.ts"],"sourcesContent":["import { nextSkip } from 'call-thru';\nimport { EventSender, OnEvent, OnEvent__symbol, onEventBy, trackValue } from 'fun-events';\nimport { UserProfile } from '../users';\nimport marked from 'marked';\n\nexport class Article implements EventSender<[string]> {\n\n  private readonly _html = trackValue<string>();\n  private _onHtml?: OnEvent<[string]>;\n\n  constructor(readonly data: Article.Data) {\n  }\n\n  get createdAt(): Date {\n    return new Date(this.data.createdAt);\n  }\n\n  get updatedAt(): Date {\n    return new Date(this.data.updatedAt);\n  }\n\n  get [OnEvent__symbol](): OnEvent<[string]> {\n    return this.onHtml;\n  }\n\n  get onHtml(): OnEvent<[string]> {\n    return onEventBy(receiver => {\n      if (this._onHtml) {\n        this._onHtml(receiver);\n        return;\n      }\n      this._onHtml = this._html.read.thru_(html => html != null ? html : nextSkip);\n      marked(this.data.body, (error, html) => {\n        if (error != null) {\n          this._html.done(error); // Failed to parse Markdown\n        } else {\n          this._html.it = html; // TODO: Sanitize HTML\n        }\n      });\n    });\n  }\n\n}\n\nexport namespace Article {\n\n  export interface Data {\n    readonly slug: string;\n    readonly title: string;\n    readonly description: string;\n    readonly body: string;\n    readonly tagList: readonly string[];\n    readonly createdAt: string;\n    readonly updatedAt: string;\n    readonly favorited: boolean;\n    readonly favoritesCount: number;\n    readonly author: UserProfile;\n  }\n\n}\n","import { ContextRef, SingleContextKey } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { ApiResponse } from '../api';\nimport { Article } from './article';\n\nexport interface FeedRequest {\n  readonly tag?: string;\n  readonly author?: string;\n  readonly favorited?: string;\n  readonly limit?: number;\n  readonly offset?: number;\n}\n\nexport interface ArticleList {\n  readonly articleCount: number;\n  readonly articles: readonly Article[];\n}\n\nexport interface FeedService {\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]>;\n\n  feed(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]>;\n\n  article(slug: string): OnEvent<[ApiResponse<Article>]>;\n\n}\n\nexport const FeedService: ContextRef<FeedService> = new SingleContextKey<FeedService>('feed-service');\n","import { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\n\nexport type ApiRootURL = URL;\n\nexport const ApiRootURL: SingleContextUpRef<ApiRootURL> = new SingleContextUpKey<ApiRootURL>(\n    'api-root-url',\n    {\n      byDefault: () => new URL('https://conduit.productionready.io/api/'),\n    },\n);\n","import { SingleContextKey } from 'context-values';\nimport { AuthService } from './auth-service';\n\nexport const AuthService__key = new SingleContextKey<AuthService>('auth-service');\n","import { HttpFetch } from '@wesib/generic';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { AfterEvent, nextOnEvent, onAsync, OnEvent, OnEventCallChain } from 'fun-events';\nimport { AuthService__key } from '../auth/auth-service.key.impl';\nimport { ApiRootURL } from './api-root-url';\n\n/**\n * Request to some API endpoint.\n *\n * @typeparam T  Response type.\n */\nexport interface ApiRequest<T> {\n\n  /**\n   * API endpoint path __relative__ to {@link ApiRootURL API root URL}.\n   *\n   * Do not start it with `/` as this would make it absolute.\n   */\n  readonly path: string;\n\n  /**\n   * Wrapper field containing response object, or a function extracting it.\n   */\n  readonly respondAs: string | ((this: void, json: any) => T);\n\n  /**\n   * Additional HTTP request options.\n   */\n  readonly init?: RequestInit;\n\n  /**\n   * Whether to send authentication token.\n   *\n   * - `true` to always send it,\n   * - `false` to never send it,\n   * - `undefined` (the default) - to send it only if {@link AuthService.user current user} is authenticated.\n   */\n  readonly auth?: boolean;\n\n}\n\nexport type ApiResponse<T> =\n    | ApiResponse.Ok<T>\n    | ApiResponse.Failure;\n\nexport namespace ApiResponse {\n\n  export interface Ok<T = any> {\n    readonly ok: true;\n    readonly response: Response;\n    readonly body: T;\n  }\n\n  export interface Failure {\n    readonly ok: false;\n    readonly response?: Response;\n    readonly errors: Errors;\n  }\n\n  export type Errors = {\n    readonly [field in string]: readonly string[];\n  };\n\n}\n\nexport type ApiFetch = <T>(this: void, request: ApiRequest<T>) => OnEvent<[ApiResponse<T>]>;\n\nexport const ApiFetch: ContextUpRef<ApiFetch, ApiFetch> = (\n    new FnContextKey<[ApiRequest<any>], OnEvent<[ApiResponse<any>]>>(\n        'api-fetch',\n        {\n          byDefault: bootstrapDefault(newApiFetch),\n        },\n    ));\n\ntype RequestOrFailure =\n    | { request: Request }\n    | { request?: undefined; failure: ApiResponse.Failure };\ntype ResponseOrFailure =\n    | { response: Response }\n    | { response?: undefined; failure: ApiResponse.Failure };\ntype ResponseBodyOrFailure =\n    | [{ response: Response }, any]\n    | [{ response?: undefined; failure: ApiResponse.Failure }];\n\nfunction newApiFetch(context: BootstrapContext): ApiFetch {\n\n  const httpFetch = context.get(HttpFetch);\n  const apiRootURL = context.get(ApiRootURL);\n\n  return request => {\n\n    const { path, init, auth } = request;\n    const onResponse: OnEvent<[ResponseOrFailure]> = apiRootURL.thru_(\n        baseURL => new URL(path, baseURL),\n        url => buildApiRequest(url, init),\n    ).thru_(\n        (request: Request): NextCall<OnEventCallChain, [RequestOrFailure]> => auth === false\n            ? nextArgs({ request })\n            : nextOnEvent(authenticateApiRequest(context, request, auth)),\n        (requestOrFailure): NextCall<OnEventCallChain, [ResponseOrFailure]> => requestOrFailure.request\n            ? nextOnEvent(httpFetch(requestOrFailure.request).thru_(response => ({ response })))\n            : nextArgs({ failure: requestOrFailure.failure }),\n    );\n\n    return onAsync(onResponse.thru_(parseApiResponse)).thru_(\n        ([responseOrFailure, json]) => handleApiResponse(request, responseOrFailure, json),\n    );\n  };\n}\n\nfunction buildApiRequest(url: URL, init: RequestInit = {}): Request {\n\n  const request = new Request(url.href, { mode: 'cors', ...init });\n  const { headers } = request;\n\n  headers.set('X-Requested-With', 'XMLHttpRequest');\n\n  return request;\n}\n\nfunction authenticateApiRequest(\n    context: BootstrapContext,\n    request: Request,\n    auth?: true,\n): AfterEvent<[RequestOrFailure]> {\n  // Access by key to avoid circular dependencies during the build\n  return context.get(AuthService__key).user.keep.thru_(\n      (user?, failure?) => {\n        if (user) {\n          request.headers.set('Authorization', `Token ${user.token}`);\n          return { request };\n        }\n        if (!auth) {\n          return { request };\n        }\n        if (!failure) {\n          failure = {\n            ok: false,\n            errors: {\n              api: ['Not authenticated'],\n            },\n          };\n        }\n        return { failure };\n      },\n  );\n}\n\nfunction parseApiResponse(\n    responseOfFailure: ResponseOrFailure,\n): ResponseBodyOrFailure | Promise<ResponseBodyOrFailure> {\n  return responseOfFailure.response\n      ? Promise.all([responseOfFailure, responseOfFailure.response.json()])\n          .catch(error => [{\n            failure: {\n              ok: false,\n              response: responseOfFailure.response,\n              errors: {\n                api: [`Failed to parse response: ${error}`],\n              },\n            },\n          }])\n      : [responseOfFailure];\n}\n\nfunction handleApiResponse<T>(\n    { respondAs }: ApiRequest<T>,\n    responseOfFailure: ResponseOrFailure,\n    json?: any,\n): ApiResponse<T> {\n  if (!responseOfFailure.response) {\n    return responseOfFailure.failure;\n  }\n\n  const { response } = responseOfFailure;\n\n  if (response.ok) {\n    return {\n      ok: true,\n      response,\n      body: typeof respondAs === 'function' ? respondAs(json) : json[respondAs],\n    };\n  }\n\n  return {\n    ok: false,\n    response,\n    errors: json.errors || {\n      http: [\n        response.statusText\n            ? `${response.status}: ${response.statusText}`\n            : `ERROR ${response.status}`,\n      ],\n    },\n  };\n}\n","import { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { OnEvent } from 'fun-events';\nimport { InSubmit, InSubmitError } from 'input-aspects';\nimport { ApiFetch, ApiRequest, ApiResponse } from './api-fetch';\n\nexport type ApiSubmitter =\n    <Value = any, Result = any>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result>;\n\nexport const ApiSubmitter: ContextUpRef<ApiSubmitter, ApiSubmitter> = (\n    new FnContextKey<[ApiRequest<any>], InSubmit.Submitter<any, any>>(\n        'api-submitter',\n        {\n          byDefault: bootstrapDefault(newApiSubmitter),\n        },\n    ));\n\nfunction newApiSubmitter(\n    context: BootstrapContext,\n): <Value, Result>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result> {\n\n  const apiFetch: ApiFetch = context.get(ApiFetch);\n\n  return <Value, Result>(request: ApiRequest<Result>) => {\n\n    const { init = {} } = request;\n    const { method = 'POST', headers = {} } = init;\n\n    return (body: Value) => {\n\n      const apiRequest: ApiRequest<Result> = {\n        ...request,\n        init: {\n          ...init,\n          method,\n          body: JSON.stringify(body),\n          headers: {\n            ...headers,\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n          },\n        },\n      };\n\n      return apiSubmit(apiFetch(apiRequest));\n    };\n  };\n}\n\nexport function apiSubmit<Result>(onFetch: OnEvent<[ApiResponse<Result>]>): Promise<Result> {\n  return new Promise((resolve, reject) => {\n    onFetch.once(\n        (response: ApiResponse<Result>) => {\n          if (response.ok) {\n            resolve(response.body);\n          } else {\n            reject(new InSubmitError({ submit: 'api', api: response.errors }));\n          }\n        },\n    ).whenOff(\n        reason => {\n          reject(\n              reason instanceof InSubmitError\n                  ? reason\n                  : new InSubmitError({ submit: 'cancel', cancel: reason }),\n          );\n        },\n    );\n  });\n}\n","import { BootstrapContext } from '@wesib/wesib';\nimport { overEntries, thruIt } from 'a-iterable';\nimport { nextArg, nextSkip } from 'call-thru';\nimport { OnEvent } from 'fun-events';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { Article } from './article';\nimport { ArticleList, FeedRequest, FeedService } from './feed-service';\n\nexport class FeedService$ implements FeedService {\n\n  private readonly _apiFetch: ApiFetch;\n\n  constructor(context: BootstrapContext) {\n    this._apiFetch = context.get(ApiFetch);\n  }\n\n  articles(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]> {\n    return this._articles('articles', request);\n  }\n\n  feed(request: FeedRequest): OnEvent<[ApiResponse<ArticleList>]> {\n    return this._articles('articles/feed', request, true);\n  }\n\n  article(slug: string): OnEvent<[ApiResponse<Article>]> {\n\n    const apiRequest: ApiRequest<Article> = {\n      path: `articles/${encodeURIComponent(slug)}`,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      respondAs: 'article',\n    };\n\n    return this._apiFetch(apiRequest);\n  }\n\n  private _articles(\n      path: string,\n      request: FeedRequest,\n      auth?: boolean,\n  ): OnEvent<[ApiResponse<ArticleList>]> {\n\n    const params: [string, string][] = Array.from(thruIt(\n        overEntries(request),\n        ([key, value]) => value\n            ? nextArg<[string, string]>([key, String(value)])\n            : nextSkip,\n    ));\n\n    if (params.length) {\n      path = `${path}?${new URLSearchParams(params)}`;\n    }\n\n    const apiRequest: ApiRequest<ArticleList> = {\n      path,\n      init: {\n        method: 'GET',\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      auth,\n      respondAs(\n          {\n            articleCount,\n            articles,\n          }: {\n            articleCount: number;\n            articles: readonly Article.Data[];\n          },\n      ): ArticleList {\n        return {\n          articleCount,\n          articles: articles.map(article => new Article(article)),\n        };\n      },\n    };\n\n    return this._apiFetch(apiRequest);\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedService } from './feed-service';\nimport { FeedService$ } from './feed-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: FeedService, as: FeedService$ });\n  },\n})\nexport class FeedSupport {\n}\n","import { ContextKey, ContextKey__symbol } from 'context-values';\nimport { AfterEvent, OnEvent } from 'fun-events';\nimport { ApiResponse } from '../api';\nimport { AuthService__key } from './auth-service.key.impl';\nimport { AuthUser } from './auth-user';\n\nexport type AuthUserOrFailure = [] | [AuthUser] | [undefined, ApiResponse.Failure];\n\nexport interface LoginRequest {\n  readonly email: string;\n  readonly password: string;\n}\n\nexport interface RegisterRequest {\n  readonly username: string;\n  readonly email: string;\n  readonly password: string;\n}\n\nexport abstract class AuthService {\n\n  static get [ContextKey__symbol](): ContextKey<AuthService> {\n    return AuthService__key;\n  }\n\n  abstract readonly user: AfterEvent<AuthUserOrFailure>;\n\n  abstract login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]>;\n\n  abstract logout(): void;\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { nextArgs, NextCall, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  eventSupply,\n  nextOnEvent,\n  OnEvent,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { ApiFetch, ApiRequest, ApiResponse } from '../api';\nimport { AuthService, AuthUserOrFailure, LoginRequest, RegisterRequest } from './auth-service';\nimport { AuthUser } from './auth-user';\n\nconst authTokenKey = 'wesib-conduit:auth';\ntype Authentication = AuthUser | string | null;\n\nexport class AuthService$ extends AuthService {\n\n  readonly user: AfterEvent<AuthUserOrFailure>;\n  private readonly _auth: ValueTracker<Authentication>;\n\n  constructor(private readonly _context: BootstrapContext) {\n    super();\n\n    const storage = _context.get(BootstrapWindow).localStorage;\n\n    this._auth = trackValue(storage.getItem(authTokenKey));\n    this._auth.on(updateAuthToken);\n    this.user = this._auth.read.keep.thru(authUser);\n\n    function updateAuthToken(newAuth: Authentication): void {\n      if (!newAuth) {\n        storage.removeItem(authTokenKey);\n      } else {\n        storage.setItem(authTokenKey, typeof newAuth === 'string' ? newAuth : newAuth.token);\n      }\n    }\n\n    function authUser(auth: Authentication): NextCall<OnEventCallChain, AuthUserOrFailure> {\n      if (!auth) {\n        return nextArgs();\n      }\n      if (typeof auth === 'string') {\n        return nextOnEvent(fetchCurrentUser(auth));\n      }\n      return nextArgs(auth);\n    }\n\n    function fetchCurrentUser(token: string): AfterEvent<AuthUserOrFailure> {\n\n      const apiFetch: ApiFetch = _context.get(ApiFetch);\n      const apiRequest: ApiRequest<AuthUser> = {\n        path: 'user',\n        init: {\n          headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            Authorization: `Token ${token}`,\n          },\n        },\n        respondAs: 'user',\n        auth: false,\n      };\n\n      return afterEventBy<AuthUserOrFailure>(\n          receiver => {\n            apiFetch(apiRequest).thru_(\n                (response: ApiResponse<AuthUser>): NextCall<OnEventCallChain, AuthUserOrFailure> => {\n                  if (response.ok) {\n                    return nextArgs(response.body);\n                  }\n                  return nextArgs(undefined, response);\n                },\n            )({\n              supply: eventSupply().needs(receiver.supply), // Do not abort after user received\n              receive(ctx, ...event) {\n                receiver.receive(ctx, ...event);\n              },\n            });\n          },\n          valuesProvider(),\n      );\n    }\n  }\n\n  login(request: LoginRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users/login', request);\n  }\n\n  register(request: RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n    return this._request('users', request);\n  }\n\n  logout(): void {\n    this._auth.it = null;\n  }\n\n  private _request(path: string, request: LoginRequest | RegisterRequest): OnEvent<[ApiResponse<AuthUser>]> {\n\n    const apiFetch: ApiFetch = this._context.get(ApiFetch);\n    const apiRequest: ApiRequest<AuthUser> = {\n      path,\n      init: {\n        method: 'POST',\n        body: JSON.stringify({ user: request }),\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json',\n        },\n      },\n      respondAs: 'user',\n      auth: false,\n    };\n\n    return apiFetch(apiRequest).thru_(\n        response => {\n          if (response.ok) {\n            this._auth.it = response.body;\n          } else {\n            this._auth.it = null;\n          }\n          return response;\n        },\n    );\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { AuthService } from './auth-service';\nimport { AuthService$ } from './auth-service.impl';\n\n@Feature({\n  setup(setup) {\n    setup.provide({ a: AuthService, as: AuthService$ });\n  },\n})\nexport class AuthSupport {\n}\n","import { nextArgs } from 'call-thru';\nimport { afterAll, nextAfterEvent } from 'fun-events';\nimport { InCssClasses, inCssError, InStatus, InValidation } from 'input-aspects';\n\nexport function bootstrapCssError(\n    {\n      mark = 'is-invalid',\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n  return control => {\n\n    const cssClasses = control.aspect(InCssClasses);\n\n    return afterAll({\n      status: control.aspect(InStatus),\n      validity: control.aspect(InValidation),\n    }).keep.thru(\n        ({\n          status: [{ touched, hasFocus }],\n          validity: [validity],\n        }) => {\n\n          const incomplete = validity.has('incomplete') || validity.has('missing');\n\n          return touched && !(hasFocus && incomplete)\n              ? nextAfterEvent(cssClasses.specs(inCssError({ mark, when })))\n              : nextArgs();\n        },\n    );\n  };\n}\n","import { NamespaceDef } from 'namespace-aliaser';\n\nexport const Conduit__NS: NamespaceDef = new NamespaceDef(\n    'https://wesib.github.io/realworld-app/ns/',\n    'conduit',\n);\n","import { HierarchyContext } from '@wesib/generic';\nimport { InputToForm } from '@wesib/generic/input';\nimport { BootstrapWindow, Component, ComponentContext, ElementRender, Render } from '@wesib/wesib';\nimport { itsEach, overEntries } from 'a-iterable';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InValidation } from 'input-aspects';\nimport { ApiResponse } from '../api';\nimport { Conduit__NS } from '../conduit.ns';\n\nconst noApiErrors: ApiResponse.Errors = {};\n\n@Component(['api-errors', Conduit__NS])\nexport class ApiErrorsComponent {\n\n  private _errors: ApiResponse.Errors = noApiErrors;\n\n  constructor(private readonly _context: ComponentContext) {\n    _context.get(HierarchyContext)\n        .get(InputToForm)\n        .thru_(\n            ({ control }): NextCall<OnEventCallChain, [ApiResponse.Errors]> => {\n              if (!control) {\n                return nextArgs(noApiErrors);\n              }\n              return nextAfterEvent(\n                  control.aspect(InValidation).read.keep.thru_(\n                      validity => validity.messages('api').reduce(\n                          (prev, message) => ({\n                            ...prev,\n                            ...message.api,\n                          }),\n                          noApiErrors,\n                      ),\n                  ),\n              );\n            },\n        )(errors => this.errors = errors);\n  }\n\n  get errors(): ApiResponse.Errors {\n    return this._errors;\n  }\n\n  set errors(value: ApiResponse.Errors) {\n\n    const old = this._errors;\n\n    if (old === value) {\n      return;\n    }\n    this._errors = value;\n    this._context.updateState('errors', old, value);\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const { contentRoot } = this._context;\n    const document = this._context.get(BootstrapWindow).document;\n    let list: HTMLUListElement | undefined;\n\n    return () => {\n      if (list) {\n        list.remove();\n        list = undefined;\n      }\n      itsEach(\n          overEntries(this.errors),\n          ([key, messages]) => {\n            if (!list) {\n              list = document.createElement('ul');\n              list.classList.add('error-messages');\n            }\n\n            const ul = list;\n\n            messages.forEach(message => {\n\n              const li = document.createElement('li');\n\n              li.innerText = `${key} ${message}`;\n              ul.appendChild(li);\n            });\n          },\n      );\n      if (list) {\n        contentRoot.append(list);\n      }\n    };\n  }\n\n}\n","import { ConvertInput } from '@wesib/generic/input';\nimport { Attributes, Component, trackAttribute } from '@wesib/wesib';\nimport { AfterEvent } from 'fun-events';\nimport { InCssClasses, inCssInfo, InStyledElement } from 'input-aspects';\nimport { Conduit__NS } from '../conduit.ns';\nimport { bootstrapCssError } from './bootstrap-css-error';\n\n@Component(\n    ['in-error', Conduit__NS],\n    Attributes('code'),\n    ConvertInput(\n        ({ control: { control }, aspects, context }) => {\n\n          const codes: AfterEvent<[string[]]> = trackAttribute(context, 'code')\n              .read.keep.thru_(\n                  code => code ? code.trim().split(/\\s+/) : [],\n              );\n\n          return codes.keep.thru(\n              when => control.convert(\n                  InStyledElement.to(context.element),\n                  aspects,\n              ).setup(\n                  InCssClasses,\n                  cssClasses => {\n                    cssClasses.add(inCssInfo());\n                    cssClasses.add(bootstrapCssError({ when }));\n                  },\n              ),\n          );\n        },\n    ),\n)\nexport class InErrorComponent {}\n","import { Feature } from '@wesib/wesib';\nimport { ApiErrorsComponent } from './api-errors.component';\nimport { InErrorComponent } from './in-error.component';\n\n@Feature({\n  needs: [\n    ApiErrorsComponent,\n    InErrorComponent,\n  ],\n})\nexport class ConduitInputSupport {\n}\n","import { FillInputForm, FillInputFormDef } from '@wesib/generic/input';\nimport { Class, Component, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { InCssClasses, inCssInfo, inFormElement, inGroup, InGroup, InMode, inModeByValidity } from 'input-aspects';\nimport { HandleConduitSubmitButton, HandleConduitSubmitButtonDef } from './handle-conduit-submit-button.decorator';\n\nexport function FillConduitForm<Model extends object = any, T extends ComponentClass = Class>(\n    {\n        emptyModel = {} as Model,\n        form = {\n          makeForm({ node, aspects }) {\n\n            const group: InGroup<Model> = inGroup<Model>(emptyModel)\n                .setup(InCssClasses, classes => classes.add(inCssInfo()))\n                .setup(InMode, mode => mode.derive(inModeByValidity()));\n            const form = inFormElement(node.element, { form: group, aspects })\n                .setup(InCssClasses, classes => classes.add(group.aspect(InCssClasses)));\n\n            return [group, form];\n          },\n        },\n        button,\n    }: FillConduitFormDef<Model> = {},\n): ComponentDecorator<T> {\n  return Component(\n      FillInputForm(form),\n      HandleConduitSubmitButton(button),\n  );\n}\n\nexport interface FillConduitFormDef<Model extends object> {\n  readonly emptyModel?: Model;\n  readonly form?: FillInputFormDef;\n  readonly button?: HandleConduitSubmitButtonDef;\n}\n","import { ComponentNode, ComponentTreeSupport, ElementPickMode, HierarchyContext } from '@wesib/generic';\nimport { DefaultInAspects, InputToForm } from '@wesib/generic/input';\nimport { Class, Component, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { afterAll } from 'fun-events';\nimport { inSubmitButton } from 'input-aspects';\n\nexport function HandleConduitSubmitButton<T extends ComponentClass = Class>(\n    {\n      select = 'button',\n      pick = { deep: true, all: true },\n    }: HandleConduitSubmitButtonDef = {},\n): ComponentDecorator<T> {\n  return Component({\n    feature: {\n      needs: ComponentTreeSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const componentNode = context.get(ComponentNode);\n        const hierarchy = context.get(HierarchyContext);\n\n        context.whenOn(supply => {\n          afterAll({\n            form: hierarchy.get(InputToForm),\n            button: componentNode.select(select, pick).first,\n            aspects: context.get(DefaultInAspects),\n          }).tillOff(supply).consume(\n              ({\n                form: [{ control: form }],\n                button: [button],\n                aspects: [aspects],\n              }) => form && button && inSubmitButton(button.element, { form, aspects }),\n          );\n        });\n      });\n    },\n  });\n}\n\nexport interface HandleConduitSubmitButtonDef {\n  readonly select?: string;\n  readonly pick?: ElementPickMode;\n}\n","import { HierarchyContext } from '@wesib/generic';\nimport { InputToForm, UseInputElement, UseInputElementDef } from '@wesib/generic/input';\nimport { Class, ComponentClass, ComponentDecorator } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { afterSupplied, EventSupply, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InCssClasses, inCssInfo, InMode } from 'input-aspects';\nimport { bootstrapCssError } from './bootstrap-css-error';\n\nexport function UseConduitInput<T extends ComponentClass = Class>(\n    def: UseInputElementDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return UseInputElement({\n    ...def,\n    makeControl(opts) {\n      return opts.context.get(HierarchyContext).get(InputToForm).keep.thru_(\n          ({ form }) => {\n\n            const ctrl = def.makeControl(opts);\n\n            if (!ctrl) {\n              return nextArgs();\n            }\n            if (ctrl instanceof InControl) {\n              return augmentControl(ctrl);\n            }\n\n            return nextAfterEvent(afterSupplied(ctrl).keep.thru_(\n                (control, supply): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n                  if (!control) {\n                    return nextArgs();\n                  }\n\n                  augmentControl(control);\n\n                  return supply ? nextArgs(control, supply) : nextArgs(control);\n                },\n            ));\n\n            function augmentControl(control: InControl<any>): InControl<any> {\n              if (form) {\n                control.aspect(InMode).derive(form.aspect(InMode));\n              }\n\n              const classes = control.aspect(InCssClasses);\n\n              classes.add(inCssInfo());\n              classes.add(bootstrapCssError());\n\n              return control;\n            }\n          },\n      );\n    },\n  });\n}\n","import { IncludePage } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['main', Conduit__NS],\n    IncludePage({\n      onResponse({ response, range }) {\n        if (!response.ok) {\n          range.deleteContents();\n          if (response.ok == null) {\n            range.insertNode(document.createTextNode('Loading...'));\n          } else {\n            range.insertNode(document.createTextNode(`Error. ${response.error}`));\n          }\n        }\n      },\n    }),\n)\nexport class MainComponent {}\n","import { ActivateNavLink, HandleNavLinks } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['navbar', Conduit__NS],\n    HandleNavLinks(),\n    ActivateNavLink({ active: 'active' }),\n)\nexport class NavbarComponent {\n}\n","import { Component, ComponentContext, DefaultNamespaceAliaser, ElementRender, Render } from '@wesib/wesib';\nimport { css__naming, QualifiedName } from 'namespace-aliaser';\nimport { AuthService, AuthUser } from '../auth';\nimport { Conduit__NS } from '../conduit.ns';\nimport { MainComponent } from './main.component';\nimport { NavbarComponent } from './navbar.component';\n\nconst authenticatedClassQName: QualifiedName = ['authenticated', Conduit__NS];\nconst notAuthenticatedClassQName: QualifiedName = ['not-authenticated', Conduit__NS];\n\n@Component({\n  name: ['container', Conduit__NS],\n  feature: {\n    needs: [MainComponent, NavbarComponent],\n  },\n})\nexport class ContainerComponent {\n\n  private _user?: AuthUser;\n\n  constructor(private readonly _context: ComponentContext) {\n    _context.whenOn(connectSupply => {\n      _context.get(AuthService).user.tillOff(connectSupply)((user?, _failure?) => {\n        this.user = user;\n      });\n    });\n  }\n\n  get user(): AuthUser | undefined {\n    return this._user;\n  }\n\n  set user(value: AuthUser | undefined) {\n\n    const oldValue = this._user;\n\n    this._user = value;\n    this._context.updateState('user', value, oldValue);\n  }\n\n  @Render()\n  render(): ElementRender {\n\n    const nsAlis = this._context.get(DefaultNamespaceAliaser);\n    const authenticatedClass = css__naming.name(authenticatedClassQName, nsAlis);\n    const notAuthenticatedClass = css__naming.name(notAuthenticatedClassQName, nsAlis);\n    const { classList }: Element = this._context.element;\n\n    return () => {\n      if (this.user) {\n        classList.remove(notAuthenticatedClass);\n        classList.add(authenticatedClass);\n      } else {\n        classList.remove(authenticatedClass);\n        classList.add(notAuthenticatedClass);\n      }\n    };\n  }\n\n}\n","import { HandleNavLinks } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Conduit__NS } from '../conduit.ns';\n\n@Component(\n    ['footer', Conduit__NS],\n    HandleNavLinks(),\n)\nexport class FooterComponent {\n}\n","import { Feature } from '@wesib/wesib';\nimport { ContainerComponent } from './container.component';\nimport { FooterComponent } from './footer.component';\n\n@Feature({\n  needs: [\n    ContainerComponent,\n    FooterComponent,\n  ],\n})\nexport class ConduitLayoutSupport {\n}\n","import { Feature } from '@wesib/wesib';\nimport { FeedSupport } from './articles';\nimport { AuthSupport } from './auth';\nimport { ConduitInputSupport } from './input';\nimport { ConduitLayoutSupport } from './layout';\n\n@Feature({\n  needs: [\n    AuthSupport,\n    ConduitInputSupport,\n    ConduitLayoutSupport,\n    FeedSupport,\n  ],\n})\nexport class ConduitFeature {\n}\n","import { bootstrapComponents } from '@wesib/wesib';\nimport { ConduitFeature } from './conduit.feature';\n\nexport * from './api';\nexport * from './articles';\nexport * from './auth';\nexport * from './conduit.feature';\nexport * from './conduit.ns';\nexport * from './input';\nexport * from './users';\n\nexport const conduitContext = bootstrapComponents(ConduitFeature);\n"],"names":["Article","[object Object]","data","this","trackValue","createdAt","Date","updatedAt","OnEvent__symbol","onHtml","onEventBy","receiver","_onHtml","_html","read","thru_","html","nextSkip","marked","body","error","done","it","FeedService","SingleContextKey","ApiRootURL","SingleContextUpKey","byDefault","URL","AuthService__key","ApiFetch","FnContextKey","bootstrapDefault","context","httpFetch","get","HttpFetch","apiRootURL","request","path","init","auth","onResponse","baseURL","url","Request","href","mode","headers","set","buildApiRequest","nextArgs","nextOnEvent","user","keep","failure","token","ok","errors","api","authenticateApiRequest","requestOrFailure","response","onAsync","parseApiResponse","responseOrFailure","json","respondAs","responseOfFailure","http","statusText","status","handleApiResponse","Promise","all","catch","apiFetch","method","apiRequest","JSON","stringify","Accept","Content-Type","apiSubmit","onFetch","resolve","reject","once","InSubmitError","submit","whenOff","reason","cancel","FeedService$","_apiFetch","_articles","slug","encodeURIComponent","params","Array","from","thruIt","overEntries","key","value","nextArg","String","length","URLSearchParams","articleCount","articles","map","article","FeedSupport","Feature","setup","provide","a","as","AuthService","ContextKey__symbol","AuthService$","_context","super","storage","BootstrapWindow","localStorage","_auth","getItem","on","newAuth","setItem","removeItem","thru","Authorization","afterEventBy","undefined","supply","eventSupply","needs","ctx","event","receive","valuesProvider","fetchCurrentUser","_request","AuthSupport","bootstrapCssError","mark","when","control","cssClasses","aspect","InCssClasses","afterAll","InStatus","validity","InValidation","touched","hasFocus","incomplete","has","nextAfterEvent","specs","inCssError","Conduit__NS","NamespaceDef","noApiErrors","ApiErrorsComponent","HierarchyContext","InputToForm","messages","reduce","prev","message","_errors","old","updateState","contentRoot","document","list","remove","itsEach","createElement","classList","add","ul","forEach","li","innerText","appendChild","append","__decorate","Render","Component","InErrorComponent","Attributes","ConvertInput","aspects","trackAttribute","code","trim","split","convert","InStyledElement","to","element","inCssInfo","ConduitInputSupport","FillConduitForm","emptyModel","form","node","group","inGroup","classes","InMode","derive","inModeByValidity","inFormElement","button","FillInputForm","select","pick","deep","feature","ComponentTreeSupport","defContext","whenComponent","componentNode","ComponentNode","hierarchy","whenOn","first","DefaultInAspects","tillOff","consume","inSubmitButton","HandleConduitSubmitButton","UseConduitInput","def","UseInputElement","makeControl","opts","ctrl","InControl","augmentControl","afterSupplied","MainComponent","IncludePage","range","deleteContents","insertNode","createTextNode","NavbarComponent","HandleNavLinks","ActivateNavLink","active","authenticatedClassQName","notAuthenticatedClassQName","ContainerComponent","connectSupply","_failure","_user","oldValue","nsAlis","DefaultNamespaceAliaser","authenticatedClass","css__naming","name","notAuthenticatedClass","FooterComponent","ConduitLayoutSupport","ConduitFeature","conduitContext","bootstrapComponents"],"mappings":"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"}