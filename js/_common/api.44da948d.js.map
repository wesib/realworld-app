{"version":3,"file":"api.44da948d.js","sources":["../../../src/common/api/api-root-url.ts","../../../src/common/api/api-fetch.ts","../../../src/common/api/api-submitter.ts"],"sourcesContent":["import { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\n\nexport type ApiRootURL = URL;\n\nexport const ApiRootURL: SingleContextUpRef<ApiRootURL> = new SingleContextUpKey<ApiRootURL>(\n    'api-root-url',\n    {\n      byDefault: () => new URL('https://conduit.productionready.io/api/'),\n    },\n);\n","import { HttpFetch } from '@wesib/generic';\nimport { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { nextArgs, NextCall } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { AfterEvent, nextOnEvent, onAsync, OnEvent, OnEventCallChain } from 'fun-events';\nimport { AuthService__key } from '../auth/auth-service.key.impl';\nimport { ApiRootURL } from './api-root-url';\n\n/**\n * Request to some API endpoint.\n *\n * @typeparam T  Response type.\n */\nexport interface ApiRequest<T> {\n\n  /**\n   * API endpoint path __relative__ to {@link ApiRootURL API root URL}.\n   *\n   * Do not start it with `/` as this would make it absolute.\n   */\n  readonly path: string;\n\n  /**\n   * Wrapper field containing response object, or a function extracting it.\n   */\n  readonly respondAs: string | ((this: void, json: any) => T);\n\n  /**\n   * Additional HTTP request options.\n   */\n  readonly init?: RequestInit;\n\n  /**\n   * Whether to send authentication token.\n   *\n   * - `true` to always send it,\n   * - `false` to never send it,\n   * - `undefined` (the default) - to send it only when {@link AuthService.authentication authenticated}.\n   */\n  readonly auth?: boolean;\n\n}\n\nexport type ApiResponse<T> =\n    | ApiResponse.Ok<T>\n    | ApiResponse.Failure;\n\nexport namespace ApiResponse {\n\n  export interface Ok<T = any> {\n    readonly ok: true;\n    readonly response: Response;\n    readonly body: T;\n  }\n\n  export interface Failure {\n    readonly ok: false;\n    readonly response?: Response;\n    readonly errors: Errors;\n  }\n\n  export type Errors = {\n    readonly [field in string]: readonly string[];\n  };\n\n}\n\nexport type ApiFetch = <T>(this: void, request: ApiRequest<T>) => OnEvent<[ApiResponse<T>]>;\n\nexport const ApiFetch: ContextUpRef<ApiFetch, ApiFetch> = (\n    new FnContextKey<[ApiRequest<any>], OnEvent<[ApiResponse<any>]>>(\n        'api-fetch',\n        {\n          byDefault: bootstrapDefault(newApiFetch),\n        },\n    ));\n\ntype RequestOrFailure =\n    | { request: Request }\n    | { request?: undefined; failure: ApiResponse.Failure };\ntype ResponseOrFailure =\n    | { response: Response }\n    | { response?: undefined; failure: ApiResponse.Failure };\ntype ResponseBodyOrFailure =\n    | [{ response: Response }, any]\n    | [{ response?: undefined; failure: ApiResponse.Failure }];\n\nfunction newApiFetch(context: BootstrapContext): ApiFetch {\n\n  const httpFetch = context.get(HttpFetch);\n  const apiRootURL = context.get(ApiRootURL);\n\n  return request => {\n\n    const { path, init, auth } = request;\n    const onResponse: OnEvent<[ResponseOrFailure]> = apiRootURL.thru_(\n        baseURL => new URL(path, baseURL),\n        url => buildApiRequest(url, init),\n    ).thru_(\n        (request: Request): NextCall<OnEventCallChain, [RequestOrFailure]> => auth === false\n            ? nextArgs({ request })\n            : nextOnEvent(authenticateApiRequest(context, request, auth)),\n        (requestOrFailure): NextCall<OnEventCallChain, [ResponseOrFailure]> => requestOrFailure.request\n            ? nextOnEvent(httpFetch(requestOrFailure.request).thru_(response => ({ response })))\n            : nextArgs({ failure: requestOrFailure.failure }),\n    );\n\n    return onAsync(onResponse.thru_(parseApiResponse)).thru_(\n        ([responseOrFailure, json]) => handleApiResponse(request, responseOrFailure, json),\n    );\n  };\n}\n\nfunction buildApiRequest(url: URL, init: RequestInit = {}): Request {\n\n  const request = new Request(url.href, { mode: 'cors', ...init });\n  const { headers } = request;\n\n  headers.set('X-Requested-With', 'XMLHttpRequest');\n\n  return request;\n}\n\nfunction authenticateApiRequest(\n    context: BootstrapContext,\n    request: Request,\n    auth?: true,\n): AfterEvent<[RequestOrFailure]> {\n  // Access by key to avoid circular dependencies during the build\n  return context.get(AuthService__key).authentication.keep.thru_(\n      ({ token, failure }) => {\n        if (token) {\n          request.headers.set('Authorization', `Token ${token}`);\n          return { request };\n        }\n        if (!auth) {\n          return { request };\n        }\n        if (!failure) {\n          failure = {\n            ok: false,\n            errors: {\n              api: ['Not authenticated'],\n            },\n          };\n        }\n        return { failure };\n      },\n  );\n}\n\nfunction parseApiResponse(\n    responseOfFailure: ResponseOrFailure,\n): ResponseBodyOrFailure | Promise<ResponseBodyOrFailure> {\n  return responseOfFailure.response\n      ? Promise.all([responseOfFailure, responseOfFailure.response.json()])\n          .catch(error => [{\n            failure: {\n              ok: false,\n              response: responseOfFailure.response,\n              errors: {\n                api: [`Failed to parse response: ${error}`],\n              },\n            },\n          }])\n      : [responseOfFailure];\n}\n\nfunction handleApiResponse<T>(\n    { respondAs }: ApiRequest<T>,\n    responseOfFailure: ResponseOrFailure,\n    json?: any,\n): ApiResponse<T> {\n  if (!responseOfFailure.response) {\n    return responseOfFailure.failure;\n  }\n\n  const { response } = responseOfFailure;\n\n  if (response.ok) {\n    return {\n      ok: true,\n      response,\n      body: typeof respondAs === 'function' ? respondAs(json) : json[respondAs],\n    };\n  }\n\n  return {\n    ok: false,\n    response,\n    errors: json.errors || {\n      http: [\n        response.statusText\n            ? `${response.status}: ${response.statusText}`\n            : `ERROR ${response.status}`,\n      ],\n    },\n  };\n}\n","import { BootstrapContext, bootstrapDefault } from '@wesib/wesib';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\nimport { OnEvent } from 'fun-events';\nimport { InSubmit, InSubmitError } from 'input-aspects';\nimport { ApiFetch, ApiRequest, ApiResponse } from './api-fetch';\n\nexport type ApiSubmitter =\n    <Value = any, Result = any>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result>;\n\nexport const ApiSubmitter: ContextUpRef<ApiSubmitter, ApiSubmitter> = (\n    new FnContextKey<[ApiRequest<any>], InSubmit.Submitter<any, any>>(\n        'api-submitter',\n        {\n          byDefault: bootstrapDefault(newApiSubmitter),\n        },\n    ));\n\nfunction newApiSubmitter(\n    context: BootstrapContext,\n): <Value, Result>(this: void, request: ApiRequest<Result>) => InSubmit.Submitter<Value, Result> {\n\n  const apiFetch: ApiFetch = context.get(ApiFetch);\n\n  return <Value, Result>(request: ApiRequest<Result>) => {\n\n    const { init = {} } = request;\n    const { method = 'POST', headers = {} } = init;\n\n    return (body: Value) => {\n\n      const apiRequest: ApiRequest<Result> = {\n        ...request,\n        init: {\n          ...init,\n          method,\n          body: JSON.stringify(body),\n          headers: {\n            ...headers,\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n          },\n        },\n      };\n\n      return apiSubmit(apiFetch(apiRequest));\n    };\n  };\n}\n\nexport function apiSubmit<Result>(onFetch: OnEvent<[ApiResponse<Result>]>): Promise<Result> {\n  return new Promise((resolve, reject) => {\n    onFetch.once(\n        (response: ApiResponse<Result>) => {\n          if (response.ok) {\n            resolve(response.body);\n          } else {\n            reject(new InSubmitError({ submit: 'api', api: response.errors }));\n          }\n        },\n    ).whenOff(\n        reason => {\n          reject(\n              reason instanceof InSubmitError\n                  ? reason\n                  : new InSubmitError({ submit: 'cancel', cancel: reason }),\n          );\n        },\n    );\n  });\n}\n"],"names":["ApiRootURL","SingleContextUpKey","byDefault","URL","ApiFetch","FnContextKey","bootstrapDefault","context","httpFetch","get","HttpFetch","apiRootURL","request","path","init","auth","onResponse","thru_","baseURL","url","Request","href","mode","headers","set","buildApiRequest","nextArgs","nextOnEvent","AuthService__key","authentication","keep","token","failure","ok","errors","api","authenticateApiRequest","requestOrFailure","response","onAsync","parseApiResponse","responseOrFailure","json","respondAs","responseOfFailure","body","http","statusText","status","handleApiResponse","Promise","all","catch","error","apiFetch","method","apiRequest","JSON","stringify","Accept","Content-Type","apiSubmit","onFetch","resolve","reject","once","InSubmitError","submit","whenOff","reason","cancel"],"mappings":"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"}